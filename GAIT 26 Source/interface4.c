/************
GAIT (Geospatial Analysis Integrity Tool) is a geospatial data validation tool developed by the Institute for Defense Analyses (IDA) for the National Geospatial-Intelligence Agency (NGA).  

This source code was used to generate GAIT 26 executable software in accordance with Amendment 6 to Task Order DH-8-3815 under Contract HQ0034-14-D-0001.

IDA is furnishing this item "as is". IDA was not tasked or funded to generate developer documentation or to provide support for this source code. IDA does not provide any warranty of the item whatsoever, whether express, implied, or statutory, including, but not limited to, any warranty of fitness for a particular purpose or any warranty that the contents of the item will be error-free. In no event shall NGA or IDA be held liable for damages arising, directly or indirectly, from the use of this source code. 

This material may be reproduced by the U.S. Government pursuant to its unlimited use rights under DFARS 252.227-7014 [Feb 2014].

The Institute for Defense Analyses (IDA) is a Federally Funded Research and Development Center that provides scientific and technical expertise on issues important to national security to the Office of the Secretary of Defense, Joint Staff, Unified Commands, and Defense Agencies. 

© 2017 Institute for Defense Analyses
  4850 Mark Center Drive
  Alexandria, Virginia 22311-1882
  703.845-2000
  www.ida.org
************/
#include "interface.h"
#include "TTshare.h"



#define MAX_POI_NUM 20000

#define NUM_GRID_TOOLS 3

struct GridToolStruct
{
  Widget ActivateButton;
  XtCallbackProc cb;
  char *name;
  char *help;
  int helpid;
};

struct GridToolStruct GridTools[NUM_GRID_TOOLS];




int NoZ_Values = 0;

int PROCESS_GRID_VALUES  = 0;
int global_mask_allocced = 0;
int old_long_attr_style = 0;

int CREATING_TREX = 0;
int TREX_TYPE = 0;

int no_layer_reset_flag=0;

int BIN_ATTR_TYPE    = 1;
int NUNANPO_TYPE     = 0;

int SPECIAL_OUTLINE_COLOR = 0;

int LABEL_PROXIMITY=2;
int LABEL_VOLUME=1;
int LABEL_OK=1;

#if (NGA_TYPE == 1)

  extern char **gifd_class_defns; 
  extern char **gifd_class_names;
  extern char **gifd_class_codes;
  extern char **gifd_attr_types;
  extern char **gifd_attr_defns;
  extern char **gifd_attr_names;
  extern char **gifd_attr_codes;
  extern char **gifd_enum_names;
  extern char **gifd_enum_codes;
  extern int   *gifd_attr_enum_count;
  extern int   *gifd_attr_enum_start;
  extern int GIFD_CLASS_NUM;
  extern int GIFD_ATTR_NUM;
  extern int DOMAINSLEN;
  extern int STRATSLEN;





  #define INscc_array (10000) 
  #define INsac_array (10000) 


#else

extern int GIFD_CLASS_NUM ;
extern int GIFD_ATTR_NUM  ;       
extern char **gifd_attr_codes ;  
extern char **gifd_class_codes;
extern char **gifd_class_names;

#define INscc_array (EDCS_TOTAL_EC+1)
#define INsac_array (EDCS_TOTAL_EA+1)

#endif



#if(USE_LINUX==1)

#include <ctype.h>

__const unsigned short int *__ctype_b;
__const __int32_t *__ctype_tolower;
__const __int32_t *__ctype_toupper;



#endif



Widget demwid,choose_txt_dialog,pad_head,vpad_head,VCGlobalTotals,otherattrwid17,
choose_dialog,chooseshape_dialog,choose_es1_dialog,choose_es2_dialog,html_button,
attr_ins_menu,color_menu,color_menu2,choosedata_dialog,point_text_button,grid_head,
attrins_label_area,ppad_text_sen_w,importshell,importshell2,shapename_w,lbutton,
line_color_menu,end_line_color_menu,QACR_button,NGAQACR_button,MGCPQACR_button,
gridwid1,gridwid2,gridwid3,gridwid4,gridwid5,gridwid6,gridwid7,gridwid8,NUNANPO_button,
otherattrwid1,otherattrwid2,otherattrwid3,otherattrwid4,otherattrwid5,attrins_text_area,
otherattrwid6,otherattrwid7,otherattrwid8,otherattrwid9,otherattrwid10,poly_color_menu,
otherattrwid11,otherattrwid12,otherattrwid13,otherattrwid14,otherattrwid15,color_menu4,
otherattrwid16,mgcpattrwid2,mgcpattrwid3,mgcpattrwid4,mgcpattrwid5,attr_type_menu,
mgcpattrwid6,mgcpattrwid7,mgcpattrwid8,mgcpattrwid9,mgcpattrwid10,attrins_browse_area,
esrimetawid,ingrmetawid,metacascade,ngametawid,layerprefs,meta_type_menu,color_menu3,
choose_xml1_dialog,choose_xml2_dialog,choose_xml3_dialog,fore_head,rbutton,toggle_all_cells,
PROJSUMM_button,CHECKSUMM_button,aoi_shape_wid,pref_dialog,pref_dialog2,trex_type_menu,
append_button;

XmFontListEntry entry1;

FILE *save_idinfo   = NULL,*save_iddata  = NULL;
FILE *save_hgtinfo  = NULL,*save_hgtdata = NULL;
FILE *save_leninfo  = NULL,*save_lendata = NULL;
FILE *save_naminfo  = NULL,*save_namdata = NULL;
FILE *save_areainfo = NULL,*save_areadata= NULL;
FILE *save_zv2info  = NULL,*save_zv2data = NULL;

Font defaultfont;


double *GLOBAL_SAVE_COORDS_X=NULL;
double *GLOBAL_SAVE_COORDS_Y=NULL;
int    *GLOBAL_SAVE_COORDS_start=NULL;
int    *GLOBAL_SAVE_COORDS_end=NULL;
int    GLOBAL_SAVE_COORDS   = -1;
int    SPECIAL_VERTEX       = -1;
int    INFOLEN              = 0;

int num_shapes_processed    = 0;
int RemovedOneDegree        = 0;

char *savemessage= NULL;
char *savetime   = NULL;


double GridX=0.0, GridY=0.0, GridSpace=1;   

int SPECIAL_COND_COLOR = -1;
int SPECIAL_COLOR = -1;
int TheContourColor = 51;
int OVERRIDE_THICKNESS = -1;


int formatting=0,pref2_up=0;
int CHECK_DATA_SET = 0;
int DrawColorFill = 0;
int import_head_in_use = 1;
int *LLFidTable  = NULL;
int *FidFidTable = NULL;
int LLFidTableCount=0;
int DEV_OPTION = 0;

#define NUM_LABEL_REMEMBER_MAX 905
int NUM_LABEL_REMEMBER = 0;
unsigned short int RememberLabelX[NUM_LABEL_REMEMBER_MAX];
unsigned short int RememberLabelY[NUM_LABEL_REMEMBER_MAX];  
unsigned char RememberLabelDepth[NUM_LABEL_REMEMBER_MAX];
int DRAW_LABELS = 1; 

char GAIT_HOME_DIR[1000];

char outattrdirectory[1000];
char outsumdirectory[1000];
char shape_out_name[200];

int NOTYPE = 3;
int C_TYPE = 5;
int D_TYPE = 7;
int I_TYPE = 9;

int LONG_ATTR_ID         =  2;
int LONG_ATTR_ID_INFO    =  4;
int LONG_ATTR_AREA       =  6;
int LONG_ATTR_HGT        = 10;
int LONG_ATTR_ZV2        = 12;
int START_ID             = 14;
int STOP_ID              = 16;
int LONG_ATTR_LEN        = 18;
int LONG_ATTR_NAM        = 20;
int START_AREA           = 22;
int STOP_AREA            = 24;
int START_HGT            = 26;
int STOP_HGT             = 28;
int START_ZV2            = 30;
int STOP_ZV2             = 32;
int LONG_ATTR_CHECK_ID   = 34;
int START_CHECK_ID       = 36;
int STOP_CHECK_ID        = 38;
int START_CHECK_HGT      = 40;
int STOP_CHECK_HGT       = 42;
int START_CHECK_ZV2      = 44;
int STOP_CHECK_ZV2       = 46;
int START_CHECK_AREA     = 48;
int STOP_CHECK_AREA      = 50;
int LONG_ATTR_CHECK_HGT  = 52;
int LONG_ATTR_CHECK_ZV2  = 54;
int LONG_ATTR_CHECK_AREA = 56;

int START_LEN            = 72;
int STOP_LEN             = 74;
int START_NAM            = 76;
int STOP_NAM             = 78;
int START_CHECK_LEN      = 80;
int STOP_CHECK_LEN       = 82;
int START_CHECK_NAM      = 84;
int STOP_CHECK_NAM       = 86;
int LONG_ATTR_CHECK_LEN  = 88;
int LONG_ATTR_CHECK_NAM  = 90;




int HAS_ID[NUM_ATTR_SCHEMA+5];
int batchsilent        = 0;
int batchignore        = 0;
int batchuser          = 0;
int layer_prefs_set    = 0;
int PPAD_UP            = 0;
int USE_GREY           = 1;
int NEED_SHADE_REDRAW  = 0;
int COLOR_ALREADY_SET  = 0;
int OVERRIDING_CONTOUR = 0;
int NO_FLATTEN_CONTOUR = 1;
int BOLD_CONTOUR       = 0;
int dev_options=0,DoDev=0;
double SaveXScroll,SaveYScroll;


short int *cache_types;
long int  *cache_posns;
double    *cache_nums;
char     **cache_chars;
int NO_QUERY,API_DRAW=0,POI_CONNECT=0,INCLUDE_PROJECTION=0;
int DoLargeLabels = 0;
int DoBoldLabels  = 1;
int ZoomToPOIs    = 0;
int global_target_ecc  = -1;
int global_target_geom = -1;
int free_global_char_type = 1;
int bad_los_result = 0, DrawAnnotations = 1;
int SpecialMapdrawPoly = 0;

int DRAW_POINT_LABELS = 1;
int DRAW_LINE_LABELS  = 1;
int DRAW_AREA_LABELS  = 1;
int DRAW_GRID_LABELS  = 1;

int num_dist_pts = 0;
int *dist_xpts = NULL;
int *dist_ypts = NULL;
int global_zoomed_too_far = 0;
int ATTRINSTYPE = 1;
int attrins_source = 0;
char attrinsfolder[1000];



extern Colormap cmap;
extern XmFontList fontlist;
extern XPoint * Drawpoints;
extern XPoint *hole_points;
extern short int PixArray[1050][900];


extern Pixmap Profile_pix,pixmap2,stipmap_avg,stipmap_lgt,stipmap_hvy,
  DRAWING_PIXMAPS[NUM_DRAWING_PIXMAPS], DRAWING_CLIPMAPS[NUM_DRAWING_PIXMAPS];
extern Pixmap stipmapstypes[NUM_STIPMAPS]; 
extern Pixmap ERROR_BITMAP;

Pixmap over_pixmap;


extern struct InfoPrintContent *InfoRoot;
extern int    *HIGH_ERRNUM             ;
extern int    *HIGH_INSTANCE           ;
extern int    *HIGH_CONDNUM            ;
extern int    *HIGH_ECC1               ;
extern int    *HIGH_ECC2               ;
extern double *HIGH_MAG                ;
extern int rec_condnum                [MAX_STACK+1];
extern struct CondHighlight ***MasterHighlighter;
extern unsigned char **MasterStacker;
extern unsigned short int rec_errnum  [MAX_STACK+1];
extern unsigned short int rec_instance[MAX_STACK+1];

extern int LODS_USED[NUM_DRAWING_PIXMAPS];
extern int NumberOfGrids;
extern int VertexPrintLimit;
extern struct GlobalGridInfo *GridHeader;

extern int num_per_page     ;
extern int view_object_page ;
extern int maxpages         ;
extern int pageptrsalloced  ;
extern int numobs;
extern long int *pageptrs;
extern int alloced_boonoff2;
extern int *BOOnOff2;
extern Dimension over_width,over_height,lod_hgt;
extern Position over_px1,over_py1;
extern Pixmap plus_pix,minus_pix;
extern Pixmap *layer_colorpix;
extern int override_location;
extern int prev_up;
extern char **GAITPrevList;

extern int head_in_use,deader_phead,NO_REBUILD,LAYER_MGCP_UP,LAYER_FC_UP,LAYER_GEOM_UP,lod_head_in_use,
dead_lod_head2,Current_head,PAD_UP,VPAD_UP,dead_network,UnsavedConditions,unsavedignore;

extern char project_to_open[1000];
extern int layers_innitted;
extern int    *layers_up;
extern XColor *layer_colors;
extern Widget *layer_colorwindows;
extern Pixmap *layer_colorpix;
extern Widget *toplevel;
extern Widget *scale1;
extern Widget *scale2;
extern Widget *scale3;
extern Widget *layer_text1;
extern Widget *layer_text2;
extern Widget *layer_text3;
extern Widget *LOD;
extern char *DNAME[NUM_D];
extern unsigned char LODS_INNITTED;
extern char globalmessage  [5000];
extern char masterrun[100];



extern struct EDCSLookup edcsstruct;

extern Widget toolbar[20],vert_scroll[100],ToolTipMaster,param_head,param2_head,
running_info,folder_wid,sum1_wid,sum2_wid,sum3_wid,data_wid,Select_head,
info_attr_head,infohead,infoparam_head,cond_dialog,lod_head,info_text_area,
pick_dialog,WW,info_list,indir_work_dialog,Demo_drawing,master_sw2,zoom_b,
Att_Demo_drawing,fan_info,text_pane,fix_running,modelhead,Bbutton,list_point,
modes[10],condwid1,condwid2,condwid3,shapewid,total_w,choosedp_dialog,ob_head[5],
cascade[10],patch_t,terrain_to_import,stf_t,condwid,genwid,savecond_wid,TEXT_HELP,
msgdialogs[5000],sw,concat_dialog,extract_dialog,run_format_dialog,color_menu4,
CSD_head,stackwids[ZOOM_REMEMBER_NUM],shift[7],beg_dialog,menubar,pop_parent,
netwid,metamap_browse_area,metamap_text_area,chooseattr_dialog,
text_ul,text_w2,text_w3,text_w4,text_w5,text_lr,fore_ver,fore_ver2,pop_menu[2],
Profile_drawing,Profile_draw,shapefile_text_area,info_tog[INsac_array+10],
BOlist_w,BOlist2_w,MARKtext_w2,MARKtext_w3,shellhead2,aoi_dialog,choosebr_dialog,
regionhead,aoi_save_wid,S_list_w,S_list2_w,text_area,text_output2,
info_scc_defs,info_sac_defs,search_w,sdcshead,
sun_az_w_z,sun_angle_w_z,vert_ex_w_z,top_menu[10],Tstrat[NUM_S+2],
import,losbutton,profile,patchshell,text_obs,text_tgt,text_angle,text_quality,
fore_grid_s,fore_con,fore_grid_xa,fore_grid_ya,xml1_wid,xml2_wid,xml3_wid,
xml_running,page_wid,prev_dialog,GlobalTotals,previousresults,lod_head2,
FixList[CONDITION_ARRAY_SIZE],fixhead[CONDITION_ARRAY_SIZE],errorhead[3],
zoom_pad_w,vpad_text_sen_w,NETGlobalTotals;


extern Widget vert_scroll_bo[25][CONDITION_ARRAY_SIZE][125];

extern char **LongValueList;
extern double *LongDValueList;


extern char  *CNAME[NUM_C],
  edcsstring            [150],
  SaveAOIShapeName      [100],
  metamapfile           [1000];
 


extern unsigned long mycolors[300],col[300],col2[300],col3[300],col4[300],
ColorBin1[SHADES_PER_BIN],ColorBin2[SHADES_PER_BIN],ColorBin3[SHADES_PER_BIN],
ColorBin4[SHADES_PER_BIN],ColorBin5[SHADES_PER_BIN],mybackground,myforeground;

extern long int StartTime,EXTRACT_STARTTIME,use_other_fileposn;

extern unsigned int PixDBWidth,PixDBHeight;

extern unsigned int EXTRACT_GRIDS_DONE;

extern int CLONE_DEFINITIONS,ThisClassLevel,
RUNNING_INFO,STOP_FLAG,OVERRIDING_STYLE,browse5_up,browse6_up,browse7_up,import_source,
browse8_up,browse12_up,browse13_up,browse14_up,browse15_up,running,PossibleToCenterNetZoom,
load_modules,deader_head,batch_mode,NumNetsLoaded,input_source,output_source,DO_OVERRIDE,
GLOBAL_draw,GLOBAL_needextrapixmap,GLOBAL_showlayers,GLOBAL_activelayer,TopLayersDrawn,
SAVE_TOPCHANGE,grx,gry,xnum,ynum,STF_INPUT,DIGITS_TO_PRINT,SAVED_VIEWS,INFO_GRIDVALUES,
CURRENT_ZOOM,MAX_ZOOM,UNIQARRAYBUILT,cond_start_onoff,info_window_up,CAOnOff1,INFO_HEX,
INFO_ATTR_WIN,SAVE_CREPORT_UP,dead_head5,dead_lod_head,busyinnitting,input_up,PrimaryLODSort,
SecondaryLODSort,IMPORT_INPUT,patch_source,PATCH_INPUT,stf_overwrite_source,layers_innitted,
*layers_up,DynLodMade,TempNumLODbands,INFO_PARAM_WIN,DEFAULT_DTP_UTM,DoMetadataChecking,
DEMO_UP,ATT_DEMO_UP,FAN_INFO,ERR_INFO,STOP_FIX_FLAG,FIX_RUNNING,DetailedInfo,curr_pop,
DoShort,DOALLCELLS,DOMAIN_DEFAULT_COLOR[NUM_D],browse26_up,DoAttrChecking,AppendInputSpec,
EXTRACT_POINTS_DONE,EXTRACT_LINEARS_DONE,EXTRACT_AREALS_DONE,load_head,LOS_WIN,GRID_WIN,
RUN_FORMAT_UP,BUSY,IMPORT_WIN,SCC_NUM,CSD_UP,pix_wid,pix_hgt,polyptsallocced,MASTERTYPE,
DYNAMIC_SCC_NUM,MOD_UP,view_object_page,INscc_loop,INsac_loop,HyperClassUp[INscc_array],
HyperAttrUp [INsac_array],METATYPE,TEMP_ATTRIBUTION_TYPE,global_scroll_min,metamap_source,
global_scroll_max,global_scroll_value,global_scroll_slide_size,global_scroll_increment,LOS,
global_scroll_pg_increment,Total2DPoint,Total3DPoint,Total2DLine,Total3DLine,Total2DArea,
Total3DArea,logo_done,pop_up[2],DOUBLECLICK,DrivesAvailable[DRIVE_MAX],PFOnOff1,DrawLabels,
SFOnOff1,ES1OnOff1,ES2OnOff1,TXTOnOff1,DATAOnOff1,SHAPE_IMPORT_OUTPUT,NumNetDrives,TYPE,
NPPFOnOff1,NPSFOnOff1,NPES1OnOff1,NPES2OnOff1,NPTXTOnOff1,NPDATAOnOff1,metabrowse_up,GRID,
FromI,ToI,FromJ,ToJ,iLimit,jLimit,iStart,jStart,pref_up,DrawUserGrid,GLOBAL_SAVE_COORDS,
DrawQuarterDegreeGrid,DrawHalfDegreeGrid,DrawOneDegreeGrid,DrawUserGridL,DrawOneDegreeGridL,
DrawHalfDegreeGridL,DrawQuarterDegreeGridL,CLIPEXTRACT,KEEP_THICKNESS,ABORT_EXTRACT,
GRID_THICKNESS,GRID_COLOR,GRID_LABEL_COLOR,shape_source,IUseDMScoordinates,P_window,FLIP,
NON_ACTUAL,ACTUAL,UNIQSACNUM,CenterZoomOnVertices,CenterZoomOnErrors,DO_DESCRIBE,ABORT_ZOOM,
SPECIAL_VERTEX,DRAWING_INFO_ITEM,InfoItemsQueried,PROFILE_MODE,INFO_DOMAIN,INFO_LENGTH,
INFO_AREA,INFO_GEOMETRY,INFO_FID,INFO_GFID,INFO_COORDS,INFO_ATTRIBUTES,INFO_ATTR_LABELS,
INFO_ATTR_VALUES,FAN_MODE,INFO_MODE,DIST_MODE,ZOOM_MODE,CHECK_MODE,PAN_MODE,BAD_PROFILE,
AOI_MODE,BAD_ZOOM,BAD_PAN,startx,starty,grx,gry,xnum,ynum,startloadx,startloady,ADD_HIST,
pro_begx,pro_begy,BAD_BEGIN_PROFILE,BAD_FAN,BAD_INFO,dead_error,dead_obhead[5],attr_color,
current_ob_head,num_highlights,DRAW_VERTICES,ATTRIBUTION_INFO_TYPE,load_reg,
endloadx,endloady,load_modules,do_long_way,MARK_COLOR,MARK_SHAPE,INFO_WINDOW,info_window_up,
startzoomx,startzoomy,startpanx,startpany,MAX_ZOOM,AOI_SAVE_UP,AOI_LOAD_UP,AOI_SHAPE_UP,
ZoomSunAzimuth,ZoomSunAngle,dead_sdcs,dead_shade,CIRCLESIZE,MAXVERTSFOUND,browse30_up,
DRAWING_ERRORS,circlecount,gridcount,LINE_TYPE_ONLY,RETURN_VERTS,num_hole_points,PATCH_WIN,
POLY_SHAPE,POLY_COLOR,LINE_SHAPE,LINE_COLOR,END_LINE_SHAPE,END_LINE_COLOR,FAN_QUALITY,
PossibleToCenterZoom,linecount,polycount,browse27_up,browse28_up,browse29_up,CONTOUR_WIN,
import_output_source,FORE_WIN,UNIQSCCNUM,XML_RUNNING,browse31_up,browse32_up,
HELP_UP[CONDITION_ARRAY_SIZE],deadfix[CONDITION_ARRAY_SIZE],OnOff1,VCOnOff1,FCOnOff1,
NPXML1OnOff1,NPXML2OnOff1,NPXML3OnOff1,XML1OnOff1,XML2OnOff1,XML3OnOff1,GLOBAL_ADDSPECS;

extern unsigned char DrawByConfig [NUM_C];
extern unsigned char DrawByStratum[NUM_S]; 
extern unsigned char DrawByDomain [NUM_D];
extern int DO_OBS[NUM_OBS]          ;

extern int highlight_starts[HIGHLIGHTMAX];
extern int highlight_ends  [HIGHLIGHTMAX];
extern int OnOff2[NUMCHECKGROUPS];
extern int VCOnOff2[NUMCHECKGROUPS];
extern int VCOnOff3[CONDITION_ARRAY_SIZE];
extern int FCOnOff2[NUMCHECKGROUPS];
extern int FCOnOff3[CONDITION_ARRAY_SIZE];

extern struct SACarray * SACARRAY;
extern struct SCCarray * SCCARRAY;

extern unsigned char UNIQSCC[INscc_array];
extern unsigned char UNIQSAC[INsac_array];
extern unsigned char InfoSac[INsac_array+10];
extern unsigned char shortmsg_up[5000];


extern int    *GLOBAL_SAVE_COORDS_start;
extern int    *GLOBAL_SAVE_COORDS_end  ;

extern double llx_zoom,lly_zoom,DBWidth,DBHeight,
GridSpace,urx_zoom,ury_zoom,ErrLLX,ErrLLY,
PAD_DIST,PPAD_DIST,VPAD_DIST,NPAD_DIST,thex,they,
ErrURX,ErrURY,FAN_ANGLE,OBS_HEIGHT,ZoomVertExag,
TGT_HEIGHT,CLIPLLX,CLIPLLY,CLIPURX,CLIPURY;

extern double *XNEW4;
extern double *YNEW4;



extern String help3,help4,help7,help8,help9,
  translations_global,toptrans,list_translations,
  list_translations2,list_translations3,list_translations4,list_translations5,
  list_translations6,list_translations7,list_translations8,list_translations12,
  list_translations16,list_translations21,list_translations23,
  list_translations53,list_translations54,list_translations55,
  translations_paste,list_translations62,list_translations64;

extern char importoutputdir      [1000];
extern char importdirectory      [1000];
extern char GAITProjectName      [1000];
extern char shapeimportoutputdir [1000];
extern char patchfile            [1000];
extern char stffix               [1000];
extern char SaveAOIName           [100];

extern char **GAITAOIList;
extern char **GAITPrefList;



extern Display *mydisplay;
extern Window mywindow; 
extern Pixmap pixmap;
extern Dimension width,height;
extern GC mygc,mybitgc;
extern Widget drawing_a;

extern unsigned long BITWHITE,BITBLACK;
extern struct LODdisplaySH *LODindex_DYN;


extern int SLASHTYPE;
extern char PROJECTLOC[1500];
extern char layer_pref_file[100];

extern int ATTRIBUTION_TYPE;
extern int GIFD_CLASS_NUM;
extern int SHOW_POLY_VERTICES,SHOW_LINE_VERTICES,SHOW_END_VERTICES;
extern int NOT_ZOOMED,DRAWING_MARKERS,NO_CIRCLES,DRAW_NOW;

extern int area_index;

extern double xunits,yunits,IRegionSize;



struct POIList  * POIRoot = NULL;

Widget param_net_head,param2_net_head,NetGlobalTotals;
int net_head_in_use  = 0;
int net_deader_head  = 1;
int net_deader_phead = 1;
int NetConfigOnOff1  = 1;
int INTERSECTION_BASED = 0;
int ADDNETS = 0;
int PROFILE_WIN=0;

Pixmap global_mask_bitmap; 
  









void ExitWrapper(int flag)
{
  

  exit(flag);
}



int FileExists(char *filename)
{
  FILE *infile;

  infile = fopen(filename,"r");
  if(infile==NULL)
  {
	return 0;
  }

  fclose(infile);
  return 1;
}


Widget BuildMasterMenu(Widget parent,int menu_type,char *menu_title,MenuItem *items)
{
  Widget menu, cascade, widget;
  int i,n=0;
  XmString str;
  Arg args[5];
  
  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);
  
  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId, menu);  n++;
  XtSetArg (args[n], XmNlabelString, str); n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;

  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);
  
  for (i = 0; items[i].label != NULL; i++) 
    {
      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);
      
	  if(
		  ((i==0)&&(MASTERTYPE==1))   ||
		  ((i==1)&&(MASTERTYPE==3))   ||
		  ((i==2)&&(MASTERTYPE==4))   ||
		  ((i==3)&&(MASTERTYPE==5))   ||
		  ((i==4)&&(MASTERTYPE==11))  ||
		  ((i==5)&&(MASTERTYPE==10))
		)
	{
	  XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);
	}

      if (items[i].callback)
	XtAddCallback (widget,
		       (items[i].cclass == &xmToggleButtonWidgetClass ||
			items[i].cclass == &xmToggleButtonWidgetClass) ?
		       XmNvalueChangedCallback : 
		       XmNactivateCallback,      
		       (XtCallbackProc)items[i].callback, items[i].callback_data);
    }
  return menu_type == XmMENU_POPUP ? menu : cascade;
}



Widget BuildContourColorMenu(Widget parent,int menu_type,char *menu_title,MenuItem *items)
{
  Widget menu, cascade, widget;
  int i,n=0;
  XmString str;
  Arg args[5];
  
  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);
  
  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId, menu);  n++;
  XtSetArg (args[n], XmNlabelString, str); n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;

  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);
  
  for (i = 0; items[i].label != NULL; i++) 
    {
      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);


	  if(
		  ((i==0)&&(TheContourColor==2))   ||
		  ((i==1)&&(TheContourColor==27))  ||
		  ((i==2)&&(TheContourColor==55))  ||
		  ((i==3)&&(TheContourColor==51))  ||
		  ((i==4)&&(TheContourColor==255)) ||
		  ((i==5)&&(TheContourColor==40))  ||
		  ((i==6)&&(TheContourColor==54))  ||
		  ((i==7)&&(TheContourColor==128)) ||
		  ((i==8)&&(TheContourColor==53))  ||
		  ((i==9)&&(TheContourColor==28))
		)
	{
	  XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);
	}

      if (items[i].callback)
	XtAddCallback (widget,
		       (items[i].cclass == &xmToggleButtonWidgetClass ||
			items[i].cclass == &xmToggleButtonWidgetClass) ?
		       XmNvalueChangedCallback : 
		       XmNactivateCallback,      
		       (XtCallbackProc)items[i].callback, items[i].callback_data);
    }
  return menu_type == XmMENU_POPUP ? menu : cascade;
}

Widget BuildDevMenu(Widget parent,int menu_type,char *menu_title,MenuItem *items)
{
  Widget menu, cascade, widget;
  int i,n=0;
  XmString str;
  Arg args[5];
  
  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);
  
  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId, menu);  n++;
  XtSetArg (args[n], XmNlabelString, str); n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;

  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);
  
  for (i = 0; items[i].label != NULL; i++) 
    {
      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);
      
	  if(
		  ((i==0)&&(DEV_OPTION==1))   ||
		  ((i==1)&&(DEV_OPTION==2))   ||
		  ((i==2)&&(DEV_OPTION==3))
		)
	{
	  XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);
	}

      if (items[i].callback)
	XtAddCallback (widget,
		       (items[i].cclass == &xmToggleButtonWidgetClass ||
			items[i].cclass == &xmToggleButtonWidgetClass) ?
		       XmNvalueChangedCallback : 
		       XmNactivateCallback,      
		       (XtCallbackProc)items[i].callback, items[i].callback_data);
    }
  return menu_type == XmMENU_POPUP ? menu : cascade;
}


void PopExtrErr()
{
  extern char ErrStr[1000];

  not_while_running(drawing_a,ErrStr,1501,"Import Error",5);
}


void metamaphelpCallback(Widget w,XtPointer data,XtPointer callData)
{
  if(NGA_TYPE==1)
    {
      not_while_running(w,"This window is used to specify a Metadata Mapping file.\n\
A Metadata Mapping file is used to tell GAIT what mappings are\n\
used to abbreviate Metadata attribute names in shapefiles,\n\
since shapefiles have a 10 character limit, and many\n\
Metadata attribute names are longer than 10 characters.\n",
1398,"Metadata mapping folder selection help",5);
    }
  else
    {
      printf("error: MMHC called\n");
    }
}

void metafileDialogCallback(Widget w, XtPointer userData, XmFileSelectionBoxCallbackStruct *data)
{
  char *junk;  
  
  XmStringGetLtoR(data->value,(XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &junk);  
  
  if(junk[strlen(junk)]=='\0') 
    {
      if(
	 (junk[strlen(junk)-1]=='/')||
	 (junk[strlen(junk)-1]=='\\')
	 )
	{
	  junk[strlen(junk)-1]='\0';
	}
    }

 
  strcpy(metamapfile,junk);
  XtFree(junk);

  XtVaSetValues(metamap_text_area,XmNvalue,metamapfile,NULL);
  
  metabrowse_up  = 0;
  metamap_source = 1;
  XtDestroyWidget(XtParent(XtParent(w)));
}


void BrowseMetaCallback(Widget w,XtPointer data,XtPointer callData)
{
  static Widget dialog;
  Widget rowcol,temp_w;
  Arg args[15];
  char startdirectory[5000];
  int n=0, type=(int)data; 


  if(type!=1)
    {
      XBell(mydisplay,50);
      printf("BMC called with %d\n",type);
      return;
    }
  
  
  
  if(metabrowse_up==1)
    {
      
      ResetWidget(dialog);
      return;
    }
  
  
  
  n = 0;
  XtSetArg(args[n], XmNdeleteResponse, XmDESTROY);                   n++;
  
  
  dialog = XtCreatePopupShell("Metadata Mapping File Selection",topLevelShellWidgetClass,
			      drawing_a,args,n);
  
  rowcol = XtVaCreateWidget ("rowcol",
			     xmRowColumnWidgetClass,  dialog, NULL);

  n = 0;

  sprintf(startdirectory,"%sMetadataMappingFiles",GAIT_HOME_DIR);

  XtSetArg(args[n], XmNdirectory, STRING(startdirectory));                             n++;
  XtSetArg(args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;
 

  temp_w = XmCreateFileSelectionBox (rowcol,"mymessagebox",args,n);
  
  XtAddCallback(temp_w, XmNokCallback,
		(XtCallbackProc)metafileDialogCallback,
		(XtPointer)data);
  
  XtAddCallback(temp_w, XmNcancelCallback,
		(XtCallbackProc)exitCallback,
		(XtPointer)21);
  
  XtAddCallback(temp_w, XmNhelpCallback,
		(XtCallbackProc)metamaphelpCallback,
		(XtPointer)NULL);

  
  XtManageChild(temp_w);
  XtManageChild(rowcol);
  XtManageChild(dialog);
  
  XtAddCallback (dialog, XmNdestroyCallback,ShellDeath,(XtPointer)4059);
  
  MyPopup (dialog);
  
  
  metabrowse_up = 1;
  

  XtVaSetValues(XmFileSelectionBoxGetChild (temp_w, XmDIALOG_DIR_LIST),
        XmNtranslations, XtParseTranslationTable (list_translations12),NULL);

  XtVaGetValues(XtParent(XmFileSelectionBoxGetChild (temp_w, XmDIALOG_DIR_LIST)),
                 XmNverticalScrollBar,&vert_scroll[FILE1_SCROLL ] ,NULL);

}


void MetaMapCallback1(Widget w,XtPointer data,XtPointer callData)
{
  char junkstring [5000];
  char junkstring2[5000];
  char junkstring3[5000];
  
  

  sprintf(junkstring,"When importing shapefiles, GAIT maps shapefile attribute names\n\
to attributes.  The shapefile 10-character limitation presents a problem for metadata\n\
attributes.  GAIT recognizes the naming conventions shown below. In addition, the\n\
user may specify a custom mapping, called a \"Metadata Mapping File\", in conjunction\n\
with the \"User-Defined\" option for \"Metadata naming convention\".  The custom\n\
mapping option is described in the help for \"Metadata Mapping File\".\n\n\
The below only applies to GAIT projects created using the Attribution Schema:\n\
GIFD D4, FACC+, VMap2_TLM, UFD1, UFD2, and UFD3.\n\n\
Metadata Attribute     \"ESRI\"      \"Intergraph\"  \"MGCP/NGA\" \n\
ACE                    ACE         ACE           ACE         \n\
ACE_EVAL_METHOD_CD     ACE_EVAL_M  ACE_EVAL_M    ACE_EVAL    \n\
ALE                    ALE         ALE           ALE         \n\
ALE_EVAL_METHOD_CD     ALE_EVAL_M  ALE_EVAL_M    ALE_EVAL    \n\
COMMENTS               COMMENTS    COMMENTS      COMMENTS    \n\
COMM_CPYRT_NOTICE      COMM_CPYRT  COMM_CPYRT    CPYRT_NOTE  \n\
COMM_LIC_TIER_NOTICE   COMM_LIC_T  COMM_LIC_T    TIER_NOTE   \n\
CREATION_DATE          CREATION_D  CREATION_D    CREAT_DATE  \n\
COMPLETENESS_CODE      COMPLETENE  COMPLETENE    COMPLETENE  \n\
OPERATOR               OPERATOR    OPERATOR      OPERATOR    \n\
ORIG_SOURCE_DATE       ORIG_SOURC  ORIG_SOURC    SRC_DATE    \n\
ORIG_SOURCE_INFO       ORIG_SOU_1  ORIG_SOUR1    SRC_INFO    \n\
ORIGINATING_SOURCE     ORIGINATIN  ORIGINATIN    SRC_NAME    \n");
  
  
  sprintf(junkstring2,"ORIGINATOR             ORIGINATOR  ORIGINATOR    ORIG_AGNCY \n\
RSTRN_DCLS_XMPT_CD     RSTRN_DCLS  RSTRN_DCLS    RSTRN_DCLS  \n\
RSTRN_DECLASS          RSTRN_DECL  RSTRN_DECL    RSTRN_DECL  \n\
RSTRN_DSEM_CTRL_IC     RSTRN_DSEM  RSTRN_DSEM    RSTRN_IC    \n\
RSTRN_DSEM_CTRL_NIC    RSTRN_DS_1  RSTRN_DSE1    RSTRN_DSEM  \n\
RSTRN_FOREIGN_GOV      RSTRN_FORE  RSTRN_FORE    RSTRN_FORE  \n\
RSTRN_RELEASIBILITY    RSTRN_RELE  RSTRN_RELE    RSTRN_RELE  \n\
SCALE                  SCALE       SCALE         SCALE_FAC   \n\
SEC_CD_CNTRL           SEC_CD_CNT  SEC_CD_CNT    SEC_CD_CNT  \n\
SEC_CLASS              SEC_CLASS   SEC_CLASS     SEC_CLASS   \n\
SEC_CLASS_SYS_ID       SEC_CLASS_  SEC_CLASS_    SEC_S_ID    \n\
SEC_CLS_AUTH_DESC      SEC_CLS_AU  SEC_CLS_AU    SEC_AUTH_D  \n\
SEC_CLS_AUTH_MULT      SEC_CLS__1  SEC_CLS_A1    SEC_AUTH_M  \n\
SEC_CLS_AUTHORITY      SEC_CLS__2  SEC_CLS_A2    SEC_AUTH    \n\
SPEC_ID                SPEC_ID     SPEC_ID       SPEC_ID     \n\
UPDATE_SOURCE          UPDATE_SOU  UPDATE_SOU    UPD_NAME    \n\
UPDATE_SOURCE_DATE     UPDATE_S_1  UPDATE_SO1    UPD_DATE    \n\
UPDATE_SOURCE_INFO     UPDATE_S_2  UPDATE_SO2    UPD_INFO    \n\
Z_VALUE_TYPE           Z_VALUE_TY  Z_VALUE_TY    ZVAL_TYPE ");
  
  sprintf(junkstring3,"%s%s",junkstring,junkstring2);
  
  not_while_running(w,junkstring3,1413,"Metadata field naming choices",5);
}


void TRExTypeHelpCallback(Widget w,XtPointer data,XtPointer callData)
{
  not_while_running(w,"This item is used to select the TREx analysis type when creating TREx projects.",1630,"TREx Analysis Type",5);
}




void master_type_cb(Widget menu_item,XtPointer client_data,XtPointer call_data)
{
  int item_no = (int) client_data;
  
  

  MASTERTYPE = item_no;
}


void contour_color_cb(Widget menu_item,XtPointer client_data,XtPointer call_data)
{
  int item_no = (int) client_data;
  
  TheContourColor = item_no;
}


void dev_cb(Widget menu_item,XtPointer client_data,XtPointer call_data)
{
  int item_no = (int) client_data;
  
  DEV_OPTION = item_no;

  printf("DEV_OPTION now %d\n",DEV_OPTION);
}


Widget BuildMetaMenu(Widget parent,int menu_type,char *menu_title,MenuItem *items)
{
  Widget menu, cascade, widget;
  int i,n=0;
  XmString str;
  Arg args[5];
  
  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);
  
  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId, menu);  n++;
  XtSetArg (args[n], XmNlabelString, str); n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;

  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);
  
  metacascade = cascade;

  for (i = 0; items[i].label != NULL; i++) 
    {
      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);
      
 	  if(i==0)
	  {
		  ngametawid = widget;
	  }
      if(i==1)
	  {
		  esrimetawid = widget;
	  }
      if(i==2)
	  {
		  ingrmetawid = widget;
	  }

    
      if  (
	   ((i==0)&&(METATYPE==1)) ||
	   ((i==1)&&(METATYPE==2)) ||
	   ((i==2)&&(METATYPE==3)) ||
	   ((i==3)&&(METATYPE==5)) 
	   )
	{
	  XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);
	}

      if (items[i].callback)
	XtAddCallback (widget,
		       (items[i].cclass == &xmToggleButtonWidgetClass ||
			items[i].cclass == &xmToggleButtonWidgetClass) ?
		       XmNvalueChangedCallback : 
		       XmNactivateCallback,      
		       (XtCallbackProc)items[i].callback, items[i].callback_data);
    }

  return menu_type == XmMENU_POPUP ? menu : cascade;
}



Widget BuildTrexTypeMenu(Widget parent,int menu_type,char *menu_title,MenuItem *items)
{
  Widget menu, cascade, widget;
  int i,n=0;
  XmString str;
  Arg args[5];
  
  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);
  
  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId, menu);  n++;
  XtSetArg (args[n], XmNlabelString, str); n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;

  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);
  


  for (i = 0; items[i].label != NULL; i++) 
    {
      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);
      
    
      if  (i==TREX_TYPE)
	{
	  XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);
	}

      if (items[i].callback)
	XtAddCallback (widget,
		       (items[i].cclass == &xmToggleButtonWidgetClass ||
			items[i].cclass == &xmToggleButtonWidgetClass) ?
		       XmNvalueChangedCallback : 
		       XmNactivateCallback,      
		       (XtCallbackProc)items[i].callback, items[i].callback_data);
    }

  return menu_type == XmMENU_POPUP ? menu : cascade;
}




Widget BuildAttrInsMenu(Widget parent,int menu_type,char *menu_title,MenuItem *items)
{
  Widget menu, cascade, widget;
  int i,n=0;
  XmString str;
  Arg args[5];
  
  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);
  
  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId, menu);  n++;
  XtSetArg (args[n], XmNlabelString, str); n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;

  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);
  

  for (i = 0; items[i].label != NULL; i++) 
    {
      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);
    
      if ((i+1)==ATTRINSTYPE)
	{
	  XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);
	}

      if (items[i].callback)
	XtAddCallback (widget,
		       (items[i].cclass == &xmToggleButtonWidgetClass ||
			items[i].cclass == &xmToggleButtonWidgetClass) ?
		       XmNvalueChangedCallback : 
		       XmNactivateCallback,      
		       (XtCallbackProc)items[i].callback, items[i].callback_data);
    }

  return menu_type == XmMENU_POPUP ? menu : cascade;
}




void LoadLayerPrefCallback(Widget w,Widget list_w,XtPointer unused)
{
  XmString *selectlist;
  char *text;
  char message[1000];
  int totalobjs;



  XtVaGetValues(list_w,
		XmNselectedItemCount,&totalobjs,
		XmNselectedItems    ,&selectlist,
		NULL);
  
  
  if(totalobjs!=1)
    {
      sprintf(message,"To select a layer preference set, select one from\n\
the list, and then click \"Use Selected Layer Preference Set\",\n\
or double-click it in the list.");

      not_while_running(w,message,1449,"Select Layer Preferences Help",5);
      
      return;
    }
  
  XmStringGetLtoR(selectlist[0],
		  (XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
  

  sprintf(layer_pref_file,"%s",text);
  
  printf("use layer prefs %s\n",layer_pref_file);
  
  XtVaSetValues(layerprefs,
		XmNtopAttachment,    XmATTACH_FORM,
		XmNvalue,            layer_pref_file,
		NULL);
  
  XtDestroyWidget(pref_dialog);
}





int BadPrefList(int num)
{
  FILE *infile;
  int line;
  char fname[1000],aline[1000],firstchunk[1000];

  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(fname,"%s\\ProjectPreferences\\%s",PROJECTLOC,GAITPrefList[num]);
    }
  else
    {
      sprintf(fname,"%s/ProjectPreferences/%s",PROJECTLOC,GAITPrefList[num]);
    }

  infile = fopen(fname,"r");

  if(infile==NULL)
    {
      return 1;
    }


  fgets(aline,1000,infile);
  line = 1;

  while(!feof(infile))
    {
      firstchunk[0] = '\0';
      sscanf(aline,"%s",firstchunk);
      
      if(
	 (strcmp(firstchunk,"##"))    &&
	 (strcmp(firstchunk,"AREA"))  &&
	 (strcmp(firstchunk,"LINE"))  &&
	 (strcmp(firstchunk,"POINT"))
	 )
	{
	  printf("file %s is not a valid layer preference file because line %d does not start with ##, POINT, LINE, or AREA: %s\n",GAITPrefList[num],line,aline);
	  fclose(infile);
	  return 1;
	}

      fgets(aline,1000,infile);
      line = line + 1;
    }
  return 0;
}


int ModifyPrefList(int num)
{
  int i,newnum,insertindex;
  
  
  
  
  
  GAITPrefList[num]   = (char *)malloc(500);
  GAITPrefList[num+1] = (char *)malloc(500);
  
  
  for(i=num+1;i>=2;i--)
    {	  
      
      sprintf(GAITPrefList[i],"%s",GAITPrefList[i-2]);
    }
  
  
  sprintf(GAITPrefList[0],"Default (MGCP)");
  sprintf(GAITPrefList[1],"Default (Baseline)");
  
  newnum = num + 2;
  

  

  for(i=2;i<newnum;i++)
    {
      if(BadPrefList(i)==1)
	{
	  printf("Found %s (%d) was bad\n",GAITPrefList[i],i);

	  GAITPrefList[i][0] = '\0';
	}
    }


  

  insertindex = 2;

  for(i=2;i<newnum;i++)
    {
      if(GAITPrefList[i][0]!='\0')
	  {
		  if(insertindex!=i)
		  {
			  sprintf(GAITPrefList[insertindex],"%s",GAITPrefList[i]);
		  }
		  insertindex = insertindex + 1;
	  }

    }



  

  for(i=insertindex;i<newnum;i++)
    {
	  free(GAITPrefList[i]);
    }
  
  return insertindex;
}


void ChoosePrefsCallback(Widget w,XtPointer data,XtPointer callData)
{ 
  char startloc[1000];
  int num,i,type=(int)data;


  if((type==1)&&(pref_up==1))
    {
      ResetWidget(pref_dialog);
      return;
    }
  else if((type==2)&&(pref2_up==1))
    {
      ResetWidget(pref_dialog2);
      return;
    }
  

  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(startloc,"%s\\ProjectPreferences\\",PROJECTLOC);
    }
  else
    {
      sprintf(startloc,"%s/ProjectPreferences/",PROJECTLOC);
    }
  
  num = GetFolders(startloc,6,1);
  


  

      
  SortPrefList(0,num-1,1);


      
  


  
  num = ModifyPrefList(num);
  
  
  


  
  
  if(type==1)
    {
      pref_dialog = MakePicker(w,6,num,-1,-1);
      pref_up = 1;
    }
  else if(type==2)
    {
      pref_dialog2 = MakePicker(w,7,num,-1,-1);
      pref2_up = 1;
    }
  
  for(i=0;i<num;i++)
    {
      free(GAITPrefList[i]);
    }
  free(GAITPrefList);
  GAITPrefList = NULL;
   
}


void SetMetaButtons()
{
  if(METATYPE==5)
    {
      XtSetSensitive(metamap_text_area,  True);
      XtSetSensitive(metamap_browse_area,True);
    }
  else
    {
      XtSetSensitive(metamap_text_area,  False);
      XtSetSensitive(metamap_browse_area,False);
    }

}



void meta_type_cb(Widget menu_item,XtPointer client_data,XtPointer call_data)
{
  int item_no = (int) client_data;
  
  

  METATYPE = item_no;

  SetMetaButtons();

}





int ATTRTYPE_D4()
{
  return ((ATTRIBUTION_TYPE==1)||(ATTRIBUTION_TYPE==2));
}
int ATTRTYPE_FACC()
{
  return ((ATTRIBUTION_TYPE==3)||(ATTRIBUTION_TYPE==4));
}
int ATTRTYPE_VMAP()
{
  return ((ATTRIBUTION_TYPE==5)||(ATTRIBUTION_TYPE==6));
}
int ATTRTYPE_MGCP3()
{
  return (ATTRIBUTION_TYPE==7);
}
int ATTRTYPE_MGCP4()
{
  return (ATTRIBUTION_TYPE==8);
}
int ATTRTYPE_UFD2()
{
  return ((ATTRIBUTION_TYPE==9)||(ATTRIBUTION_TYPE==10));
}
int ATTRTYPE_UFD1()
{
  return ((ATTRIBUTION_TYPE==11)||(ATTRIBUTION_TYPE==12));
}
int ATTRTYPE_UFD3()
{
  return ((ATTRIBUTION_TYPE==13)||(ATTRIBUTION_TYPE==14));
}
int ATTRTYPE_NFDD()
{
  return ((ATTRIBUTION_TYPE==23)||(ATTRIBUTION_TYPE==24));
}
int ATTRTYPE_DFDD()
{
  return ((ATTRIBUTION_TYPE==25)||(ATTRIBUTION_TYPE==26));
}
int ATTRTYPE_SAC()
{
  return ((ATTRIBUTION_TYPE==27)||(ATTRIBUTION_TYPE==28));
}
int ATTRTYPE_GGDM21()
{
  return ((ATTRIBUTION_TYPE==45)||(ATTRIBUTION_TYPE==46));
}
int ATTRTYPE_GGDM22()
{
  return ((ATTRIBUTION_TYPE==29)||(ATTRIBUTION_TYPE==30));
}
int ATTRTYPE_GGDM3()
{
  return ((ATTRIBUTION_TYPE==47)||(ATTRIBUTION_TYPE==48));
}
int ATTRTYPE_TDS4()
{
  return ((ATTRIBUTION_TYPE==39)||(ATTRIBUTION_TYPE==40));
}
int ATTRTYPE_TDS5()
{
  return ((ATTRIBUTION_TYPE==41)||(ATTRIBUTION_TYPE==42));
}
int ATTRTYPE_TDS6()
{
  return ((ATTRIBUTION_TYPE==43)||(ATTRIBUTION_TYPE==44));
}
int ATTRTYPE_ANY_MGCP()
{
  return (ATTRTYPE_MGCP3() || ATTRTYPE_MGCP4());
}
int ATTRTYPE_ANY_UFD()
{
  return (ATTRTYPE_UFD1() || ATTRTYPE_UFD2() || ATTRTYPE_UFD3() );
}
int ATTRTYPE_ANY_TDS()
{
  return (ATTRTYPE_TDS4() || ATTRTYPE_TDS5() || ATTRTYPE_TDS6());
}

int ATTRTYPE_ANY_GGDM()
{
  return (ATTRTYPE_GGDM21()||ATTRTYPE_GGDM22()||ATTRTYPE_GGDM3());
}

int ATTRTYPE_TREX()
{
  extern int GetAttrInsType();

  if(ATTRTYPE_DFDD())
  {
    if(GetAttrInsType()==5)
	{ 
      return 1;
	} 
  }
  return 0;
}





int PossibleForNUNANPO(int test)
{
  if( (test==1) ||  
	  (test==3) ||  
	  (test==5) ||  
	  (test==9) ||  
	  (test==11)||  
	  (test==13)||  
	  (test==23)||  
	  (test==25)    
	)
  {
    return 1;
  }

  return 0;
}



int MetaMappingPossible(int attr_type_in)
{

 int temp;

 temp = ATTRIBUTION_TYPE;

 ATTRIBUTION_TYPE = attr_type_in;


 

 if(
     (ATTRTYPE_ANY_MGCP()) ||
     (ATTRTYPE_ANY_TDS())  ||
     (ATTRTYPE_ANY_GGDM()) ||
     (ATTRTYPE_NFDD())     ||
     (ATTRTYPE_DFDD())     ||
     (ATTRTYPE_SAC())
  )
 {
   ATTRIBUTION_TYPE = temp;
   return 0;
 }

 ATTRIBUTION_TYPE = temp;

 return 1;
}



void attr_type_cb(Widget menu_item,XtPointer client_data,XtPointer call_data)
{
  int item_no = (int) client_data;

  



  if(item_no==999)
  {
    
	CREATING_TREX = 1;
    item_no = 26;
  }
  else
  {
    CREATING_TREX = 0;
  }


  TEMP_ATTRIBUTION_TYPE = item_no;


  

  if(
	  (CREATING_TREX==0) &&   
	  (
	    (TEMP_ATTRIBUTION_TYPE==23)||(TEMP_ATTRIBUTION_TYPE==24)||
	    (TEMP_ATTRIBUTION_TYPE==25)||(TEMP_ATTRIBUTION_TYPE==26)
	  )
	)
  {
    XtSetSensitive(attr_ins_menu,      True);
    XtSetSensitive(attrins_text_area,  True);
    XtSetSensitive(attrins_label_area, True);
    XtSetSensitive(attrins_browse_area,True);
  }
  else
  {
    XtSetSensitive(attr_ins_menu,      False);
    XtSetSensitive(attrins_text_area,  False);
    XtSetSensitive(attrins_label_area, False);
    XtSetSensitive(attrins_browse_area,False);
  }



  if((TEMP_ATTRIBUTION_TYPE==7)||(TEMP_ATTRIBUTION_TYPE==8))
  { 
    if(!strcmp(layer_pref_file,"Default (Baseline)"))
	{ 
	  sprintf(layer_pref_file,"Default (MGCP)");
	} 
  }
  else
  {
    if(!strcmp(layer_pref_file,"Default (MGCP)"))
	{ 
	  sprintf(layer_pref_file,"Default (Baseline)");
	} 
  }
 
 XtVaSetValues(layerprefs,
	       XmNvalue,            layer_pref_file,
	       NULL);

 
 if((TEMP_ATTRIBUTION_TYPE==7)||(TEMP_ATTRIBUTION_TYPE==8))
   {
     XtSetSensitive(esrimetawid,False);
     XtSetSensitive(ingrmetawid,False);
     
     
     
     if((METATYPE!=5)&&(METATYPE!=1))
       {
	 
	 
	 XtVaSetValues(metacascade,				
		       XmNmenuHistory, ngametawid,
		       NULL);
	 
	 METATYPE = 1;
       }
   }
 else
   {
     XtSetSensitive(esrimetawid,True);
     XtSetSensitive(ingrmetawid,True);
   }




  if(PossibleForNUNANPO(TEMP_ATTRIBUTION_TYPE)==1)
  {
    XtSetSensitive(NUNANPO_button,True);
  }
  else
  {
    XtSetSensitive(NUNANPO_button,False);
    NUNANPO_TYPE = 0;
    XmToggleButtonSetState(NUNANPO_button,(Boolean)NUNANPO_TYPE,(Boolean)0);
  }
  



  if(MetaMappingPossible(TEMP_ATTRIBUTION_TYPE)==0)
  {
    XtSetSensitive(meta_type_menu,False);
  }
  else
  {
    XtSetSensitive(meta_type_menu,True);
  }


  if(CREATING_TREX==0)
  {
    XtSetSensitive(trex_type_menu,False);
    XtSetSensitive(append_button,True);
  }
  else
  {
    XtSetSensitive(trex_type_menu,True);

	
    XtSetSensitive(append_button,False);
	AppendInputSpec = 0;
    XmToggleButtonSetState(append_button,(Boolean)AppendInputSpec,(Boolean)0);
  }


}


double ModifyFormatMult(double oldmult)
{
  int total;
  extern int SH_Points_Done;
  extern int SH_Linears_Done;
  extern int SH_Areals_Done;

  


  if(CREATING_TREX==1)
  {
	
    return oldmult/5.0;
  }



  


  total = SH_Linears_Done + SH_Areals_Done + SH_Points_Done/2;


  

  if(total>4000000)
  {
    if(oldmult<49)
	{
      oldmult = 49;
	}
  }
  else if(total>3000000)
  {
    if(oldmult<36)
	{
      oldmult = 36;
	}
  }
  else if(total>2000000)
  {
    if(oldmult<25)
	{
      oldmult = 25;
	}
  }
  else if(total>1000000)
  {
    if(oldmult<16)
	{
      oldmult = 16;
	}
  }
  else if(total>500000)
  {
    if(oldmult<9)
	{
      oldmult = 9;
	}
  }

  if(oldmult>49)
  {
    oldmult = 49;
  }




  if(DoDev==0)
  {
    return oldmult;
  }


  if(DEV_OPTION==1) 
  {
    return oldmult;
  }

  if(DEV_OPTION==2) 
  {
	if(oldmult<0.5)
	{
      return oldmult * 50.0;
	}
	if(oldmult<1)
	{
      return oldmult * 25.0;
	}
	if(oldmult<2)
	{
      return oldmult * 10.0;
	}
	if(oldmult < 5)
	{
	  return oldmult * 7.0;
	}
	if(oldmult < 7)
	{
	  return oldmult * 4.0;
	}
	if(oldmult < 10)
	{
	  return oldmult * 3.0;
	}
	if(oldmult < 14)
	{
	  return oldmult * 2.0;
	}
	if(oldmult < 20)
	{
	  return oldmult * 1.5;
	}

    return 49.0;
  }

  
  return 49.0;

}



void AttrCheckCallback(Widget w,XtPointer data,XtPointer callData)
{
  ATTRINSTYPE = (int)data;
}


void trex_type_cb(Widget w,XtPointer data,XtPointer callData)
{
  TREX_TYPE = (int)data;
}





void Import3Callback(Widget w,XtPointer data,XtPointer callData)
{
  Widget parent;
  Arg Args[15];
  XmString t;
  FILE *tempfile;
  char message[500],comboname[1000],domainsname[1000],resultmessage[2500],resultmessage2[2500],
	  VVname[1000],VVdomainsname[1000],resultmessage3[2500];
  int n=0,success,old_attr_type=-1;
  extern Widget attrdialog;
  extern int ATTRINSTYPE,OVERRIDING_ATTRINS,DO_QAST;
  extern int Extract(int TYPE, char file[]);
  extern void E_FreeTree();
  extern char * ParseUserSchema(char *combofile, char * domainfile);
  extern char * ParseUserVVFiles(char *VVfile, char * VVdomainfile);


  if((int)data==1)
  {
    
    if(batch_mode==0)
    {
      XtUnmanageChild(XtParent(XtParent(w)));
      XtDestroyWidget(XtParent(XtParent(w))); 
    }
  }

  if(BadConditions(2,w,NULL,(int)data))
  {
    return;
  }

 
  
  
  parent = drawing_a;

  DoAttrChecking = 1;

  BIN_ATTR_TYPE = 1;

  if(NGA_TYPE==1)
  {
    if(
		(TEMP_ATTRIBUTION_TYPE==23)||(TEMP_ATTRIBUTION_TYPE==24)||
		(TEMP_ATTRIBUTION_TYPE==25)||(TEMP_ATTRIBUTION_TYPE==26)
		)
	{
	  if(CREATING_TREX==1)
	  {
		printf("Begin creating TREX project\n");
        DoAttrChecking = 0;
	  }
      else if(ATTRINSTYPE==1)
	  {
        DoAttrChecking = 0;
		printf("Not performing any additional attribution inspections\n");
	  }
	  else if(ATTRINSTYPE==2)
	  {
        
		printf("Using built-in NAS-based attribution inspections\n");
	  }
	  else if((ATTRINSTYPE==3)||(ATTRINSTYPE==4))
	  {
        
		BIN_ATTR_TYPE = 0;

		if(attrins_source==0)
		{

          sprintf(resultmessage,"\
Error: When using \"User-pecified\" attribution inspections, you are required\n\
to specify a \"Folder with attribution files\"");


          

          IMPORT_WIN=0;

          if(NGA_TYPE==1)
		  { 
	        ImportGAITButtonCallback((Widget) NULL,(XtPointer)NULL,(XtPointer) NULL);
		  } 
          else
		  { 
	        ImportSEEITButtonCallback((Widget) NULL,(XtPointer)NULL,(XtPointer) NULL);
		  } 

          not_while_running(GetImportShell(),resultmessage,1530,"No \"Folder with attribution files\" specified",1);

          return;
		}

		printf("using user-defined attribution file folder:\n  %s\n",attrinsfolder);

		if(ATTRINSTYPE==4)
		{
           printf("Also using valid values files from this folder\n");
		}

        if((TEMP_ATTRIBUTION_TYPE==23)||(TEMP_ATTRIBUTION_TYPE==24))
		{
          sprintf(comboname,    "%sNFDD.csv",attrinsfolder);
          sprintf(domainsname,  "%sNFDD_domains.csv",attrinsfolder);
          sprintf(VVname,       "%sNFDD_VV.csv",attrinsfolder);
          sprintf(VVdomainsname,"%sNFDD_VVdomains.csv",attrinsfolder);
		}
        else if((TEMP_ATTRIBUTION_TYPE==25)||(TEMP_ATTRIBUTION_TYPE==26))
		{
          sprintf(comboname,    "%sDFDD.csv",attrinsfolder);
          sprintf(domainsname,  "%sDFDD_domains.csv",attrinsfolder);
          sprintf(VVname,       "%sDFDD_VV.csv",attrinsfolder);
          sprintf(VVdomainsname,"%sDFDD_VVdomains.csv",attrinsfolder);
		}





        if((TEMP_ATTRIBUTION_TYPE==23)||(TEMP_ATTRIBUTION_TYPE==24))
		{

		  tempfile = fopen(comboname,"r");
		  if(tempfile==NULL)
		  { 
            sprintf(resultmessage,"\
Error: When using \"User-specified\" attribution inspections with the NFDD\n\
attribution schema, you are required to specify a \"Folder with attribution files\"\n\
that contains the specification files NFDD.csv and NFDD_domains.csv.\n\n\
The file %s was not found.\n",comboname);

			if(batch_mode==1)
			{
              printf("%s\n",resultmessage);
              exit(-1);
			}

            

            IMPORT_WIN=0;

            if(NGA_TYPE==1)
			{  
	          ImportGAITButtonCallback((Widget) NULL,(XtPointer)NULL,(XtPointer) NULL);
			}
            else
			{
              ImportSEEITButtonCallback((Widget) NULL,(XtPointer)NULL,(XtPointer) NULL);
			} 

            not_while_running(parent,resultmessage,1531,"No \"NFDD.csv\" in specified folder",1);

            return;
		  } 
		  fclose(tempfile);


		  tempfile = fopen(domainsname,"r");
		  if(tempfile==NULL)
		  { 
            sprintf(resultmessage,"\
Error: When using \"User-specified\" attribution inspections with the NFDD\n\
attribution schema, you are required to specify a \"Folder with attribution files\"\n\
that contains the specification files NFDD.csv and NFDD_domains.csv.\n\n\
The file %s was not found.\n",domainsname);

			if(batch_mode==1)
			{
              printf("%s\n",resultmessage);
              exit(-1);
			}

            

            IMPORT_WIN=0;

            if(NGA_TYPE==1)
			{
	          ImportGAITButtonCallback((Widget) NULL,(XtPointer)NULL,(XtPointer) NULL);
			}
            else
			{
	          ImportSEEITButtonCallback((Widget) NULL,(XtPointer)NULL,(XtPointer) NULL);
			}

            not_while_running(parent,resultmessage,1532,"No \"NFDD_domains.csv\" in specified folder",1);

            return;
		  } 
		  fclose(tempfile);


		  if(ATTRINSTYPE==4)
		  {
		    tempfile = fopen(VVname,"r");
		    if(tempfile==NULL)
			{  
              sprintf(resultmessage,"\
Error: When using \"User-specified with valid values\" with the NFDD\n\
attribution schema, you are required to specify a \"Folder with attribution files\"\n\
that contains the specification files NFDD_VV.csv and NFDD_VVdomains.csv.\n\n\
The file %s was not found.\n",VVname);

			  if(batch_mode==1)
			  { 
                printf("%s\n",resultmessage);
                exit(-1);
			  } 

              

              IMPORT_WIN=0;

              if(NGA_TYPE==1)
			  { 
	            ImportGAITButtonCallback((Widget) NULL,(XtPointer)NULL,(XtPointer) NULL);
			  } 
              else
			  { 
	            ImportSEEITButtonCallback((Widget) NULL,(XtPointer)NULL,(XtPointer) NULL);
			  } 

              not_while_running(parent,resultmessage,1532,"No \"NFDD_VV.csv\" in specified folder",1);

              return;
			} 
		    fclose(tempfile);



		    tempfile = fopen(VVdomainsname,"r");
		    if(tempfile==NULL)
			{  
              sprintf(resultmessage,"\
Error: When using \"User-specified with valid values\" with the NFDD\n\
attribution schema, you are required to specify a \"Folder with attribution files\"\n\
that contains the specification files NFDD_VV.csv and NFDD_VVdomains.csv.\n\n\
The file %s was not found.\n",VVdomainsname);

			  if(batch_mode==1)
			  { 
                printf("%s\n",resultmessage);
                exit(-1);
			  } 

              

              IMPORT_WIN=0;

              if(NGA_TYPE==1)
			  { 
	            ImportGAITButtonCallback((Widget) NULL,(XtPointer)NULL,(XtPointer) NULL);
			  } 
              else
			  { 
	            ImportSEEITButtonCallback((Widget) NULL,(XtPointer)NULL,(XtPointer) NULL);
			  } 

              not_while_running(parent,resultmessage,1532,"No \"NFDD_VVdomains.csv\" in specified folder",1);

              return;
			} 
		    fclose(tempfile);

		  } 

		} 


        if((TEMP_ATTRIBUTION_TYPE==25)||(TEMP_ATTRIBUTION_TYPE==26))
		{
		  tempfile = fopen(comboname,"r");
		  if(tempfile==NULL)
		  { 
            sprintf(resultmessage,"\
Error: When using \"User-specified\" attribution inspections with the DFDD\n\
attribution schema, you are required to specify a \"Folder with attribution files\"\n\
that contains the specification files DFDD.csv and DFDD_domains.csv.\n\n\
The file %s was not found.\n",comboname);
      
			if(batch_mode==1)
			{
              printf("%s\n",resultmessage);
              exit(-1);
			}

            

            IMPORT_WIN=0;

            if(NGA_TYPE==1)
			{
	          ImportGAITButtonCallback((Widget) NULL,(XtPointer)NULL,(XtPointer) NULL);
			}
            else
			{
	          ImportSEEITButtonCallback((Widget) NULL,(XtPointer)NULL,(XtPointer) NULL);
			}

            not_while_running(parent,resultmessage,1533,"No \"DFDD.csv\" in specified folder",1);

            return;
		  } 
		  fclose(tempfile);

		  tempfile = fopen(domainsname,"r");
		  if(tempfile==NULL)
		  { 
            sprintf(resultmessage,"\
Error: When using \"User-specified\" attribution inspections with the DFDD\n\
attribution schema, you are required to specify a \"Folder with attribution files\"\n\
that contains the specification files DFDD.csv and DFDD_domains.csv.\n\n\
The file %s was not found.\n",domainsname);
      
			if(batch_mode==1)
			{
              printf("%s\n",resultmessage);
              exit(-1);
			}

            

            IMPORT_WIN=0;

            if(NGA_TYPE==1)
			{
	          ImportGAITButtonCallback((Widget) NULL,(XtPointer)NULL,(XtPointer) NULL);
			}
            else
			{
	          ImportSEEITButtonCallback((Widget) NULL,(XtPointer)NULL,(XtPointer) NULL);
			}

            not_while_running(parent,resultmessage,1534,"No \"DFDD_domains.csv\" in specified folder",1);

            return;
		  } 
		  fclose(tempfile);



		  if(ATTRINSTYPE==4)
		  {
		    tempfile = fopen(VVname,"r");
		    if(tempfile==NULL)
			{  
              sprintf(resultmessage,"\
Error: When using \"User-specified with valid values\" with the DFDD\n\
attribution schema, you are required to specify a \"Folder with attribution files\"\n\
that contains the specification files DFDD_VV.csv and DFDD_VVdomains.csv.\n\n\
The file %s was not found.\n",VVname);

			  if(batch_mode==1)
			  { 
                printf("%s\n",resultmessage);
                exit(-1);
			  } 

              

              IMPORT_WIN=0;

              if(NGA_TYPE==1)
			  { 
	            ImportGAITButtonCallback((Widget) NULL,(XtPointer)NULL,(XtPointer) NULL);
			  } 
              else
			  { 
	            ImportSEEITButtonCallback((Widget) NULL,(XtPointer)NULL,(XtPointer) NULL);
			  } 

              not_while_running(parent,resultmessage,1532,"No \"DFDD_VV.csv\" in specified folder",1);

              return;
			} 
		    fclose(tempfile);



		    tempfile = fopen(VVdomainsname,"r");
		    if(tempfile==NULL)
			{  
              sprintf(resultmessage,"\
Error: When using \"User-specified with valid values\" with the DFDD\n\
attribution schema, you are required to specify a \"Folder with attribution files\"\n\
that contains the specification files DFDD_VV.csv and DFDD_VVdomains.csv.\n\n\
The file %s was not found.\n",VVdomainsname);

			  if(batch_mode==1)
			  { 
                printf("%s\n",resultmessage);
                exit(-1);
			  } 

              

              IMPORT_WIN=0;

              if(NGA_TYPE==1)
			  { 
	            ImportGAITButtonCallback((Widget) NULL,(XtPointer)NULL,(XtPointer) NULL);
			  } 
              else
			  { 
	            ImportSEEITButtonCallback((Widget) NULL,(XtPointer)NULL,(XtPointer) NULL);
			  } 

              not_while_running(parent,resultmessage,1532,"No \"DFDD_VVdomains.csv\" in specified folder",1);

              return;
			} 
		    fclose(tempfile);

		  } 

		} 


		old_attr_type = ATTRIBUTION_TYPE;
        ATTRIBUTION_TYPE = TEMP_ATTRIBUTION_TYPE;
        InitializeAttribution();
        printf("Attribution schema in effect %s\n",ParseAttributionType(ATTRIBUTION_TYPE));

        printf("parsing user attr files\n");

        not_while_running(drawing_a,"Parsing user-supplied attribution files.\nPlease be patient.",1536,"Please be patient.",5);


        sprintf(resultmessage,"%s",ParseUserSchema(comboname,domainsname));
        printf("resultmessage is *** %s ***\n",resultmessage);

		if(ATTRINSTYPE==4)
		{
          sprintf(resultmessage2,"%s",ParseUserVVFiles(VVname,VVdomainsname));
          printf("resultmessage2 is *** %s ***\n",resultmessage);
		}
		else
		{
          resultmessage2[0] = '\0';
		}

        if(attrdialog!=NULL)
		{
		  XtPopdown(XtParent(attrdialog));
          XtDestroyWidget(attrdialog);
		}

        if((resultmessage[0]!='\0')||(resultmessage2[0]!='\0'))
		{

           ATTRIBUTION_TYPE = old_attr_type;
           InitializeAttribution();
           printf("Reverting to attribution schema %s\n",ParseAttributionType(ATTRIBUTION_TYPE));

           if(resultmessage[0]!='\0')
		   {
			  sprintf(resultmessage3,"Error parsing user-specified attribution inspection files:\n  %s and\n  %s\n\n%s\n",comboname,domainsname,resultmessage);
		   }
           else if(resultmessage2[0]!='\0')
		   {
			  sprintf(resultmessage3,"Error parsing user-specified valid value files:\n  %s and\n  %s\n\n%s\n",VVname,VVdomainsname,resultmessage2);
		   }

            

            IMPORT_WIN=0;

            if(NGA_TYPE==1)
			{
	          ImportGAITButtonCallback((Widget) NULL,(XtPointer)NULL,(XtPointer) NULL);
			}
            else
			{
	          ImportSEEITButtonCallback((Widget) NULL,(XtPointer)NULL,(XtPointer) NULL);
			}

           not_while_running(parent,resultmessage3,1535,"Error parsing user-specified attribution inspection files",1);
           return;
		}

		printf("Using User-specified attribution specification files:\n %s\n and %s\n",comboname,domainsname);
		if(ATTRINSTYPE==4)
		{
          printf("  Also using User-specified valid value files:\n %s\n and %s\n",VVname,VVdomainsname);
		}

	  }
	  else
	  {
        XBell(mydisplay,50);
		printf("Error: I3C got DAC %d\n",DoAttrChecking);
		return;
	  }
	}
  }


  ResetContours();

  



  if(batchsilent==0)
  {
    sprintf(message,"Extracting %s.",importdirectory);
  
    t = XmStringCreateLtoR (message,XmSTRING_DEFAULT_CHARSET);
  
    n = 0;
    XtSetArg(Args[n], XmNcancelLabelString,  STRING("Abort"));        n++;
    XtSetArg(Args[n], XmNdialogTitle,        STRING("Importing...")); n++;
    XtSetArg(Args[n], XmNmessageString,      t);                      n++;
    XtSetArg(Args[n], XmNdefaultPosition,    False);                  n++;
    XtSetArg(Args[n], XmNx,                  100);                    n++;
    XtSetArg(Args[n], XmNy,                  100);                    n++;

    extract_dialog = XmCreateInformationDialog (drawing_a, "Importing...", Args, n);
  
    XtUnmanageChild (XmMessageBoxGetChild (extract_dialog, XmDIALOG_OK_BUTTON));      
    XtUnmanageChild (XmMessageBoxGetChild (extract_dialog, XmDIALOG_HELP_BUTTON));      
    XtAddCallback   (extract_dialog, XmNcancelCallback, exitCallback, (XtPointer)18);
 


    XtManageChild (extract_dialog);
    XtPopup  (XtParent(extract_dialog), XtGrabNone);
    XmStringFree (t);
  }

   
  BUSY = 1;
  set_cursor(mydisplay,mywindow,WATCH);

  E_FreeTree();
  
  StartTime = time(NULL);


  

  RemoveOldExtractFiles();


  if(NUNANPO_TYPE>0)
  {
    if(PossibleForNUNANPO(TEMP_ATTRIBUTION_TYPE)==1)
	{
      TEMP_ATTRIBUTION_TYPE = TEMP_ATTRIBUTION_TYPE + 1;
	}
	else
	{
      printf("Error: NT %d but PFN(%d) %d\n",
		  NUNANPO_TYPE,TEMP_ATTRIBUTION_TYPE,PossibleForNUNANPO(TEMP_ATTRIBUTION_TYPE));
	}
  }


  if(NGA_TYPE==1)
    {
	  if(CREATING_TREX==1)
	  {
	    OVERRIDING_ATTRINS = 5;
	  }

	  if(ATTRIBUTION_TYPE!=TEMP_ATTRIBUTION_TYPE)
	  {
        ATTRIBUTION_TYPE = TEMP_ATTRIBUTION_TYPE;

        InitializeAttribution();

		if(OVERRIDING_ATTRINS!=5)
		{
		  OVERRIDING_ATTRINS = -2;
		}

        printf("New attribution schema in effect %s\n",ParseAttributionType(ATTRIBUTION_TYPE));

	  }
	  else
	  {
		if(OVERRIDING_ATTRINS!=5)
		{
		  OVERRIDING_ATTRINS = -2;
		}

        printf("Attribution schema still in effect %s\n",ParseAttributionType(ATTRIBUTION_TYPE));
	  }
    }

  OVERRIDING_ATTRINS = -1; 


  if(MakeOutStuff(importoutputdir)==0)
    {
      success = 0;
    }
  else
    {
      int change;
      change = 0;

      if(METATYPE==4)
	{
	  
	  change = 1;
	  METATYPE = 1;
	}

      if(NGA_TYPE==0)
	{
	  EXTRACT_STARTTIME = StartTime;
	}

      RemoveLayerFile();

      success = Extract(TYPE,importdirectory); 

      if(change==1)
	{
	  
	  METATYPE = 4;
	}

      FreeShapeMemory();
      
      E_FreeTree();
      
      

      if((ATTRINSTYPE==3)||(ATTRINSTYPE==4))
	  {
        

        sprintf(resultmessage,"%sattribution_errors",importoutputdir);

        if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		{
          sprintf(resultmessage2,"copy \"%s\" \"%s\"",comboname,resultmessage);
          system(resultmessage2);

          sprintf(resultmessage2,"copy \"%s\" \"%s\"",domainsname,resultmessage);
          system(resultmessage2);
		}
		else
		{
          sprintf(resultmessage2,"cp \"%s\" \"%s\"",comboname,resultmessage);
          system(resultmessage2);

          sprintf(resultmessage2,"cp \"%s\" \"%s\"",domainsname,resultmessage);
          system(resultmessage2);
		}

		if(ATTRINSTYPE==4)
		{
          if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
		  {
            sprintf(resultmessage2,"copy \"%s\" \"%s\"",VVname,resultmessage);
            system(resultmessage2);

            sprintf(resultmessage2,"copy \"%s\" \"%s\"",VVdomainsname,resultmessage);
            system(resultmessage2);
		  }
		  else
		  { 
            sprintf(resultmessage2,"cp \"%s\" \"%s\"",VVname,resultmessage);
            system(resultmessage2);

            sprintf(resultmessage2,"cp \"%s\" \"%s\"",VVdomainsname,resultmessage);
            system(resultmessage2);
		  } 
		}
	  }
    }


  if(NUNANPO_TYPE>0)
  {
    if(PossibleForNUNANPO(TEMP_ATTRIBUTION_TYPE-1)==1)
	{
      TEMP_ATTRIBUTION_TYPE = TEMP_ATTRIBUTION_TYPE - 1;
	}
	else
	{
      printf("Error: (2) NT %d but PFN(%d) %d\n",
		  NUNANPO_TYPE,TEMP_ATTRIBUTION_TYPE-1,PossibleForNUNANPO(TEMP_ATTRIBUTION_TYPE-1));
	}
  }



  
  if(success==0)
    {
      

      

	  if(batchsilent==0)
	  {
        XtVaSetValues(extract_dialog,
		    XmNcancelLabelString, STRING("Bummer!"),
		    NULL);
	  }

	  if(DO_QAST==0)
	  {
		
        ABORT_EXTRACT = 0;
	  }
      BUSY = 0;
      set_cursor(mydisplay,mywindow,GOOD);
      return;
    }
  else
    {
      if(CheckDataContent(importoutputdir,0)==0)
	{
	  
	  if(batchsilent==0)
	  {
	    XtVaSetValues(extract_dialog,
			XmNcancelLabelString, STRING("Bummer!"),
			NULL);
	  }
	  ABORT_EXTRACT = 0;
	  BUSY = 0;
	  set_cursor(mydisplay,mywindow,GOOD);
	  return;
	}
      
      
      SetEndian(importoutputdir);

      
      


	  if(batchsilent==0)
	  {
        XtPopdown(XtParent(extract_dialog));
        XtDestroyWidget(extract_dialog);
	  }
      

      WriteDynamicDefs();


      


      FormatCallback(drawing_a,(XtPointer)NULL,(XtPointer)NULL);

      BUSY = 0;
      set_cursor(mydisplay,mywindow,GOOD);
      return;
    }
}










void ImportGAITButtonCallback(Widget w,XtPointer data,XtPointer callData)
{
  Widget rowcol,form,button,button1,button2,text_w,master_type_menu,dev_menu,NoZ_button;
  Arg args[15];
  int n = 0,flipper;
  char tempvalue[1000];
  Dimension Pheight;
  extern int FORMATBUTTON;


  MenuItem attribution_type[] = {
    {"Select Schema...",       &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_type_cb, (XtPointer)0,  (MenuItem *) NULL},
    {ParseAttributionType(1),  &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_type_cb, (XtPointer)1,  (MenuItem *) NULL},
      
    {ParseAttributionType(3),  &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_type_cb, (XtPointer)3,  (MenuItem *) NULL},
     
    {ParseAttributionType(5),  &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_type_cb, (XtPointer)5,  (MenuItem *) NULL},
     
    {ParseAttributionType(7),  &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_type_cb, (XtPointer)7,  (MenuItem *) NULL},
	{ParseAttributionType(8),  &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_type_cb, (XtPointer)8,  (MenuItem *) NULL},
    {ParseAttributionType(11), &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_type_cb, (XtPointer)11, (MenuItem *) NULL},
     
    {ParseAttributionType(9),  &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_type_cb, (XtPointer)9,  (MenuItem *) NULL},
     
    {ParseAttributionType(13), &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_type_cb, (XtPointer)13, (MenuItem *) NULL},
     

	


    
	{ParseAttributionType(39), &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_type_cb, (XtPointer)39, (MenuItem *) NULL},




	
	{ParseAttributionType(43), &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_type_cb, (XtPointer)43,(MenuItem *) NULL},

	

    {ParseAttributionType(27), &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_type_cb, (XtPointer)27, (MenuItem *) NULL},
    


	
    {"TREx", &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_type_cb, (XtPointer)999,(MenuItem *) NULL},


	
    {ParseAttributionType(45), &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_type_cb, (XtPointer)45, (MenuItem *) NULL},

	
    {ParseAttributionType(29), &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_type_cb, (XtPointer)29, (MenuItem *) NULL},

	
    {ParseAttributionType(47), &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_type_cb, (XtPointer)47, (MenuItem *) NULL},


	{ParseAttributionType(23), &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_type_cb, (XtPointer)23, (MenuItem *) NULL},
     
    {ParseAttributionType(25), &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_type_cb, (XtPointer)25, (MenuItem *) NULL},
     


    {NULL},
  };






  MenuItem metadata_type[] = {
    {"MGCP/NGA",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())meta_type_cb, (XtPointer)1, (MenuItem *) NULL},
    {"ESRI",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())meta_type_cb, (XtPointer)2, (MenuItem *) NULL},
    {"Intergraph",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())meta_type_cb, (XtPointer)3, (MenuItem *) NULL},
    {"User-Defined",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())meta_type_cb, (XtPointer)5, (MenuItem *) NULL},
    {NULL},
  };


  MenuItem master_type[] = {
    {"DFEG Master Profile",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())master_type_cb, (XtPointer)1, (MenuItem *) NULL},
    {"MGCP Master Profile",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())master_type_cb, (XtPointer)3, (MenuItem *) NULL},
    {"UFD1 Master Profile",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())master_type_cb, (XtPointer)4, (MenuItem *) NULL},
    {"UFD3 Master Profile",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())master_type_cb, (XtPointer)5, (MenuItem *) NULL},
    {"TDS Master Profile",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())master_type_cb, (XtPointer)11,(MenuItem *) NULL},
    {"AFD Master Profile",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())master_type_cb, (XtPointer)10,(MenuItem *) NULL},
    {"TREx Master Profile",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())master_type_cb, (XtPointer)12,(MenuItem *) NULL},
    {NULL},
  };


  MenuItem dev_type[] = {
    {"Normal",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())dev_cb, (XtPointer)1, (MenuItem *) NULL},
    {"High",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())dev_cb, (XtPointer)2, (MenuItem *) NULL},
    {"Maximum",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())dev_cb, (XtPointer)3, (MenuItem *) NULL},
    {NULL},
  };

  MenuItem trex_type[] = {
    {"Not Specified",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())trex_type_cb, (XtPointer)0, (MenuItem *) NULL},
    {"QC",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())trex_type_cb, (XtPointer)1, (MenuItem *) NULL},
    {"cQA",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())trex_type_cb, (XtPointer)2, (MenuItem *) NULL},
    {"sQA",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())trex_type_cb, (XtPointer)3, (MenuItem *) NULL},
    {NULL},
  };


  
  MenuItem dd_menu[] = {  
    { "None", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrCheckCallback,(XtPointer)1,  (MenuItem *) NULL },    
    { "NAS-based", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrCheckCallback,(XtPointer)2,  (MenuItem *) NULL },    
    { "User-specified", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrCheckCallback,(XtPointer)3,  (MenuItem *) NULL },    
    { "User-specified with valid values", &xmPushButtonWidgetClass, '!',NULL,NULL,
      (void (*)())AttrCheckCallback,(XtPointer)4,  (MenuItem *) NULL },    
    {NULL},
  };


  flipper = 0;
  if((int)data==999)
  {
    flipper = 1;
  }
  

  if(flipper==1)
  {
    if(import_head_in_use==1)
    {
      XtPopdown(importshell);
	  XtDestroyWidget(importshell);
	  import_head_in_use = 0;
	  IMPORT_WIN = 0;
    }
    else if(import_head_in_use==0)
	{
      XtPopdown(importshell2);
	  XtDestroyWidget(importshell2);
	  import_head_in_use = 1;
	  IMPORT_WIN = 0;
	}
  }


  if(IMPORT_WIN==0)
    {
      ABORT_EXTRACT = 0;


	  if(import_head_in_use==1)
	  {
        importshell = XtCreatePopupShell("Create GAIT Project...",
				       topLevelShellWidgetClass,drawing_a,args,n);

        rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass, importshell, NULL);
      }
	  else
	  {
        importshell2 = XtCreatePopupShell("Create GAIT Project...",
				       topLevelShellWidgetClass,drawing_a,args,n);

        rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass, importshell2, NULL);
	  }



      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
      text_w = XtVaCreateManagedWidget ("Create GAIT Project:",
					xmLabelWidgetClass, form,
					XmNtraversalOn,      True,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,  99,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					LABELWTRANSLATE,
					NULL);      
      XtManageChild(form);


	  
      
      if(NGA_TYPE==1)
	{
	  form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
				   XmNfractionBase,  100,
				   NULL);
	  
	  attr_type_menu = BuildImportMenu (form, XmMENU_OPTION, "Attribution Schema:", attribution_type);

	  XtManageChild (attr_type_menu);
	  XtManageChild(form);
	}



      TYPE = 3; 







      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);    
      

      button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Help"),
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, ImportHelpCallback, (XtPointer)25);
      XtManageChild(button);


      NUNANPO_button = XtVaCreateManagedWidget ("Allow Additional NUNANPO Values   ",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,          XmATTACH_FORM,
					 XmNtraversalOn,            False,
					 XmNbottomAttachment,       XmATTACH_FORM,
					 XmNleftAttachment,         XmATTACH_WIDGET,
					 XmNleftWidget,             button,
					 XmNlabelString,            STRING("Allow Additional NUNANPO Values   "),
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);

      XtAddCallback (NUNANPO_button, XmNvalueChangedCallback,Iinvert, (XtPointer)21);
      XmToggleButtonSetState(NUNANPO_button,(Boolean)NUNANPO_TYPE,(Boolean)0);



      button2 = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Help"),
					XmNtraversalOn,        False,
					XmNleftAttachment,     XmATTACH_WIDGET,
					XmNleftWidget,         NUNANPO_button,
					TOGGLETRANSLATE,       TOGGLEINCLUDE,
					NULL);
      XtAddCallback(button2, XmNactivateCallback, ImportHelpCallback, (XtPointer)26);
      XtManageChild(button2);


      NoZ_button = XtVaCreateManagedWidget ("Ignore Feature Z Values",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,          XmATTACH_FORM,
					 XmNtraversalOn,            False,
					 XmNbottomAttachment,       XmATTACH_FORM,
					 XmNleftAttachment,         XmATTACH_WIDGET,
					 XmNleftWidget,             button2,
					 XmNlabelString,            STRING("Ignore Feature Z Values"),
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);

      XtAddCallback (NoZ_button, XmNvalueChangedCallback,Iinvert, (XtPointer)22);
      XmToggleButtonSetState(NoZ_button,(Boolean)NoZ_Values,(Boolean)0);


      XtManageChild(form);


	  if(PossibleForNUNANPO(TEMP_ATTRIBUTION_TYPE)==0)
	  {
        XtSetSensitive(NUNANPO_button,False);
	  }





      

      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);      
      text_w = XtVaCreateManagedWidget ("Input Specification File/Project Location:",
					xmLabelWidgetClass, form,
					LABELWTRANSLATE,
					NULL);
      XtManageChild(form);





      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);      
      if(import_source==0)
	{
	  terrain_to_import = XtVaCreateManagedWidget ("   <enter project name below to specify>                                        ",
						       xmLabelWidgetClass, form,
						       LABELWTRANSLATE,
						       NULL);
	}
      else if(import_source==1)
	{
	  terrain_to_import = XtVaCreateManagedWidget (importdirectory,
						       xmLabelWidgetClass, form,
						       LABELWTRANSLATE,
						       NULL); 
	}
      else
	{
	  printf("bad value %d for input_source!\n",input_source);
	  ExitWrapper(-1);
	}
      XtManageChild(form);


      






      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
      button = XtVaCreateManagedWidget ("Project name...",
					xmLabelWidgetClass,form,
					XmNlabelString,        
					STRING("Project name:"),
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNleftAttachment,   XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,                   15,
					XmNtraversalOn,                  False,
					LABELWTRANSLATE,
					NULL); 
      XtManageChild(button);
      
      if(import_source==1)
	{
	  sprintf(tempvalue,"%s",GAITProjectName);
	}
      else
	{
	  tempvalue[0] = '\0';
	}


      button = XtVaCreateManagedWidget ("project_button",
					xmTextFieldWidgetClass, form,	  
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNvalue,            tempvalue,
					XmNtraversalOn,      True,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    100,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     15,
					XmNmaxLength,        80,
					XmNtranslations,     XtParseTranslationTable ( translations_paste ) ,
					NULL);
      XtManageChild(button);
      
      XtAddCallback (button, XmNvalueChangedCallback,
		     (XtCallbackProc)fore_result, (XtPointer)24);
      
      XtManageChild(form);







      
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);

      if(USE_DOS==1)
	{
	  text_w = XtVaCreateManagedWidget ("Input Data folder:",
					    xmLabelWidgetClass, form,
					    XmNleftAttachment,  XmATTACH_FORM,
					    XmNtopAttachment,    XmATTACH_FORM,
					    XmNbottomAttachment, XmATTACH_FORM,
					    LABELWTRANSLATE,
					    NULL);
	}
      else
	{
	  text_w = XtVaCreateManagedWidget ("Input Data directory:",
					    xmLabelWidgetClass, form,
					    XmNleftAttachment,  XmATTACH_FORM,
					    XmNtopAttachment,    XmATTACH_FORM,
					    XmNbottomAttachment, XmATTACH_FORM,
					    LABELWTRANSLATE,
					    NULL);
	}
      
      if(shape_source==0)
	{
      tempvalue[0] = '\0';
	}
      else if(shape_source==1)
	{
	  sprintf(tempvalue,"%s",shapeimportoutputdir);
	}
      
      shapefile_text_area = XtVaCreateManagedWidget ("project_button",
						     xmTextFieldWidgetClass, form,	  
						     XmNtopAttachment,       XmATTACH_FORM,
						     XmNbottomAttachment,    XmATTACH_FORM,
						     XmNvalue,               tempvalue,
						     XmNtraversalOn,         True,
						     XmNrightAttachment,     XmATTACH_POSITION,
						     XmNrightPosition,       80,
						     XmNleftAttachment,      XmATTACH_WIDGET,
						     XmNleftWidget,          text_w,
						     XmNmaxLength,           80,
                             XmNtranslations,        XtParseTranslationTable ( translations_paste ) ,
						     NULL);
      XtManageChild(shapefile_text_area);
      
      XtAddCallback (shapefile_text_area, XmNvalueChangedCallback,
		     (XtCallbackProc)fore_result, (XtPointer)25);
      




      button2 = XtVaCreateManagedWidget ("Browse...",
					 xmPushButtonWidgetClass,form,
					 XmNlabelString,       STRING("Browse..."),
					 XmNleftAttachment,    XmATTACH_WIDGET,
					 XmNleftWidget,        shapefile_text_area,
					 XmNrightAttachment,   XmATTACH_FORM,
					 XmNtopAttachment,     XmATTACH_FORM,
					 XmNbottomAttachment,  XmATTACH_FORM,
					 XmNtraversalOn,       False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					 NULL); 
      XtAddCallback(button2, XmNactivateCallback, ImportDestinationCallback, (XtPointer)1);
      XtManageChild(button2);
      

      
      
      XtManageChild(form);





      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      

      

      button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNtopAttachment,      XmATTACH_FORM,
					XmNbottomAttachment,   XmATTACH_FORM,
					XmNlabelString,        STRING("Help"),
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, ImportHelpCallback, (XtPointer)23);
      XtManageChild(button);

      attr_ins_menu = BuildAttrInsMenu (form, XmMENU_OPTION, "Additional Attribution Inspections for NFDD/DFDD:",dd_menu);

      XtVaSetValues(attr_ins_menu,
		    XmNtopAttachment,          XmATTACH_FORM,
		    XmNbottomAttachment,       XmATTACH_FORM,
		    XmNleftAttachment,         XmATTACH_WIDGET,
		    XmNleftWidget,             button,
		    NULL);

      XtManageChild (attr_ins_menu);
      XtManageChild(form);


      if(
	     (CREATING_TREX==1) ||   
		 (
	       (TEMP_ATTRIBUTION_TYPE!=23)&&(TEMP_ATTRIBUTION_TYPE!=24) &&
	       (TEMP_ATTRIBUTION_TYPE!=25)&&(TEMP_ATTRIBUTION_TYPE!=26) 
		 )
	    )
	  { 
		
        XtSetSensitive(attr_ins_menu,False);
	  }


      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);


      button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNtopAttachment,      XmATTACH_FORM,
					XmNbottomAttachment,   XmATTACH_FORM,
					XmNleftAttachment,     XmATTACH_POSITION,
					XmNleftPosition,       2,
					XmNlabelString,        STRING("Help"),
					XmNtraversalOn,        False,
					XmNtranslations, XtParseTranslationTable ( translations_global ),
					NULL);

      XtAddCallback(button, XmNactivateCallback, ImportHelpCallback, (XtPointer)24);
      XtManageChild(button);

      attrins_label_area = XtVaCreateManagedWidget ("Folder with attribution files:",
					xmLabelWidgetClass,  form,
					XmNleftAttachment,   XmATTACH_WIDGET,
					XmNleftWidget,       button,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,
					LABELWTRANSLATE,
					NULL);

      if(attrins_source==0)
	  {
        tempvalue[0] = '\0';
	  } 
      else if(attrins_source==1)
	  { 
	    sprintf(tempvalue,"%s",attrinsfolder);
	  } 
      
      attrins_text_area = XtVaCreateManagedWidget ("project_button",
						     xmTextFieldWidgetClass, form,	  
						     XmNtopAttachment,       XmATTACH_FORM,
						     XmNbottomAttachment,    XmATTACH_FORM,
						     XmNvalue,               tempvalue,
						     XmNtraversalOn,         True,
						     XmNrightAttachment,     XmATTACH_POSITION,
						     XmNrightPosition,       80,
						     XmNleftAttachment,      XmATTACH_WIDGET,
						     XmNleftWidget,          attrins_label_area,
						     XmNmaxLength,           80,
                             XmNtranslations,        XtParseTranslationTable ( translations_paste ) ,
						     NULL);
      XtManageChild(attrins_text_area);
      
      XtAddCallback (attrins_text_area, XmNvalueChangedCallback,
		     (XtCallbackProc)fore_result, (XtPointer)34);



      attrins_browse_area = XtVaCreateManagedWidget ("Browse...",
					 xmPushButtonWidgetClass,form,
					 XmNlabelString,       STRING("Browse..."),
					 XmNleftAttachment,    XmATTACH_WIDGET,
					 XmNleftWidget,        attrins_text_area,
					 XmNrightAttachment,   XmATTACH_FORM,
					 XmNtopAttachment,     XmATTACH_FORM,
					 XmNbottomAttachment,  XmATTACH_FORM,
					 XmNtraversalOn,       False,
                     XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					 NULL); 
      XtAddCallback(attrins_browse_area, XmNactivateCallback, ImportDestinationCallback, (XtPointer)2);
      XtManageChild(attrins_browse_area);


      XtManageChild(form);



      if(
	     (CREATING_TREX==1) ||   
		 (
	       (TEMP_ATTRIBUTION_TYPE!=23)&&(TEMP_ATTRIBUTION_TYPE!=24) &&
	       (TEMP_ATTRIBUTION_TYPE!=25)&&(TEMP_ATTRIBUTION_TYPE!=26) 
		 )
	    )
	  { 
		
        XtSetSensitive(attrins_text_area,  False);
        XtSetSensitive(attrins_label_area, False);
        XtSetSensitive(attrins_browse_area,False);
	  }






      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      


      button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNtopAttachment,      XmATTACH_FORM,
					XmNbottomAttachment,   XmATTACH_FORM,
					XmNleftAttachment,     XmATTACH_POSITION,
					XmNleftPosition,       0,
					XmNlabelString,        STRING("Help"),
					XmNtraversalOn,        False,
					XmNtranslations, XtParseTranslationTable ( translations_global ),
					NULL);

      XtAddCallback(button, XmNactivateCallback, MetaMapCallback1, (XtPointer)NULL);
      XtManageChild(button);


      

      meta_type_menu = BuildMetaMenu (form, XmMENU_OPTION, "Metadata naming convention:",metadata_type);
      
      XtVaSetValues(meta_type_menu,
		    XmNtopAttachment,          XmATTACH_FORM,
		    XmNbottomAttachment,       XmATTACH_FORM,
		    XmNleftAttachment,         XmATTACH_WIDGET,
		    XmNleftWidget,             button,
		    NULL);

      XtManageChild (meta_type_menu);
      XtManageChild(form);



	  if(MetaMappingPossible(TEMP_ATTRIBUTION_TYPE)==0)
	  { 
		
        XtSetSensitive(meta_type_menu,False);

	  }


      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);


      button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNtopAttachment,      XmATTACH_FORM,
					XmNbottomAttachment,   XmATTACH_FORM,
					XmNleftAttachment,     XmATTACH_POSITION,
					XmNleftPosition,       2,
					XmNlabelString,        STRING("Help"),
					XmNtraversalOn,        False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, ImportHelpCallback, (XtPointer)20);
      XtManageChild(button);

      text_w = XtVaCreateManagedWidget ("Metadata mapping file:",
					xmLabelWidgetClass,  form,
					XmNleftAttachment,   XmATTACH_WIDGET,
					XmNleftWidget,       button,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,
					LABELWTRANSLATE,
					NULL);



      if(metamap_source==0)
	{
	  tempvalue[0] = '\0';
	}
      else if(metamap_source==1)
	{
	  sprintf(tempvalue,"%s",metamapfile);
	}
      
      metamap_text_area = XtVaCreateManagedWidget ("project_button",
						     xmTextFieldWidgetClass, form,	  
						     XmNtopAttachment,       XmATTACH_FORM,
						     XmNbottomAttachment,    XmATTACH_FORM,
						     XmNvalue,               tempvalue,
						     XmNtraversalOn,         True,
						     XmNrightAttachment,     XmATTACH_POSITION,
						     XmNrightPosition,       80,
						     XmNleftAttachment,      XmATTACH_WIDGET,
						     XmNleftWidget,          text_w,
						     XmNmaxLength,           80,
                             XmNtranslations,        XtParseTranslationTable ( translations_paste ) ,
						     NULL);
      XtManageChild(metamap_text_area);
      
      XtAddCallback (metamap_text_area, XmNvalueChangedCallback,
		     (XtCallbackProc)fore_result, (XtPointer)27);
      


      
      
      metamap_browse_area = XtVaCreateManagedWidget ("Browse...",
						     xmPushButtonWidgetClass,form,
						     XmNlabelString,       STRING("Browse..."),
						     XmNleftAttachment,    XmATTACH_WIDGET,
						     XmNleftWidget,        metamap_text_area,
						     XmNrightAttachment,   XmATTACH_FORM,
						     XmNtopAttachment,     XmATTACH_FORM,
						     XmNbottomAttachment,  XmATTACH_FORM,
						     XmNtraversalOn,       False,
						     XmNtranslations, XtParseTranslationTable ( translations_global ) ,
						     NULL); 

      XtAddCallback(metamap_browse_area, XmNactivateCallback, BrowseMetaCallback, (XtPointer)1);      
      XtManageChild(metamap_browse_area);                
      XtManageChild(form);



      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);


      button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNtopAttachment,      XmATTACH_FORM,
					XmNbottomAttachment,   XmATTACH_FORM,
					XmNleftAttachment,     XmATTACH_POSITION,
					XmNleftPosition,       0,
					XmNlabelString,        STRING("Help"),
					XmNtraversalOn,        False,
					XmNtranslations, XtParseTranslationTable ( translations_global ),
					NULL);

      XtAddCallback(button, XmNactivateCallback, TRExTypeHelpCallback, (XtPointer)NULL);
      XtManageChild(button);


      

      trex_type_menu = BuildTrexTypeMenu (form, XmMENU_OPTION, "TREx analysis type:",trex_type);
      
      XtVaSetValues(trex_type_menu,
		    XmNtopAttachment,          XmATTACH_FORM,
		    XmNbottomAttachment,       XmATTACH_FORM,
		    XmNleftAttachment,         XmATTACH_WIDGET,
		    XmNleftWidget,             button,
		    NULL);

      XtManageChild (trex_type_menu);
      XtManageChild(form);


	  if(CREATING_TREX==0)
	  { 
        XtSetSensitive(trex_type_menu,False);
	  }





            
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
      button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Help"),
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, ImportHelpCallback, (XtPointer)10);
      XtManageChild(button);
      
      
      button2 = XtVaCreateManagedWidget ("Import data from specified rectangle",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,          XmATTACH_FORM,
					 XmNtraversalOn,            False,
					 XmNbottomAttachment,       XmATTACH_FORM,
					 XmNleftAttachment,         XmATTACH_WIDGET,
					 XmNleftWidget,             button,
					 XmNlabelString,            STRING("Import data from specified rectangle     "),
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
      XtAddCallback (button2, XmNvalueChangedCallback,Iinvert, (XtPointer)9);
      XmToggleButtonSetState(button2,(Boolean)CLIPEXTRACT,(Boolean)0);
      
      
      button = XtVaCreateManagedWidget ("Specify Rectangle...",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Specify Rectangle..."),
					XmNtraversalOn,                 False,
					XmNleftAttachment,         XmATTACH_WIDGET,
					XmNleftWidget,             button2,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, RectangleCallback, (XtPointer)NULL);
      XtManageChild(button);
      
	  
      XtManageChild(form);
      



      if(0)
	  {
        form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
        button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Help"),
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
        XtAddCallback(button, XmNactivateCallback, ImportHelpCallback, (XtPointer)15);
        XtManageChild(button);
      

        button = XtVaCreateManagedWidget ("Do metadata checking",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,          XmATTACH_FORM,
					 XmNtraversalOn,            False,
					 XmNbottomAttachment,       XmATTACH_FORM,
					 XmNleftAttachment,         XmATTACH_WIDGET,
					 XmNleftWidget,             button,
					 XmNlabelString,            STRING("Do metadata checking"),
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
        XtAddCallback (button, XmNvalueChangedCallback,Iinvert, (XtPointer)15);
        XmToggleButtonSetState(button,(Boolean)DoMetadataChecking,(Boolean)0);
      
	  
        XtManageChild(form);


        form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
        button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Help"),
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
        XtAddCallback(button, XmNactivateCallback, ImportHelpCallback, (XtPointer)17);
        XtManageChild(button);
      
      
        button2 = XtVaCreateManagedWidget ("Do attribution checking",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,          XmATTACH_FORM,
					 XmNtraversalOn,            False,
					 XmNbottomAttachment,       XmATTACH_FORM,
					 XmNleftAttachment,         XmATTACH_WIDGET,
					 XmNleftWidget,             button,
					 XmNlabelString,            STRING("Do attribution checking"),
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
        XtAddCallback (button2, XmNvalueChangedCallback,Iinvert, (XtPointer)17);
        XmToggleButtonSetState(button2,(Boolean)DoAttrChecking,(Boolean)0);
      
        XtManageChild(form);
	  }






      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
      button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Help"),
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, ImportHelpCallback, (XtPointer)16);
      XtManageChild(button);

      
      append_button = XtVaCreateManagedWidget ("Append to Input Specification file if it exists already",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,          XmATTACH_FORM,
					 XmNtraversalOn,            False,
					 XmNbottomAttachment,       XmATTACH_FORM,
					 XmNleftAttachment,         XmATTACH_WIDGET,
					 XmNleftWidget,             button,
					 XmNlabelString,            STRING("Append to Input Specification file if it exists already"),
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
      XtAddCallback (append_button, XmNvalueChangedCallback,Iinvert, (XtPointer)16);
      XmToggleButtonSetState(append_button,(Boolean)AppendInputSpec,(Boolean)0);
      
	  if(CREATING_TREX==1)
	  {
        XtSetSensitive(append_button,False);
	  }

      XtManageChild(form);








      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
      button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNtopAttachment,      XmATTACH_FORM,
					XmNbottomAttachment,   XmATTACH_FORM,
					XmNlabelString,        STRING("Help"),
					XmNtraversalOn,        False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, ImportHelpCallback, (XtPointer)19);
      XtManageChild(button);

      
      button2 = XtVaCreateManagedWidget ("Do inspections after creating project using:",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,          XmATTACH_FORM,
					 XmNtraversalOn,            False,
					 XmNbottomAttachment,       XmATTACH_FORM,
					 XmNleftAttachment,         XmATTACH_WIDGET,
					 XmNleftWidget,             button,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 XmNlabelString, 
					 STRING("Do inspections after creating project using:"),
					 NULL);
      XtAddCallback (button2, XmNvalueChangedCallback,Iinvert, (XtPointer)18);
      XmToggleButtonSetState(button2,(Boolean)DoShort,(Boolean)0);


      master_type_menu = BuildMasterMenu (form, XmMENU_OPTION, "",master_type);
      
      XtVaSetValues(master_type_menu,
		    XmNtopAttachment,          XmATTACH_FORM,
		    XmNbottomAttachment,       XmATTACH_FORM,
		    XmNleftAttachment,         XmATTACH_WIDGET,
		    XmNleftWidget,             button2,
		    NULL);
      
      XtManageChild (master_type_menu);

      XtManageChild(form);







	  if(dev_options==1)
	  {

        form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
        button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNtopAttachment,      XmATTACH_FORM,
					XmNbottomAttachment,   XmATTACH_FORM,
					XmNlabelString,        STRING("Help"),
					XmNtraversalOn,        False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
        XtAddCallback(button, XmNactivateCallback, ImportHelpCallback, (XtPointer)22);
        XtManageChild(button);

      
        button2 = XtVaCreateManagedWidget ("(Dev option) Specify format granularity:",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,          XmATTACH_FORM,
					 XmNtraversalOn,            False,
					 XmNbottomAttachment,       XmATTACH_FORM,
					 XmNleftAttachment,         XmATTACH_WIDGET,
					 XmNleftWidget,             button,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 XmNlabelString, 
					 STRING("(Dev option) Specify format granularity:"),
					 NULL);
        XtAddCallback (button2, XmNvalueChangedCallback,Iinvert, (XtPointer)19);
        XmToggleButtonSetState(button2,(Boolean)DoDev,(Boolean)0);

        dev_menu = BuildDevMenu (form, XmMENU_OPTION, "",dev_type);
      
        XtVaSetValues(dev_menu,
		    XmNtopAttachment,          XmATTACH_FORM,
		    XmNbottomAttachment,       XmATTACH_FORM,
		    XmNleftAttachment,         XmATTACH_WIDGET,
		    XmNleftWidget,             button2,
		    NULL);
      
        XtManageChild (dev_menu);

        XtManageChild(form);
	  }






      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
      
      button = XtVaCreateManagedWidget ("Use layer preference set:",
					xmLabelWidgetClass, form,
					XmNtraversalOn,      False,
					XmNleftAttachment,   XmATTACH_FORM,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,
					LABELWTRANSLATE,
					NULL);
      
      
      if(layer_prefs_set==0)
	{
	  if((TEMP_ATTRIBUTION_TYPE==7)||(TEMP_ATTRIBUTION_TYPE==8))
	    { 
	      sprintf(layer_pref_file,"Default (MGCP)");
	    }
	  else
	    {
	      sprintf(layer_pref_file,"Default (Baseline)");
	    }
	  layer_prefs_set = 1;
	}

      layerprefs = XtVaCreateManagedWidget ("Red",
					    xmTextFieldWidgetClass, form,
					    XmNvalue,            layer_pref_file,
					    XmNcolumns,          30,
					    XmNleftAttachment,   XmATTACH_WIDGET,
					    XmNleftWidget,       button,
					    XmNtopAttachment,    XmATTACH_FORM,
					    XmNbottomAttachment, XmATTACH_FORM,
					    XmNmaxLength,        50,
					    XmNtranslations,     XtParseTranslationTable ( translations_paste ),
					    NULL);
      
      XtAddCallback (layerprefs, XmNactivateCallback,
		     EnterFileCallback, (XtPointer)23);
      
      XtManageChild(layerprefs);
      
      


      
      button1 = XtVaCreateManagedWidget ("Help4",
					 xmPushButtonWidgetClass, form,
					 XmNtraversalOn,      False,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNleftAttachment,   XmATTACH_WIDGET,
					 XmNleftWidget,       layerprefs,
					 XmNlabelString,      STRING("Choose..."),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					 NULL);
      XtAddCallback (button1, XmNactivateCallback,
		     ChoosePrefsCallback, (XtPointer)1);
      
      XtManageChild(button1);
      XtManageChild(form);
      










      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      button = XtVaCreateManagedWidget ("Cat DBs",xmPushButtonWidgetClass,form,
					XmNlabelString,        
					STRING("Build Input Specification file"),
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,                    0,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,                 100,
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, ngainfileCallback, (XtPointer) NULL);
      XtManageChild(button);
      XtManageChild (form);
      

      
      

     
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
            
      button = XtVaCreateManagedWidget ("Create GAIT project using Input Specification file",xmPushButtonWidgetClass,form,
					XmNlabelString,        
					STRING("Create GAIT project using Input Specification file"),
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,                    0,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,                 100,
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL); 
      XtAddCallback(button, XmNactivateCallback, Import2Callback, (XtPointer) NULL);
      XtManageChild(button);
      XtManageChild (form);




if(FORMATBUTTON==1)
{
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);

      button = XtVaCreateManagedWidget ("Format Imported Database (GET RID OF THIS FOR RELEASE)",
					xmPushButtonWidgetClass,form,
					XmNlabelString,        
					STRING("Format Imported Database (GET RID OF THIS FOR RELEASE)"),
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,                    0,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,                 100,
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL); 
      XtAddCallback(button, XmNactivateCallback, ImportFormatCallback, (XtPointer) NULL);
      XtManageChild(button);
      XtManageChild (form);
}







      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);

      button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Help"),
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,                    0,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,                  50,
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, ImportHelpCallback, (XtPointer)0);
      XtManageChild(button);

      button = XtVaCreateManagedWidget ("Done",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Done"),
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,                   50,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,                 100,
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, die_callback, (XtPointer)114);
      XtManageChild(button);
      XtManageChild (form);
      XtManageChild (rowcol);
      
      IMPORT_WIN = 1;


	  if(import_head_in_use==1)
	  {
        MyPopup(importshell);
        XtAddCallback(importshell,XmNdestroyCallback,ShellDeath,(XtPointer)218);       

        XtVaGetValues(importshell, XmNheight,    &Pheight,   NULL);	  
        XtVaSetValues(importshell, XmNminHeight,  Pheight, NULL);
        XtVaSetValues(importshell, XmNmaxHeight,  Pheight, NULL);

        XtAddEventHandler(importshell,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)Pheight));
	  }
	  else
	  {
        MyPopup(importshell2);
        XtAddCallback(importshell2,XmNdestroyCallback,ShellDeath,(XtPointer)218);       

        XtVaGetValues(importshell2, XmNheight,    &Pheight,   NULL);	  
        XtVaSetValues(importshell2, XmNminHeight,  Pheight, NULL);
        XtVaSetValues(importshell2, XmNmaxHeight,  Pheight, NULL);

        XtAddEventHandler(importshell2,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)Pheight));
	  }


      SetMetaButtons();

    }
  else
    {
	  if(import_head_in_use==1)
	  {
        ResetWidget(importshell);
	  }
	  else
	  {
        ResetWidget(importshell2);
	  }
    }
}










void SetLoadModules()
{  
  
  
  Widget rowcol,form,text_w,button;
  char fromi[100];
  char fromj[100];
  char toi[100];    
  char toj[100];    
  char fromitoj[100];
  char toifromj[100];
  char junk[100];
  Arg args[50];
  int n=0;
  
  sprintf(fromi,"%d",FromI);
  sprintf(fromj,"%d",FromJ);
  sprintf(toi,"%d",ToI);
  sprintf(toj,"%d",ToJ);
  sprintf(fromitoj,"%d,%d",FromI,ToJ);
  sprintf(toifromj,"%d,%d",ToI,FromJ);
  
  XtSetArg(args[n],  XmNminWidth,     400);  n++;  
  XtSetArg(args[n],  XmNminHeight,    250);  n++;  
  XtSetArg(args[n],  XmNmaxWidth,     400);  n++;  
  XtSetArg(args[n],  XmNmaxHeight,    250);  n++;  
  
  if(load_head==1)
    {
      XtSetArg(args[n],  XmNdeleteResponse, XmDESTROY); n++;
      
      Select_head = XtCreatePopupShell("Region Designation",
				topLevelShellWidgetClass,sw,args,n);
      
      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass, Select_head, NULL);
      
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      text_ul = XtVaCreateManagedWidget (fromitoj,
					 xmLabelWidgetClass, form,
					 XmNtraversalOn,      True,
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,  30,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     0,
					 LABELWTRANSLATE,
					 NULL);
      
      text_w2 = XtVaCreateManagedWidget ("text_w",
					 xmTextFieldWidgetClass, form,	  
					 XmNvalue, toi,
					 XmNtraversalOn,      True,
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,  84,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     69,
					 XmNmaxLength,4,
                     XmNtranslations,        XtParseTranslationTable ( translations_paste ) ,
					 NULL);
      
      text_w3 = XtVaCreateManagedWidget ("text_w",
					 xmTextFieldWidgetClass, form,	  
					 XmNvalue, toj,
					 XmNtraversalOn,      True,
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,  100,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     85,
					 XmNmaxLength,4,
                     XmNtranslations,        XtParseTranslationTable ( translations_paste ) ,
					 NULL);
      
      XtManageChild(form);
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      XtAddCallback (text_w2, XmNactivateCallback,
		     print_result2, (XtPointer)1);
      
      XtAddCallback (text_w3, XmNactivateCallback,
		     print_result2, (XtPointer)2);
      
      XtManageChild(form);
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      text_w = XtVaCreateManagedWidget ("You are now set to inspect the",
					xmLabelWidgetClass, form,
					XmNtraversalOn,      True,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,  99,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					LABELWTRANSLATE,
					NULL);
      
      XtManageChild(form);
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      text_w = XtVaCreateManagedWidget ("regions defined by this box.",
					xmLabelWidgetClass, form,
					XmNtraversalOn,      True,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,  99,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					LABELWTRANSLATE,
					NULL);
      
      XtManageChild(form);
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      text_w = XtVaCreateManagedWidget ("You may enter new lower left",
					xmLabelWidgetClass, form,
					XmNtraversalOn,      True,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,  99,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					LABELWTRANSLATE,
					NULL);
      
      XtManageChild(form);
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      text_w = XtVaCreateManagedWidget ("or upper right coordinates to",
					xmLabelWidgetClass, form,
					XmNtraversalOn,      True,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,  99,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					LABELWTRANSLATE,
					NULL);
      
      XtManageChild(form);
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      text_w = XtVaCreateManagedWidget ("define a new box.",
					xmLabelWidgetClass, form,
					XmNtraversalOn,      True,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,  99,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					LABELWTRANSLATE,
					NULL);
      
      XtManageChild(form);
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      text_w4 = XtVaCreateManagedWidget ("text_w",
					 xmTextFieldWidgetClass, form,	  
					 XmNvalue, fromi,
					 XmNtraversalOn,      True,
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,  15,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     0,
					 XmNmaxLength,4,
                     XmNtranslations,        XtParseTranslationTable ( translations_paste ) ,
					 NULL);
      
      text_w5 = XtVaCreateManagedWidget ("text_w",
					 xmTextFieldWidgetClass, form,	  
					 XmNvalue, fromj,
					 XmNtraversalOn,      True,
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,  32,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     16,
					 XmNmaxLength,4,
                     XmNtranslations,        XtParseTranslationTable ( translations_paste ) ,
					 NULL);
      
      text_lr = XtVaCreateManagedWidget (toifromj,
					 xmLabelWidgetClass, form,
					 XmNtraversalOn,      True,
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,  99,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     69,
					 LABELWTRANSLATE,
					 NULL);
      
      XtAddCallback (text_w4, XmNactivateCallback,
		     print_result2, (XtPointer)3);
      XtAddCallback (text_w5, XmNactivateCallback,
		     print_result2, (XtPointer)4);
      XtManageChild(form);
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      sprintf(toifromj,"Total number of regions to inspect: %d",(ToI-FromI+1)*(ToJ-FromJ+1));
      
      total_w = XtVaCreateManagedWidget (toifromj,
					 xmLabelWidgetClass, form,
					 XmNtraversalOn,      True,
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,  99,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     1,
					 LABELWTRANSLATE,
					 NULL);
      
      XtManageChild(form);
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget("Done",xmPushButtonWidgetClass,form,
				       XmNlabelString, STRING("Done"),
				       XmNorientation, XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    1,
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    49,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      
      XtAddCallback(button, XmNactivateCallback,
		    die_callback, (XtPointer)12);
      XtManageChild(button);




      button = XtVaCreateManagedWidget("Done",xmPushButtonWidgetClass,form,
				       XmNlabelString, STRING("Done / Execute"),
				       XmNorientation, XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    51,
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    99,
				       XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      
      XtAddCallback(button, XmNactivateCallback,
		    die_callback, (XtPointer)17);
      XtManageChild(button);




      XtManageChild(form);
      XtManageChild(rowcol);
      MyPopup(Select_head);
      XtAddCallback(Select_head,XmNdestroyCallback,ShellDeath,(XtPointer)203);
      load_head = 0;

      XtVaSetValues(Select_head,  
		    XmNwidth,     400,
		    XmNheight,    250,
		    NULL);

      XtAddEventHandler(Select_head,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)250));
    }
  else
    {
      ResetWidget(Select_head);
    }
  
  sprintf(junk,"Total number of regions to inspect: %d",(ToI-FromI+1)*(ToJ-FromJ+1));
  XtVaSetValues (total_w, XmNlabelString, STRING(junk), NULL);
  
  sprintf(junk,"%d,%d",FromI,ToJ);
  XtVaSetValues (text_ul, XmNlabelString, STRING(junk), NULL);
  
  sprintf(junk,"%d,%d",ToI,FromJ);
  XtVaSetValues (text_lr, XmNlabelString, STRING(junk), NULL);
  
  sprintf(junk,"%d",ToI);
  XmTextFieldSetString(text_w2,junk);

  sprintf(junk,"%d",ToJ);
  XmTextFieldSetString(text_w3,junk);

  sprintf(junk,"%d",FromI);
  XmTextFieldSetString(text_w4,junk);

  sprintf(junk,"%d",FromJ);
  XmTextFieldSetString(text_w5,junk);
}



void ProfileSetup()
{
  int n=0;
  Arg args[15];
  Widget rowcol,form,button;  
  
  XtSetArg(args[n],  XmNminWidth,     620);         n++;  
  XtSetArg(args[n],  XmNminHeight,    340);         n++;  
  XtSetArg(args[n],  XmNmaxWidth,     620);         n++;  
  XtSetArg(args[n],  XmNmaxHeight,    340);         n++;
  XtSetArg(args[n],  XmNdeleteResponse, XmDESTROY); n++;



  if((ACTUAL==1)&&(LOS==0))
    {
      Profile_drawing = XtCreatePopupShell("NON-Exaggerated Profile",topLevelShellWidgetClass,
					   drawing_a,args,n);
    }
  else if((ACTUAL==0)&&(LOS==0))
    {
      Profile_drawing = XtCreatePopupShell("Vertically Exaggerated Profile",topLevelShellWidgetClass,
					   drawing_a,args,n);
    }
  else 
    {
      Profile_drawing = XtCreatePopupShell("Vertically Exaggerated LOS Profile",topLevelShellWidgetClass,
					   drawing_a,args,n);
    }
  
  rowcol = XtVaCreateWidget ("rowcol",
			     xmRowColumnWidgetClass, Profile_drawing, NULL);
  
  form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			   XmNfractionBase,  100,  
			   NULL);
  
  Profile_draw = XtVaCreateManagedWidget ("Profile It",
					  xmDrawingAreaWidgetClass, form,
					  XmNunitType,     XmPIXELS,
					  XmNwidth,        620, 
					  XmNheight,       300, 
					  XmNresizePolicy, XmNONE,
					  NULL);
  
  XtAddCallback (Profile_draw, XmNexposeCallback, redraw_net, (XtPointer) (1000));  
  XtManageChild(Profile_draw);  
  XtManageChild(form);
  
  form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			   XmNfractionBase,  100,  
			   NULL);
  
  button = XtVaCreateManagedWidget("Done2",xmPushButtonWidgetClass,form,
				   XmNlabelString, STRING("Done"),
				   XmNorientation, XmVERTICAL,
				   XmNleftAttachment,  XmATTACH_POSITION,
				   XmNleftPosition,    0,
				   XmNrightAttachment,  XmATTACH_POSITION,
				   XmNrightPosition,    99,
				   XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				   NULL
				   ); 
  
  XtAddCallback (button, XmNactivateCallback,
		 die_callback, (XtPointer)(1000));
  
  XtManageChild(button);
  XtManageChild(form);   
  XtManageChild(rowcol);
  MyPopup(Profile_drawing);
  
  XtAddEventHandler(Profile_drawing,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)340));
	
  XtAddCallback(Profile_drawing,XmNdestroyCallback,ShellDeath,(XtPointer)4064);


  
  set_color(Profile_draw,"White",(XtPointer)NULL);
  
  Profile_pix = XCreatePixmap (XtDisplay (Profile_draw),
			       RootWindowOfScreen (XtScreen (Profile_draw)), 620,300,
			       DefaultDepthOfScreen (XtScreen (Profile_draw)));
  XFillRectangle (XtDisplay (Profile_draw), Profile_pix,       mygc, 0, 0, 620,300);
  
  set_color(Profile_draw,"Black",(XtPointer)NULL);
}






void MakeClip(double *llx_clip,double *lly_clip,double *urx_clip,double *ury_clip)
{  
  *llx_clip = llx_zoom;
  *lly_clip = lly_zoom;
  *urx_clip = llx_zoom+(990.0/xunits)*IRegionSize;  
  *ury_clip = lly_zoom+(790.0/yunits)*IRegionSize;  
 
}


void BadDraw(char *caller)
{
  printf("BD: should not be calling %s at this time\n",caller);
}


void MAPdrawstring(double x1,double y1,char thestring[],int color, int yoff, int Lindex, int adjust)
{
  int rendering_priority,overadjustx,overadjusty;
  double llx_clip,lly_clip,urx_clip,ury_clip;


  

  LABEL_OK = 0;

  if(batch_mode==1){return;}  
  
  if((running==1)&&(API_DRAW==0))
  {
    BadDraw("MAPdrawstring");
    return;
  }

  MakeClip(&llx_clip,&lly_clip,&urx_clip,&ury_clip);
  
  

  if(x1<llx_clip)
    {
      return;
    }
  if(y1<lly_clip)
    {
      return;
    }
  if(x1>urx_clip)
    {
      return;
    }
  if(y1>ury_clip)
    {
      return;
    }


  LABEL_OK = 1;


  if(color<5000)
  {
    if(SPECIAL_COLOR>0) 
	{
      XSetForeground(mydisplay,mygc,mycolors[SPECIAL_COLOR]);
	}
    else if((SPECIAL_COND_COLOR>0)&&(color==1))
	{
      XSetForeground(mydisplay,mygc,mycolors[SPECIAL_COND_COLOR]);
	}
    else
	{
      XSetForeground(mydisplay,mygc,mycolors[color]);
	}
  }
  else
  {
    XSetForeground(mydisplay,mygc,color-5000);
  }

  if(Lindex==DRAW_NOW)
    {
      x1 = x1 - llx_clip;
      y1 = y1 - lly_clip;

      XDrawString(mydisplay,mywindow,mygc,
		  (short int)((int)  (10.0+(double)(x1/IRegionSize)*xunits)),
		  (short int)((height-(10.0+(double)(y1/IRegionSize)*xunits))+yoff),
		  thestring,(int)strlen(thestring));
      
      XDrawString(mydisplay,pixmap,mygc,
		  (short int)((int)  (10.0+(double)(x1/IRegionSize)*xunits)),
		  (short int)((height-(10.0+(double)(y1/IRegionSize)*xunits))+yoff),
		  thestring,(int)strlen(thestring));
    }
  else
    {
	  

      rendering_priority = MAX_RENDER_PRI;
      LODS_USED[rendering_priority] = 1;

	  


	  overadjustx = 0;
	  overadjusty = 0;
      ComputeOverAdjust(x1,y1,&overadjustx,&overadjusty);


      

      x1 = x1 - llx_clip;
      y1 = y1 - lly_clip;

      XDrawString(mydisplay,DRAWING_PIXMAPS[rendering_priority],mygc,
		  (short int)((int)  (10.0+(double)(x1/IRegionSize)*xunits))         + adjust*8 + overadjustx,
		  (short int)((height-(10.0+(double)(y1/IRegionSize)*xunits)) + yoff + overadjusty),
		  thestring,(int)strlen(thestring));
      
      XDrawString(mydisplay,DRAWING_CLIPMAPS[rendering_priority],mybitgc,
		  (short int)((int)  (10.0+(double)(x1/IRegionSize)*xunits))          + adjust*8 + overadjustx,
		  (short int)((height-(10.0+(double)(y1/IRegionSize)*xunits))  + yoff + overadjusty),
		  thestring,(int)strlen(thestring));

      
    }
 
  XSetForeground(mydisplay,mygc,mycolors[DRAW_COLOR_BLACK]);
}


int GetDigits(double spacing)
{
  

  if(spacing>=1)
  {
	return 1;
  }
  else if (spacing>=.1)
  {
	return 2;
  }
  else if (spacing>=.01)
  {
	return 3;
  }
  return 4;
}



int GetYShifter()
{
  int digits = GetDigits(GridSpace);
  int adder=0;
  extern double MinXcoord,MaxXcoord;

  

  if(DoLargeLabels)
  {
	if(digits==1)
	{
	  adder = adder + 40;
	}
	else if(digits==2)
	{
	  adder = adder + 20;
	}
	else if(digits==3)
	{
	  adder = 0;
	}
	else
	{
	adder = adder - 20;
	}

    if((MinXcoord/100000 + Xtranslation) < 0)
	{
	  adder = adder - 20;  
	}
    if( ((MinXcoord/100000 + Xtranslation) < -99) || ((MaxXcoord/100000 + Xtranslation) > 99) )
	{
  	  adder = adder - 20; 
	}
  }
  else
  {
	if(digits==1)
	{
	  adder = adder + 50;
	}
	else if(digits==2)
	{
	  adder = adder + 40;
	}
	else if(digits==3)
	{
	  adder = adder + 30;
	}
	else
	{
	  adder = adder + 20;
	}

    if((MinXcoord/100000 + Xtranslation) < 0)
	{
	  adder = adder - 10;  
	}
    if( ((MinXcoord/100000 + Xtranslation) < -99) || ((MaxXcoord/100000 + Xtranslation) > 99) )
	{
  	  adder = adder - 10; 
	}
  }

  return adder;
}



void MAPdrawrotatedstring(double x1,double y1,char thestring[],int color, int Lindex)	
{
  Pixmap localpixmap,localpixmap2;
  int lwidth,lheight,i,j,xcoord,ycoord;
  XImage *myimage,*myimage2;
  double llx_clip,lly_clip,urx_clip,ury_clip;

  
  

  

  if(batch_mode==1){return;}

  if((running==1)&&(API_DRAW==0))
  {
	  BadDraw("MAPdrawrotatedstring");
	  return;
  }


  MakeClip(&llx_clip,&lly_clip,&urx_clip,&ury_clip);


  x1 = x1 - llx_clip;
  y1 = y1 - lly_clip;
    

  lwidth = 200;
  lheight = 20;

  localpixmap      = XCreatePixmap (XtDisplay (drawing_a),
				    RootWindowOfScreen (XtScreen (drawing_a)), lwidth, lheight,
				    DefaultDepthOfScreen (XtScreen (drawing_a)));

  localpixmap2     = XCreatePixmap (XtDisplay (drawing_a),
				    RootWindowOfScreen (XtScreen (drawing_a)), lwidth, lheight,
				    DefaultDepthOfScreen (XtScreen (drawing_a)));

  XSetForeground(mydisplay,mygc,mycolors[DRAW_COLOR_WHITE]);

  
  XFillRectangle (mydisplay, localpixmap,  mygc, 0, 0,lwidth, lheight);
  XFillRectangle (mydisplay, localpixmap2, mygc, 0, 0,lwidth, lheight);


  
  XSetForeground(mydisplay,mygc,mycolors[DRAW_COLOR_BLACK]);  
  XDrawString(mydisplay,localpixmap,mygc,0,lheight,thestring,(int)strlen(thestring));  

  
  
  myimage = XGetImage(mydisplay,localpixmap,0,0,lwidth,lheight,XAllPlanes(),ZPixmap);

  for(i=0;i<lheight;i++)
    {      
      for(j=0;j<lwidth;j++)
	{
	  if((XGetPixel(myimage,j,i))==mycolors[DRAW_COLOR_BLACK]) 
	    {
	      XDrawPoint (mydisplay, localpixmap2, mygc,j,lheight-i);
	    }
	}
    }

  XSetForeground(mydisplay,mygc,mycolors[color]);  



  myimage2 = XGetImage(mydisplay,localpixmap2,0,0,lwidth,lheight,XAllPlanes(),ZPixmap);
  
  for(i=0;i<lheight;i++)
    {      
      for(j=0;j<lwidth;j++)
	{
	  if((XGetPixel(myimage2,j,i))==mycolors[DRAW_COLOR_BLACK]) 
	    {
	      
	      
	      xcoord = i + (short int)((int)  (10.0+(double)(x1/IRegionSize)*xunits));
	      ycoord = j + (short int)(height-(10.0+(double)(y1/IRegionSize)*xunits));
	      
	      

	     ycoord = ycoord - 100; 
	      
		 
		 ycoord = ycoord + GetYShifter();
	      
	      if(Lindex==DRAW_NOW)
		{
		  XDrawPoint (mydisplay, pixmap,   mygc,xcoord,ycoord);
		  XDrawPoint (mydisplay, mywindow, mygc,xcoord,ycoord);      
		}
	      else
		{
		  printf("shouldnt be calling MAPdrawrotatedstring with %d\n",Lindex);
		}
	    }
	}
    }
  XSetForeground(mydisplay,mygc,mycolors[DRAW_COLOR_BLACK]);  
  XFreePixmap(mydisplay,localpixmap);
  XFreePixmap(mydisplay,localpixmap2);
  XDestroyImage(myimage);
  XDestroyImage(myimage2);
}



void MySetLineThickness(int thickness)
{  
  if(OVERRIDE_THICKNESS<0)
  {
    if(thickness>2)  
	{
      KEEP_THICKNESS = 1;
    }
    else
    {
      KEEP_THICKNESS = 0;
    }
  }

  XSetLineAttributes(mydisplay,mygc,thickness,LineSolid,CapButt,JoinMiter);
  XSetLineAttributes(mydisplay,mybitgc,thickness,LineSolid,CapButt,JoinMiter);
}



void ReallyDrawTopGrid()
{
  double tempx,tempy,multiplier,llx,lly,urx,ury;
  char c[50];
  int good=0,padspace;
  int minusx = 0;
  int minusy = 0;
  extern XFontStruct *LabelFont;

  


  if(GRID_THICKNESS>1)
    {
      MySetLineThickness(GRID_THICKNESS);
    }


  llx = llx_zoom;
  lly = lly_zoom;
  urx = llx_zoom+(980.0/xunits)*IRegionSize;
  ury = lly_zoom+(780.0/yunits)*IRegionSize;


  if(urx> ((MaxXindex+1)*IRegionSize) )
  {
	urx = (MaxXindex+1)*IRegionSize;
  }

  if(ury> ((MaxYindex+1)*IRegionSize) )
  {
	ury = (MaxYindex+1)*IRegionSize;
  }


  if(Ctype()==1)
    {multiplier = 100000.0;} 
  else if(Ctype()==2)
    {multiplier = 1.0;}
  else 
    {printf("GB2: bad coordinate system! %d\n",CoordinateSystem); ExitWrapper(-1);}
  


  if(llx<0)
    {
      minusx = (int)llx;
    }
  if(lly<0)
    {
      minusy = (int)lly;
    }


  
  tempx = (GridX - Xtranslation)*multiplier;

  if((tempx>urx)&&(DrawUserGrid==1))
    {
      padspace = (int)floor( (urx-tempx)/(GridSpace*multiplier) );
      
      tempx = tempx + (GridSpace*multiplier*padspace);
    }

  while(tempx>=llx)
    {
      MAPdrawline(-1,tempx,minusy,tempx,(MaxYindex+1)*IRegionSize,GRID_COLOR,DRAW_NOW); 
      tempx = tempx - (GridSpace*multiplier);
    }



  
  tempx = (GridX - Xtranslation)*multiplier;

  if((tempx<llx)&&(DrawUserGrid==1))
    {
      padspace = (int)floor( (llx-tempx)/(GridSpace*multiplier) );
      tempx = tempx + (GridSpace*multiplier*padspace);
    }

  while(tempx<=urx)
    {
      MAPdrawline(-1,tempx,minusy,tempx,(MaxYindex+1)*IRegionSize,GRID_COLOR,DRAW_NOW); 
      tempx = tempx + (GridSpace*multiplier);
    }  



  
  
  tempy = (GridY - Ytranslation)*multiplier;

  if((tempy>ury)&&(DrawUserGrid==1))
    {
      padspace = (int)floor( (ury-tempy)/(GridSpace*multiplier) );
      
      tempy = tempy + (GridSpace*multiplier*padspace);
    }

  while(tempy>=lly)
    {
      MAPdrawline(-1,minusx,tempy,(MaxXindex+1)*IRegionSize,tempy,GRID_COLOR,DRAW_NOW); 
      tempy = tempy - (GridSpace*multiplier);
    }





  
  
  tempy = (GridY - Ytranslation)*multiplier;

  if((tempy<lly)&&(DrawUserGrid==1))
    {
      padspace = (int)floor( (lly-tempy)/(GridSpace*multiplier) );
      tempy = tempy + (GridSpace*multiplier*padspace);
    }

  while(tempy<=ury)
    {
      MAPdrawline(-1,minusx,tempy,(MaxXindex+1)*IRegionSize,tempy,GRID_COLOR,DRAW_NOW); 
      tempy = tempy + (GridSpace*multiplier);
    }



  if(DrawLabels==1)
    {      
	  

	  if((DoLargeLabels==1)&&(DoBoldLabels==1))
	  {
        XSetFont(mydisplay,mygc,XLoadFont(mydisplay,"-*-courier-bold-r-*--*-240-*"));
	  }
	  else if((DoLargeLabels==1)&&(DoBoldLabels==0))
	  {
        XSetFont(mydisplay,mygc,XLoadFont(mydisplay,"-*-courier-medium-r-*--*-240-*"));
	  }
	  else if((DoLargeLabels==0)&&(DoBoldLabels==1))
	  {
        XSetFont(mydisplay,mygc,XLoadFont(mydisplay,"-*-courier-bold-r-*--*-90-*"));
	  }
	  else if((DoLargeLabels==0)&&(DoBoldLabels==0))
	  {
        XSetFont(mydisplay,mygc,XLoadFont(mydisplay,"-*-courier-medium-r-*--*-90-*"));
	  }


      
      
      
      tempy = (GridY - Ytranslation)*multiplier;
      
      if((tempy<lly)&&(DrawUserGrid==1))
	  { 
	  padspace = (int)floor( (lly-tempy)/(GridSpace*multiplier) );
	  tempy = tempy + (GridSpace*multiplier*padspace);
	  }
      
      while(tempy<=ury)
	  { 
	  good = 0;

	  if( (Ctype()==1)&&
	      (tempy>=lly)&&(tempy<=ury) )
	    {
	      good = 1;
	      sprintf(c,"%.*lf",GetDigits(GridSpace),(double)tempy/multiplier + Ytranslation);
	    }
	  else if((Ctype()==2)
		  &&(tempy>=lly)&&(tempy<=ury) )
	    {
	      good = 1;
	      sprintf(c,"%.0lf",(double)tempy + Ytranslation);
	    }
	  
	  if(good==1)
	    {
	      if(DEBUG==1){printf("drawing string %s at %d %d\n",c,(int)llx,(int)tempy);}
	      MAPdrawstring(llx,tempy,c,GRID_LABEL_COLOR,0,DRAW_NOW,0);
	  } 
	  tempy = tempy + (GridSpace*multiplier);
	  } 



      
      tempy = (GridY - Ytranslation)*multiplier;

      if((tempy>ury)&&(DrawUserGrid==1))
	{
	  padspace = (int)floor( (ury-tempy)/(GridSpace*multiplier) );
	  
	  tempy = tempy + (GridSpace*multiplier*padspace);
	}
      
      while(tempy>=lly)
	{
	  good = 0;

	  if( (Ctype()==1)
	      &&(tempy>=lly)&&(tempy<=ury) )
	    {
	      good = 1;
	      sprintf(c,"%.*lf",GetDigits(GridSpace),(double)tempy/multiplier + Ytranslation);
	    }
	  else if((Ctype()==2)
		  &&(tempy>=lly)&&(tempy<=ury) )
	    {
	      good = 1;
	      sprintf(c,"%.0lf",(double)tempy + Ytranslation);
	    }
	  
	  if(good==1)
	    {
	      if(DEBUG==1){printf("drawing string %s at %d %d\n",c,(int)llx,(int)tempy);}
	      MAPdrawstring(llx,tempy,c,GRID_LABEL_COLOR,0,DRAW_NOW,0);
	  }
	  tempy = tempy - (GridSpace*multiplier);
	}




      
      tempx = (GridX - Xtranslation)*multiplier;

      if((tempx<llx)&&(DrawUserGrid==1))
	{
	  padspace = (int)floor( (llx-tempx)/(GridSpace*multiplier) );
	  tempx = tempx + (GridSpace*multiplier*padspace);
	}

      while(tempx<=urx)
	{
	  good = 0;

	  if( (Ctype()==1)
	      &&(tempx>=llx)&&(tempx<=urx) )
	    {
	      good = 1;
	      sprintf(c,"%.*lf",GetDigits(GridSpace),(double)tempx/multiplier + Xtranslation);
	    }
	  else if((Ctype()==2)
		  &&(tempx>=llx)&&(tempx<=urx) )
	    {
	      good = 1;
	      sprintf(c,"%.0lf",(double)tempx + Xtranslation);
	    }
	  
	  if(good==1)
	    {
	      if(DEBUG==1){printf("drawing string %s at %d %d\n",c,(int)llx,(int)tempx);}
	      MAPdrawrotatedstring(tempx,lly,c,GRID_LABEL_COLOR,DRAW_NOW);
	    }
	  tempx = tempx + (GridSpace*multiplier);
	}



      
      
      tempx = (GridX - Xtranslation)*multiplier;

      if((tempx>urx)&&(DrawUserGrid==1))
	{
	  padspace = (int)floor( (urx-tempx)/(GridSpace*multiplier) );
	  
	  tempx = tempx + (GridSpace*multiplier*padspace);
	}

      while(tempx>=llx)
	{
	  good = 0;
	  
	  if((Ctype()==1)
	     &&(tempx>=llx)&&(tempx<=urx) )
	    {
	      good = 1;
	      sprintf(c,"%.*lf",GetDigits(GridSpace),(double)tempx/multiplier + Xtranslation);
	    }
	  else if((Ctype()==2)
		  &&(tempx>=llx)&&(tempx<=urx) )
	    {
	      good = 1;
	      sprintf(c,"%.0lf",(double)tempx + Xtranslation);
	    }	  
	  
	  if(good==1)
	    {
	      if(DEBUG==1){printf("drawing string %s at %d %d\n",c,(int)llx,(int)tempx);}
	      MAPdrawrotatedstring(tempx,lly,c,GRID_LABEL_COLOR,DRAW_NOW);
	    }
	  tempx = tempx - (GridSpace*multiplier);
	}

	
	XSetFont(mydisplay,mygc,defaultfont);

	if(LabelFont)
	{
      XSetFont(mydisplay,mygc,LabelFont->fid);
      XSetFont(mydisplay,mybitgc,LabelFont->fid);
	}
	else
	{
      XSetFont(mydisplay,mygc,defaultfont);
	}


    }
  
  if(GRID_THICKNESS>1)
    {
      MySetLineThickness(0);
    }
}





void DrawTopGrid()
{
  int totalgrids=0,padspace;
  double tempx,tempy,multiplier,llx,lly,urx,ury,SaveGridX,SaveGridY,SaveGridSpace;


  if((DrawUserGrid  + DrawOneDegreeGrid  + DrawHalfDegreeGrid  + DrawQuarterDegreeGrid +
	  DrawUserGridL + DrawOneDegreeGridL + DrawHalfDegreeGridL + DrawQuarterDegreeGridL)<1)
  {
	return;
  }


  SaveGridX     = GridX;
  SaveGridY     = GridY;
  SaveGridSpace = GridSpace;

  if((DrawQuarterDegreeGrid+DrawQuarterDegreeGridL)>0)
  {
	GridX         = 0;
	GridY         = 0;
	GridSpace     = 0.25;
  }
  else if((DrawHalfDegreeGrid+DrawHalfDegreeGridL)>0)
  {
	GridX         = 0;
	GridY         = 0;
	GridSpace     = 0.5;
  }
  else if((DrawOneDegreeGrid+DrawOneDegreeGridL)>0)
  {
	GridX         = 0;
	GridY         = 0;
	GridSpace     = 1.0;
  }


  
  
  if(Ctype()==1)
    {multiplier = 100000.0;} 
  else if(Ctype()==2)
    {multiplier = 1.0;}
  else 
    {printf("bad coordinate system! %d\n",CoordinateSystem); ExitWrapper(-1);}
  
  
  llx = llx_zoom;
  lly = lly_zoom;
  urx = llx_zoom+(980.0/xunits)*IRegionSize;
  ury = lly_zoom+(780.0/yunits)*IRegionSize;


  
  
  tempy = (GridY - Ytranslation)*multiplier;
  
  if((tempy<lly)&&(DrawUserGrid==1))
    {
      padspace = (int)floor( (lly-tempy)/(GridSpace*multiplier) );
      tempy = tempy + (GridSpace*multiplier*padspace);
    }
  
  while(tempy<=ury)
    {
      if((Ctype()==1)
	 &&(tempy>=lly)&&(tempy<=ury) )     
	{
	  totalgrids++;
	}
      else if((Ctype()==2)
	      &&(tempy>=lly)&&(tempy<=ury) )
	{
	  totalgrids++;
	}
      tempy = tempy + (GridSpace*multiplier);
    }
  


  
  tempy = (GridY - Ytranslation)*multiplier;

  if((tempy>ury)&&(DrawUserGrid==1))
    {
      padspace = (int)floor( (ury-tempy)/(GridSpace*multiplier) );
      
      tempy = tempy + (GridSpace*multiplier*padspace);
    }
      
  while(tempy>=lly)
    {
      if((Ctype()==1)&&(tempy>=lly)&&(tempy<=ury) )     
	{
	  totalgrids++;
	}
      else if((Ctype()==2)&&(tempy>=lly)&&(tempy<=ury) ) 
	{
	  totalgrids++;
	}
      tempy = tempy - (GridSpace*multiplier);
    }



  
  tempx = (GridX - Xtranslation)*multiplier;
  
  if((tempx<llx)&&(DrawUserGrid==1))
    {
      padspace = (int)floor( (llx-tempx)/(GridSpace*multiplier) );
      tempx = tempx + (GridSpace*multiplier*padspace);
    }
  
  while(tempx<=urx)
    {
      if((Ctype()==1)&&(tempx>=llx)&&(tempx<=urx))
	{
	  totalgrids++;
	}
      else if((Ctype()==2)&&(tempx>=llx)&&(tempx<=urx))
	{
	  totalgrids++;
	}
      tempx = tempx + (GridSpace*multiplier);
    }
  


  
  tempx = (GridX - Xtranslation)*multiplier;

  if((tempx>urx)&&(DrawUserGrid==1))
    {
      padspace = (int)floor( (urx-tempx)/(GridSpace*multiplier) );
      
      tempx = tempx + (GridSpace*multiplier*padspace);
    }

  while(tempx>=llx)
    {
      if((Ctype()==1)&&(tempx>=llx)&&(tempx<=urx) )        
	{
	  totalgrids++;
	}
      else if((Ctype()==2)&&(tempx>=llx)&&(tempx<=urx) )  
	{
	  totalgrids++;
	}
      tempx = tempx - (GridSpace*multiplier);
    }


  
  if(totalgrids<200)
    {
      ReallyDrawTopGrid();
    }
  else
    {      
	  printf("Too many grid lines %d\n",totalgrids);
      not_while_running(drawing_a,"At this zoom level, the current settings for the foreground user-defined\n\
grid would cause the grid lines to be far too close together.\n\n\
Grid not drawn.\n\n\
To see the grid, either zoom in far enough for the individual grid\n\
lines to be resolvable with the current settings, or change\n\
the grid settings under \"Miscellaneous Parameters...\".",1221,"Grid Not Drawn",5);
    }



  GridX     = SaveGridX;
  GridY     = SaveGridY;
  GridSpace = SaveGridSpace;

}







void UnTranslateCoords(double *x, double *y)
{
  if(Ctype()==2)
    {
      *x = *x-Xtranslation;
      *y = *y-Ytranslation;
    }
  else if(Ctype()==1)
    {
      *x = (*x-Xtranslation)*100000.0;
      *y = (*y-Ytranslation)*100000.0;
    }  
  else
    {
      printf("bad coordinate system %d to UnTranslateCoords!\n",CoordinateSystem);
      XBell(mydisplay,50);
    }
}









void CreateLoadModule(double x,double y,int *loadx,int *loady)
{
  *loadx = (int)(x/RegionSize);
  *loady = (int)(y/RegionSize);
}





void PanScreen(int panx, int pany)
{


  lly_zoom =  lly_zoom - (double)((double)(pany)/yunits)*IRegionSize;
  llx_zoom =  llx_zoom - (double)((double)(panx)/xunits)*IRegionSize; 
  
  
    
  MakePixmap3();
  
  set_color (drawing_a, "White",(XtPointer)NULL);
  
  XFillRectangle (XtDisplay (drawing_a), pixmap, mygc, 0, 0, width,height);
  XFillRectangle (XtDisplay (drawing_a), mywindow, mygc, 0, 0, width,height);
  set_color (drawing_a, "Black",(XtPointer)NULL); 
  
  if(GRID==1)
    {
      DrawGrid();
    }
  
  XFlush(mydisplay);
  if(ZOOMDEBUG==1){printf("fromi, fromj, toi, toj: %d %d %d %d\n",FromI,FromJ,ToI,ToJ);}
  
  urx_zoom = llx_zoom+(1000.0/xunits)*IRegionSize;
  ury_zoom = lly_zoom+(850.0/yunits) *IRegionSize;

  SaveXScroll = ScrollPercent(1);
  SaveYScroll = ScrollPercent(2);

  SAVE_ZOOM_STATE(SaveXScroll,SaveYScroll); 
  DrawAll();

}





void ZoomAllOut()
{
  
  int junk, temp_mode = 0;
  String temp="zoom_out";



  if(ZOOM_MODE==0)
    {
      if(PROFILE_MODE==1)   {PROFILE_MODE = 0; temp_mode = 1;}
      else if(FAN_MODE==1)  {FAN_MODE     = 0; temp_mode = 2;}
      else if(INFO_MODE==1) {INFO_MODE    = 0; temp_mode = 3;}
      else if(DIST_MODE==1) {DIST_MODE    = 0; temp_mode = 4;}
      else if(CHECK_MODE==1){CHECK_MODE   = 0; temp_mode = 5;}
      else if(PAN_MODE==1)  {PAN_MODE     = 0; temp_mode = 6;}
      else if(LOS==1)       {LOS          = 0; temp_mode = 7;}
      ZOOM_MODE=1;
    }
  
  junk = 1;
  

  draw(drawing_a,NULL,&temp,&junk);


  
  
  
  if(temp_mode>0)
    {
      if(temp_mode==1)     {PROFILE_MODE = 1;}
      else if(temp_mode==2){FAN_MODE     = 1;}
      else if(temp_mode==3){INFO_MODE    = 1;}
      else if(temp_mode==4){DIST_MODE    = 1;}
      else if(temp_mode==5){CHECK_MODE   = 1;}
      else if(temp_mode==6){PAN_MODE     = 1;}
      else if(temp_mode==7){LOS          = 1;}
      ZOOM_MODE=0;
    }


  if(NOT_ZOOMED==1)
    {
      if(PAN_MODE==1)
	{
	  
	  modeCallback(drawing_a,(XtPointer)1,(XtPointer)1);
	}
      XtSetSensitive(modes[1],False);
    }
  else
    {
      XtSetSensitive(modes[1],True);
    }

  StopDistanceGathering();

}




double ScrollPercent(int xy)
{
  extern Widget draw_h_scroll;
  int min,max,slidesize,increment,Pincrement,value;
  double dmax,dval;

  if(xy==1)
	{
	  XtVaGetValues(draw_h_scroll,
		XmNminimum,      &min,
		XmNmaximum,      &max,
		XmNsliderSize,   &slidesize,
		XmNincrement,    &increment,
		XmNpageIncrement,&Pincrement,
		XmNvalue,        &value,
		NULL);

    	dmax = (double)max - (double)slidesize;
		dval = (double)value;

        return dval/dmax;
	}
	else
	{
      XtVaGetValues(vert_scroll[DRAWING_A_SCROLL],
		XmNminimum,      &min,
		XmNmaximum,      &max,
		XmNsliderSize,   &slidesize,
		XmNincrement,    &increment,
		XmNpageIncrement,&Pincrement,
		XmNvalue,        &value,
		NULL);

    	dmax = (double)max - (double)slidesize;
		dval = (double)value;

        return 1.0-(dval/dmax); 
	}
}





int ZoomTooFar(double temp_llx_zoom,double temp_lly_zoom,
			   double temp_xunits,double temp_yunits,
			   int x, int y)
{
  double temp_urx_zoom,temp_ury_zoom,temp_xrange,temp_yrange,
	  xmod,ymod,xpercent,ypercent;
  int Ixmod,Iymod;


  temp_urx_zoom = temp_llx_zoom+(1000.0/temp_xunits)*IRegionSize;
  temp_ury_zoom = temp_lly_zoom+(850.0/temp_yunits) *IRegionSize;

  
  temp_xrange = fabs(temp_urx_zoom-temp_llx_zoom);
  temp_yrange = fabs(temp_ury_zoom-temp_lly_zoom);
  
  
  temp_xrange = temp_xrange/IRegionSize;
  temp_yrange = temp_yrange/IRegionSize;
  
  if(
     ((temp_xrange*DBWidth)  < X_ZOOM_MAX)  ||
     ((temp_yrange*DBHeight) < Y_ZOOM_MAX)
     )
    {
     if((x<0)&&(y<0))
	 {
		 
		 return 1;
	 }

      

	  

      xmod = 500-AddVoidSpace(-1)/2.0;
	  ymod = 425+AddVoidSpace(-2)/2.0;

      xpercent = ScrollPercent(1);
      ypercent = ScrollPercent(2);
	  if(ypercent<0.0)
	  {
		  ypercent = 0.0;
	  }
      

      xmod = xmod + xpercent*AddVoidSpace(-1);
      ymod = ymod - ypercent*AddVoidSpace(-2);

	  Ixmod = (int)xmod;
	  Iymod = (int)ymod;
      PanScreen(Ixmod-x,y-Iymod);


      return 1;
    }


  return 0;
}


void ZoomIt(int x,int y,double xunit_modifier)
{
  double current_x_extent,current_y_extent,llx_click,lly_click,temp_llx_zoom,temp_lly_zoom;
  extern double AddVoidSpace(int xy);


  if((NOT_ZOOMED==1)&&(xunit_modifier<1))
  {
	
    return;
  }

  if((xunits*xunit_modifier)<(mydmax((double)PixDBWidth,(double)PixDBHeight)))
  {
    
    ZoomAllOut();
    return;
  }



  current_x_extent = urx_zoom - llx_zoom - AddVoidSpace(1);
  current_y_extent = ury_zoom - lly_zoom - AddVoidSpace(2);

  if((x>=0)||(y>=0)) 
  {

	if(NOT_ZOOMED==1)
    {
      current_x_extent = DBWidth;
      current_y_extent = DBHeight;
 
      llx_click = 0 + (double)((double)(IRegionSize/xunits)*(double)(x-10.0));
      lly_click = 0 + (double)((double)(IRegionSize/yunits)*(double)(height-y-10.0));
    }
    else
	{
	  llx_click  = llx_zoom + (double)((double)(IRegionSize/xunits)*(double)(x-10.0));
      lly_click  = lly_zoom + (double)((double)(IRegionSize/yunits)*(double)(height-y)); 
	}

    temp_llx_zoom   = llx_click - current_x_extent*0.25 - 0.5*ScrollPercent(1)*AddVoidSpace(1);
    temp_lly_zoom   = lly_click - current_y_extent*0.25 - 0.5*ScrollPercent(2)*AddVoidSpace(2);

	NOT_ZOOMED = 0; 

  }

  else if(xunit_modifier<1) 
  {
    temp_llx_zoom   = llx_zoom  - current_x_extent*0.50 - 1.0*ScrollPercent(1)*AddVoidSpace(1);
    temp_lly_zoom   = lly_zoom  - current_y_extent*0.50 - 1.0*ScrollPercent(2)*AddVoidSpace(2);
  }
  else 
  {
    NOT_ZOOMED = 0; 

    temp_llx_zoom   = llx_zoom  + current_x_extent*0.25 + 0.5*ScrollPercent(1)*AddVoidSpace(1);
    temp_lly_zoom   = lly_zoom  + current_y_extent*0.25 + 0.5*ScrollPercent(2)*AddVoidSpace(2);
  }
 

  if(ZoomTooFar(temp_llx_zoom,temp_lly_zoom,
	            xunits*xunit_modifier,xunits*xunit_modifier,
				x,y)==1)
  {
    return;
  }

  llx_zoom = temp_llx_zoom;
  lly_zoom = temp_lly_zoom;


  xunits = xunits * xunit_modifier;
  yunits = xunits;


  urx_zoom = llx_zoom+(1000.0/xunits)*IRegionSize;
  ury_zoom = lly_zoom+(850.0/yunits) *IRegionSize;

 

  MakePixmap3();
  set_color (drawing_a, "White",(XtPointer)NULL);
  XFillRectangle (XtDisplay (drawing_a), pixmap,   mygc, 0, 0, width, height);
  XFillRectangle (XtDisplay (drawing_a), mywindow, mygc, 0, 0, width, height);
  SetColorRight();

  if(GRID==1)
    {
      DrawGrid();
    }
  
  SaveXScroll = ScrollPercent(1);
  SaveYScroll = ScrollPercent(2);

  SAVE_ZOOM_STATE(SaveXScroll,SaveYScroll); 
  DrawAll();
  StopDistanceGathering();
}


void info_toggles(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int togglenum=(int)client_data;



  if(togglenum==0)
    {
      INFO_GEOMETRY   = !INFO_GEOMETRY;
    }
  if(togglenum==1)
    {
      INFO_DOMAIN     = !INFO_DOMAIN;
    }
  if(togglenum==2)
    {
      INFO_LENGTH     = !INFO_LENGTH;
    }
  if(togglenum==3)
    {
      INFO_AREA       = !INFO_AREA;
    }
  if(togglenum==4)
    {
      INFO_FID        = !INFO_FID;
    }
  if(togglenum==5)
    {
      INFO_GFID       = !INFO_GFID;
    }
  if(togglenum==6)
    {
      INFO_COORDS     = !INFO_COORDS;
    }
  if(togglenum==7)
    {
      INFO_ATTRIBUTES = !INFO_ATTRIBUTES;
    }
  if(togglenum==8)
    {
      INFO_ATTR_LABELS = !INFO_ATTR_LABELS;
    }
  if(togglenum==9)
    {
      INFO_ATTR_VALUES = !INFO_ATTR_VALUES;
    }
  if(togglenum==10)
    {
      DRAW_VERTICES = !DRAW_VERTICES;
    }
  if(togglenum==11)
    {
      INFO_HEX = !INFO_HEX;
    }
  if(togglenum==12)
    {
      INFO_GRIDVALUES = !INFO_GRIDVALUES;
    }
}



void HelpInfoParamsCallback(Widget w,XtPointer data,XtPointer callData)
{
  not_while_running(XtParent(w),"This window is used to specify what data to present when querying features.\n\
Any of the available options on this window may be toggled on or off by clicking\n\
it.\n\n\
For \"Attributes\", it is possible to specify which particular attributes\n\
to show, by clicking the \"Specify Attributes\" button and choosing from the list.\n\
A maximum number of coordinates to print is also available here.\n\n\
If \"Coordinates\" is selected, and the feature being queried has less than\n\
or equal to the \"Maximum number of coordinates to show\", then all of the\n\
feature's coordinates will be shown.\n\n\
\"Number Vertices\" causes vertices drawn on the screen to be numbered, in\n\
order to correspond with the numbered vertices shown in the information window.\n\n\
\"Zoom to individual vertices\" allows the ability to click a vertex in the\n\
information window, and zoom to that vertex on the map.\n",1224,"Information Options Help",5);
}

void HelpInfoAttrCallback(Widget w,XtPointer data,XtPointer callData)
{
  not_while_running(XtParent(w),"This window is used to specify what attributes to present when querying features.\n\
Those attributes that are toggled \"on\" in the list will be shown for any features\n\
that are queried.  Note that attributes are only shown if \"Attributes\" is also\n\
\"on\" in the Information Parameters window.",1225,"Attribute Information Help",5);
}



void SelectAttrCallback(Widget w,XtPointer data,XtPointer callData)
{
  int type=(int)data;
  int i;

  

  if(type==0)
    {
      for(i=1;i<INsac_loop;i++)
	  { 
	    if(UNIQSAC[i]==1)
	    {
	      InfoSac[i] = 0;
	      XmToggleButtonSetState(info_tog[i],(Boolean)InfoSac[i],(Boolean)0);
	    }
	  } 
    }
  else if(type==1)
    {
      for(i=1;i<INsac_loop;i++)
	  {
	    if(UNIQSAC[i]==1)
	    {
	      InfoSac[i] = 1;
	      XmToggleButtonSetState(info_tog[i],(Boolean)InfoSac[i],(Boolean)0);
	    }
	  } 
    }
  else if(type==2)
    {
      for(i=1;i<INsac_loop;i++)
	  { 
	    if(UNIQSAC[i]==1)
		{
          if(IsMetadata(GetEACCode(i)))
		  {
			InfoSac[i] = 1;
			XmToggleButtonSetState(info_tog[i],(Boolean)InfoSac[i],(Boolean)0);
		  }
	    }
	  }
    }
  else if(type==3)
  {
    for(i=1;i<INsac_loop;i++)
	{  
	  if(UNIQSAC[i]==1)
	  {
        if(IsMetadata(GetEACCode(i)))
		{
	      InfoSac[i] = 0;
		  XmToggleButtonSetState(info_tog[i],(Boolean)InfoSac[i],(Boolean)0);
		}
	  }
	}
  }
}


void SpecifyAttrsCallback(Widget w,XtPointer data,XtPointer callData)
{
  Arg resources[15];
  Widget form,rowcol,button,sw3,rc3,label1,sb2;
  XmString str;
  char temp[500];
  int n,i;
  
  
  if(INFO_ATTR_WIN==0)
    {	
      n=0;
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++; 
      
      info_attr_head = 
	XtCreatePopupShell
	("Information Attributes",topLevelShellWidgetClass,drawing_a,resources,n);
      
      

      rowcol = XtVaCreateManagedWidget
	(
	 "XformWidget", xmPanedWindowWidgetClass, info_attr_head,
	 XmNrubberPositioning, False,
	 XmNresizable,         True,
	 XmNseparatorOn,       False,
	 XmNsashHeight,        1,
	 NULL
	 );
            
      
      if(UNIQARRAYBUILT==0)
	{
	  BuildUNIQArray();
	}
      


      form = XtVaCreateWidget ("formola", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   15,
			       XmNpaneMaximum,   15,
			       XmNfractionBase,  100,  
			       NULL);
      

      sprintf(temp,"Attributes (%d Definitions found):",UNIQSACNUM);

      
      label1 = XtVaCreateManagedWidget (temp,
					xmLabelWidgetClass, form,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,   99,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    0,
					XmNalignment,       XmALIGNMENT_CENTER,
					XmNlabelString,     STRING(temp),
					XmNtraversalOn,     False, 
					LABELWTRANSLATE,
					NULL);
      
      XtManageChild(form);
      
      
      form = XtVaCreateWidget ("formola", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      

      sw3 = XtVaCreateManagedWidget ("scrolled_win",
				     xmScrolledWindowWidgetClass, form,
				     XmNvisibleItemCount,        10,
				     XmNincrement,               1,
				     XmNwidth,                   200,
				     XmNheight,                  300,
				     XmNtraversalOn,             False,
				     XmNscrollingPolicy,         XmAUTOMATIC,
				     XmNscrollBarDisplayPolicy,  XmSTATIC,
				     XmNtopAttachment,           XmATTACH_FORM,
				     XmNbottomAttachment,        XmATTACH_FORM,
				     XmNrightAttachment,         XmATTACH_POSITION,
				     XmNrightPosition,           99,
				     XmNleftAttachment,          XmATTACH_POSITION,
				     XmNleftPosition,            0,
				     NULL);
      
      XtVaGetValues(sw3,XmNverticalScrollBar,&sb2,NULL);
      rc3 = XtVaCreateWidget ("rc.error.editor",xmRowColumnWidgetClass, sw3, NULL);
      
      XtManageChild(form);
      


      
      for(i=1;i<INsac_loop;i++)
	{
	  if(UNIQSAC[i]==1)
	    {
	      form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rc3,
				       XmNfractionBase,  100,  
				       NULL);
	      

	      if(NGA_TYPE==1)
		{
		  sprintf(temp,"%s\n(%s)",GetEACLabel(i),GetEACCode(i));
		}
	      else
		{
		  sprintf(temp,"%s",GetEACLabel(i));
		}

	      str = XmStringCreateLtoR (temp, "mytag1");
	      
	      
	      info_tog[i] = XtVaCreateManagedWidget ("the_test",
					     xmToggleButtonWidgetClass, form,
					     XmNtopAttachment,    XmATTACH_FORM,
					     XmNtraversalOn,      False,
					     XmNbottomAttachment, XmATTACH_FORM,
					     XmNalignment,        XmALIGNMENT_BEGINNING,			
					     XmNlabelString,      str,
					     XmNrightAttachment,  XmATTACH_POSITION,
					     XmNrightPosition,    99,
					     XmNleftAttachment,   XmATTACH_POSITION,
					     XmNleftPosition,     1,
					     TOGGLETRANSLATE,     TOGGLEINCLUDE,
					     NULL);
	      XtAddCallback (info_tog[i], XmNvalueChangedCallback, info_sac_tog, (XtPointer)i);
	      XmToggleButtonSetState(info_tog[i],(Boolean)InfoSac[i],(Boolean)0);
	      XtManageChild(form);
	    }
	}


      XtManageChild(rc3);
      XtManageChild(sw3);
      
      



     form = XtVaCreateWidget ("formola", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget ("Select All",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    50,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     0,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);      

      XtAddCallback(button, XmNactivateCallback, SelectAttrCallback, (XtPointer)1);
      XtManageChild(button);
  

      button = XtVaCreateManagedWidget ("De-Select All",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    100,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     50,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);      

      XtAddCallback(button, XmNactivateCallback, SelectAttrCallback, (XtPointer)0);
      XtManageChild(button);
      XtManageChild(form);
	    
      
      if(NGA_TYPE==1)
	{
	  form = XtVaCreateWidget ("formola", xmFormWidgetClass, rowcol,
				   XmNpaneMinimum,   25,
				   XmNpaneMaximum,   25,
				   XmNfractionBase,  100,  
				   NULL);
	  
	  button = XtVaCreateManagedWidget ("Select All Metadata",
					    xmPushButtonWidgetClass, form,
					    XmNtopAttachment,    XmATTACH_FORM,
					    XmNtraversalOn,      False,
					    XmNbottomAttachment, XmATTACH_FORM,
					    XmNrightAttachment,  XmATTACH_POSITION,
					    XmNrightPosition,    50,
					    XmNleftAttachment,   XmATTACH_POSITION,
					    XmNleftPosition,     0,
					    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					    NULL);      
	  
	  XtAddCallback(button, XmNactivateCallback, SelectAttrCallback, (XtPointer)2);
	  XtManageChild(button);
	  

	  button = XtVaCreateManagedWidget ("De-Select All Metadata",
					    xmPushButtonWidgetClass, form,
					    XmNtopAttachment,    XmATTACH_FORM,
					    XmNtraversalOn,      False,
					    XmNbottomAttachment, XmATTACH_FORM,
					    XmNrightAttachment,  XmATTACH_POSITION,
					    XmNrightPosition,    100,
					    XmNleftAttachment,   XmATTACH_POSITION,
					    XmNleftPosition,     50,
					    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					    NULL);      
	  
	  XtAddCallback(button, XmNactivateCallback, SelectAttrCallback, (XtPointer)3);
	  XtManageChild(button);
	  XtManageChild(form);
	}


           
      form = XtVaCreateWidget ("formola", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget ("Help",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    50,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     0,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);      

      XtAddCallback(button, XmNactivateCallback, HelpInfoAttrCallback, (XtPointer)NULL);
      XtManageChild(button);
  

      button = XtVaCreateManagedWidget ("Done",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    100,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     50,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);      

      XtAddCallback(button, XmNactivateCallback, exitCallback, (XtPointer)38);
      XtManageChild(button);
      XtManageChild(form);
	    



      XtManageChild (rowcol);
      MyPopup(info_attr_head); 

      XtAddCallback(info_attr_head,XmNdestroyCallback,ShellDeath,(XtPointer)308);

      

      INFO_ATTR_WIN=1;
      XtVaSetValues(sb2,XmNincrement,30,NULL);
    }
  else
    {
      ResetWidget(info_attr_head);
    }
}





void poi_toggle(Widget widget,XtPointer client_data,XtPointer call_data)
{
  if(ZoomToPOIs==0)
    {
      ZoomToPOIs = 1;
    }
  else 
    {
      ZoomToPOIs = 0;
    }
}



void poi_connect_toggle(Widget widget,XtPointer client_data,XtPointer call_data)
{
  if(POI_CONNECT==0)
    {
      POI_CONNECT = 1;
    }
  else 
    {
      POI_CONNECT = 0;
    }
}



void help_ppad_callback(Widget w,XtPointer data,XtPointer callData)
{
  not_while_running(XtParent(w),"This window is used to set the amount of \"padding\" distance\n\
to be used when zooming the screen to individual points of interest.\n\
When the screen is zoomed to individual points of interest, the point\n\
will be shown on the screen with at least this amount of distance,\n\
in meters, added on all sides of it.",1464,"Points Of Interest Padding Distance Help",5);
}

 
void kill_ppad_callback(Widget button, XtPointer client_data, XtPointer call_data)
{
  
  los_result(ppad_text_sen_w,(XtPointer)11,(XtPointer)NULL);
  
  if(bad_los_result==1)
    {
      not_while_running(button,"The pad distance entered was invalid. It has been reset\nto the last valid value (valid range: 1-5000)",
			1465,"Invalid Pad Distance",1);
      return;
    }

  XtDestroyWidget(XtParent(XtParent(XtParent(button))));
}



void set_ppad_distance(Widget w,XtPointer data,XtPointer callData)
{ 
  static Widget ppad_head;  
  int n=0;
  Widget rowcol,form,exitbutton,sep;
  Arg resources[20];
  char temp[500];
  Dimension Pheight;
  
  if(PPAD_UP==0)
    {
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++; 
      XtSetArg(resources[n],  XmNmaxWidth,       800);          n++;  
      
      ppad_head = XtCreatePopupShell
	("Point Of Interest Zoom Pad Distance",
	 topLevelShellWidgetClass,XtParent(XtParent(XtParent(w))),resources,n);
      
      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass, ppad_head, NULL);
      
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      
      XtVaCreateManagedWidget ("",
			       xmLabelWidgetClass, form,
			       XmNtopAttachment,    XmATTACH_FORM,
			       XmNbottomAttachment, XmATTACH_FORM,
			       XmNrightAttachment,  XmATTACH_POSITION,
			       XmNrightPosition,  100,
			       XmNleftAttachment,  XmATTACH_POSITION,
			       XmNleftPosition,     0,
			       XmNalignment,        XmALIGNMENT_CENTER,
			       XmNlabelString, STRING("Pad Distance:"),
			       LABELWTRANSLATE,
			       NULL);
      XtManageChild(form);
      
      

      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      sprintf(temp,"%lf",PPAD_DIST);

      ppad_text_sen_w = XtVaCreateManagedWidget ("text_w",
						 xmTextFieldWidgetClass, form,	  
						 XmNvalue, temp,
						 XmNtraversalOn,      True,
						 XmNrightAttachment,  XmATTACH_POSITION,
						 XmNrightPosition,    80,
						 XmNleftAttachment,   XmATTACH_POSITION,
						 XmNleftPosition,     0,
						 XmNmaxLength,        15,
                         XmNtranslations,     XtParseTranslationTable ( translations_paste ) ,
						 NULL);
      
      XtAddCallback (ppad_text_sen_w, XmNactivateCallback,
		     los_result, (XtPointer)11);
      
      XtManageChild(form);


      sep = XtVaCreateManagedWidget ("sep1",
				     xmSeparatorWidgetClass, rowcol,
				     NULL);
      
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      exitbutton = XtVaCreateManagedWidget("Help", xmPushButtonWidgetClass, form,
					   XmNlabelString, STRING("Help"),
					   XmNleftAttachment,   XmATTACH_POSITION,
					   XmNleftPosition,     30,
					   XmNrightAttachment,   XmATTACH_POSITION,
					   XmNrightPosition,     50,
					   XmNtraversalOn,  False,
					   XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					   NULL);
      XtAddCallback(exitbutton, XmNactivateCallback, help_ppad_callback, (XtPointer)NULL);
      XtManageChild(exitbutton);
      
      n = 0;  
      exitbutton = XtVaCreateManagedWidget("Exit",xmPushButtonWidgetClass, form,
					   XmNlabelString,      STRING("Done"),
					   XmNleftAttachment,   XmATTACH_POSITION,
					   XmNleftPosition,     50,
					   XmNrightAttachment,  XmATTACH_POSITION,
					   XmNrightPosition,    70,
					   XmNtraversalOn,      False,
					   XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					   NULL);

      XtAddCallback(exitbutton, XmNactivateCallback, kill_ppad_callback, (XtPointer)NULL);
      XtManageChild(exitbutton);

      XtManageChild(form);
      XtManageChild (rowcol);
      
      XtAddCallback(ppad_head,XmNdestroyCallback,(XtCallbackProc)ShellDeath,(XtPointer)4080);       
      MyPopup(ppad_head); 
      PPAD_UP = 1;

      XtVaGetValues(ppad_head,  XmNheight,     &Pheight, NULL);
      XtVaSetValues(ppad_head,  XmNminHeight,   Pheight, NULL);
      XtVaSetValues(ppad_head,  XmNmaxHeight,   Pheight, NULL);

      XtAddEventHandler(ppad_head,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)Pheight));
    }
  else
    {
      ResetWidget(ppad_head);
    }
}







void InfoParamsCallback(Widget w,XtPointer data,XtPointer callData)
{
  
  Arg resources[15];
  Widget form,rowcol,button,tog;
  Dimension y1;
  int n=0;
  char obs_str[500];
  
  
  if(NGA_TYPE==1)
    {
      if(input_source==0)
	{
	  not_while_running(w,"You must select a GAIT project\n\
before you can set information mode parameters",1226,"No input source",1);
	  return;
	}
    }
  else
    {
      if(input_source==0)
	{
	  not_while_running(w,"You must select an input source data directory\n\
before you can set information mode parameters",1227,"No input source",1);
	  return;
	}
    }

  if(INFO_PARAM_WIN==0)
    {	   
      n=0;
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++; 
      
      infoparam_head = 
	XtCreatePopupShell
	("Parameters (information)",topLevelShellWidgetClass,drawing_a,resources,n);
      
      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass, infoparam_head, NULL);
      
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      
      



      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      tog = XtVaCreateManagedWidget ("the_test",
				     xmToggleButtonWidgetClass, form,
				     XmNtopAttachment,    XmATTACH_FORM,
				     XmNtraversalOn,      False,
				     XmNbottomAttachment, XmATTACH_FORM,
				     XmNalignment,        XmALIGNMENT_BEGINNING,			
				     XmNlabelString,      STRING("Geometric Type"),
				     XmNrightAttachment,  XmATTACH_POSITION,
				     XmNrightPosition,    25,
				     XmNleftAttachment,   XmATTACH_POSITION,
				     XmNleftPosition,     0,
				     TOGGLETRANSLATE,     TOGGLEINCLUDE,
				     NULL);
      XtAddCallback (tog, XmNvalueChangedCallback, info_toggles, (XtPointer)0);
      XmToggleButtonSetState(tog,(Boolean)INFO_GEOMETRY,(Boolean)0);


      if(NGA_TYPE==1)
	{
	  tog = XtVaCreateManagedWidget ("the_test",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNalignment,        XmALIGNMENT_BEGINNING,			
					 XmNlabelString,      STRING("Functional Category"),
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    50,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     25,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
	  XtAddCallback (tog, XmNvalueChangedCallback, info_toggles, (XtPointer)1);
	  XmToggleButtonSetState(tog,(Boolean)INFO_DOMAIN,(Boolean)0);
	}
      else
	{
	  tog = XtVaCreateManagedWidget ("the_test",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNalignment,        XmALIGNMENT_BEGINNING,			
					 XmNlabelString,      STRING("Domain"),
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    50,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     25,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
	  XtAddCallback (tog, XmNvalueChangedCallback, info_toggles, (XtPointer)1);
	  XmToggleButtonSetState(tog,(Boolean)INFO_DOMAIN,(Boolean)0);
	}


     tog = XtVaCreateManagedWidget ("the_test",
				     xmToggleButtonWidgetClass, form,
				     XmNtopAttachment,    XmATTACH_FORM,
				     XmNtraversalOn,      False,
				     XmNbottomAttachment, XmATTACH_FORM,
				     XmNalignment,        XmALIGNMENT_BEGINNING,			
				     XmNlabelString,      STRING("Length (meters)"),
				     XmNrightAttachment,  XmATTACH_POSITION,
				     XmNrightPosition,    75,
				     XmNleftAttachment,   XmATTACH_POSITION,
				     XmNleftPosition,     50,
				     TOGGLETRANSLATE,     TOGGLEINCLUDE,
				    NULL);
      XtAddCallback (tog, XmNvalueChangedCallback, info_toggles, (XtPointer)2);
      XmToggleButtonSetState(tog,(Boolean)INFO_LENGTH,(Boolean)0);
      
      tog = XtVaCreateManagedWidget ("the_test",
				     xmToggleButtonWidgetClass, form,
				     XmNtopAttachment,    XmATTACH_FORM,
				     XmNtraversalOn,      False,
				     XmNbottomAttachment, XmATTACH_FORM,
				     XmNalignment,        XmALIGNMENT_BEGINNING,			
				     XmNlabelString,      STRING("Area (sq. meters)"),
				     XmNrightAttachment,  XmATTACH_POSITION,
				     XmNrightPosition,    100,
				     XmNleftAttachment,   XmATTACH_POSITION,
				     XmNleftPosition,     75,
				     TOGGLETRANSLATE,     TOGGLEINCLUDE,
				     NULL);
      XtAddCallback (tog, XmNvalueChangedCallback, info_toggles, (XtPointer)3);
      XmToggleButtonSetState(tog,(Boolean)INFO_AREA,(Boolean)0);
      XtManageChild(form);








      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      if(NGA_TYPE==1)
	{
	  tog = XtVaCreateManagedWidget ("the_test",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNalignment,        XmALIGNMENT_BEGINNING,			
					 XmNlabelString,      STRING("FID"),
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    25,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     0,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
	  XtAddCallback (tog, XmNvalueChangedCallback, info_toggles, (XtPointer)4);
	  XmToggleButtonSetState(tog,(Boolean)INFO_FID,(Boolean)0);

	  tog = XtVaCreateManagedWidget ("the_test",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNalignment,        XmALIGNMENT_BEGINNING,			
					 XmNlabelString,      STRING("GFID/FLDBID/UID"),
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    50,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     25,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
	  XtAddCallback (tog, XmNvalueChangedCallback, info_toggles, (XtPointer)5);
	  XmToggleButtonSetState(tog,(Boolean)INFO_GFID,(Boolean)0);
	  
	  
	  tog = XtVaCreateManagedWidget ("the_test",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNalignment,        XmALIGNMENT_BEGINNING,			
					 XmNlabelString,      STRING("Coordinates"),
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    75,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     50,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
	  XtAddCallback (tog, XmNvalueChangedCallback, info_toggles, (XtPointer)6);
	  XmToggleButtonSetState(tog,(Boolean)INFO_COORDS,(Boolean)0);


	  tog = XtVaCreateManagedWidget ("the_test",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNalignment,        XmALIGNMENT_BEGINNING,			
					 XmNlabelString,      STRING("Number Vertices"),
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    99,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     75,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
	  XtAddCallback (tog, XmNvalueChangedCallback, info_toggles, (XtPointer)10);
	  XmToggleButtonSetState(tog,(Boolean)DRAW_VERTICES,(Boolean)0);
	}
      else
	{

	  tog = XtVaCreateManagedWidget ("the_test",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNalignment,        XmALIGNMENT_BEGINNING,			
					 XmNlabelString,      STRING("STF Object ID"),
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    25,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     0,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
	  XtAddCallback (tog, XmNvalueChangedCallback, info_toggles, (XtPointer)5);
	  XmToggleButtonSetState(tog,(Boolean)INFO_GFID,(Boolean)0);
	  
	  
	  tog = XtVaCreateManagedWidget ("the_test",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNalignment,        XmALIGNMENT_BEGINNING,			
					 XmNlabelString,      STRING("Coordinates"),
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    50,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     25,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
	  XtAddCallback (tog, XmNvalueChangedCallback, info_toggles, (XtPointer)6);
	  XmToggleButtonSetState(tog,(Boolean)INFO_COORDS,(Boolean)0);


	  tog = XtVaCreateManagedWidget ("the_test",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNalignment,        XmALIGNMENT_BEGINNING,			
					 XmNlabelString,      STRING("Number Vertices"),
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    99,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     75,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
	  XtAddCallback (tog, XmNvalueChangedCallback, info_toggles, (XtPointer)10);
	  XmToggleButtonSetState(tog,(Boolean)DRAW_VERTICES,(Boolean)0);
	}


      XtManageChild(form);





      if(NGA_TYPE==1)
	{
	  form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
				   XmNfractionBase,  100,  
				   NULL);
	  
	  tog = XtVaCreateManagedWidget ("the_test",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNalignment,        XmALIGNMENT_BEGINNING,			
					 XmNlabelString,      STRING("Attribute Labels (names)"),
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    50,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     0,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
	  XtAddCallback (tog, XmNvalueChangedCallback, info_toggles, (XtPointer)8);
	  XmToggleButtonSetState(tog,(Boolean)INFO_ATTR_LABELS,(Boolean)0);

	  tog = XtVaCreateManagedWidget ("the_test",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNalignment,        XmALIGNMENT_BEGINNING,			
					 XmNlabelString,      STRING("Attribute Value Labels"),
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    100,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     50,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
	  XtAddCallback (tog, XmNvalueChangedCallback, info_toggles, (XtPointer)9);
	  XmToggleButtonSetState(tog,(Boolean)INFO_ATTR_VALUES,(Boolean)0);
	  
	  XtManageChild(form);
	}




      if(NGA_TYPE==1)
	{
	  form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
				   XmNfractionBase,  100,  
				   NULL);
	  
	  tog = XtVaCreateManagedWidget ("the_test",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNalignment,        XmALIGNMENT_BEGINNING,			
					 XmNlabelString,      STRING("Show hexadecimal encoding for non-ASCII string values"),
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    80,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     0,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
	  XtAddCallback (tog, XmNvalueChangedCallback, info_toggles, (XtPointer)11);
	  XmToggleButtonSetState(tog,(Boolean)INFO_HEX,(Boolean)0);


	  XtManageChild(form);
	}


	  form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
				   XmNfractionBase,  100,  
				   NULL);
	  
	  tog = XtVaCreateManagedWidget ("the_test",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNalignment,        XmALIGNMENT_BEGINNING,			
					 XmNlabelString,      STRING("Show gridded data values"),
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    80,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     0,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
	  XtAddCallback (tog, XmNvalueChangedCallback, info_toggles, (XtPointer)12);
	  XmToggleButtonSetState(tog,(Boolean)INFO_GRIDVALUES,(Boolean)0);


	  XtManageChild(form);



      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      tog = XtVaCreateManagedWidget ("the_test",
				     xmToggleButtonWidgetClass, form,
				     XmNtopAttachment,    XmATTACH_FORM,
				     XmNtraversalOn,      False,
				     XmNbottomAttachment, XmATTACH_FORM,
				     XmNalignment,        XmALIGNMENT_BEGINNING,			
				     XmNlabelString,      STRING("Attributes"),
				     XmNrightAttachment,  XmATTACH_POSITION,
				     XmNrightPosition,    25,
				     XmNleftAttachment,   XmATTACH_POSITION,
				     XmNleftPosition,     0,
				     TOGGLETRANSLATE,     TOGGLEINCLUDE,
				     NULL);
      XtAddCallback (tog, XmNvalueChangedCallback, info_toggles, (XtPointer)7);
      XmToggleButtonSetState(tog,(Boolean)INFO_ATTRIBUTES,(Boolean)0);
      

      
      button = XtVaCreateManagedWidget ("Specify Attributes...",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    75,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     25,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback (button, XmNactivateCallback, SpecifyAttrsCallback , (XtPointer)NULL);      
      XtManageChild(button);

      XtManageChild(form);







      
      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget ("Zoom to individual vertices",
					xmToggleButtonWidgetClass, form,
					XmNtraversalOn,      False,
					XmNleftAttachment,   XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    50,
					XmNlabelString,      STRING("Zoom to individual vertices"),
					XmNtraversalOn,      False,
					TOGGLETRANSLATE,     TOGGLEINCLUDE,
					NULL);
      
      XtAddCallback (button, XmNvalueChangedCallback, toggled8, NULL);
      XtManageChild(button);
      
      XmToggleButtonSetState(button,(Boolean)CenterZoomOnVertices,(Boolean)0);
      
      
      button  = XtVaCreateManagedWidget("Set Vertex Zoom Pad Distance",xmPushButtonWidgetClass,form,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    50,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,   100,
					XmNlabelString,     STRING("Set Vertex Zoom Pad Distance..."),
					XmNtraversalOn,     False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
      
      XtAddCallback (button, XmNactivateCallback,
		     set_vpad_distance, (XtPointer)NULL);
      
      XtManageChild(button);
      XtManageChild(form);
      









     form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      
      
      sprintf(obs_str,"%d",VertexPrintLimit);
      
      fore_ver = XtVaCreateManagedWidget ("fore_ver",
					  xmTextFieldWidgetClass, form,	  
					  XmNvalue,            obs_str,
					  XmNtraversalOn,      True,
					  XmNrightAttachment,  XmATTACH_POSITION,
					  XmNrightPosition,    100,
					  XmNleftAttachment,   XmATTACH_POSITION,
					  XmNleftPosition,     65,
					  XmNmaxLength,8,
                      XmNtranslations,     XtParseTranslationTable ( translations_paste ) ,
					  NULL);
      XtManageChild(fore_ver);
      XtAddCallback (fore_ver, XmNactivateCallback,
		     (XtCallbackProc)fore_result, (XtPointer)23);


      button = XtVaCreateManagedWidget ("FV",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    65,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     0,
					XmNlabelString,      STRING("Maximum number of coordinates to show"),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtManageChild(button);
      XtAddCallback (button, XmNactivateCallback,
		     con_info, (XtPointer)13);      
      XtManageChild(form);



     






      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      
      
      sprintf(obs_str,"%d",DIGITS_TO_PRINT);
      
      fore_ver2 = XtVaCreateManagedWidget ("fore_ver2",
					  xmTextFieldWidgetClass, form,	  
					  XmNvalue,            obs_str,
					  XmNtraversalOn,      True,
					  XmNrightAttachment,  XmATTACH_POSITION,
					  XmNrightPosition,    100,
					  XmNleftAttachment,   XmATTACH_POSITION,
					  XmNleftPosition,     65,
					  XmNmaxLength,        3,
                      XmNtranslations,     XtParseTranslationTable ( translations_paste ) ,
					  NULL);
      XtManageChild(fore_ver2);
      XtAddCallback (fore_ver2, XmNactivateCallback,
		     (XtCallbackProc)fore_result, (XtPointer)26);


      button = XtVaCreateManagedWidget ("FV",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    65,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     0,
					XmNlabelString,      STRING("Number of decimals to show"),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtManageChild(button);
      XtAddCallback (button, XmNactivateCallback,
		     con_info, (XtPointer)14);
      XtManageChild(form);








      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget ("Help",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    50,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     0,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback (button, XmNactivateCallback, HelpInfoParamsCallback , (XtPointer)NULL);      
      XtManageChild(button);
      
      button = XtVaCreateManagedWidget ("Done",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    100,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     50,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      
      XtAddCallback(button, XmNactivateCallback, exitCallback, (XtPointer)37);
      XtManageChild(button);
      

      XtManageChild(form);
      XtManageChild (rowcol);
      MyPopup(infoparam_head); 
      XtAddCallback(infoparam_head,XmNdestroyCallback,ShellDeath,(XtPointer)307);

      XtVaGetValues (infoparam_head,  XmNheight, &y1, NULL);
      XtVaSetValues (infoparam_head,  XmNminHeight, y1, NULL);
      XtVaSetValues (infoparam_head,  XmNmaxHeight, y1, NULL);

      XtAddEventHandler(infoparam_head,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)y1));

      XtVaGetValues (infoparam_head,  XmNwidth, &y1, NULL);
      XtVaSetValues (infoparam_head,  XmNminWidth, y1, NULL);
      XtVaSetValues (infoparam_head,  XmNmaxWidth, y1, NULL);

      INFO_PARAM_WIN=1;
    }
  else
    {
      ResetWidget(infoparam_head);
    }
}





void InfoHelpCallback(Widget w,XtPointer data,XtPointer callData)
{
  not_while_running(XtParent(w),"This window is used to query features.  Features are queried (in information mode)\n\
by clicking them or drawing a box that contains all or part of them.\n\n\
Queried features are listed in the left pane of this window.  Clicking\n\
one of them displays detailed information about them in the right pane\n\
of this window, and draws them in the highlight color on the screen.\n\n\
If exactly 2 features are selected in the left pane, those features\n\
are drawn in the highlight color, and the differences in attribution\n\
between the 2 features is given in the right pane.\n\n\
If more than 2 features are selected in the left pane, those features\n\
are drawn in the highlight color, but no description is given.\n\n\
The information displayed in the right pane may be set using the\n\
\"Set params...\" button, or the \"Information Parameters...\" button\n\
under the \"Parameters\" menu.",1228,"Information Help",5);
}


char *GetFrontPart()
{
  if((ATTRTYPE_D4()))
    {
      return "GFID";
    }
  else if((ATTRTYPE_FACC()))
    {
      return "FLDBID";
    }
  else if((ATTRTYPE_MGCP3())||(ATTRTYPE_MGCP4()))
    {
      return "UID";
    }
  else if((ATTRTYPE_UFD2()))
    {
      return "GFID";
    }
  else if((ATTRTYPE_UFD1()))
    {
      return "GFID";
    }
  else if((ATTRTYPE_UFD3()))
    {
      return "GFID";
    }
  else if((ATTRTYPE_ANY_TDS()))
    {
      return "UFI";
    }
  else if((ATTRTYPE_NFDD()))
    {
      return "UFI";
    }
  else if((ATTRTYPE_DFDD()))
    {
      return "UID"; 
    }
  else if((ATTRTYPE_SAC()))
    {
      return "UUID_1";
    }
  else if((ATTRTYPE_ANY_GGDM()))
    {
      return "UFI";
    }
   else if(ATTRIBUTION_TYPE>22)
    {
      printf("Error in GFP: %d\n",ATTRIBUTION_TYPE);
      return "";
    }
   return "";
}




FILE *GetLongAttrFilePtr(int InfoOrData,int AttrType)
{
  

  FILE *retfile;
  char fname[1000];
  
  if(
     (AttrType==LONG_ATTR_ID_INFO) ||
     (AttrType==LONG_ATTR_ID)      ||
     (AttrType==START_ID)          ||
     (AttrType==STOP_ID)           ||
     (AttrType==START_CHECK_ID)    ||
     (AttrType==STOP_CHECK_ID)     ||
     (AttrType==LONG_ATTR_CHECK_ID)
     )
    {
      sprintf(fname,"%sidlookup%d.bin",indirectory,InfoOrData);
    }
  else if(
	      (AttrType==LONG_ATTR_AREA)  ||
	      (AttrType==START_AREA)      ||
		  (AttrType==STOP_AREA)       ||
		  (AttrType==START_CHECK_AREA)||
		  (AttrType==STOP_CHECK_AREA)
		 )
    {
      sprintf(fname,"%sarealookup%d.bin",indirectory,InfoOrData);
    }
  else if(
 	      (AttrType==LONG_ATTR_HGT)  ||
	      (AttrType==START_HGT)      ||
	      (AttrType==STOP_HGT)       ||
	      (AttrType==START_CHECK_HGT)||
	      (AttrType==STOP_CHECK_HGT)
	     )
    {
      sprintf(fname,"%shgtlookup%d.bin",indirectory,InfoOrData);
    }
  else if(
 	      (AttrType==LONG_ATTR_LEN)  ||
	      (AttrType==START_LEN)      ||
	      (AttrType==STOP_LEN)       ||
	      (AttrType==START_CHECK_LEN)||
	      (AttrType==STOP_CHECK_LEN)
	     )
    {
      sprintf(fname,"%slenlookup%d.bin",indirectory,InfoOrData);
    }
  else if(
 	      (AttrType==LONG_ATTR_NAM)  ||
	      (AttrType==START_NAM)      ||
	      (AttrType==STOP_NAM)       ||
	      (AttrType==START_CHECK_NAM)||
	      (AttrType==STOP_CHECK_NAM)
	     )
    {
      sprintf(fname,"%snamlookup%d.bin",indirectory,InfoOrData);
    }
  else if(
	      (AttrType==LONG_ATTR_ZV2)  ||
	      (AttrType==START_ZV2)      ||
	      (AttrType==STOP_ZV2)       ||
          (AttrType==START_CHECK_ZV2)||
	      (AttrType==STOP_CHECK_ZV2)
		 )
   {
      sprintf(fname,"%szvlookup%d.bin",indirectory,InfoOrData);
    }
  else
    {
      printf("Error-bad flag %d to GetLongAttrFilePtr\n",AttrType);
      return NULL;
    }
  
  retfile = fopen(fname,"rb");
  
  if(retfile==NULL)
    {
      if(InfoOrData==2)
	  {
        printf("Error: could not open %s but could open the 1-file\n",fname);
	  }
	  else
	  {
        printf("Error: could not open %s\n",fname);
	  }
    }


  return retfile;
}






void CacheLongAttrData(int type, FILE *infofile, FILE *datafile)
{
  int i,Ival,thisecc,thisgeom;
  extern int SPECIAL_NAME_ECC;
  extern int SPECIAL_NAME_LEN;
  extern int global_filter_cache;

  

  


  BuildLLTable(1,LLFidTableCount); 
  
  cache_types = (short int *)malloc(sizeof(short int)*LLFidTableCount);
  cache_posns = (long int *) malloc(sizeof(long int) *LLFidTableCount);
  cache_nums  = (double *)   malloc(SzD*LLFidTableCount);
  cache_chars = (char **)    malloc(sizeof(char *)*LLFidTableCount);

  if(cache_types==NULL)
  {
    printf("out of memory in CLAD1\n");
	exit(-1);
  }
  if(cache_posns==NULL)
  {
    printf("out of memory in CLAD2\n");
	exit(-1);
  }
  if(cache_nums==NULL)
  {
    printf("out of memory in CLAD3\n");
	exit(-1);
  }
  if(cache_chars==NULL)
  {
    printf("out of memory in CLAD4\n");
	exit(-1);
  }


  for(i=0;i<LLFidTableCount;i++)
    {
      SEEIT_fread_short (&cache_types[i],infofile);
      
      
      SEEIT_fread_long  (&cache_posns[i],infofile);

      cache_chars[i] = NULL;
      
      if(LLFidTable[i]<0)
	  {
	    
	  cache_types[i] = 0;
	  }

       
	  

	  if(LLFidTable[i]>=0)
	  {
	    thisecc  = SCCtable[CrsWlk[LLFidTable[i]].LtoSmapping].ECC;
	    thisgeom =          CrsWlk[LLFidTable[i]].geomtype;

		if(SPECIAL_NAME_ECC>=0) 
		{
          if(thisecc!=SPECIAL_NAME_ECC)
		  { 
		    cache_types[i] = 0;
		  } 
		}


	    if((global_filter_cache==1)||(old_long_attr_style==1))
		{

		  if(cache_types[i]>0)
		  { 
		    if(SPECIAL_NAME_LEN>0) 
			{  
              if(cache_types[i]>SPECIAL_NAME_LEN)
			  {   
		        cache_types[i] = 0;
			  }   
			}  
		  } 


	      if((global_target_ecc>=0)&&(global_target_geom>=0))
		  { 
            

	        if((thisecc!=global_target_ecc)||(thisgeom!=global_target_geom))
			{ 
		      cache_types[i] = 0;
			} 
		  } 
		} 
	  } 
  }

  for(i=0;i<LLFidTableCount;i++)
    {
      if(cache_types[i]>0)
	{
	  cache_chars[i] = (char *)malloc(cache_types[i]+3);
	  if(cache_chars[i]==NULL)
	  {
		printf("out of memory in CCi\n");
		exit(-1);
	  }
	  
      fseek(datafile,cache_posns[i],SEEK_SET);
 

	  fread(&cache_chars[i][0],cache_types[i],1,datafile);
	  cache_chars[i][cache_types[i]] = '\0';
	}
      else if(cache_types[i]==-1)
	{
      fseek(datafile,cache_posns[i],SEEK_SET);
	  SEEIT_fread_int(&Ival,datafile);
	  cache_nums[i] = Ival;
	}
      else if(cache_types[i]==-2)
	{
      fseek(datafile,cache_posns[i],SEEK_SET);
	  SEEIT_fread_double(&cache_nums[i],datafile);
	}	
    }


   

  

}


void FreeCacheVariables()
{
  int i;

  if(cache_types!=NULL)
  {
    free(cache_types);
  }
  if(cache_posns!=NULL)
  {
    free(cache_posns);
  }
  if(cache_nums!=NULL)
  {
    free(cache_nums);
  }

  if(cache_chars!=NULL)
  {
    for(i=0;i<LLFidTableCount;i++)
	{
      if(cache_chars[i]!=NULL)
	  {
        free(cache_chars[i]);
	  }
    }
    free(cache_chars);
  }

  cache_types = NULL;
  cache_posns = NULL;
  cache_nums  = NULL;
  cache_chars = NULL;

}



int GetLongAttrVal(int type,int uniqueid,int *Ival,double *Dval,char *Cval)
{
  FILE *infofile,*datafile;
  char tempval[1000];
  short int thisid;
  int retval,alreadyopen=0;
  long int seekposn,endposn;

  static int id_open=0,area_open=0,hgt_open=0,zv2_open=0,len_open=0,nam_open=0;


  


  
  sprintf(Cval,"Error");
  *Ival = -123456;
  *Dval = -123456;

  if(formatting==1)
  {
	
    if(type==LONG_ATTR_AREA)
	{
	  type = LONG_ATTR_CHECK_AREA;
	}
    else if(type==LONG_ATTR_HGT)
	{
	  type = LONG_ATTR_CHECK_HGT;
	}
    else if(type==LONG_ATTR_LEN)
	{
	  type = LONG_ATTR_CHECK_LEN;
	}
    else if(type==LONG_ATTR_NAM)
	{
	  type = LONG_ATTR_CHECK_NAM;
	}
    else if(type==LONG_ATTR_ZV2)
	{
	  type = LONG_ATTR_CHECK_ZV2;
	}
  }


  if(type==STOP_CHECK_ID)
    {
      if(save_idinfo==NULL)
	{
	  printf("Error, save_idinfo already NULL\n");
	}
      else
	{
	  fclose(save_idinfo);
	}
      
      if(save_iddata==NULL)
	{
	  printf("Error, save_iddata already NULL\n");
	}
      else
	{
	  fclose(save_iddata);
	}
      save_idinfo = NULL;
      save_iddata = NULL;
      id_open     = 0;

      return NOTYPE;
    }
  else if(type==STOP_CHECK_HGT)
    {
      if(save_hgtinfo==NULL)
	{
	  printf("Error, save_hgtinfo already NULL\n");
	}
      else
	{
	  fclose(save_hgtinfo);
	}
      
      if(save_hgtdata==NULL)
	{
	  printf("Error, save_hgtdata already NULL\n");
	}
      else
	{
	  fclose(save_hgtdata);
	}

      save_hgtinfo = NULL;
      save_hgtdata = NULL;
      hgt_open     = 0;

      return NOTYPE;
    }
  else if(type==STOP_CHECK_LEN)
    {
      if(save_leninfo==NULL)
	{
	  printf("Error, save_leninfo already NULL\n");
	}
      else
	{
	  fclose(save_leninfo);
	}
      
      if(save_lendata==NULL)
	{
	  printf("Error, save_lendata already NULL\n");
	}
      else
	{
	  fclose(save_lendata);
	}

      save_leninfo = NULL;
      save_lendata = NULL;
      len_open     = 0;

      return NOTYPE;
    }
  else if(type==STOP_CHECK_NAM)
    {
      if(save_naminfo==NULL)
	{
	  printf("Error, save_naminfo already NULL\n");
	}
      else
	{
	  fclose(save_naminfo);
	}
      
      if(save_namdata==NULL)
	{
	  printf("Error, save_namdata already NULL\n");
	}
      else
	{
	  fclose(save_namdata);
	}

      save_naminfo = NULL;
      save_namdata = NULL;
      nam_open     = 0;

      return NOTYPE;
    }
  else if(type==STOP_CHECK_ZV2)
    {
      if(save_zv2info==NULL)
	{
	  printf("Error, save_zv2info already NULL\n");
	}
      else
	{
	  fclose(save_zv2info);
	}
      
      if(save_zv2data==NULL)
	{
	  printf("Error, save_zv2data already NULL\n");
	}
      else
	{
	  fclose(save_zv2data);
	}
      save_zv2info = NULL;
      save_zv2data = NULL;
      zv2_open     = 0;

      return NOTYPE;
    }
  else if(type==STOP_CHECK_AREA)
    {
      if(save_areainfo==NULL)
	{
	  printf("Error, save_areainfo already NULL\n");
	}
      else
	{
	  fclose(save_areainfo);
	}
      
      if(save_areadata==NULL)
	{
	  printf("Error, save_areadata already NULL\n");
	}
      else
	{
	  fclose(save_areadata);
	}
      save_areainfo = NULL;
      save_areadata = NULL;
      area_open     = 0;

      return NOTYPE;
    }
  else if(type==STOP_ID)
    {
      if(save_idinfo==NULL)
	{
	  printf("Error, save_idinfo already NULL\n");
	}
      else
	{
	  fclose(save_idinfo);
	}
      
      if(save_iddata==NULL)
	{
	  printf("Error, save_iddata already NULL\n");
	}
      else
	{
	  fclose(save_iddata);
	}
      save_idinfo = NULL;
      save_iddata = NULL;
      id_open     = 0;

      FreeCacheVariables();
      return NOTYPE;
    }
  else if(type==STOP_AREA)
    {
      if(save_areainfo==NULL)
	{
	  printf("Error, save_area already NULL\n");
	}
      else
	{
	  fclose(save_areainfo);
	}
      
      if(save_areadata==NULL)
	{
	  printf("Error, save_areadata already NULL\n");
	}
      else
	{
	  fclose(save_areadata);
	}
      save_areainfo = NULL;
      save_areadata = NULL;
      area_open     = 0;
      FreeCacheVariables();
      return NOTYPE;
    }
  else if(type==STOP_HGT)
    {
      if(save_hgtinfo==NULL)
	{
	  printf("Error, save_hgt already NULL\n");
	}
      else
	{
	  fclose(save_hgtinfo);
	}
      
      if(save_hgtdata==NULL)
	{
	  printf("Error, save_hgtdata already NULL\n");
	}
      else
	{
	  fclose(save_hgtdata);
	}

      save_hgtinfo = NULL;
      save_hgtdata = NULL;
      hgt_open     = 0;
      FreeCacheVariables();
      return NOTYPE;
    }
  else if(type==STOP_LEN)
    {
      if(save_leninfo==NULL)
	{
	  printf("Error, save_len already NULL\n");
	}
      else
	{
	  fclose(save_leninfo);
	}
      
      if(save_lendata==NULL)
	{
	  printf("Error, save_lendata already NULL\n");
	}
      else
	{
	  fclose(save_lendata);
	}

      save_leninfo = NULL;
      save_lendata = NULL;
      len_open     = 0;
      FreeCacheVariables();
      return NOTYPE;
    }
  else if(type==STOP_NAM)
    {
      if(save_naminfo==NULL)
	{
	  printf("Error, save_nam already NULL\n");
	}
      else
	{
	  fclose(save_naminfo);
	}
      
      if(save_namdata==NULL)
	{
	  printf("Error, save_namdata already NULL\n");
	}
      else
	{
	  fclose(save_namdata);
	}

      save_naminfo = NULL;
      save_namdata = NULL;
      nam_open     = 0;
      FreeCacheVariables();
      return NOTYPE;
    }
  else if(type==STOP_ZV2)
    {
      if(save_zv2info==NULL)
	{
	  printf("Error, save_zv2 already NULL\n");
	}
      else
	{
	  fclose(save_zv2info);
	}
      
      if(save_zv2data==NULL)
	{
	  printf("Error, save_zv2data already NULL\n");
	}
      else
	{
	  fclose(save_zv2data);
	}
      save_zv2info = NULL;
      save_zv2data = NULL;
      zv2_open     = 0;
      FreeCacheVariables();
      return NOTYPE;
    }



  if(
     (id_open==1)&&
     ((type==LONG_ATTR_ID_INFO)||(type==LONG_ATTR_ID)||(type==LONG_ATTR_CHECK_ID))
     )
    {
      alreadyopen = 1;
    }
  

  if((area_open==1)&&((type==LONG_ATTR_AREA) || (type==LONG_ATTR_CHECK_AREA)))
    {
      alreadyopen = 1;
    }
  if((hgt_open==1)&&((type==LONG_ATTR_HGT) || (type==LONG_ATTR_CHECK_HGT)))
    {
      alreadyopen = 1;
    }
  if((len_open==1)&&((type==LONG_ATTR_LEN) || (type==LONG_ATTR_CHECK_LEN)))
    {
      alreadyopen = 1;
    }
  if((nam_open==1)&&((type==LONG_ATTR_NAM) || (type==LONG_ATTR_CHECK_NAM)))
    {
      alreadyopen = 1;
    }
  if((zv2_open==1)&&((type==LONG_ATTR_ZV2) || (type==LONG_ATTR_CHECK_ZV2)))
    {
      alreadyopen = 1;
    }
 

  
  if(uniqueid<0)
    {
      printf("Error: GetLongAttrVal called with uniqueid %d\n",uniqueid);
      return NOTYPE;
    }
  
  
  if((NGA_TYPE==1)                     &&
     (HAS_ID[ATTRIBUTION_TYPE]==0)     &&
     ((type==LONG_ATTR_ID)||(type==LONG_ATTR_ID_INFO)||(type==LONG_ATTR_CHECK_ID))
     )
    {
      
      sprintf(Cval," "); 
      return C_TYPE;
    }
  
  if(alreadyopen==0)
    {      
      infofile = GetLongAttrFilePtr(1,type);

      if(infofile==NULL)
	  {
	   return NOTYPE;
	  } 

      datafile = GetLongAttrFilePtr(2,type);

      if(datafile==NULL)
	  { 
	   fclose(infofile);
 	   return NOTYPE;
	  } 

    }
  else
    {

      if((type==LONG_ATTR_ID_INFO)||(type==LONG_ATTR_ID)||(type==LONG_ATTR_CHECK_ID))
	{
	  infofile = save_idinfo;
	  datafile = save_iddata;
	}
      else if((type==LONG_ATTR_HGT) || (type==LONG_ATTR_CHECK_HGT))
	{
	  infofile = save_hgtinfo;
	  datafile = save_hgtdata;
	}
      else if((type==LONG_ATTR_LEN) || (type==LONG_ATTR_CHECK_LEN))
	{
	  infofile = save_leninfo;
	  datafile = save_lendata;
	}
      else if((type==LONG_ATTR_NAM) || (type==LONG_ATTR_CHECK_NAM))
	{
	  infofile = save_naminfo;
	  datafile = save_namdata;
	}
      else if((type==LONG_ATTR_AREA) || (type==LONG_ATTR_CHECK_AREA))
	{
	  infofile = save_areainfo;
	  datafile = save_areadata;
	}
      else if((type==LONG_ATTR_ZV2) || (type==LONG_ATTR_CHECK_ZV2))
	{
	  infofile = save_zv2info;
	  datafile = save_zv2data;
	}
    }
  
  if(type==START_CHECK_ID)
    {
      
      id_open       = 1;
      save_idinfo   = infofile;
      save_iddata   = datafile;
      return NOTYPE;
    }
  else if(type==START_CHECK_HGT)
    {
      
      hgt_open       = 1;
      save_hgtinfo   = infofile;
      save_hgtdata   = datafile;
      return NOTYPE;
    }
  else if(type==START_CHECK_LEN)
    {
      
      len_open       = 1;
      save_leninfo   = infofile;
      save_lendata   = datafile;
      return NOTYPE;
    }
  else if(type==START_CHECK_NAM)
    {
      
      nam_open       = 1;
      save_naminfo   = infofile;
      save_namdata   = datafile;
      return NOTYPE;
    }
  else if(type==START_CHECK_ZV2)
    {
      
      zv2_open       = 1;
      save_zv2info   = infofile;
      save_zv2data   = datafile;
      return NOTYPE;
    }
  else if(type==START_CHECK_AREA)
    {
      
      area_open       = 1;
      save_areainfo   = infofile;
      save_areadata   = datafile;
      return NOTYPE;
    }
  else if(type==START_ID)
    {
      id_open       = 1;
      save_idinfo   = infofile;
      save_iddata   = datafile;
      CacheLongAttrData(type,infofile,datafile);
      return NOTYPE;
    }
  else if(type==START_HGT)
    {
      hgt_open      = 1;
      save_hgtinfo  = infofile;
      save_hgtdata  = datafile;
      CacheLongAttrData(type,infofile,datafile);
      return NOTYPE;
    }
  else if(type==START_LEN)
    {
      len_open      = 1;
      save_leninfo  = infofile;
      save_lendata  = datafile;
      CacheLongAttrData(type,infofile,datafile);
      return NOTYPE;
    }
  else if(type==START_NAM)
    {
      nam_open      = 1;
      save_naminfo  = infofile;
      save_namdata  = datafile;
      CacheLongAttrData(type,infofile,datafile);
      return NOTYPE;
    }
  else if(type==START_AREA)
    {
      area_open     = 1;
      save_areainfo = infofile;
      save_areadata = datafile;
      CacheLongAttrData(type,infofile,datafile);
      return NOTYPE;
    }
  else if(type==START_ZV2)
    {
      zv2_open      = 1;
      save_zv2info  = infofile;
      save_zv2data  = datafile;
      CacheLongAttrData(type,infofile,datafile);
      return NOTYPE;
    }



  

  if( 
	  (alreadyopen==0)               ||
	  (type==LONG_ATTR_CHECK_ID)     || 
	  (type == LONG_ATTR_CHECK_AREA) || 
	  (type == LONG_ATTR_CHECK_HGT)  ||
	  (type == LONG_ATTR_CHECK_LEN)  ||
	  (type == LONG_ATTR_CHECK_NAM)  ||
      (type == LONG_ATTR_CHECK_ZV2)
	  )
    {
      

      seekposn = (uniqueid) * (sizeof(short int)+SzL);  

      fseek(infofile,0,SEEK_END);
      endposn = ftell(infofile);
           
      if(seekposn>=endposn)
	{
	  printf("error: tried to read past end of file for long attr %d %d %d\n",type,(int)seekposn,(int)endposn);
	  fclose(infofile);
	  fclose(datafile);
	  return NOTYPE;
	}
      
      fseek(infofile,seekposn,SEEK_SET);
      
            
      SEEIT_fread_short (&thisid,infofile);

    }
  else
    {

      thisid = cache_types[uniqueid];


      if(thisid==0)
	{
	  return NOTYPE;
	}
      else if(thisid>0)
	{	  
	  if(type==LONG_ATTR_ID_INFO)
	    {
	      
	      sprintf(Cval,"%s: %s\n",GetFrontPart(),cache_chars[uniqueid]);
	    }
	  else
	    {
	      sprintf(Cval,"%s",cache_chars[uniqueid]);
	    }

	  if(free_global_char_type==1)  
	  {
	   free(cache_chars[uniqueid]);
	   cache_chars[uniqueid] = NULL;
	  }
	  return C_TYPE;
	}
      else if(thisid==-1)
	{
	  *Ival = (int)cache_nums[uniqueid];
	  return I_TYPE;
	}
      else if(thisid==-2)
	{
	  *Dval = cache_nums[uniqueid];
	  return D_TYPE;
	}      
      else
	{
	  printf("error in GLAV: got bad id %d for %d\n",thisid,uniqueid);
	  return NOTYPE;
	}
    }
  


  


  if(thisid==0)
    {
      retval = NOTYPE;
    }
  else
    {
      SEEIT_fread_long  (&seekposn,infofile);
      fseek(datafile,seekposn,SEEK_SET);
    }
  
  if(thisid>0)
    {
      fread(&tempval[0],thisid,1,datafile);
      tempval[thisid] = '\0';
      
      if(type==LONG_ATTR_ID_INFO)
	  {
	    
	    sprintf(Cval,"%s: %s\n",GetFrontPart(),tempval);
	  }
      else
	  { 
	    sprintf(Cval,"%s",tempval);
	  }
      retval = C_TYPE;
    }
  else if(thisid==-1)
    {
      SEEIT_fread_int(Ival,datafile);
      retval = I_TYPE;
    }
  else if(thisid==-2)
    {
      SEEIT_fread_double(Dval,datafile);
      retval = D_TYPE;
    }


  if(alreadyopen==0)
    {
      
      fclose(infofile);
      fclose(datafile);
    }

  return retval;
}








int IsMetadata(char *attr_code)
{
  int i;
  extern char *MetaLeft    [num_meta];
  extern char *MetaLeftMGCP[num_MGCP_meta];
  extern char *MetaLeftTDS [num_TDS_meta];

  if((ATTRTYPE_NFDD()))
    {
      return 0;
    }
  if((ATTRTYPE_DFDD()))
    {
      return 0;
    }
  if((ATTRTYPE_SAC()))
    {
      return 0;
    }
  if((ATTRTYPE_ANY_GGDM()))
    {
      return 0;
    }

  if((ATTRTYPE_MGCP3())||(ATTRTYPE_MGCP4()))
    {
      for(i=0;i<num_MGCP_meta;i++)
	{
	  if(!strcmp(MetaLeftMGCP[i],attr_code))
	    {
	      return 1;
	    }	    
	}
    }
  else if(
	  (ATTRTYPE_ANY_TDS())
	  )
    {
      for(i=0;i<num_TDS_meta;i++)
	{
	  if(!strcmp(MetaLeftTDS[i],attr_code))
	    {
	      return 1;
	    }
	}
    }
  else
    {
      for(i=0;i<num_meta;i++)
	{
	  if(!strcmp(MetaLeft[i],attr_code))
	    {
	      return 1;
	    }
	}
    }
  return 0;
}


int ArrangeMetadata(struct AStrings SortAttrs[],int p,int r)
{
  int i,j;
  struct AStrings temp;

  if(p>=r)  
  {
    return p;
  }

  i = p-1;
  j = r+1;
  while(1)
  {
    do{j=j-1;  if(j<=p)break;}
    while(IsMetadata(SortAttrs[j].code)==1);

    do{i=i+1;  if(i>=r)break;}
    while(IsMetadata(SortAttrs[i].code)==0);

    if(i<j)
	{
      temp = SortAttrs[i];
	  SortAttrs[i] = SortAttrs[j];
	  SortAttrs[j] = temp;
	}
    else
	{
      return j;
	}
  }
}



int PartitionAttributes(struct AStrings SortAttrs[], int p,int r)
{
  char x[500];
  int i,j;
  struct AStrings temp;

  sprintf(x,"%s",SortAttrs[p].code);
  i = p-1;
  j = r+1;
  while(1)
    {
      do{j=j-1;}
      while(strcmp(SortAttrs[j].code,x)>0);

      do{i=i+1;}
      while(strcmp(SortAttrs[i].code,x)<0);
    
      if(i<j)
	  {
	   temp = SortAttrs[i];
	   SortAttrs[i] = SortAttrs[j];
	   SortAttrs[j] = temp;
	  }
      else
	  {
	  return j;
	  }
    }
}



void SortAttributes(struct AStrings SortAttrs[],int p,int r)
{
  int q;
 
  

  if(p<r)
   {
     q = PartitionAttributes(SortAttrs,p,r);
     SortAttributes(SortAttrs,p,q);
     SortAttributes(SortAttrs,q+1,r);
   }

}


char *GetLongCode (int attr_type)
{
       if(((ATTRTYPE_D4()))  &&(attr_type==LONG_ATTR_AREA)){return "ARE_";}
  else if(((ATTRTYPE_FACC()))  &&(attr_type==LONG_ATTR_AREA)){return "ARE" ;}
  else if(((ATTRTYPE_VMAP()))  &&(attr_type==LONG_ATTR_AREA)){return "ARA" ;}
  else if(((ATTRTYPE_MGCP3()) ||(ATTRTYPE_MGCP4()))  &&(attr_type==LONG_ATTR_AREA)){return "ARA" ;}
  else if(((ATTRTYPE_ANY_TDS())) &&(attr_type==LONG_ATTR_AREA)){return "ARA" ;}
  else if(((ATTRTYPE_NFDD())) &&(attr_type==LONG_ATTR_AREA)){return "ARA" ;}
  else if(((ATTRTYPE_DFDD())) &&(attr_type==LONG_ATTR_AREA)){return "ARA" ;}
  else if(((ATTRTYPE_SAC())) &&(attr_type==LONG_ATTR_AREA)){return "ARA" ;}
  else if(((ATTRTYPE_ANY_GGDM())) &&(attr_type==LONG_ATTR_AREA)){return "ARA" ;}
       


  else if(((ATTRTYPE_D4())) &&(attr_type==LONG_ATTR_HGT)){return "HGT"  ;}
  else if(((ATTRTYPE_FACC())) &&(attr_type==LONG_ATTR_HGT)){return "HGT"  ;}
  else if(((ATTRTYPE_VMAP())) &&(attr_type==LONG_ATTR_HGT)){return "HGT"  ;}
  else if(((ATTRTYPE_MGCP3())) &&(attr_type==LONG_ATTR_HGT)){return "HGT"  ;}
  else if(((ATTRTYPE_MGCP4())) &&(attr_type==LONG_ATTR_HGT)){return "HGT"  ;}
  else if(((ATTRTYPE_UFD2()))&&(attr_type==LONG_ATTR_HGT)){return "HGT"  ;}
  else if(((ATTRTYPE_UFD1()))&&(attr_type==LONG_ATTR_HGT)){return "HGT"  ;}
  else if(((ATTRTYPE_UFD3()))&&(attr_type==LONG_ATTR_HGT)){return "HGT"  ;}
  else if(((ATTRTYPE_ANY_TDS())) &&(attr_type==LONG_ATTR_HGT)){return "HGT"  ;}
  else if(((ATTRTYPE_NFDD()))&&(attr_type==LONG_ATTR_HGT)){return "HGT"  ;}
  else if(((ATTRTYPE_DFDD()))&&(attr_type==LONG_ATTR_HGT)){return "HGT"  ;}
  else if(((ATTRTYPE_SAC()))&&(attr_type==LONG_ATTR_HGT)){return "HGT"  ;}
  else if(((ATTRTYPE_ANY_GGDM()))&&(attr_type==LONG_ATTR_HGT)){return "HGT"  ;}



  else if(((ATTRTYPE_D4())) &&(attr_type==LONG_ATTR_LEN)){return "LEN_"  ;}
  else if(((ATTRTYPE_FACC())) &&(attr_type==LONG_ATTR_LEN)){return "LEN"  ;}
  else if(((ATTRTYPE_VMAP())) &&(attr_type==LONG_ATTR_LEN)){return "LEN"  ;}
  else if(((ATTRTYPE_MGCP3())) &&(attr_type==LONG_ATTR_LEN)){return "LEN"  ;}
  else if(((ATTRTYPE_MGCP4())) &&(attr_type==LONG_ATTR_LEN)){return "LEN"  ;}
  else if(((ATTRTYPE_UFD2()))&&(attr_type==LONG_ATTR_LEN)){return "LEN"  ;}
  else if(((ATTRTYPE_UFD1()))&&(attr_type==LONG_ATTR_LEN)){return "LEN"  ;}
  else if(((ATTRTYPE_UFD3()))&&(attr_type==LONG_ATTR_LEN)){return "LEN"  ;}
  else if(((ATTRTYPE_ANY_TDS())) &&(attr_type==LONG_ATTR_LEN)){return "LZN"  ;}
  else if(((ATTRTYPE_NFDD()))&&(attr_type==LONG_ATTR_LEN)){return "LZN"  ;}
  else if(((ATTRTYPE_DFDD()))&&(attr_type==LONG_ATTR_LEN)){return "LEN"  ;}
  else if(((ATTRTYPE_SAC()))&&(attr_type==LONG_ATTR_LEN)){return "LEN"  ;}
  else if(((ATTRTYPE_ANY_GGDM()))&&(attr_type==LONG_ATTR_LEN)){return "LZN"  ;}


  else if(((ATTRTYPE_D4())) &&(attr_type==LONG_ATTR_NAM)){return "NAM"  ;}
  else if(((ATTRTYPE_FACC())) &&(attr_type==LONG_ATTR_NAM)){return "NAM"  ;}
  else if(((ATTRTYPE_VMAP())) &&(attr_type==LONG_ATTR_NAM)){return "NAM"  ;}
  else if(((ATTRTYPE_MGCP3())) &&(attr_type==LONG_ATTR_NAM)){return "NAM"  ;}
  else if(((ATTRTYPE_MGCP4())) &&(attr_type==LONG_ATTR_NAM)){return "NAM"  ;}
  else if(((ATTRTYPE_UFD2()))&&(attr_type==LONG_ATTR_NAM)){return "NAM"  ;}
  else if(((ATTRTYPE_UFD1()))&&(attr_type==LONG_ATTR_NAM)){return "NAM"  ;}
  else if(((ATTRTYPE_UFD3()))&&(attr_type==LONG_ATTR_NAM)){return "NAM"  ;}
  else if(((ATTRTYPE_ANY_TDS())) &&(attr_type==LONG_ATTR_NAM)){return "ZI005_FNA"  ;}
  else if(((ATTRTYPE_DFDD()))&&(attr_type==LONG_ATTR_NAM)){return "NAM"  ;}
  else if(((ATTRTYPE_ANY_GGDM()))&&(attr_type==LONG_ATTR_NAM)){return "ZI005_FNA"  ;}
       


  else if(((ATTRTYPE_D4())) &&(attr_type==LONG_ATTR_ZV2)){return "ZV2"  ;}
  else if(((ATTRTYPE_FACC())) &&(attr_type==LONG_ATTR_ZV2)){return "ZV2"  ;}
  else if(((ATTRTYPE_VMAP())) &&(attr_type==LONG_ATTR_ZV2)){return "ZV2"  ;}
         
  else if(((ATTRTYPE_UFD2()))&&(attr_type==LONG_ATTR_ZV2)){return "ZV2"  ;}
  else if(((ATTRTYPE_UFD1()))&&(attr_type==LONG_ATTR_ZV2)){return "ZV2"  ;}
  else if(((ATTRTYPE_UFD3()))&&(attr_type==LONG_ATTR_ZV2)){return "ZV2"  ;}
  else if(((ATTRTYPE_ANY_TDS()))&&(attr_type==LONG_ATTR_ZV2)){return "ZVH"  ;}
  else if(((ATTRTYPE_NFDD()))&&(attr_type==LONG_ATTR_ZV2)){return "ZVH"  ;}
  else if(((ATTRTYPE_DFDD()))&&(attr_type==LONG_ATTR_ZV2)){return "ZVH"  ;}
  else if(((ATTRTYPE_SAC()))&&(attr_type==LONG_ATTR_ZV2)){return "ZV7"  ;}
  else if(((ATTRTYPE_ANY_GGDM()))&&(attr_type==LONG_ATTR_ZV2)){return "ZVH"  ;}
 

  else if(((ATTRTYPE_D4()))  &&(attr_type==LONG_ATTR_ID)){return "GFID"  ;}
  else if(((ATTRTYPE_FACC()))  &&(attr_type==LONG_ATTR_ID)){return "FLDBID";}
  else if(((ATTRTYPE_MGCP3()) ||(ATTRTYPE_MGCP4()))  &&(attr_type==LONG_ATTR_ID)){return "UID"   ;}
  else if(((ATTRTYPE_UFD2())) &&(attr_type==LONG_ATTR_ID)){return "GFID"  ;}
  else if(((ATTRTYPE_UFD1())) &&(attr_type==LONG_ATTR_ID)){return "GFID"  ;}
  else if(((ATTRTYPE_UFD3())) &&(attr_type==LONG_ATTR_ID)){return "GFID"  ;}
  else if(((ATTRTYPE_ANY_TDS())) &&(attr_type==LONG_ATTR_ID)){return "UFI"   ;}
  else if(((ATTRTYPE_NFDD())) &&(attr_type==LONG_ATTR_ID)){return "UFI"   ;}
  else if(((ATTRTYPE_DFDD())) &&(attr_type==LONG_ATTR_ID)){return "UID"   ;}
  else if(((ATTRTYPE_SAC())) &&(attr_type==LONG_ATTR_ID)){return "UUID_1"   ;}
  else if(((ATTRTYPE_ANY_GGDM())) &&(attr_type==LONG_ATTR_ID)){return "UFI"   ;}
  else
  {
    printf("failed to find attr_code for %d\n",attr_type);
    return "Error--See Console";
  }
}


char *GetLongLabel (int attr_type)
{
  return GetEACLabel(SilentGetAttrIndex(GetLongCode(attr_type)));
}


void AddLongInfoAttribute(struct InfoPrintContent *newentry,int valtype,int attrtype,
						  char *Cval,int Ival,double Dval)
{
  int lastindex;

  newentry->numattr = newentry->numattr + 1;
  lastindex = newentry->numattr-1;

  newentry->A = (struct AStrings *) realloc(newentry->A,sizeof(struct AStrings) * newentry->numattr);


  newentry->A[lastindex].code  = (char *)malloc(100);
  newentry->A[lastindex].Label = (char *)malloc(100);

  sprintf(newentry->A[lastindex].code ,"%s", GetLongCode (attrtype));
  sprintf(newentry->A[lastindex].Label,"%s", GetLongLabel(attrtype));
  newentry->A[lastindex].valueLabel = NULL;
  newentry->A[lastindex].SEDRISxtra = NULL;

  if(valtype==C_TYPE)
  {
   newentry->A[lastindex].value = (char *)malloc(strlen(Cval)+10);
   sprintf(newentry->A[lastindex].value,"\"%s\"",Cval);
  }
  else if(valtype==I_TYPE)
  {
   newentry->A[lastindex].value = (char *)malloc(50);
   sprintf(newentry->A[lastindex].value,"%d",Ival);
  }
  else if(valtype==D_TYPE)
  {
   newentry->A[lastindex].value = (char *)malloc(50);
   sprintf(newentry->A[lastindex].value,"%lf",Dval);
  }

}




int AddInfoEntry(int uniqueid, int addtail)
{
  char Cval[1000];
  int totalobjs=0,i,badvalue,Ival,attr_type,index,valtype,c1,c2;
  double Dval;
  struct InfoPrintContent *newentry, *tempentry;
  extern struct InfoPrintContent IPC;


  totalobjs = 0;

  newentry = (struct InfoPrintContent *) malloc(sizeof(struct InfoPrintContent));  

  newentry->ECC        = IPC.ECC;
  newentry->geom       = IPC.geom;
  newentry->radius     = IPC.radius;
  newentry->FID        = IPC.FID;
  newentry->ishole     = IPC.ishole;
  newentry->numcoords  = IPC.numcoords;
  newentry->numattr    = IPC.numattr;
  newentry->length     = IPC.length;
  newentry->area       = IPC.area;
  newentry->domain     = IPC.domain;
  newentry->X          = (double *) malloc (SzD * (IPC.numcoords+1));
  newentry->Y          = (double *) malloc (SzD * (IPC.numcoords+1));
  newentry->Z          = (double *) malloc (SzD * (IPC.numcoords+1));
  newentry->ID2str     = NULL;
  newentry->numholes   = IPC.numholes;
  newentry->innerings  = IPC.innerings;
  newentry->longindex  = IPC.longindex;


  

  if((IPC.geom==C_AREA)||(IPC.geom==C_LINE))
  {
	newentry->X[IPC.numcoords] = 0.0;
    
    for(c1=0;c1<IPC.numcoords;c1++)
	{ 
	  c2 = c1 - 1;

	  if(c2<0)
	   {
		 c2 = IPC.numcoords - 1;
	   }

	  if(IPC.geom==C_LINE)
	   {
		 c2 = c1 + 1;
		 if(c2>=IPC.numcoords)
		  {
			break;
		  }
	   }

       newentry->X[IPC.numcoords] = newentry->X[IPC.numcoords] + 
		   Distance3D(
		   IPC.X[c1],IPC.Y[c1],IPC.Z[c1],
		   IPC.X[c2],IPC.Y[c2],IPC.Z[c2]);
	}  
  } 
 

  IPC.innerings        = NULL;  

  if(IPC.geom!=C_GRID)
    {      
      attr_type = GetLongAttrVal(LONG_ATTR_ID_INFO,uniqueid,&Ival,&Dval,&Cval[0]);
      
      if(attr_type!=C_TYPE)
	  { 
	    printf("Error 1 getting ID.  Expected %d got %d\n",C_TYPE,attr_type);
	    sprintf(Cval,"Error - See Console\n");
	  } 
      
      newentry->IDstr      = (char *) malloc (strlen(Cval)+25);
      sprintf(newentry->IDstr,"%s",Cval);
  }
  else
  {
    newentry->IDstr      = (char *) malloc (25);
    sprintf(newentry->IDstr," ");
  }


  if(newentry->numcoords>0)
    {      
      for(i=0; i<newentry->numcoords; i++)
	  {
	    newentry->X[i] = IPC.X[i]; 
	    newentry->Y[i] = IPC.Y[i]; 
	    newentry->Z[i] = IPC.Z[i]; 
	  }
    }  

  
  
  if(newentry->numattr>0)
    {
      newentry->A = (struct AStrings *) malloc (sizeof(struct AStrings)*newentry->numattr);
      
      for(i=0; i<newentry->numattr; i++)
	  {
	  
	   if(IPC.A[i].Label!=NULL)
	    {
	      if(IPC.A[i].Label[0] == '*') {badvalue = 1;} else {badvalue = 0;}

	      newentry->A[i].Label = (char *) malloc (strlen(IPC.A[i].Label)+5);
	      sprintf(newentry->A[i].Label,"%s",IPC.A[i].Label);
	    }
	   else
	    {
	      newentry->A[i].Label = NULL;
	    }


	   if(IPC.A[i].valueLabel!=NULL)
	    {
	      newentry->A[i].valueLabel = (char *) malloc (strlen(IPC.A[i].valueLabel)+5);
	      sprintf(newentry->A[i].valueLabel,"%s",IPC.A[i].valueLabel);
	    }
	   else
	    {
	      newentry->A[i].valueLabel = NULL;
	    }
	  

	   if(badvalue==1)
	    {
          if(!strcmp(IPC.A[i].Label,"*Polygon Flag"))
		  {
            newentry->ID2str = (char *)malloc(strlen(newentry->A[i].valueLabel)+5);
			sprintf(newentry->ID2str,"%s",newentry->A[i].valueLabel);
		  }

	      newentry->A[i].code       = (char *)malloc(5);
          newentry->A[i].code[0]    = 0; 
	      newentry->A[i].value      = NULL;
	      newentry->A[i].SEDRISxtra = NULL;
	      continue;
	    }



	   if(IPC.A[i].code!=NULL)
	    {
	      newentry->A[i].code = (char *) malloc (strlen(IPC.A[i].code)+5);
	      sprintf(newentry->A[i].code,"%s",IPC.A[i].code);
	    }
	   else
	    {
	      newentry->A[i].code = NULL;
	    }
	  
	  
	   if(IPC.A[i].value!=NULL)
	    {
	      newentry->A[i].value = (char *) malloc (strlen(IPC.A[i].value)+5);
	      sprintf(newentry->A[i].value,"%s",IPC.A[i].value);
	    }
	   else
	    {
	      newentry->A[i].value = NULL;
	    }
	  	  
	  
	   if(IPC.A[i].SEDRISxtra!=NULL)
	    {
	      newentry->A[i].SEDRISxtra = (char *) malloc (strlen(IPC.A[i].SEDRISxtra)+5);
	      sprintf(newentry->A[i].SEDRISxtra,"%s",IPC.A[i].SEDRISxtra);
	    }
	   else
	    {
	      newentry->A[i].SEDRISxtra = NULL;
	    }
	  }
    }
  else
    {
      newentry->A = NULL;
    }
  
  newentry->next = NULL;
  
  




  


  if(IPC.geom!=C_GRID)
    {      

      valtype = GetLongAttrVal(LONG_ATTR_AREA,uniqueid,&Ival,&Dval,&Cval[0]);
      
      if(valtype!=NOTYPE)
	  {
	   AddLongInfoAttribute(newentry,valtype,LONG_ATTR_AREA,Cval,Ival,Dval);
	  }
      
      
      valtype = GetLongAttrVal(LONG_ATTR_HGT,uniqueid,&Ival,&Dval,&Cval[0]);
      
      if(valtype!=NOTYPE)
	  { 
	   AddLongInfoAttribute(newentry,valtype,LONG_ATTR_HGT,Cval,Ival,Dval);
	  } 
      
      

      valtype = GetLongAttrVal(LONG_ATTR_ZV2,uniqueid,&Ival,&Dval,&Cval[0]);
      
      if(valtype!=NOTYPE)
	  { 
	   AddLongInfoAttribute(newentry,valtype,LONG_ATTR_ZV2,Cval,Ival,Dval);
	  } 


      valtype = GetLongAttrVal(LONG_ATTR_LEN,uniqueid,&Ival,&Dval,&Cval[0]);
      
      if(valtype!=NOTYPE)
	  { 
	   AddLongInfoAttribute(newentry,valtype,LONG_ATTR_LEN,Cval,Ival,Dval);
	  } 


      valtype = GetLongAttrVal(LONG_ATTR_NAM,uniqueid,&Ival,&Dval,&Cval[0]);
      
      if(valtype!=NOTYPE)
	  { 
	   AddLongInfoAttribute(newentry,valtype,LONG_ATTR_NAM,Cval,Ival,Dval);
	  } 


    }

  

  

  if(NGA_TYPE==1)
  {
    index = ArrangeMetadata(newentry->A,0,newentry->numattr-1);
    SortAttributes (newentry->A,0,index);
    SortAttributes (newentry->A,index+1,newentry->numattr-1);
  }


  
  
  
  
  
  if(InfoRoot==NULL)
    {
      InfoRoot = newentry;
      return 1;
    }
  


   
  totalobjs++;  
  tempentry = InfoRoot;
  totalobjs++;  
  
  while(tempentry->next!=NULL)
    {
      tempentry = tempentry->next;
      totalobjs++;
    }


  if(addtail==1)
  {
    tempentry->next = newentry;
  }
  else
  {
    
    newentry->next = InfoRoot;
    InfoRoot = newentry;
  }


  
  return totalobjs;

}






char *GetShortGeomName(int geom)
{
  switch(geom)
    {
    case C_NONE:
      printf("Got geom C_NONE\n");
      return "";
    case C_AREA:
      return "AREA";
    case C_DILI:
      return "D LINE";
    case C_FOMO:
      return "FOOTPRINT MODEL";
    case C_LINE:
      return "LINE";
    case C_POFE:
      return "POINT";
    case C_POMO:
      return "POINT MODEL";
    case C_POLY:
      return "POLYGON";
    case C_DYMO:
      return "DYNAMIC MODEL";
    case C_GRID:
      return "GRID";
    case C_COVS:
      return "COLL VOL (S)";
    case C_COVP:
      return "COLL VOL (P)";
    case C_MOLI:
      return "MODEL LIB POLY";
    case C_FMPF:
      return "FM POINT";
    case C_FMLF:
      return "FM LINE";
    case C_FMAF:
      return "FM AREA";
    default:
      printf("Unknown geom to GetShortGeomName %d\n",geom);
      return "";
    }
  return "";
}








void get_info_coord(Widget w,XtPointer data,XmTextVerifyCallbackStruct *callData)
{
  int i,clickedvert=0;
  int position = (int)callData->newInsert;
  char *selected = XmTextGetSelection(w);
  static int LOCALBUSY = 0;

  


  if(LOCALBUSY==1)
    {
      
      return;
    }


  LOCALBUSY = 1;


  if(selected==NULL)
    {
      
      
      
      for(i=0;i<GLOBAL_SAVE_COORDS;i++)
	{
	  if(
	     (position>=GLOBAL_SAVE_COORDS_start[i]) &&
	     (position<=GLOBAL_SAVE_COORDS_end[i])
	     )
	    {
	      SPECIAL_VERTEX = i;
	      UnderlineSpecialVertex();
		  clickedvert = 1;
	      break;
	    }
	}
      
      
      
      
      if(clickedvert==1)
	  {
        choose_specific_info((Widget)NULL,(XtPointer)4,(XtPointer)4);
	  }

      
    }
  else
    {
      
    }
  
  LOCALBUSY = 0;
}


void HTMLCallback(Widget w,XtPointer data,XtPointer callData)
{
  char command[1000];
  long int ThisTime;
  static long int LastTime=-999;


  ThisTime = time(NULL);
  
  if((ThisTime-LastTime)<=1) 
  {
    return;
  }

  LastTime = ThisTime;


  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
  {
    
    sprintf(command,"start \"tt\" \"%sinternal_data\\queryresults.htm\"",indirectory);
  }
  else
  {
    
    sprintf(command,"\"%sinternal_data/queryresults.htm\"",indirectory);
  }

  system(command);

}

void NewInfoPrint(int uniqueid)
{
  
  
  
  Widget form,rowcol,button;
  Arg args[25];
  int n=0,i,left,right;
  XmString *blank_list,*selectlist;
  int pos_count;
  int *pos_list;
  int totalobjs,totalrealobjs,foundit,j;
  struct InfoPrintContent *thisobj;
  int minnum=30;
  char temp[100];
  extern struct InfoPrintContent IPC;

  
  InfoItemsQueried = InfoItemsQueried + 1;
  if(InfoItemsQueried>100)
    {
      DO_DESCRIBE = 0;
      return;
    }

 


  

  DRAWING_INFO_ITEM = 1;
  DrawInfoItem(&IPC);
  DRAWING_INFO_ITEM = 0;
  



  if(info_window_up==0)
    {
      n=0;

      XtSetArg(args[n],  XmNwidth,     700);            n++;  
      XtSetArg(args[n],  XmNdeleteResponse, XmDESTROY); n++;
      
      infohead = XtCreatePopupShell("Information",
				    topLevelShellWidgetClass,sw,args,n);
      
      
      
      
      rowcol = XtVaCreateManagedWidget
	(
	 "XformWidget", xmPanedWindowWidgetClass, infohead,
	 XmNrubberPositioning, False,
	 XmNresizable,         True,
	 XmNseparatorOn,       False,
	 XmNsashHeight,        1,
	 NULL
	 );



      

      totalobjs = AddInfoEntry(uniqueid,0);
      
      if(totalobjs<minnum)
	{
	  totalobjs = minnum;
	}


      blank_list = (XmString *) (malloc(sizeof(XmString *) * totalobjs));
      if(blank_list==NULL){printf("bl6: out of allocation memory!\n"); ExitWrapper(-1);}
      

      
      totalobjs = 0;
      
      if(InfoRoot!=NULL)
	{
	  thisobj = InfoRoot;
	  
	  while(thisobj != NULL)
	    {

		  if(   
			  ((thisobj->ishole==1)||(thisobj->ishole==4)) &&
			  (thisobj->geom==C_AREA)
			  )
		  {
	       if(NGA_TYPE==1)
		   {
		     sprintf(temp,"%s CUT-OUT",GetECCCode(thisobj->ECC));
		   }
	      else
			{
		     sprintf(temp,"%s CUT-OUT",GetECCLabel(thisobj->ECC));
			}
		  }
		  else
		  {
	       if(NGA_TYPE==1)
		   {
             if(thisobj->geom==C_GRID)
			 {
		       sprintf(temp,"%s",GetECCLabel(0));
			 }
			 else
			 {
		       sprintf(temp,"%s %s",GetECCCode(thisobj->ECC),GetShortGeomName(thisobj->geom));
			 }
		   }
	      else
			{
		     sprintf(temp,"%s %s",GetECCLabel(thisobj->ECC),GetShortGeomName(thisobj->geom));
			}
		  }
		  

	      blank_list[totalobjs] = XmStringCreateLocalized (temp);
	      totalobjs = totalobjs + 1;
	      thisobj = thisobj->next;
	    }	 
	}



      

      if(totalobjs<minnum)
	{
	  for(i=totalobjs;i<minnum;i++)
	    {
	      blank_list[i] = XmStringCreateLocalized ("        ");
	    }
	  totalobjs = minnum;
	}

      


      form = XtVaCreateWidget ("form3", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);

      n = 0;
      XtSetArg(args[n], XmNitemCount, totalobjs);                n++;
      XtSetArg(args[n], XmNvisibleItemCount, minnum);            n++;
      XtSetArg(args[n], XmNitems,            blank_list);        n++;
      XtSetArg(args[n], XmNselectionPolicy,  XmEXTENDED_SELECT); n++;
      XtSetArg(args[n], XmNleftAttachment,   XmATTACH_FORM);     n++;
      XtSetArg(args[n], XmNrightAttachment,  XmATTACH_POSITION); n++;
      XtSetArg(args[n], XmNrightPosition,    25);                n++;
      XtSetArg(args[n], XmNtopAttachment,    XmATTACH_FORM);     n++;
      XtSetArg(args[n], XmNbottomAttachment, XmATTACH_FORM);     n++;
      
      XtSetArg(args[n], XmNtranslations, XtParseTranslationTable (list_translations));  n++;




      info_list = XmCreateScrolledList (form, "Info list", args,n);
	      
      XtManageChild (info_list);

      XtAddCallback (info_list, XmNextendedSelectionCallback, choose_specific_info, (XtPointer) 2);

      


      n = 0;
      XtSetArg(args[n], XmNscrollBarDisplayPolicy,  XmSTATIC);            n++;
      XtSetArg(args[n], XmNrows,                    minnum);              n++;
      XtSetArg(args[n], XmNleftAttachment,          XmATTACH_WIDGET);     n++;
      XtSetArg(args[n], XmNleftWidget,              info_list);           n++;
      XtSetArg(args[n], XmNrightAttachment,         XmATTACH_FORM);       n++;
      XtSetArg(args[n], XmNtopAttachment,           XmATTACH_FORM);       n++;
      XtSetArg(args[n], XmNbottomAttachment,        XmATTACH_FORM);       n++;
      XtSetArg(args[n], XmNcolumns,                 30);                  n++;
      XtSetArg(args[n], XmNeditable,                False);               n++;
      XtSetArg(args[n], XmNeditMode,                XmMULTI_LINE_EDIT);   n++;
      XtSetArg(args[n], XmNscrollHorizontal,        False);               n++;
      XtSetArg(args[n], XmNwordWrap,                True);                n++;
      XtSetArg(args[n], XmNcursorPositionVisible,   False);               n++;
      XtSetArg(args[n], XmNtraversalOn,             False);               n++;
      XtSetArg(args[n], XmNtranslations, XtParseTranslationTable (list_translations2));  n++;

      info_text_area = XmCreateScrolledText(form, "info_text_area", args, n);
      XtManageChild (info_text_area);

      XtManageChild(form);



      
      XtVaGetValues(info_list                ,XmNverticalScrollBar,&vert_scroll[INFO_LEFT_SCROLL ] ,NULL);

      
      XtVaGetValues(XtParent(info_text_area) ,XmNverticalScrollBar,&vert_scroll[INFO_RIGHT_SCROLL],NULL);


      XtAddCallback (info_text_area, XmNmotionVerifyCallback, (XtCallbackProc)get_info_coord, (XtPointer)NULL);




      for(i=0;i<totalobjs;i++)
	{
	  XmStringFree(blank_list[i]);
	}
      free(blank_list);




      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,  25,
			       XmNpaneMaximum,  25,
			       XmNfractionBase, 100,  
			       XmNtraversalOn,  False,
			       NULL);
      

	  if(USE_DOS==1)
	  {
        left  = 1;
		right = 25;
	  }
	  else
	  {
        left  = 1;
		right = 33;
	  }

      button = XtVaCreateManagedWidget("Help",xmPushButtonWidgetClass,form,
				       XmNlabelString,     STRING("Set params..."),
				       XmNorientation,     XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    left,
				       XmNrightAttachment, XmATTACH_POSITION,
				       XmNrightPosition,   right,
				       XmNtraversalOn,     False,
				       XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      
      XtAddCallback(button, XmNactivateCallback,InfoParamsCallback, (XtPointer)NULL);
      XtManageChild(button);
      

	  if(USE_DOS==1)
	  {
        left  = 25;
		right = 50;
	  }
	  else
	  {
        left  = 33;
		right = 66;
	  }

      button = XtVaCreateManagedWidget("Help",xmPushButtonWidgetClass,form,
				       XmNlabelString,     STRING("Help"),
				       XmNorientation,     XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    left,
				       XmNrightAttachment, XmATTACH_POSITION,
				       XmNrightPosition,   right,
				       XmNtraversalOn,     False,
				       XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 

      XtAddCallback(button, XmNactivateCallback,InfoHelpCallback, (XtPointer)NULL);
      XtManageChild(button);


	  if(USE_DOS==1)
	  {
        html_button = XtVaCreateManagedWidget("Help",xmPushButtonWidgetClass,form,
				       XmNlabelString,     STRING("Show as HTML"),
				       XmNorientation,     XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    50,
				       XmNrightAttachment, XmATTACH_POSITION,
				       XmNrightPosition,   75,
				       XmNtraversalOn,     False,
				       XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      
        XtAddCallback(html_button, XmNactivateCallback,HTMLCallback, (XtPointer)NULL);
        XtManageChild(html_button);
        XtSetSensitive(html_button,False);

	  }


	  if(USE_DOS==1)
	  {
        left  = 75;
	  }
	  else
	  {
        left  = 66;
	  }


      button = XtVaCreateManagedWidget("Done",xmPushButtonWidgetClass,form,
				       XmNlabelString,     STRING("Done"),
				       XmNorientation,     XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    left,
				       XmNrightAttachment, XmATTACH_POSITION,
				       XmNrightPosition,   99,
				       XmNtraversalOn,     False,
				       XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 

      XtAddCallback(button, XmNactivateCallback,exitCallback, (XtPointer)36);
      XtManageChild(button);
      XtManageChild(form);
      XtManageChild(rowcol);
      MyPopup(infohead);
      XtAddCallback(infohead,XmNdestroyCallback,ShellDeath,(XtPointer)306);

      info_window_up = 1;
      
      XtVaSetValues (infohead, XmNminHeight,  100, NULL);
      XtVaSetValues (infohead, XmNminWidth,   100, NULL);

      



      
      XmListSelectPos(info_list,1,0);
    }
  else
    {

      


      

      XmListGetSelectedPos(info_list,&pos_list,&pos_count);



      totalobjs = AddInfoEntry(uniqueid,0);
      
      if(totalobjs<minnum)
	{
	  totalobjs = minnum;
	}


      blank_list = (XmString *) (malloc(sizeof(XmString *) * totalobjs));
      if(blank_list==NULL){printf("bl6: out of allocation memory!\n"); ExitWrapper(-1);}



      totalobjs = 0;

      if(InfoRoot!=NULL)
	{
	  thisobj = InfoRoot;

	  while(thisobj != NULL)
	    {

		  if(   
			  ((thisobj->ishole==1)||(thisobj->ishole==4)) &&
			  (thisobj->geom==C_AREA)
			 )
		  {
	       if(NGA_TYPE==1)
		   {
		     sprintf(temp,"%s CUT-OUT",GetECCCode(thisobj->ECC));
		   }
	      else
			{
		     sprintf(temp,"%s CUT-OUT",GetECCLabel(thisobj->ECC));
			}
		  }
		  else
		  {
	        if(NGA_TYPE==1)
			{
              if(thisobj->geom==C_GRID)
			  { 
                sprintf(temp,"%s",GetECCLabel(0));
			  } 
			  else
			  {
                sprintf(temp,"%s %s",GetECCCode(thisobj->ECC),GetShortGeomName(thisobj->geom));
			  } 
			} 
	        else
			{
			  sprintf(temp,"%s %s",GetECCLabel(thisobj->ECC),GetShortGeomName(thisobj->geom));
			} 
		  } 
		  
	      blank_list[totalobjs] = XmStringCreateLocalized (temp);
	      totalobjs = totalobjs + 1;
	      thisobj = thisobj->next;
	    }	 
	}
      

      totalrealobjs = totalobjs;
      
      if(totalobjs<minnum)
	{
	  for(i=totalobjs;i<minnum;i++)
	    {
	      blank_list[i] = XmStringCreateLocalized ("        ");
	    }
	  totalobjs = minnum;
	}



      XmListDeleteAllItems(info_list); 
      XmListAddItems(info_list,blank_list,totalobjs,1);



      


      

      XtVaGetValues(info_list,XmNitems,&selectlist,NULL);

      XtVaSetValues(info_list,
		    XmNselectedItemCount,totalobjs,
		    XmNselectedItems    ,selectlist,
		    NULL);




      
      
      for(i=totalrealobjs+1;i<=totalobjs;i++)
	{
	  XmListDeselectPos(info_list,i);
	}



      


	  

      for(i=   2  ;i<=(totalrealobjs    );i++)
	{
	  foundit = 0;
	  for(j=0;j<pos_count;j++)
	    {
	      if( (pos_list[j]+1) ==i)  
		{
		  foundit = 1;
		  break;
		}
	    }

	  if(foundit==0)
	    {
	      
	      XmListDeselectPos(info_list,i);
	    }
	}


      for(i=0;i<totalobjs;i++)
	{
	  XmStringFree(blank_list[i]);
	}
      free(blank_list);


      
 
	  
	  




     
    }
}





void list_scroll_spec(Widget widget, XEvent *event, String *args, int *num_args)
{
  int updown,widindex;
  



  sscanf(args[0],"%d",&updown);




  XtVaGetValues(widget  ,XmNverticalScrollBar,&vert_scroll[SPECIAL_SCROLL] ,NULL);
  widindex = SPECIAL_SCROLL;




  if(vert_scroll[widindex]==NULL)
    {
      printf("NULL widget %d: aborting attempt to use mouse wheel\n",widindex);
      return;
    }
  
  XtVaGetValues(vert_scroll[widindex],
		XmNminimum,      &global_scroll_min,
		XmNmaximum,      &global_scroll_max,
		XmNvalue,        &global_scroll_value,
		XmNsliderSize,   &global_scroll_slide_size,
		XmNincrement,    &global_scroll_increment,
		XmNpageIncrement,&global_scroll_pg_increment,
		NULL);
  
  
  if(updown==1)
    {
      global_scroll_increment = global_scroll_increment * -1;
    }


  global_scroll_value = global_scroll_value+global_scroll_increment;
  
  if(global_scroll_value>global_scroll_max-global_scroll_slide_size)
    {
      global_scroll_value = global_scroll_max-global_scroll_slide_size;
    }
  else if(global_scroll_value<global_scroll_min)
    {
      global_scroll_value = global_scroll_min;
    }
  
 if(global_scroll_increment<0)
  {
	global_scroll_increment = global_scroll_increment * -1;
  }

  XmScrollBarSetValues(vert_scroll[widindex],
		       global_scroll_value,
		       global_scroll_slide_size,
		       global_scroll_increment,
		       global_scroll_pg_increment,
		       1);

}


void SetQACRButtons()
{
  char filename[1000];


  if(input_source==0)
  {
    XtSetSensitive(QACR_button,False);
  }
  else
  {

    if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{ 
	  XtSetSensitive(QACR_button,True);



	  sprintf(filename,"%sQACR_files\\NGA_QACR.doc",indirectory);
	
	  if(FileExists(filename))
	  {
	    XtSetSensitive(NGAQACR_button,True);
	  }
	  else
	  {
	    XtSetSensitive(NGAQACR_button,False);
	  }
	



	  sprintf(filename,"%sQACR_files\\MGCP_QACR.doc",indirectory);
	
	  if(FileExists(filename))
	  {
	    XtSetSensitive(MGCPQACR_button,True);
	  }
	  else
	  {
	    XtSetSensitive(MGCPQACR_button,False);
	  }



	  sprintf(filename,"%ssummary_files\\projectsummary.txt",indirectory);
	
	  if(FileExists(filename))
	  {
	    XtSetSensitive(PROJSUMM_button,True);
	  }
	  else
	  {
	    XtSetSensitive(PROJSUMM_button,False);
	  }


	  sprintf(filename,"%ssummary_files\\checksummary.txt",indirectory);
	
	  if(FileExists(filename))
	  {
	    XtSetSensitive(CHECKSUMM_button,True);
	  }
	  else
	  {
	    XtSetSensitive(CHECKSUMM_button,False);
	  }




	}
    else
      {
	XtSetSensitive(QACR_button,True);
	
	sprintf(filename,"%sQACR_files/NGA_QACR.doc",indirectory);
	
	if(FileExists(filename))
	  {
	    XtSetSensitive(NGAQACR_button,True);
	  }
	else
	  {
	    XtSetSensitive(NGAQACR_button,False);
	  }
	
	sprintf(filename,"%sQACR_files/MGCP_QACR.doc",indirectory);
	
	if(FileExists(filename))
	  {
	    XtSetSensitive(MGCPQACR_button,True);
	  }
	else
	  {
	    XtSetSensitive(MGCPQACR_button,False);
	  }


	  sprintf(filename,"%ssummary_files/projectsummary.txt",indirectory);
	
	  if(FileExists(filename))
	  {
	    XtSetSensitive(PROJSUMM_button,True);
	  }
	  else
	  {
	    XtSetSensitive(PROJSUMM_button,False);
	  }


	  sprintf(filename,"%ssummary_files/checksummary.txt",indirectory);
	
	  if(FileExists(filename))
	  {
	    XtSetSensitive(CHECKSUMM_button,True);
	  }
	  else
	  {
	    XtSetSensitive(CHECKSUMM_button,False);
	  }






	} 


  }
}



void MakeSen(Widget widget, XEvent *event, String *args, int *num_args)
{
  

  int total = 0;
  int i;
  extern void SetNumNets(int num);



  SetQACRButtons();


  if(NOT_ZOOMED==1)
    {
      XtSetSensitive(modes[1],False);
    }
  else
    {
      XtSetSensitive(modes[1],True);
    }


  for(i=1;i<=CONDITION_DEFINITIONS;i++)
    {      
      total = total + ErrorLookup[i].number;
    }

  for(i=1;i<=CLONE_DEFINITIONS;i++)
    {
      total = total + CloneErrorLookup[i-1].number;
    }


  if(total==0)
    {
      XtSetSensitive(shapewid, False);
      XtSetSensitive(condwid1,False);
      XtSetSensitive(condwid2,False);
    }
  else
    {
      XtSetSensitive(shapewid,True);
      XtSetSensitive(condwid1,True);
      XtSetSensitive(condwid2,True);
    }


  if(NumNetsLoaded>0)
    {
      XtSetSensitive(netwid,1);
    }
  else
    {
      XtSetSensitive(netwid,0);
    }
}




void list_scroll(Widget widget, XEvent *event, String *args, int *num_args)
{
  XmString *selectlist;
  char *text;
  int totalobjs;
  int updown,widindex;


  


  


  sscanf(args[0],"%d",&updown);
  sscanf(args[1],"%d",&widindex);



  if(updown==5)
    {
      


      if((widindex!=0)&&(widindex!=1))
	{
	  XBell(mydisplay,50);
	  printf("got bad updown %d with widindex 5\n",widindex);
	  printf("aborting attempt to use left/right arrows in info vertex mode\n");
	  return;
	}


      

      XtVaGetValues(info_list,
		    XmNselectedItemCount,&totalobjs,
		    XmNselectedItems    ,&selectlist,
		    NULL);
      

      if((INFO_COORDS==1)&&(totalobjs==1))
	{
	  XmStringGetLtoR(selectlist[0],
			  (XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);

	  if(strncmp(text,"     ",5)) 
	    {
	      if(widindex==0)
		{
		  

		  if( (SPECIAL_VERTEX==-1) || (SPECIAL_VERTEX==0) )
		    {
		      
		      SPECIAL_VERTEX = GLOBAL_SAVE_COORDS-1;
		    }
		  else if(SPECIAL_VERTEX>=1)
		    {
		      SPECIAL_VERTEX = SPECIAL_VERTEX - 1;
		    }
		}
	      else if(widindex==1)
		{
		  

		  if(SPECIAL_VERTEX<(GLOBAL_SAVE_COORDS-1))
		    {
		      
		      SPECIAL_VERTEX = SPECIAL_VERTEX + 1;
		    }
		  else
		    {
		      
		      SPECIAL_VERTEX = 0;
		    }
		}


          

          choose_specific_info((Widget)NULL,(XtPointer)4,(XtPointer)4);

	    }
	}
      return;
    }

  if((updown<0)&&(widindex<0))
    {
      printf("Detected click of mouse wheel.  Ignoring.\n");
      return;
    }
  
  

  if(vert_scroll[widindex]==NULL)
    {
      printf("NULL widget %d: aborting attempt to use mouse wheel (a)\n",widindex);
      return;
    }


  XtVaGetValues(vert_scroll[widindex],
		XmNminimum,      &global_scroll_min,
		XmNmaximum,      &global_scroll_max,
		XmNvalue,        &global_scroll_value,
		XmNsliderSize,   &global_scroll_slide_size,
		XmNincrement,    &global_scroll_increment,
		XmNpageIncrement,&global_scroll_pg_increment,
		NULL);
  
	  

	  if(
		  (widindex==CHOOSEPROJ_SCROLL)   ||
		  (widindex==CHOOSESHAPE_SCROLL)  ||
		  (widindex==CHOOSE_ES1_SCROLL)   ||
		  (widindex==CHOOSE_ES2_SCROLL)   ||
		  (widindex==CHOOSE_TXT_SCROLL)	  ||
		  (widindex==CHOOSE_XML1_SCROLL)  ||
		  (widindex==CHOOSE_XML2_SCROLL)  ||
		  (widindex==CHOOSE_XML3_SCROLL)  ||
		  (widindex==CHOOSEATTR_SCROLL)   ||
		  (widindex==CHOOSE_DP_SCROLL)    ||
		  (widindex==CHOOSEBROWSE_SCROLL)
		  )
	  {
	    global_scroll_increment = 20;
	  }
	  if(
		  (widindex==EXE_SCROLL)      ||
		  (widindex==NET_SCROLL)      ||
		  (widindex==CONDITION_SCROLL)||
		  (widindex==BO_SCROLL)       ||
		  (widindex==NETWORK_SCROLL)
		)
	  {
	    global_scroll_increment = 30;
	  }
      

  if(updown==1)
    {
      global_scroll_increment = global_scroll_increment * -1;
    }


  global_scroll_value = global_scroll_value+global_scroll_increment;
  
  if(global_scroll_value>(global_scroll_max-global_scroll_slide_size))
    {
      global_scroll_value = global_scroll_max-global_scroll_slide_size;
    }
  else if(global_scroll_value<global_scroll_min)
    {
      global_scroll_value = global_scroll_min;
    }
  
  if(global_scroll_increment<0)
  {
	global_scroll_increment = global_scroll_increment * -1;
  }


  XmScrollBarSetValues(vert_scroll[widindex],
		       global_scroll_value,
		       global_scroll_slide_size,
		       global_scroll_increment,
		       global_scroll_pg_increment,
		       1);

}





void list_scroll_bo(Widget widget, XEvent *event, String *args, int *num_args)
{
  int updown,boindex,errnum,instance;


  sscanf(args[0],"%d",&updown);
  sscanf(args[1],"%d",&boindex);
  sscanf(args[2],"%d",&errnum);
  sscanf(args[3],"%d",&instance);
 

  if((updown<0)&&(boindex<0))
  {
    printf("Detected click of mouse wheel.  Ignoring.\n");
    return;
  }


  if(vert_scroll_bo[boindex][errnum][instance]==NULL)
    {
      printf("NULL widget %d %d %d: aborting attempt to use mouse wheel\n",boindex,errnum,instance);
      return;
    }
  
  XtVaGetValues(vert_scroll_bo[boindex][errnum][instance],
		XmNminimum,      &global_scroll_min,
		XmNmaximum,      &global_scroll_max,
		XmNvalue,        &global_scroll_value,
		XmNsliderSize,   &global_scroll_slide_size,
		XmNincrement,    &global_scroll_increment,
		XmNpageIncrement,&global_scroll_pg_increment,
		NULL);
  
  
  if(updown==1)
    {
      global_scroll_increment = global_scroll_increment * -1;
    }


  global_scroll_value = global_scroll_value+global_scroll_increment;
  
  if(global_scroll_value>(global_scroll_max-global_scroll_slide_size))
    {
      global_scroll_value = global_scroll_max-global_scroll_slide_size;
    }
  else if(global_scroll_value<global_scroll_min)
    {
      global_scroll_value = global_scroll_min;
    }
  
  if(global_scroll_increment<0)
  {
	global_scroll_increment = global_scroll_increment * -1;
  }

  XmScrollBarSetValues(vert_scroll_bo[boindex][errnum][instance],
		       global_scroll_value,
		       global_scroll_slide_size,
		       global_scroll_increment,
		       global_scroll_pg_increment,
		       1);

}




void RetainError(Widget widget, XEvent *event, String *args, int *num_args)
{
  int errnum,cloneindex,onoff,itemCount;
  
  sscanf(args[0],"%d",&onoff);
  sscanf(args[1],"%d",&errnum);
  sscanf(args[2],"%d",&cloneindex);

  XtVaGetValues(widget,XmNselectedItemCount,&itemCount,NULL);

  if(itemCount<1)
    {
      printf("too few items selected to use shortcut\n");
      return;
    }

  SetSelected(errnum,cloneindex,onoff);

}


void SetUpProfileLayers(int type)
{
  int i;
  extern int *profiling_layers;

  

  for(i=0;i<NumLODbands;i++)
  {
	if(type==1)
	{
	  if((profiling_layers[i]==100)&&(LODindex[i].active==1))
	  {
        
	    LODindex[i].active = 0;
	    profiling_layers[i] = 102;
	  } 
	  if((profiling_layers[i]==101)&&(LODindex[i].active==0))
	  {
        
	    LODindex[i].active = 1;
	    profiling_layers[i] = 103;
	  }
	}
	else if(type==2)
	{
	  if((profiling_layers[i]==102)&&(LODindex[i].active==0))
	  {
        
	    LODindex[i].active = 1;
	    profiling_layers[i] = 100;
	  }  
	  if((profiling_layers[i]==103)&&(LODindex[i].active==1))
	  {
        
	    LODindex[i].active = 0;
	    profiling_layers[i] = 101;
	  }
	}
  }
}



void list_scroll_vc(Widget widget, XEvent *event, String *args, int *num_args)
{
  Widget modwid;
  int updown,errindex,cloneindex;


  sscanf(args[0],"%d",&updown);
  sscanf(args[1],"%d",&errindex);
  sscanf(args[2],"%d",&cloneindex);


  if((updown<0)&&(errindex<0))
  {
    printf("Detected click of mouse wheel.  Ignoring.\n");
    return;
  }

  if(errindex>=0)
  {
    modwid = ErrorLookup[errindex].vertwid;
  }
  else
  {
    modwid = CloneErrorLookup[cloneindex].vertwid;
  }

  if(modwid==NULL)
  {
      printf("NULL widget %d %d %d: aborting attempt to use mouse wheel\n",updown,errindex,cloneindex);
      return;
    }
  
   XtVaGetValues(modwid,
		XmNminimum,      &global_scroll_min,
		XmNmaximum,      &global_scroll_max,
		XmNvalue,        &global_scroll_value,
		XmNsliderSize,   &global_scroll_slide_size,
		XmNincrement,    &global_scroll_increment,
		XmNpageIncrement,&global_scroll_pg_increment,
		NULL);
  
  
  if(updown==1)
    {
      global_scroll_increment = global_scroll_increment * -1;
    }


  global_scroll_value = global_scroll_value+global_scroll_increment;
  
  if(global_scroll_value>(global_scroll_max-global_scroll_slide_size))
    {
      global_scroll_value = global_scroll_max-global_scroll_slide_size;
    }
  else if(global_scroll_value<global_scroll_min)
    {
      global_scroll_value = global_scroll_min;
    }
  
  if(global_scroll_increment<0)
  {
	global_scroll_increment = global_scroll_increment * -1;
  }

  XmScrollBarSetValues(modwid,
		       global_scroll_value,
		       global_scroll_slide_size,
		       global_scroll_increment,
		       global_scroll_pg_increment,
		       1);

}





void list_scroll_net(Widget widget, XEvent *event, String *args, int *num_args)
{
  Widget modwid;
  int updown,errindex,cloneindex;


  sscanf(args[0],"%d",&updown);
  sscanf(args[1],"%d",&errindex);
  sscanf(args[2],"%d",&cloneindex);


  if((updown<0)&&(errindex<0))
  {
    printf("Detected click of mouse wheel.  Ignoring.\n");
    return;
  }

  if(errindex>=0)
  {
    modwid = ErrorLookup[errindex].vertwidNET;
  }
  else
  {
    modwid = CloneErrorLookup[cloneindex].vertwidNET;
  }

  if(modwid==NULL)
  {
      printf("NULL widget %d %d %d: aborting attempt to use mouse wheel (1)\n",updown,errindex,cloneindex);
      return;
    }
  
   XtVaGetValues(modwid,
		XmNminimum,      &global_scroll_min,
		XmNmaximum,      &global_scroll_max,
		XmNvalue,        &global_scroll_value,
		XmNsliderSize,   &global_scroll_slide_size,
		XmNincrement,    &global_scroll_increment,
		XmNpageIncrement,&global_scroll_pg_increment,
		NULL);
  
  
  if(updown==1)
    {
      global_scroll_increment = global_scroll_increment * -1;
    }


  global_scroll_value = global_scroll_value+global_scroll_increment;
  
  if(global_scroll_value>(global_scroll_max-global_scroll_slide_size))
    {
      global_scroll_value = global_scroll_max-global_scroll_slide_size;
    }
  else if(global_scroll_value<global_scroll_min)
    {
      global_scroll_value = global_scroll_min;
    }
  
  if(global_scroll_increment<0)
  {
	global_scroll_increment = global_scroll_increment * -1;
  }

  XmScrollBarSetValues(modwid,
		       global_scroll_value,
		       global_scroll_slide_size,
		       global_scroll_increment,
		       global_scroll_pg_increment,
		       1);

}


void SpecialSetRetIgn(int errnum, int instance, int condnum, int retainign)
{
  printf("errnum %d instance %d cond %d set to %d\n",errnum,instance,condnum,retainign);
}


void HighlightIgnoreCallback(Widget w,XtPointer data,XtPointer callData)
{
  int i = (int)data;

  SpecialSetRetIgn(HIGH_ERRNUM[i],HIGH_INSTANCE[i],HIGH_CONDNUM[i],0);
}

void HighlightRetainCallback(Widget w,XtPointer data,XtPointer callData)
{
  int i = (int)data;

  SpecialSetRetIgn(HIGH_ERRNUM[i],HIGH_INSTANCE[i],HIGH_CONDNUM[i],1);
}



void HighlightCallback(Widget w,XtPointer data,XtPointer callData)
{
  int index = (int)data,cloneindex,outlen,i,saveset,possset;
  char scrubout[2000];
  int ConditionFlags[CONDITION_ARRAY_SIZE];
  struct ConditionList * NEW_LIST=NULL;
  struct AdditionalConditions * AdditionalConditionFlags=NULL;
  extern int PossibleToPopInfoWin;


  if(index==0)
    {
      
      return;
    }
  
  

  for(i=1;i<=CONDITION_DEFINITIONS;i++)
    {
      ConditionFlags[i] = 0;
    }    
  
  
  if(rec_instance[index]>0)
    {
      cloneindex = GetCloneIndex(rec_instance[index],rec_errnum[index]);
    }
  else
    {
      cloneindex = -1;
    }
  
  sprintf(scrubout,"%s",outdirectory);
  outlen = strlen(scrubout);
  scrubout[outlen-1] = '\0';
  
  SEEIT_LoadConditionReport(scrubout);
  
  if(cloneindex >= 0)
    {
      
      
      SEEIT_AddAdditionalFlag(&AdditionalConditionFlags,
			      CloneErrorLookup[cloneindex].CloneNumber, 
			      GetCloneNumber(cloneindex,CloneErrorLookup[cloneindex].CloneNumber)
			      );	  
    }
  else
    {
      ConditionFlags[rec_errnum[index]] = 1;
    }
  
  ABORT_ZOOM = 0;
  
  NEW_LIST =
    SEEIT_GetConditions(scrubout,
			ConditionFlags,
			rec_condnum[index],  
			rec_condnum[index],  
			AdditionalConditionFlags, 
			1,        
			0,        
			0,        
			NULL,
			-1
			);
  
  
  if(NEW_LIST==NULL)
    {
      XBell(mydisplay,50);
      printf("(2) serious error: NEW_LIST NULL\n");
      return;
    }
  
  
  saveset = DetailedInfo;
  possset = PossibleToPopInfoWin;

  DetailedInfo = 1;
  PossibleToPopInfoWin = 1;

  not_while_running(drawing_a,NEW_LIST->Message,-2,ParseErrType(NEW_LIST->CONDITION_TYPE),5);

  DetailedInfo = saveset;
  PossibleToPopInfoWin = possset;
  
  SEEIT_FreeConditions(NEW_LIST);
  SEEIT_FreeAdditionalFlags(AdditionalConditionFlags);
  AdditionalConditionFlags = NULL;
  SEEIT_FreeConditionReportMemory();
}


int AlreadyFound(int errnum,int instance,int condnum,int indexer)
{
  int i;

  for(i=1;i<indexer;i++) 
    {
      if(
	 (HIGH_ERRNUM[i]  ==errnum)   &&
	 (HIGH_INSTANCE[i]==instance) &&
	 (HIGH_CONDNUM[i] ==condnum)
	 )
	{
	  return 1;
	}
    }

  return 0;
}


char *GetRetainIgnoreString(int errnum, int instance, int num)
{
  int cloneindex;

  if(instance>0)
    {
      cloneindex = GetCloneIndex(instance,errnum);
      
      if(CloneErrorLookup[cloneindex].keepdismiss[num]==1)
	{
	  return "(currently RETAINED)";
	}
      return "(currently IGNORED)";
    }
  else
    {
      if(ErrorLookup[errnum].keepdismiss[num]==1)
	{
	  return "(currently RETAINED)";
	}
      
      return "(currently IGNORED)";
    }
  
  XBell(mydisplay,50);
  printf("could not find retain/ignore value for errnum %d instance %d num %d\n",
	 errnum,instance,num);
  return "";
}


char *GetFirstLine(int errnum, int instance)
{
  static char retstring[2000];
  int cloneindex;
  
  if(instance>0)
    {
      cloneindex = GetCloneIndex(instance,errnum);
      if(CloneErrorLookup[cloneindex].Annotation==NULL)
	{
	  sprintf(retstring,"%s",ParseErrType(errnum));
	}
      else
	{
	  sprintf(retstring,"%s",CloneErrorLookup[cloneindex].Annotation);
	}
    }
  else
    {
      if(ErrorLookup[errnum].Annotation==NULL)
	{
	  sprintf(retstring,"%s",ParseErrType(errnum));
	}
      else
	{
	  sprintf(retstring,"%s",ErrorLookup[errnum].Annotation);
	}
    }

  return retstring;
}



void PopHighMenu(XButtonEvent *bevent)
{
  Widget button;
  Arg resources[20];
  struct ConditionList * NEW_LIST=NULL;
  struct AdditionalConditions * AdditionalConditionFlags=NULL;
  struct CondHighlight *temp;
  int ConditionFlags[CONDITION_ARRAY_SIZE];
  int errnum,instance,condnum,n,x,y,cloneindex=-1,i,outlen,indexer,
    xlooper,ylooper,total,startindex,endindex;
  char buttonstr[1000],scrubout[1000];
  static int LOCALBUSY=0;

  


  if(MasterStacker==NULL)
    {
      return;
    }

  
  if(LOCALBUSY==1)
    {
      printf("too busy\n");
      return;
    }
  
  x = bevent->x;
  y = bevent->y;

  if(x%2!=0)
    {
      x = x - 1;
    }
  if(y%2!=0)
    {
      y = y - 1;
    }

  x = x / 2;
  y = y / 2;
  

  total = 0;
  for(xlooper=x-5;xlooper<x+5;xlooper++)
    {
      if((xlooper<0)||(xlooper>499))
	{
	  continue;
	}
      for(ylooper=y-5;ylooper<y+5;ylooper++)
	{
	  if((ylooper<0)||(ylooper>424))
	    {
	      continue;
	    }

	  total = total + MasterStacker[xlooper][ylooper];
	}
    }

  if(total==0)
    {
      return;
    }

  
  

  HIGH_ERRNUM    = (int *)   malloc(SzI*(total+2));
  HIGH_INSTANCE  = (int *)   malloc(SzI*(total+2));
  HIGH_CONDNUM   = (int *)   malloc(SzI*(total+2));
  HIGH_ECC1      = (int *)   malloc(SzI*(total+2));
  HIGH_ECC2      = (int *)   malloc(SzI*(total+2));
  HIGH_MAG       = (double *)malloc(SzD*(total+2));


  
  LOCALBUSY = 1; 
  
  for(i=1;i<=CONDITION_DEFINITIONS;i++)
    {
      ConditionFlags[i] = 0;
    }    
  
  
  if(curr_pop==0)
    {
      if(pop_up[0]==1)
	{
	  if(POPDEBUG==1)
	    {
	      printf("destroying %d\n",curr_pop);
	    }
	  XtDestroyWidget(pop_menu[curr_pop]);
	}
      pop_up[0] = 0;
      curr_pop = 1;
    }
  else
    {
      if(pop_up[1]==1)
	{
	  if(POPDEBUG==1)
	    {
	      printf("destroying %d\n",curr_pop);
	    }
	  XtDestroyWidget(pop_menu[curr_pop]);
	}
      pop_up[1] = 0;
      curr_pop  = 0;
    }


  if(POPDEBUG==1)
    {
      printf("creating %d\n",curr_pop);
    }

  
  n=0;
  XtSetArg(resources[n], XmNdeleteResponse, XmDESTROY);         n++;
  XtSetArg(resources[n], XmNautoUnmanage,   True);              n++;
  XtSetArg(resources[n], XmNisHomogeneous,  False);             n++;
  XtSetArg(resources[n], XmNentryClass,     xmFormWidgetClass); n++;


  
  pop_menu[curr_pop] = XmCreatePopupMenu(pop_parent,"zyzyzyy",resources,n);


  indexer = 0; 

  for(xlooper=x-5;xlooper<x+5;xlooper++)
    {
      if((xlooper<0)||(xlooper>499))
	{
	  continue;
	}
      for(ylooper=y-5;ylooper<y+5;ylooper++)
	{
	  if((ylooper<0)||(ylooper>424))
	    {
	      continue;
	    }
	  
	
	  temp = MasterHighlighter[xlooper][ylooper];

	  while((temp!=NULL)&&(indexer<=(MAX_STACK-1)))
	    {

	      errnum   = temp->errnum;
	      instance = temp->instance;
	      condnum  = temp->condnum;


	      if(AlreadyFound(errnum,instance,condnum,indexer+1)==0)
		  {
		  indexer = indexer + 1;
		  
		  if(indexer<=MAX_STACK)
		    {
		      HIGH_ERRNUM  [indexer] = errnum;
		      HIGH_INSTANCE[indexer] = instance;
		      HIGH_CONDNUM [indexer] = condnum;
		    }
		  else
		    {
		      XBell(mydisplay,50);
		      printf("too many entries in %d %d (%d) (%d)\n",x,y,indexer,MasterStacker[xlooper][ylooper]);
		    }
		  
		  
		  if(AdditionalConditionFlags!=NULL)
		    {
		      printf("abnormally setting to NULL\n");
		      AdditionalConditionFlags = NULL;
		    }
		  
		  if(instance>0)
		    {
		      cloneindex = GetCloneIndex(instance,errnum);
		    }
		  else
		    {
		      cloneindex = -1;
		    }
		  
		   sprintf(scrubout,"%s",outdirectory);
		   outlen = strlen(scrubout);
		   scrubout[outlen-1] = '\0';
		  
		   SEEIT_LoadConditionReport(scrubout);
		  
		   if(cloneindex >= 0)
		    {
		      
		  
		      SEEIT_AddAdditionalFlag(&AdditionalConditionFlags,
					      CloneErrorLookup[cloneindex].CloneNumber, 
					      GetCloneNumber(cloneindex,CloneErrorLookup[cloneindex].CloneNumber)
					      );	  
		    }
		  else
		    {
		      ConditionFlags[errnum] = 1;
		    }

		    use_other_fileposn = temp->fileposn;		  

		  ABORT_ZOOM = 0;

 
		  NEW_LIST =
		    SEEIT_GetConditions(scrubout,
					ConditionFlags,
					condnum,  
					condnum,  
					AdditionalConditionFlags, 
					1,        
					1,        
					0,        
					NULL,
					-1
					);

		  use_other_fileposn = -1;

		  if(NEW_LIST==NULL)
		    {
		      XBell(mydisplay,50);
		      printf("serious error: NULL NEW_LIST\n");
		      LOCALBUSY = 0;
		      return;
		    }
		  else if(NEW_LIST->next!=NULL)
		    {
		      XBell(mydisplay,50);
		      printf("serious error: too many returns:\n");
		      while(NEW_LIST!=NULL)
			  {
			   printf("%s\n",ParseErrType(NEW_LIST->CONDITION_TYPE));
			   NEW_LIST = NEW_LIST->next;
			  }
		      LOCALBUSY = 0;
		      return;
		    }
		  
		  HIGH_ECC1[indexer] = NEW_LIST->ECC1;
		  HIGH_ECC2[indexer] = NEW_LIST->ECC2;
		  HIGH_MAG [indexer] = NEW_LIST->magnitude;
		  
		  SEEIT_FreeConditions(NEW_LIST);
		  SEEIT_FreeAdditionalFlags(AdditionalConditionFlags);
		  AdditionalConditionFlags = NULL;
		  SEEIT_FreeConditionReportMemory();
		  
		  
		  ConditionFlags[errnum] = 0;
		  
		}
	      
	      temp = temp->next;
	    }
	}
    }
    
  
  


  SortHighlighter(1,indexer,1);


  


  startindex = 1;
  endindex   = 1;
  

  for(i=1;i<=indexer;i++)
    {
      if(HIGH_ERRNUM[endindex]==HIGH_ERRNUM[i])
	{
	  endindex = i;
	}
      else
	{
	  if(startindex!=endindex)
	    {
	      SortHighlighter(startindex,endindex,2);
	    }
	  startindex = i;
	  endindex   = i;
	}
    }
  
  
  if(startindex!=endindex)
    {
      
      SortHighlighter(startindex,endindex,2);
    }




  for(i=1;i<=indexer;i++)
    {
      rec_errnum  [i] = HIGH_ERRNUM  [i];
      rec_instance[i] = HIGH_INSTANCE[i];
      rec_condnum [i] = HIGH_CONDNUM [i];
      

	  if(rec_errnum[i]!=COVERFAIL)  
	  {
        sprintf(buttonstr,"\"%s\"\n Condition #%d, Instantiation #%d (%s%d) %s\n %s",
	      GetFirstLine(HIGH_ERRNUM[i],HIGH_INSTANCE[i]),
	      HIGH_CONDNUM[i],HIGH_INSTANCE[i]+1,
	      ParseErrName(HIGH_ERRNUM[i]),HIGH_INSTANCE[i]+1,
	      GetRetainIgnoreString(HIGH_ERRNUM[i],HIGH_INSTANCE[i],HIGH_CONDNUM[i]),
	      GetCondDetails(2,0,
			     HIGH_ECC1[i],
			     HIGH_ECC2[i],
			     HIGH_MAG[i],
			     HIGH_ERRNUM[i],
			     -1, 
			     0,0,0,0,0));  
	  }
	  else
	  {
          sprintf(buttonstr,"\"%s\"\n Condition #%d, Instantiation #%d (%s%d) %s",
	       GetFirstLine(HIGH_ERRNUM[i],HIGH_INSTANCE[i]),
	       HIGH_CONDNUM[i],HIGH_INSTANCE[i]+1,
	       ParseErrName(HIGH_ERRNUM[i]),HIGH_INSTANCE[i]+1,
	       GetRetainIgnoreString(HIGH_ERRNUM[i],HIGH_INSTANCE[i],HIGH_CONDNUM[i]));  
	  }






      n=0;
      XtSetArg(resources[n],XmNlabelString,XmStringCreateLtoR (buttonstr,"TAG5"));                n++;
      XtSetArg(resources[n],XmNleftAttachment,   XmATTACH_POSITION);                              n++;
      XtSetArg(resources[n],XmNleftPosition,     0);                                              n++;
            
      button = XmCreatePushButton(pop_menu[curr_pop],"Click me",resources,n);
      XtAddCallback(button, XmNactivateCallback,
		    HighlightCallback, (XtPointer)i);
      XtManageChild(button);




      


    }


  free(HIGH_ERRNUM);
  free(HIGH_INSTANCE);
  free(HIGH_CONDNUM);
  free(HIGH_ECC1);
  free(HIGH_ECC2);
  free(HIGH_MAG);


  
  
  
  
  XmMenuPosition(pop_menu[curr_pop],bevent);
  XtManageChild(pop_menu[curr_pop]);
  
  XtAddCallback (pop_menu[curr_pop], XmNdestroyCallback,ShellDeath,(XtPointer)309);
  pop_up[curr_pop] = 1;
  
  LOCALBUSY = 0;
}
    

int GetIxmod()
{
  int Ixmod,Iymod;
  double xmod,ymod,xpercent,ypercent;

  xmod = 500-AddVoidSpace(-1)/2.0;
  ymod = 425+AddVoidSpace(-2)/2.0;

  xpercent = ScrollPercent(1);
  ypercent = ScrollPercent(2);
  if(ypercent<0.0)
  {
    ypercent = 0.0;
  }
      

  xmod = xmod + xpercent*AddVoidSpace(-1);
  ymod = ymod - ypercent*AddVoidSpace(-2);

 Ixmod = (int)xmod;
 Iymod = (int)ymod;
 return Ixmod;
}



int GetIymod()
{
  int Ixmod,Iymod;
  double xmod,ymod,xpercent,ypercent;

  xmod = 500-AddVoidSpace(-1)/2.0;
  ymod = 425+AddVoidSpace(-2)/2.0;

  xpercent = ScrollPercent(1);
  ypercent = ScrollPercent(2);
  if(ypercent<0.0)
  {
    ypercent = 0.0;
  }
      

  xmod = xmod + xpercent*AddVoidSpace(-1);
  ymod = ymod - ypercent*AddVoidSpace(-2);

 Ixmod = (int)xmod;
 Iymod = (int)ymod;
 return Iymod;
}




int isclosepix(int a, int b)
{
  if(fabs(a-b)<4)
    {
      return 1;
    }
  return 0;
}



#if(USE_DOS==1)

void startTimer( stopWatch *timer) 
{
  QueryPerformanceCounter(&timer->start);
}

void stopTimer( stopWatch *timer) 
{
  QueryPerformanceCounter(&timer->stop);
}

double LIToSecs( LARGE_INTEGER * L) 
{
  LARGE_INTEGER frequency;
  QueryPerformanceFrequency( &frequency );
  return ((double)L->QuadPart /(double)frequency.QuadPart);
}

double getElapsedTime( stopWatch *timer) 
{
  LARGE_INTEGER time;
  time.QuadPart = timer->stop.QuadPart - timer->start.QuadPart;
  return LIToSecs( &time) ;
}

#endif



void StopDistanceGathering()
{
  if(num_dist_pts>0)
  {
    free(dist_xpts);
    free(dist_ypts);
    dist_xpts = NULL;
    dist_ypts = NULL;
    num_dist_pts = 0;
  }
}


void AddDistVertex(int x, int y, int override)
{
  double thisDtime,elapsed;
  static double lastDtime = 0.0;
  extern int DOUBLECLICK;

#if(USE_DOS==1)
  static stopWatch stopper;
#endif

	  
  if(override==0)
    {

#if(USE_DOS==1)

      if(lastDtime<0.001)
	{
	  startTimer(&stopper);
 	  lastDtime = 1.0;
	  elapsed = 5.0;
	} 
      else
	{ 
	  stopTimer(&stopper);
	  thisDtime = getElapsedTime(&stopper);
	  elapsed = thisDtime - lastDtime;
	  lastDtime = thisDtime;
	  if(elapsed<0)
	    {
	      elapsed = 5.0;
	    }
	}
      
#else
      
      struct timeval thistime;
      
      if(gettimeofday(&thistime,NULL)==0)
	{ 
	  thisDtime = thistime.tv_sec+thistime.tv_usec/1000000.0;
	}
      elapsed = thisDtime-lastDtime;
      lastDtime = thisDtime;
      
#endif
    }
  
  
  

  
  if( (override==1) || ((elapsed*1000)<DOUBLECLICK))
    {
      
      if(num_dist_pts>0)
	{ 
	  if(
	     (override==1) ||
	     (
	      (isclosepix(x,dist_xpts[num_dist_pts-1])) &&
	      (isclosepix(y,dist_ypts[num_dist_pts-1]))
	      )
	     )
	    {
	      free(dist_xpts);
	      free(dist_ypts);
	      dist_xpts = NULL;
	      dist_ypts = NULL;
	      num_dist_pts = 0;
	      return;
	    }
	}
    }
  else
  {
     
  }
  
  
  if(num_dist_pts==0)
    {
      dist_xpts = (int *)malloc(SzI);
      dist_ypts = (int *)malloc(SzI);
    }
  else
    {
      
      dist_xpts = (int *)realloc(dist_xpts,SzI*(num_dist_pts+1));
      dist_ypts = (int *)realloc(dist_ypts,SzI*(num_dist_pts+1));
    }
  
  
  dist_xpts[num_dist_pts] = x;
  dist_ypts[num_dist_pts] = y;
  num_dist_pts = num_dist_pts + 1;
}



char *MakeDist(double thedist)
{
  static char retval[50];

  if(thedist>.1)
  {
    sprintf(retval,"%.2lf",thedist);
  }
  else if(thedist>.001)
  {
    sprintf(retval,"%.4lf",thedist);
  }
  else if(thedist>.00001)
  {
    sprintf(retval,"%.6lf",thedist);
  }
  else if(thedist>.0000001)
  {
    sprintf(retval,"%.8lf",thedist);
  }
  else
  {
    sprintf(retval,"%.10lf",thedist);
  }

 return retval;
}


void DrawNextSeg(int x,int y)
{
  XmString t1;
  char help[300],help_1[300],help_2[300],tempchar[50];
  int i;
  double thedist,segdist;

  if(num_dist_pts<1)
  {
	
    return;
  }

  for(i=1;i<num_dist_pts;i++)
  { 
    line(dist_xpts[i-1], gry-dist_ypts[i-1],dist_xpts[i], gry-dist_ypts[i]);
  }

  if(num_dist_pts>0)
  {
    line(dist_xpts[num_dist_pts-1], gry-dist_ypts[num_dist_pts-1],x, gry-y);
  }


  if(num_dist_pts==1) 
  {
    UseDMScoordinates = IUseDMScoordinates;

	sprintf(help_1,"%s",Coordinate2DtoString(
						   (double)((double)(dist_xpts[0]-10)/xunits)*IRegionSize + llx_zoom,
						   (double)((double)(gry-dist_ypts[0]-10)/yunits)*IRegionSize + lly_zoom));
	  
	sprintf(help_2,"%s",Coordinate2DtoString(
						   (double)((double)(x-10)/xunits)*IRegionSize + llx_zoom,
						   (double)((double)(gry-y-10)/yunits)*IRegionSize + lly_zoom));
	  
	UseDMScoordinates = 0;

	thedist = Distance(
			   (double)((double)(dist_xpts[0]-10)/xunits)*IRegionSize + llx_zoom,
			   (double)((double)(gry-dist_ypts[0]-10)/yunits)*IRegionSize + lly_zoom,
			   (double)((double)(x-10)/xunits)*IRegionSize + llx_zoom,
			   (double)((double)(gry-y-10)/yunits)*IRegionSize + lly_zoom);


	sprintf(tempchar,"%s",MakeDist(thedist));

	sprintf(help,"Left: Click points to add distance: Right: Stop %s to %s: %s m",
		  help_1,help_2,tempchar);

  }
  else if(num_dist_pts>1)
  {
    thedist = 0.0;

	  for(i=1;i<num_dist_pts;i++)
    {
	  thedist = thedist + Distance(
			   (double)((double)(dist_xpts[i-1]-10)/xunits)*IRegionSize + llx_zoom,
			   (double)((double)(gry-dist_ypts[i-1]-10)/yunits)*IRegionSize + lly_zoom,
			   (double)((double)(dist_xpts[i]-10)/xunits)*IRegionSize + llx_zoom,
			   (double)((double)(gry-dist_ypts[i]-10)/yunits)*IRegionSize + lly_zoom);
    }

	  segdist = Distance(
			   (double)((double)(dist_xpts[num_dist_pts-1]-10)/xunits)*IRegionSize + llx_zoom,
			   (double)((double)(gry-dist_ypts[num_dist_pts-1]-10)/yunits)*IRegionSize + lly_zoom,
			   (double)((double)(x-10)/xunits)*IRegionSize + llx_zoom,
			   (double)((double)(gry-y-10)/yunits)*IRegionSize + lly_zoom);

	  thedist = thedist + segdist;

	  sprintf(tempchar,"%s",MakeDist(thedist));

	  sprintf(help,"Left: Click points to add distance: Right: Stop  Segment: %s Total: %s m",MakeDist(segdist),tempchar);
  }

  t1 = XmStringCreateLtoR (help,"TAG5");
  XtVaSetValues(TEXT_HELP,XmNlabelString,t1,NULL); 
  XmStringFree(t1);      
  
}



void draw(Widget widget, XEvent *event, String *args, int *num_args)
{
  
  
  char c[20],c1[20],c2[20],c3[20],c4[20];
  char help[200],help1[500];
  char message[150];
  
  int temp;
  int i,sen1,sen2,ijunk;
  int Addin;
  int inx,iny,outx,outy;
  int myx,myy;
  int singlePoly;
  int i_nvert=1;
  int bad=0;
  int not_bad,profile_not_bad;
  int tempint,haveobs=0,havetgt=0;
  int RESETINFOLIST = 0;
  static int panx,pany;

  long int tempheight;

  double xrange,yrange;
  double max, min, dist,zz;
  double xscale,yscale,mid;
  double intersectx,intersecty;
  double testx1,testy1,testx2,testy2;
  double minXint, minYint;
  double obsht,tgtht;
  double myradius;
  double startangle,tempangle;
  double xleft,yleft;
  double xright,yright;
  double si,co;
  double currentx,currenty;
  double val1,val2,val3,val4,zrange;
  static double startloadxPt,startloadyPt,endloadxPt,endloadyPt;

  XButtonEvent *bevent = (XButtonEvent *) event;
  Dimension x1,y1;
  XmString t1,message2;
  struct ProfileList *cp,*pp;
  char myarg[100];
  static int LOCALBUSY=0;
  extern int SAVE_TOPCHANGE;


  if(LOCALBUSY==1)
    {
      printf("Aborting mouse action on main screen due to being busy\n");
	  return;
    }


  LOCALBUSY = 1;


  if(!strcmp(args[0],"scrolldown"))
    {
      XtVaGetValues(vert_scroll[DRAWING_A_SCROLL],
		    XmNminimum,      &global_scroll_min,
		    XmNmaximum,      &global_scroll_max,
		    XmNvalue,        &global_scroll_value,
		    XmNsliderSize,   &global_scroll_slide_size,
		    XmNincrement,    &global_scroll_increment,
		    XmNpageIncrement,&global_scroll_pg_increment,
		    NULL);
      

      global_scroll_value = global_scroll_value + 30;



      if(global_scroll_value>(global_scroll_max-global_scroll_slide_size))
	{
	  global_scroll_value = global_scroll_max-global_scroll_slide_size;
	}

      XmScrollBarSetValues(vert_scroll[DRAWING_A_SCROLL],
			   global_scroll_value,
			   global_scroll_slide_size,
			   30,
			   global_scroll_pg_increment,
			   1);
      LOCALBUSY = 0;
      return;
    }


  if(!strcmp(args[0],"scrollup"))
    {
      XtVaGetValues(vert_scroll[DRAWING_A_SCROLL],
		    XmNminimum,      &global_scroll_min,
		    XmNmaximum,      &global_scroll_max,
		    XmNvalue,        &global_scroll_value,
		    XmNsliderSize,   &global_scroll_slide_size,
		    XmNincrement,    &global_scroll_increment,
		    XmNpageIncrement,&global_scroll_pg_increment,
		    NULL);
      

      global_scroll_value = global_scroll_value-global_scroll_increment;
      
      if(global_scroll_value<global_scroll_min)
	{
	  global_scroll_value = global_scroll_min;
	}
      
      XmScrollBarSetValues(vert_scroll[DRAWING_A_SCROLL],
			   global_scroll_value,
			   global_scroll_slide_size,
			   global_scroll_increment,
			   global_scroll_pg_increment,
			   1);
      LOCALBUSY = 0;
      return;
    }


  if(busyinnitting==1)
  {
	printf("Tried to DWIN\n");
    LOCALBUSY = 0;
    return;
  }


  if(!strcmp(args[0],"distmotion"))
    {
	  
	  set_cursor(mydisplay,mywindow,GOOD);

	  if(DIST_MODE==1)
	  {
        if(bevent!=NULL)
		{  
	      if(num_dist_pts>0) 
		  {
	        XCopyArea (mydisplay, pixmap, mywindow, mygc,
			 0, 0, width, height, 0, 0);
	      
	        DrawNextSeg(bevent->x,bevent->y);
		  }
		}  
      LOCALBUSY = 0;
      return;
	  } 
  }


  if (
      (!strcmp(args[0],"mid_up"))     ||
      (!strcmp(args[0],"mid_down"))   ||
      (!strcmp(args[0],"mid_motion"))
      )
    {
      
      LOCALBUSY = 0;
      return;
    }

  RESETINFOLIST = 0;

  if((CHECK_MODE==0)&&(AOI_MODE==0))
    {
      if     ((FLIP==1)&&(!strcmp(args[0],"up")))         {sprintf(myarg,"mid_up"); RESETINFOLIST = 1;}
      else if((FLIP==1)&&(!strcmp(args[0],"shiftb1up")))  {sprintf(myarg,"mid_up"); RESETINFOLIST = 0;}
      else if((FLIP==1)&&(!strcmp(args[0],"down")))       {sprintf(myarg,"mid_down");}
      else if((FLIP==1)&&(!strcmp(args[0],"motion")))     {sprintf(myarg,"mid_motion");}
      else {  sprintf(myarg,"%s",args[0]); }  
    }
  else
    {
      sprintf(myarg,"%s",args[0]);
    }



  if(BUSY==1)
    {
      if(DEBUG==1){printf("button click dismissed due to being busy\n");}
      BAD_ZOOM = 1;
      BAD_PAN  = 1;
      LOCALBUSY = 0;
printf("busy!\n");
      return;
    }
  else if (input_source==0)
    {
      LOCALBUSY = 0;
      return;
    }
  
  else if((INFO_MODE==0)&&(running==1))
    {
      LOCALBUSY = 0;
      return;
    }  
  else if(output_source==0)
    { 
      
      printf(" bad output source 1\n");
      LOCALBUSY = 0;
      return;
    }
  else if((PAN_MODE==1)&&(NOT_ZOOMED==1)&&(AOI_MODE==0))
    {
      
      LOCALBUSY = 0;
      return;
    }




  else if (*num_args != 1)
    {
      printf("Wrong number of args : %d\n",*num_args);
      XBell(mydisplay,50);
      LOCALBUSY = 0;
      return;
    }


  

  if(bevent!=NULL)
    {
      if(INFO_MODE==1){bevent->y = bevent->y+7;}
      if((FAN_MODE==1)&&(startx==bevent->x)){bevent->x=bevent->x+1;}
      if((FAN_MODE==1)&&(starty==bevent->y)){bevent->y=bevent->y+1;}
    }

  if(AOI_MODE==1)
    {
      if (!(strcmp (myarg, "down"))) 
	{
          if((bevent->x > 10)&&
	     (bevent->x <= xnum*xunits+10)&&
	     (bevent->y >= gry - ynum*yunits - 10)&&
	     (bevent->y <= gry-10)   
	     )
	    {	      

	      they =  (double)((double)(gry-bevent->y-10)/yunits)*IRegionSize + lly_zoom;
	      thex =  (double)((double)(bevent->x-10)/xunits)*IRegionSize + llx_zoom; 

	      mapCallback(NULL,(XtPointer)4,(XtPointer)4);
	    }
	  else
	    {
	      if(DEBUG==1){printf("detected out of range stuff\n");}
	    }
	}
      FlushMainScreen(1);
      LOCALBUSY = 0;
      return;
    }
  
  else if ((CHECK_MODE==1)&&(!(strcmp (myarg, "down"))))
    {
      
      
      
      
      
      if(DOALLCELLS==1)
	{
	  LOCALBUSY = 0;
	  return;
	}
      
      if(DEBUG==1)
	{
	  printf("Found llx=%lf\n",llx_zoom);
	  printf("mouse clicked at x=%d\n",bevent->x);
	  printf("One region is %lf pixels\n",xunits);
	  printf("I think a new region starts at %d meters over\n",
		 (int)(IRegionSize-((int)llx_zoom%((int)IRegionSize))));
	  printf("I think a new region starts at pixel %lf\n",
		 10+(IRegionSize-((int)llx_zoom%((int)IRegionSize)))*xunits/IRegionSize);
	  
	  printf("x location of click: %lf\n",llx_zoom+ ((double)(bevent->x-10.0)/xunits*IRegionSize));
	  printf("y location of click: %lf\n",lly_zoom+ ((double)(gry-bevent->y-10.0)/yunits*IRegionSize));
	  
	  printf("startloadx must be %d\n",  
		 (int)((llx_zoom+ ((double)(bevent->x-10.0)/xunits*IRegionSize))/IRegionSize));
	  printf("startloady must be %d\n",  
		 (int)((lly_zoom+ ((double)(gry-bevent->y-10.0)/yunits*IRegionSize))/IRegionSize));
	}
      startloadxPt = llx_zoom + (double)((double)(IRegionSize/xunits)*(double)(bevent->x-10.0));
      startloadyPt = lly_zoom + (double)((double)(IRegionSize/yunits)*(double)(height-bevent->y-10.0));
      
      if(DEBUG==1){printf("just set x,y to %d %d\n",startloadx,startloady);}
      
      
      startx = bevent->x;
      starty = bevent->y;
      
      if((startx<10)||(startx>xlimit)||(starty>(gry-10))||(starty<(gry-ylimit)))
	{set_cursor(mydisplay,mywindow,PIRATE);}
    }

  

  else if ((CHECK_MODE==1)&&(!(strcmp (myarg, "motion"))))
    {          
      if(DOALLCELLS==1)
	{
	  
	  LOCALBUSY = 0;
	  return;
	} 
      
      
      
      XCopyArea (mydisplay, pixmap, mywindow, mygc,0,0, width, height, 0, 0);
      
   
      if(
	 (startx <= xlimit)
	 &&
	 (bevent->x <= xlimit)
	 &&
	 (bevent->x >= 10)
	 &&
	 (startx >= 10)                        
	 &&                                    
	 (bevent->y <= gry-10)                 
	 &&
	 (starty <= gry-10)
	 &&
	 (bevent->y >= gry - ylimit)
	 &&
	 (starty >= gry - ylimit)
	 )
	{
	  line(startx,       gry-starty,        startx,    gry-bevent->y);
	  line(startx,       gry-starty,     bevent->x,    gry-starty);
	  line(bevent->x,    gry-bevent->y,  bevent->x,    gry-starty);
	  line(bevent->x,    gry-bevent->y,     startx,    gry-bevent->y);
	  set_cursor(mydisplay,mywindow,GOOD);
	}
      else
	{
	  set_cursor(mydisplay,mywindow,PIRATE);
	  LOCALBUSY = 0;
	  return;
	}
    }
  
  else if ((CHECK_MODE==1)&&(!(strcmp (myarg, "up"))))
    {
      set_cursor(mydisplay,mywindow,GOOD);
      if(DOALLCELLS==1)
	{
	  
	  LOCALBUSY = 0;
	  return;
	} 
      

      
      if( (startx<10)||
	  (startx>(xnum*xunits+10))||
	  (starty<(gry - ynum*yunits - 10))||
	  (starty>(gry-10))||
	  (bevent->y > gry-10)||
	  (bevent->y < (gry - ynum*yunits - 10))||
	  (bevent->x < 10)||
	  (bevent->x > xnum*xunits+10)
	  )
	{
	  LOCALBUSY = 0;
	  return;  
	}
      
      endloadxPt = llx_zoom + (double)((double)(IRegionSize/xunits)*(double)(bevent->x-10.0));
      endloadyPt = lly_zoom + (double)((double)(IRegionSize/yunits)*(double)(height-bevent->y-10.0));
      
            
      
      
      CreateLoadModule(endloadxPt,endloadyPt,&endloadx,&endloady);
      CreateLoadModule(startloadxPt,startloadyPt,&startloadx,&startloady);

      

      if(endloadx<startloadx){temp = startloadx;  startloadx=endloadx;  endloadx = temp;}
      if(endloady<startloady){temp = startloady;  startloady=endloady;  endloady = temp;}
      
      if(startloadx< MinXindex){startloadx = MinXindex;}
      if(startloadx> MaxXindex){startloadx = MaxXindex;}
      
      if(startloady< MinYindex){startloady = MinYindex;}
      if(startloady> MaxYindex){startloady = MaxYindex;}
      
      if(endloadx  > MaxXindex){endloadx = MaxXindex;}
      if(endloadx  < MinXindex){endloadx = MinXindex;}
      
      if(endloady  > MaxYindex){endloady = MaxYindex;}
      if(endloady  < MinYindex){endloady = MinYindex;}
      
      FromI = startloadx;
      ToI   = endloadx  ;
      FromJ = startloady;
      ToJ   = endloady  ;	
          
      SetLoadModules();  
      
      if(DEBUG==1){printf("Just set fromi. fromj, toi, toj to %d %d %d %d:\n",FromI,FromJ,ToI,ToJ);}
      
      load_modules = 1;
    }
  else if(CHECK_MODE==1)
    {
      LOCALBUSY = 0;
      return;
    }
  
  else if (!(strcmp (myarg, "mid_down"))) 
    {      
      if(output_source==0)
	{
	  LOCALBUSY = 0;
	  return;    
	}   
      
      set_cursor(mydisplay,mywindow,GOOD);
      
      if(PROFILE_MODE==1)
	{
	  pro_begx = bevent->x;
	  pro_begy = bevent->y;
	  profile_not_bad = 1;

	  

	  if(profile_not_bad==0) 
	    {
	      
	      BAD_BEGIN_PROFILE=1;
	    }
	  else
	    {
	      
	      BAD_BEGIN_PROFILE=0;
	    }
	  LOCALBUSY = 0;
	  return;
	}
      
      if(FAN_MODE==1)
	{
	  if ((bevent->x > xlimit)||(bevent->x < 10)
	      ||(bevent->y > gry-10)||(bevent->y < gry - ylimit))
	    {
	      BAD_FAN=1; startzoomx=-1000; startzoomy=-10000; 

	      set_cursor(mydisplay,mywindow,PIRATE);
	      LOCALBUSY = 0;
	      return;
	    }
	  
	  BAD_FAN=0;
	  startx = bevent->x;
	  starty = bevent->y;
	  LOCALBUSY = 0;
	  return;
	}    
      if(PROFILE_MODE==1)
	{
	  pro_begx = bevent->x;
	  pro_begy = bevent->y;
	  LOCALBUSY = 0;
	  return;
	}
      if(DIST_MODE==1)
	{
	  AddDistVertex(bevent->x,bevent->y,0);
	  LOCALBUSY = 0;
	  return;
	}
    
      if(ZOOM_MODE==1)
	{	  
	  if (
	      (bevent->x > xlimit)                   ||
	      (bevent->x < (10-INFO_BUFFER))         ||
	      (bevent->y > (gry - (10-INFO_BUFFER))) ||
	      (bevent->y < (gry - ylimit))      
	      )
	    {
	      BAD_ZOOM=1; startzoomx=-1000; startzoomy=-10000; 

		  set_cursor(mydisplay,mywindow,PIRATE);

		  if(DEBUG==1)
		  { 
		    printf("bad zoom!\n");
		  } 
	      LOCALBUSY = 0;
	      return;
	    }
	  
	  BAD_ZOOM=0;
	  
	  if(DEBUG==1){printf("xunits, yunits %lf %lf\n",xunits,yunits);}
	}



      if(PAN_MODE==1)
	{
	  if (
	      (bevent->x > xlimit)                   ||
	      (bevent->x < (10-INFO_BUFFER))         ||
	      (bevent->y > (gry - (10-INFO_BUFFER))) ||
	      (bevent->y < (gry - ylimit))      
	      )
	    {
	      BAD_PAN=1; startpanx=-1000; startpany=-10000; 
	      set_cursor(mydisplay,mywindow,PIRATE);
	      
	      printf("bad pan!\n");
	      LOCALBUSY = 0;
	      return;
	    }
	  
	  BAD_PAN=0;

	  

	}



      if(INFO_MODE==1)
	{
	  if (
	      (bevent->x > xlimit)                   ||
	      (bevent->x < (10-INFO_BUFFER))         ||
	      (bevent->y > (gry - (10-INFO_BUFFER))) ||
	      (bevent->y < (gry - ylimit))      

	      )
	    {
	      BAD_INFO=1; startzoomx=-1000; startzoomy=-10000; 
	      set_cursor(mydisplay,mywindow,PIRATE);
	      LOCALBUSY = 0;
	      return;
	    }	  
	  BAD_INFO=0;
	}
      
      startzoomx = bevent->x;
      startzoomy = bevent->y;

      startpanx = bevent->x;
      startpany = bevent->y;
    }
    
  else if (!(strcmp (myarg, "mid_motion"))) 
    {    
      if(output_source==0)
	{
	  LOCALBUSY = 0;
	  return;    
	}   
      
      if(bevent->y==starty){bevent->y=bevent->y-1;}
 



      if(PAN_MODE==0)
	{
	  

	  if((DIST_MODE==0)||(num_dist_pts>0))
	    {
	      XCopyArea (mydisplay, pixmap, mywindow, mygc,
			 0, 0, width, height, 0, 0);
	    }
	}
            


      

      if(DIST_MODE==1)
	{
	  DrawNextSeg(bevent->x,bevent->y);
	  LOCALBUSY = 0;
	  return;
	}
      
      if(PROFILE_MODE==1)
	{
	  if (
	      (pro_begx >= xlimit)||(bevent->x >= xlimit)||
	      (bevent->x < 10)||(pro_begx < 10)||                       
	      (bevent->y > gry-10)||(pro_begy > gry-10)||
	      (bevent->y < gry - ylimit)||(pro_begy < gry - ylimit)||
	      (BAD_BEGIN_PROFILE==1) 
	      )	  
	    {
	      set_cursor(mydisplay,mywindow,PIRATE);
	      BAD_PROFILE=1;
	      LOCALBUSY = 0;
	      return;
	    }
	  not_bad = 1;

	  if(not_bad==1)
	    {
		  line(pro_begx, gry-pro_begy, bevent->x, gry-bevent->y);
	      BAD_PROFILE=0;
	      set_cursor(mydisplay,mywindow,GOOD);
	      LOCALBUSY = 0;
	      return;
	    } 
	  else if(PROFILE_MODE==1)
	    {
	      set_cursor(mydisplay,mywindow,PIRATE);BAD_PROFILE=1;
	      LOCALBUSY = 0;
	      return;
	    }
	}
      
      else if(FAN_MODE==1)
	{
	  if (
	      (startx >= xlimit)||(bevent->x >= xlimit)||
	      (bevent->x < 10)||(startx < 10)||                       
	      (bevent->y > gry-10)||(starty > gry-10)||
	      (bevent->y < gry - ylimit)||(starty < gry - ylimit) 
	      )	  
	    {
	      set_cursor(mydisplay,mywindow,PIRATE);
	      BAD_FAN=1;
	      if(FANDEBUG==1){printf("set bad fan\n");}
	      LOCALBUSY = 0;
	      return;
	    }
	  for(i=0;i<(int)(FAN_ANGLE/2);i++)
	    {
	      si = sin(-0.0174532*(double)(i+1.0));
	      co = cos(-0.0174532*(double)(i+1.0));
	      
	      currentx =  (bevent->x-startx)*co - (bevent->y-starty)*si;
	      currenty =  (bevent->x-startx)*si + (bevent->y-starty)*co;
	      
	      currentx = currentx+startx;
	      currenty = currenty+starty;
	      
	      si = sin(+0.0174532*(double)(i+1.0));
	      co = cos(+0.0174532*(double)(i+1.0));
	      
	      xright =  (bevent->x-startx)*co - (bevent->y-starty)*si;
	      yright =  (bevent->x-startx)*si + (bevent->y-starty)*co;
	      
	      xright = xright+startx;
	      yright = yright+starty;
	      
	      if(
		 
		 LineSegmentsIntersect((double)10.0,(double)(gry-10.0),
				       (double)(10000.0),(double)(gry-10.0),
				       (double)startx,(double)starty,
				       currentx,currenty,
				       &intersectx,&intersecty)
		 ||
		 
		 LineSegmentsIntersect((double)10.0,(double)(gry-10.0),
				       (double)(10.0),(double)(gry-(790.0)),
				       (double)startx,(double)starty,
				       currentx,currenty,
				       &intersectx,&intersecty)
		 ||
		 
		 LineSegmentsIntersect((double)(10.0),(double)(10.0),
				       (double)(990.0),(double)(10.0),
				       (double)startx,(double)starty,
				       currentx,currenty,
				       &intersectx,&intersecty)
		 ||
		 
		 LineSegmentsIntersect((double)(990.0),(double)(gry-790.0),
				       (double)(990.0),(double)(gry-10.0),
				       (double)startx,(double)starty,
				       currentx,currenty,
				       &intersectx,&intersecty)
		 ||
		 
		 LineSegmentsIntersect((double)10.0,(double)(gry-10.0),
				       (double)(990.0),(double)(gry-10.0),
				       (double)startx,(double)starty,
				       xright,yright,
				       &intersectx,&intersecty)
		 ||
		 
		 LineSegmentsIntersect((double)(10.0),(double)(gry-10.0),
				       (double)(10.0),(double)(gry-790.0),
				       (double)startx,(double)starty,
				       xright,yright,
				       &intersectx,&intersecty)
		 ||
		 
		 LineSegmentsIntersect((double)(10.0),(double)(gry-790.0),
				       (double)(990.0),(double)(gry-790.0),
				       (double)startx,(double)starty,
				       xright,yright,
				       &intersectx,&intersecty)
		 ||
		 
		 LineSegmentsIntersect((double)(990.0),(double)(gry-10.0),
				       (double)(990.0),(double)(gry-790.0),
				       (double)startx,(double)starty,
				       xright,yright,
				       &intersectx,&intersecty)
		 )
		{
		  BAD_FAN=1;
		  set_cursor(mydisplay,mywindow,PIRATE);
		  LOCALBUSY = 0;
		  return;
		}
	      
	    }
	  
	  myradius = EuclideanDistance(
			      (double)((double)(startx-10)/xunits)*IRegionSize,
			      (double)((double)(gry-starty-10)/yunits)*IRegionSize,
			      (double)((double)(bevent->x-10)/xunits)*IRegionSize,
			      (double)((double)(gry-bevent->y-10)/yunits)*IRegionSize
			      );
	  myradius=myradius*2;
	  myradius=myradius*xunits/IRegionSize;
	  
	  
	  
	  
	  tempangle= 
	    acos(
		 EuclideanDistance((double)startx,(double)starty,
			  (double)bevent->x,starty)/ (myradius/2.0));
	  
	  if((bevent->x >= startx)&&(bevent->y <=starty))
	    {
	      
	      startangle= (  (tempangle) / (MYPI/2.0))*90.0*64.0;
	    }
	  else if((bevent->x <= startx)&&(bevent->y <=starty))
	    {
	      
	      
	      startangle = 90.0*64.0 - (  (tempangle) / (MYPI/2.0))*90.0*64.0 + 90.0*64.0;
	    }
	  
	  else if((bevent->x <= startx)&&(bevent->y >=starty))
	    {
	      
	      startangle= (  (tempangle) / (MYPI/2.0))*90.0*64.0  + 180.0*64.0;
	    }
	  else if((bevent->x >= startx)&&(bevent->y >=starty))
	    {
	      
	      startangle= 90.0*64.0 - (  (tempangle) / (MYPI/2.0))*90.0*64.0 + 270.0*64.0;
	    }
	  
	  XCopyArea (mydisplay, pixmap, mywindow, mygc,
		     0, 0, width, height, 0, 0);
	  
	  startangle = startangle-((FAN_ANGLE*64)/2.0);
	  if(startangle<0){startangle=startangle+360.0*64.0;}
	  
	  XDrawArc(mydisplay,mywindow,mygc,
		   startx-(int)(myradius/2.0),starty-(int)(myradius/2.0),
		   (unsigned int)myradius,(unsigned int)myradius,(int)startangle,(int)(FAN_ANGLE*64.0));
	  
	  
	  
	  
	  si = sin(0.0174532 * FAN_ANGLE/2.0);
	  co = cos(0.0174532 * FAN_ANGLE/2.0);
	  
	  xleft = (bevent->x-startx)*co - (bevent->y-starty)*si;
	  yleft = (bevent->x-startx)*si + (bevent->y-starty)*co;
	  
	  xleft = xleft+startx;
	  yleft = yleft+starty;
	  
	  si = sin(-0.0174532 * FAN_ANGLE/2.0);
	  co = cos(-0.0174532 * FAN_ANGLE/2.0);
	  
	  xright = (bevent->x-startx)*co - (bevent->y-starty)*si;
	  yright = (bevent->x-startx)*si + (bevent->y-starty)*co;
	  
	  xright = xright+startx;
	  yright = yright+starty;
	  
	  line(startx, gry-starty,(int)  xleft, gry-(int)yleft);
	  line(startx, gry-starty,(int) xright, gry-(int)yright);
	  
	  XFlush(mydisplay);
	  BAD_FAN=0;
	  set_cursor(mydisplay,mywindow,GOOD);
	  LOCALBUSY = 0;
	  return;
	}
    

      else if (
	       (ZOOM_MODE==1)                         &&
	       (startzoomx <= xlimit)                 &&
	       (bevent->x  <= xlimit)                 &&
	       (bevent->x  >= (10-INFO_BUFFER))       &&
	       (startzoomx >= (10-INFO_BUFFER))       &&                        
	       (bevent->y  <= gry - (10-INFO_BUFFER)) &&
	       (startzoomy <= gry - (10-INFO_BUFFER)) &&
	       (bevent->y  >= gry - ylimit)           &&
	       (startzoomy >= gry - ylimit)
	       )
	{
	  if((ZOOM_MODE==1)&&(BAD_ZOOM==2))
	    {
	      
	      if(ZOOMDEBUG==1){printf("returning for abnormal zoom type 1\n"); }
	      LOCALBUSY = 0;
	      return;
	    }
	  else if(ZOOM_MODE==1){BAD_ZOOM=0;}
	  
	  line(startzoomx, gry-startzoomy, startzoomx,  gry-bevent->y);
	  line(startzoomx, gry-startzoomy, bevent->x,   gry-startzoomy);
	  line(bevent->x,  gry-bevent->y,  bevent->x,   gry-startzoomy);
	  line(bevent->x,  gry-bevent->y,  startzoomx,  gry-bevent->y);
	  set_cursor(mydisplay,mywindow,GOOD);
	}


      else if (
	       (PAN_MODE==1)                          &&
	       (startpanx <= xlimit)                 &&
	       (bevent->x  <= xlimit)                 &&
	       (bevent->x  >= (10-INFO_BUFFER))       &&
	       (startpanx >= (10-INFO_BUFFER))       &&                        
	       (bevent->y  <= gry - (10-INFO_BUFFER)) &&
	       (startpany <= gry - (10-INFO_BUFFER)) &&
	       (bevent->y  >= gry - ylimit)           &&
	       (startpany >= gry - ylimit)
	       )
	{
	  BAD_PAN=0;


	  panx = bevent->x - startpanx;
	  pany = (gry-bevent->y) - (gry-startpany);

	  



	  


	  


	  set_color (drawing_a, "White",(XtPointer)NULL);
	  XFillRectangle (XtDisplay (drawing_a), mywindow, mygc, 0, 0, width,height);

	  XCopyArea (mydisplay, pixmap, mywindow, mygc,
		     0, pany, width, height, panx, 0);

	  set_cursor(mydisplay,mywindow,GOOD);
	}


      else if (
	       (INFO_MODE==1)                           &&
	       ((BAD_INFO==0)||(BAD_INFO==2))           &&
	       (startzoomx <= xlimit)                   &&
	       (bevent->x  <= xlimit)                   &&
	       (bevent->x  >= (10-INFO_BUFFER))         &&
	       (startzoomx >= (10-INFO_BUFFER))         &&                        
	       (bevent->y  <= gry-(10-INFO_BUFFER))     &&
	       (startzoomy <= gry-(10-INFO_BUFFER))     &&
	       (bevent->y  >= gry - ylimit)             &&
	       (startzoomy >= gry - ylimit)
	       )
	{
	  BAD_INFO=0;
	  
	  line(startzoomx, gry-startzoomy, startzoomx,  gry-bevent->y);
	  line(startzoomx, gry-startzoomy, bevent->x,   gry-startzoomy);
	  line(bevent->x,  gry-bevent->y,  bevent->x,   gry-startzoomy);
	  line(bevent->x,  gry-bevent->y,  startzoomx,  gry-bevent->y);
	  set_cursor(mydisplay,mywindow,GOOD);
	}
      else
	{

	  if(
		  ((PAN_MODE==1)&&( (startpanx<10) || (startpany<10) ))  ||
		  ((startzoomx<10)||(startzoomy<10))
		  )
	    {
	      
	      set_cursor(mydisplay,mywindow,GOOD);
	    }
	  else
	    {
		  
	      set_cursor(mydisplay,mywindow,PIRATE);
	    }

	  if(ZOOM_MODE==1)
	    {
	      BAD_ZOOM=1;
	      if(ZOOMDEBUG==1)
		{
		  printf("BAD MOTION\n");
		}
	    }
	  else if((INFO_MODE==1)&&(BAD_INFO==0))
	    {
	      BAD_INFO=2; 
	    }
	}
    }
  
  else if (!(strcmp (myarg, "mid_up"))) 
    {
      set_cursor(mydisplay,mywindow,GOOD);
      
      if(DIST_MODE==1)
	{
	  if(DEBUG==1){printf("DONE with distance.\n");}
	  
	  

	  LOCALBUSY = 0;
	  return;
	}
      
      if(FAN_MODE==1)
	{
	  if(BAD_FAN==1)
	    {
	      LOCALBUSY = 0;
	      return;
	    }
	  
	  si = sin(0.0174532 * FAN_ANGLE/2.0);
	  co = cos(0.0174532 * FAN_ANGLE/2.0);
	  
	  xleft = (bevent->x-startx)*co - (bevent->y-starty)*si;
	  yleft = (bevent->x-startx)*si + (bevent->y-starty)*co;
	  
	  xleft = xleft+startx;
	  yleft = yleft+starty;
	  
	  si = sin(-0.0174532 * FAN_ANGLE/2.0);
	  co = cos(-0.0174532 * FAN_ANGLE/2.0);
	  
	  xright = (bevent->x-startx)*co - (bevent->y-starty)*si;
	  yright = (bevent->x-startx)*si + (bevent->y-starty)*co;
	  
	  xright = xright+startx;
	  yright = yright+starty;
	  
	  colorpixLine(startx, gry-starty,(int)  xleft, gry-(int)yleft, mycolors[DRAW_COLOR_BLACK]);
	  colorpixLine(startx, gry-starty,(int) xright, gry-(int)yright,mycolors[DRAW_COLOR_BLACK]);
	  
	  myradius = EuclideanDistance((double)((double)(startx-10)/xunits)*IRegionSize,
			      (double)((double)(gry-starty-10)/yunits)*IRegionSize,
			      (double)((double)(bevent->x-10)/xunits)*IRegionSize,
			      (double)((double)(gry-bevent->y-10)/yunits)*IRegionSize);

	  myradius=myradius*2;
	  myradius=myradius*xunits/IRegionSize;
	  
	  tempangle= acos(EuclideanDistance((double)startx,(double)starty,
				   (double)bevent->x,starty)/ (myradius/2.0));
	  
	  if((bevent->x >= startx)&&(bevent->y <=starty))
	    {startangle= (  (tempangle) / (MYPI/2.0))*90.0*64.0;}
	  else if((bevent->x <= startx)&&(bevent->y <=starty))
	    {startangle = 90.0*64.0 - (  (tempangle) / (MYPI/2.0))*90.0*64.0 + 90.0*64.0;}
	  else if((bevent->x <= startx)&&(bevent->y >=starty))
	    {startangle= (  (tempangle) / (MYPI/2.0))*90.0*64.0  + 180.0*64.0;}
	  else if((bevent->x >= startx)&&(bevent->y >=starty))
	    {startangle= 90.0*64.0 - (  (tempangle) / (MYPI/2.0))*90.0*64.0 + 270.0*64.0;}
	  
	  XCopyArea (mydisplay, pixmap, mywindow, mygc,
		     0, 0, width, height, 0, 0);
	  
	  startangle = startangle-((FAN_ANGLE*64)/2.0);
	  if(startangle<0){startangle=startangle+360.0*64.0;}
	  
	  XDrawArc(mydisplay,mywindow,mygc,
		   startx-(int)(myradius/2.0),starty-(int)(myradius/2.0),
		   (unsigned int)myradius,(unsigned int)myradius,(int)startangle,(int)(FAN_ANGLE*64.0));
	  
	  XDrawArc(mydisplay,pixmap,mygc,
		   startx-(int)(myradius/2.0),starty-(int)(myradius/2.0),
		   (unsigned int)myradius,(unsigned int)myradius,(int)startangle,(int)(FAN_ANGLE*64.0));
	  
	  XFlush (mydisplay);
	  
	  set_cursor(mydisplay,mywindow,WATCH);
	  BUSY=1;
	  
	  
	  NO_CIRCLES = 1;
	  CalcLOSfan(
		     (double)((double)(startx-10)/xunits)*IRegionSize + llx_zoom,
		     (double)((double)(gry-starty-10)/yunits)*IRegionSize + lly_zoom, 
		     (double)((double)(bevent->x-10)/xunits)*IRegionSize + llx_zoom,
		     (double)((double)(gry-bevent->y-10)/yunits)*IRegionSize + lly_zoom 
		     );
	  NO_CIRCLES = 0;
	  
	  cleanse_events();
	  BUSY=0;
	  set_cursor(mydisplay,mywindow,GOOD);
	  LOCALBUSY = 0;
	  return;
	}
      
      if(PROFILE_MODE==1)
	{	  
	  if(BAD_PROFILE==1)
	    {
	      LOCALBUSY = 0;
	      return;
	    }
	  
	  if((pro_begx>=0)&&(pro_begy>=0))
	    {
	      

          
		  MySetLineThickness(2);
          XDrawLine(mydisplay,mywindow,mygc,pro_begx,pro_begy,bevent->x,bevent->y);
          XDrawLine(mydisplay,pixmap,  mygc,pro_begx,pro_begy,bevent->x,bevent->y);
          MySetLineThickness(0);

	      set_cursor(mydisplay,mywindow,WATCH);



		  SetUpProfileLayers(1);

	      CreateDrawProfile
		(
		 (double)((double)(pro_begx-10)/xunits)*IRegionSize + llx_zoom,  
		 (double)((double)(gry-pro_begy-10)/yunits)*IRegionSize + lly_zoom,  
		 (double)((double)(bevent->x-10)/xunits)*IRegionSize + llx_zoom,
		 (double)((double)(gry-bevent->y-10)/yunits)*IRegionSize +lly_zoom,
		 &min,&max
		 ); 
		  
		  SetUpProfileLayers(2);

	      cleanse_events();
	      set_cursor(mydisplay,mywindow,GOOD);
	      
	      if(
		 ( (double)((double)(pro_begx-10)/xunits)*IRegionSize)  
		 <=
		 ( (double)((double)(bevent->x-10)/xunits)*IRegionSize) 
		 )
		{i_nvert = 0;}
	      
	      dist = Distance
		(
		 (double)((double)(pro_begx-10)/xunits)*IRegionSize + llx_zoom,
		 (double)((double)(gry-pro_begy-10)/yunits)*IRegionSize + lly_zoom, 
		 (double)((double)(bevent->x-10)/xunits)*IRegionSize + llx_zoom,
		 (double)((double)(gry-bevent->y-10)/yunits)*IRegionSize + lly_zoom 
		 );

	      if((ProfileRoot==NULL)||(DrawProfileRoot==NULL))
		{
		  if(NGA_TYPE==1)
		    {
		      not_while_running
			(drawing_a,"No elevation data found under the profile line.",1231,"No polys",1);
		    }
		  else
		    {		    
		      not_while_running
			(drawing_a,"No polys found under the profile line.",1232,"No polys",1);
		    }
		  LOCALBUSY = 0;
		  return;  
		}

	      if(dist < 0.01)
		{
		  not_while_running(drawing_a,"That profile is too short.",1233,"Too Short",1);
		  LOCALBUSY = 0;
		  return;  
		}
	      
	      if(ProfileRoot->next->next == NULL)
		{
		  singlePoly = 1;
		}
	      else
		{
		  singlePoly = 0;
		}

	      haveobs = GetPointElevation(
				(double)((double)(pro_begx-10)/xunits)*IRegionSize + 
				llx_zoom,
				(double)((double)(gry-pro_begy-10)/yunits)*IRegionSize + 
				lly_zoom,
				&obsht );
	      
	      tempheight = (long int) (obsht * 100.0);
	      obsht = ((double) tempheight) / 100.0;
	      
	      havetgt = GetPointElevation(
				(double)((double)(bevent->x-10)/xunits)*IRegionSize+ 
				llx_zoom,
				(double)((double)(gry-bevent->y-10)/yunits)*IRegionSize+ 
				lly_zoom,
				&tgtht );
	      
	      if(ProfileRoot->next!=NULL)
		{
		  if(ProfileRoot->next->next!=NULL)
		    {
		      if(DEBUG==1)
			{printf("First 3 are: %lf %lf %lf %lf %lf %lf\n",
				ProfileRoot->dist,ProfileRoot->elev,
				ProfileRoot->next->dist,ProfileRoot->next->elev,
				ProfileRoot->next->next->dist,ProfileRoot->next->next->elev);
			}
		    }
		}
	      obsht = obsht + OBS_HEIGHT;
	      
	      tempheight = (long int) (tgtht * 100.0);
	      tgtht = ((double) tempheight) / 100.0;
	      
	      tgtht = tgtht + TGT_HEIGHT;
	      
	      if(DEBUG==1){printf("max %lf min %lf TGT %lf OBS %lf\n",max,min,TGT_HEIGHT,OBS_HEIGHT);}

	      zrange = fabs(min-max);

	      if(zrange<0.5)
		{
		  min = min - zrange;
		  max = max + zrange;
		}
	      else
		{
		  min = min-2;
		  max = max+1.0;
		}
	      if(LOS==1)
		{
		  max = max + mydmax(TGT_HEIGHT,OBS_HEIGHT);
		}


	      if(DEBUG==1){printf("max %lf min %lf TGT %lf OBS %lf\n",max,min,TGT_HEIGHT,OBS_HEIGHT);}
	      

	      xscale = (490.0/dist);
	      yscale = (260.0/(max-min));
	      
	      if(DEBUG==1)
		{
		  printf("xscale: %lf yscale: %lf dist: %lf max: %lf min: %lf\n",
			 xscale,yscale,dist,max, min);
		}
	      if((xscale<yscale)&&(ACTUAL==1))
		{
		  mid=(max-min)/2 + min;
		  yscale=xscale;
		  max = 130.0/yscale + mid;
		  min = mid - 130/yscale;
		  if(DEBUG==1){printf("min: %lf max: %lf mid: %lf\n",min,max,mid);}
		}
	      


	      if((ACTUAL==1)&&(LOS==0))
		{
		  sprintf(message,"NON-Exaggerated Profile");
		}
	      else if((ACTUAL==0)&&(LOS==0))
		{
		  sprintf(message,"Vertically Exaggerated Profile");
		}
	      else if(LOS==1)
		{
		  sprintf(message,"Vertically Exaggerated LOS...Observer AGL: %.2lf Target AGL: %.2lf",
			  OBS_HEIGHT,TGT_HEIGHT);
		}


	      


	      if(P_window==0)
		{
		  ProfileSetup();
		  P_window=1;
		  XtVaSetValues(Profile_drawing,XmNtitle,message,NULL); 
		}
	      else
		{
		  
		  

		  if(DEBUG==1){printf("popping up existing profile window\n");}
		  XtVaSetValues(Profile_drawing,XmNtitle,message,NULL); 

		  ResetWidget(Profile_drawing);
		}
	      




	      XSetForeground(XtDisplay (Profile_draw),mygc,mycolors[DRAW_COLOR_WHITE]);
	      XFillRectangle(XtDisplay (Profile_draw),Profile_pix,       mygc, 0, 0, 620,300);
	      XFillRectangle(XtDisplay (Profile_draw),XtWindow(Profile_draw),mygc,0,0,620,300);
	      XSetForeground(XtDisplay (Profile_draw),mygc,mycolors[DRAW_COLOR_BLACK]);
	      
	      
	      
	      XDrawLine(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,100,270,100,10);
	      XDrawLine(XtDisplay(Profile_draw),Profile_pix,      mygc,100,270,100,10);
	      XDrawLine(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,99,271,99,10);
	      XDrawLine(XtDisplay(Profile_draw),Profile_pix,      mygc,99,271,99,10);
	      
	      XDrawLine(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,100,270,590,270);
	      XDrawLine(XtDisplay(Profile_draw),Profile_pix,      mygc,100,270,590,270);
	      XDrawLine(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,99,271,590,271);
	      XDrawLine(XtDisplay(Profile_draw),Profile_pix,      mygc,99,271,590,271);
	      
	      XDrawLine(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,95,10,105,10);
	      XDrawLine(XtDisplay(Profile_draw),Profile_pix,      mygc,95,10,105,10);
	      
	      XDrawLine(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,95,75,105,75);
	      XDrawLine(XtDisplay(Profile_draw),Profile_pix,      mygc,95,75,105,75);
	      
	      XDrawLine(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,95,140,105,140);
	      XDrawLine(XtDisplay(Profile_draw),Profile_pix,      mygc,95,140,105,140);
	      
	      XDrawLine(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,95,205,105,205);
	      XDrawLine(XtDisplay(Profile_draw),Profile_pix,      mygc,95,205,105,205);
	      
	      
	      
	      
	      if(zrange<0.5)
		{
		  sprintf(c,"%.2lf",(double)min);
		  XDrawString(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,
			      (50-strlen(c)*5),270+6,c,(int)strlen(c));
		  XDrawString(XtDisplay(Profile_draw),Profile_pix,mygc,
			      (50-strlen(c)*5),270+6,c,(int)strlen(c));
		  
		  sprintf(c,"%.2lf",(double)((max-min)/4.0)+(double)min);
		  XDrawString(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,
			      (50-strlen(c)*5),270-65+6,c,(int)strlen(c));
		  XDrawString(XtDisplay(Profile_draw),Profile_pix,mygc,
			      (50-strlen(c)*5),270-65+6,c,(int)strlen(c));
		  
		  sprintf(c,"%.2lf",(double)((max-min)/2.0)+(double)min);
		  XDrawString(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,
			      (50-strlen(c)*5),270-65*2+6,c,(int)strlen(c));
		  XDrawString(XtDisplay(Profile_draw),Profile_pix,mygc,
			      (50-strlen(c)*5),270-65*2+6,c,(int)strlen(c));
		  
		  sprintf(c,"%.2lf",(double)(3.0*(max-min)/4.0)+(double)min);
		  XDrawString(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,
			      (50-strlen(c)*5),270-65*3+6,c,(int)strlen(c));
		  XDrawString(XtDisplay(Profile_draw),Profile_pix,mygc,
			      (50-strlen(c)*5),270-65*3+6,c,(int)strlen(c));
		  
		  sprintf(c,"%.2lf",(double)(max));
		  XDrawString(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,
			      (50-strlen(c)*5),270-65*4+6,c,(int)strlen(c));
		  XDrawString(XtDisplay(Profile_draw),Profile_pix,mygc,
			      (50-strlen(c)*5),270-65*4+6,c,(int)strlen(c));		  
		}
	      else
		{
		  sprintf(c,"%.1lf",(double)min);
		  XDrawString(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,
			      (50-strlen(c)*5),270+6,c,(int)strlen(c));
		  XDrawString(XtDisplay(Profile_draw),Profile_pix,mygc,
			      (50-strlen(c)*5),270+6,c,(int)strlen(c));
		  
		  sprintf(c,"%.1lf",(double)((max-min)/4.0)+(double)min);
		  XDrawString(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,
			      (50-strlen(c)*5),270-65+6,c,(int)strlen(c));
		  XDrawString(XtDisplay(Profile_draw),Profile_pix,mygc,
			      (50-strlen(c)*5),270-65+6,c,(int)strlen(c));
		  
		  sprintf(c,"%.1lf",(double)((max-min)/2.0)+(double)min);
		  XDrawString(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,
			      (50-strlen(c)*5),270-65*2+6,c,(int)strlen(c));
		  XDrawString(XtDisplay(Profile_draw),Profile_pix,mygc,
			      (50-strlen(c)*5),270-65*2+6,c,(int)strlen(c));
		  
		  sprintf(c,"%.1lf",(double)(3.0*(max-min)/4.0)+(double)min);
		  XDrawString(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,
			      (50-strlen(c)*5),270-65*3+6,c,(int)strlen(c));
		  XDrawString(XtDisplay(Profile_draw),Profile_pix,mygc,
			      (50-strlen(c)*5),270-65*3+6,c,(int)strlen(c));
		  
		  sprintf(c,"%.1lf",(double)(max));
		  XDrawString(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,
			      (50-strlen(c)*5),270-65*4+6,c,(int)strlen(c));
		  XDrawString(XtDisplay(Profile_draw),Profile_pix,mygc,
			      (50-strlen(c)*5),270-65*4+6,c,(int)strlen(c));
		  
		}




	      XDrawLine(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,222,265,222,275);
	      XDrawLine(XtDisplay(Profile_draw),Profile_pix,           mygc,222,265,222,275);
	      
	      XDrawLine(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,345,265,345,275);
	      XDrawLine(XtDisplay(Profile_draw),Profile_pix,           mygc,345,265,345,275);
	      
	      XDrawLine(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,467,265,467,275);
	      XDrawLine(XtDisplay(Profile_draw),Profile_pix,           mygc,467,265,467,275);
	      
	      XDrawLine(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,590,265,590,275);
	      XDrawLine(XtDisplay(Profile_draw),Profile_pix,           mygc,590,265,590,275);
	      
	      if(dist>1)
		{
		  sprintf(c,"%.1lf",0.0);
		  sprintf(c1,"%.1lf",(double)(dist/4.0));
		  sprintf(c2,"%.1lf",(double)(dist/2.0));
		  sprintf(c3,"%.1lf",(double)(3.0*(dist)/4.0));
		  sprintf(c4,"%.1lf",(double)dist);
		}
	      else
		{
		  sprintf(c, "%.2lf",0.0);
		  sprintf(c1,"%.2lf",(double)(dist/4.0));
		  sprintf(c2,"%.2lf",(double)(dist/2.0));
		  sprintf(c3,"%.2lf",(double)(3.0*(dist)/4.0));
		  sprintf(c4,"%.2lf",(double)dist);
		}
	      
	      XDrawString(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,
			  (100+6-strlen(c)*5),290,c,(int)strlen(c));
	      XDrawString(XtDisplay(Profile_draw),Profile_pix,mygc,
			  (100+6-strlen(c)*5),290,c,(int)strlen(c));
	      
	      XDrawString(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,
			  (100+122+6-strlen(c1)*5),290,c1,(int)strlen(c1));
	      XDrawString(XtDisplay(Profile_draw),Profile_pix,mygc,
			  (100+122+6-strlen(c1)*5),290,c1,(int)strlen(c1));
	      
	      XDrawString(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,
			  (100+245+6-strlen(c2)*5),290,c2,(int)strlen(c2));
	      XDrawString(XtDisplay(Profile_draw),Profile_pix,mygc,
			  (100+245+6-strlen(c2)*5),290,c2,(int)strlen(c2));
	      
	      XDrawString(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,
			  (100+367+6-strlen(c3)*5),290,c3,(int)strlen(c3));
	      XDrawString(XtDisplay(Profile_draw),Profile_pix,mygc,
			  (100+367+6-strlen(c3)*5),290,c3,(int)strlen(c3));
	      
	      XDrawString(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,
			  (100+490+5-strlen(c4)*5 -10),290,c4,(int)strlen(c4));
	      XDrawString(XtDisplay(Profile_draw),Profile_pix,mygc,
			  (100+490+5-strlen(c4)*5 -10),290,c4,(int)strlen(c4));

	      
	      
	      
	      
	      
	      if(DEBUG==1){printf("MAX: %lf MIN: %lf\n",max,min);}
	      
	      pp = cp = DrawProfileRoot;
	      bad=0;	
	      if(i_nvert == 1)
		{
		  xscale = -xscale;
		  Addin = 590;
		}
	      else
		{
		  Addin = 100;    
		}

	      while(cp != NULL)
		{

          

		  if(pp->ptype < 999)
		    {

		      tempint = (int) AssignDrawingColor(
				  -1, 
				  (unsigned char)pp->ptype , 
				  pp->LLindex); 
		      
		      XSetForeground(mydisplay,mygc,mycolors[239]);

		      XDrawLine(XtDisplay(Profile_draw),Profile_pix, mygc,
				(int)(Addin+xscale*pp->dist),(int)(10+(max-pp->elev)*yscale),
				(int)(Addin+xscale*cp->dist),(int)(10+(max-cp->elev)*yscale));
		      
		      XDrawLine(XtDisplay(Profile_draw),XtWindow(Profile_draw), mygc,
				(int)(Addin+xscale*pp->dist),(int)(10+(max-pp->elev)*yscale),
				(int)(Addin+xscale*cp->dist),(int)(10+(max-cp->elev)*yscale));
		    }
		  pp = cp;
		  cp = cp->next;
		}
	      
	      cp = DrawProfileRoot;
              while(cp != NULL)
		{
		  pp = cp;
		  cp = cp->next;
		  free(pp);
		}
	      
	      pp = cp = ProfileRoot;
	      bad = 0;
	      minXint = dist + 1;
	      minYint = tgtht;
	      
	      
	      if((LOS==1)&&(cp!=NULL)&&(singlePoly==0))
		  { 
            if(haveobs==0)
			{
              bad = 3;
			}
		    else if(havetgt==0)
			{ 
              bad = 2;
			}
		    else
			{ 
		      while(cp != NULL)
			  { 
		        if((pp != cp) && 
			       (pp->ptype < 999) && 
			       (minXint > pp->dist) 
			       
			      )
				{
			      if( LineSegmentsIntersect(   0.0,obsht,dist,tgtht,
						       pp->dist,pp->elev,cp->dist,cp->elev,
						     &intersectx,&intersecty))
				  {
			        if(intersectx < minXint)
					{
				      minXint = intersectx;
				      minYint = intersecty;
					}   
			        bad = 1;
				  }   
				}  
		        pp = cp;
		        cp = cp->next;
			  }  
			}  
		  } 

	      cp = ProfileRoot;
	      while(cp != NULL)
		{
		  pp = cp;
		  cp = cp->next;
		  free(pp);
		}
	      
	      if(LOS==1)
		{
          if(bad==2)
		  {
            sprintf(help1,"No LOS line drawn because the target location is not within an active DEM");
            XDrawString(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,150,20,help1,(int)strlen(help1));
            XDrawString(XtDisplay(Profile_draw),Profile_pix,           mygc,150,20,help1,(int)strlen(help1));
		  }
		  else if(bad==3)
		  {
            sprintf(help1,"No LOS line drawn because the observer location is not within an active DEM");
            XDrawString(XtDisplay(Profile_draw),XtWindow(Profile_draw),mygc,150,20,help1,(int)strlen(help1));
            XDrawString(XtDisplay(Profile_draw),Profile_pix,           mygc,150,20,help1,(int)strlen(help1));
		  }
		  else if(bad==1)
		    {
		      XSetForeground(mydisplay,mygc,mycolors[DRAW_COLOR_LTGREEN]); 
		      
		      XDrawLine(XtDisplay(Profile_draw),Profile_pix, mygc,
				(int)(Addin+xscale*minXint),
				(int)(10+(max-minYint)*yscale),
				(int)(Addin),
				(int)(10+(max-obsht)*yscale));
		      
		      XDrawLine(XtDisplay(Profile_draw),XtWindow(Profile_draw), mygc,
				(int)(Addin+xscale*minXint),
				(int)(10+(max-minYint)*yscale),
				(int)(Addin),
				(int)(10+(max-obsht)*yscale));
		      
		      XSetForeground(mydisplay,mygc,mycolors[DRAW_COLOR_RED]);  
		      
		      XDrawLine(XtDisplay(Profile_draw),Profile_pix, mygc,
				(int)(Addin+xscale*minXint),
				(int)(10+(max-minYint)*yscale),
				(int)(Addin + xscale*dist),
				(int)(10+(max-tgtht)*yscale));

		      XDrawLine(XtDisplay(Profile_draw),XtWindow(Profile_draw), mygc,
				(int)(Addin+xscale*minXint),
				(int)(10+(max-minYint)*yscale),
				(int)(Addin + xscale*dist),
				(int)(10+(max-tgtht)*yscale));
		      
		      bad = 1;
		      if(DEBUG==1){printf("got %lf %lf\n",minXint,minYint);}
		    }
		  else if(bad==0)
		    {
		      
		      
		      XSetForeground(mydisplay,mygc,mycolors[DRAW_COLOR_LTGREEN]);
		      
		      XDrawLine(XtDisplay(Profile_draw),Profile_pix, mygc,
				(int)(Addin), (int)(10+(max-obsht)*yscale),
				(int)(Addin+xscale*dist),(int)(10+(max-tgtht)*yscale));
		      
		      XDrawLine(XtDisplay(Profile_draw),XtWindow(Profile_draw), mygc,
				(int)(Addin), (int)(10+(max-obsht)*yscale),
				(int)(Addin+xscale*dist),(int)(10+(max-tgtht)*yscale));
		    }
		}
	      set_color(drawing_a,"Black",(XtPointer)NULL);
	    }
	  pro_begx = -1;
	  pro_begy = -1;
	  LOCALBUSY = 0;
	  return;
	}
    
      if(INFO_MODE==1)  
	{
	  
	  

	  if(RESETINFOLIST==1)
	    {
	      if(info_window_up==1)
		{
		  
		  FreeInfoList();

		  
		  TransferCleanPixmap();
		}
	    }

	  if(BAD_INFO>0)
	    {
	      if(DEBUG==1)
		{
		  printf("bad info\n");
		}
	      LOCALBUSY = 0;
	      return;
	    }
	  
	  inx = startzoomx;
	  iny = height - startzoomy;
	  outx = bevent->x;
	  outy = height - bevent->y;
	  
	  if(inx<10){inx=10;}
	  if(iny<10){iny=10;}
	  if(outx<10){outx=10;}
	  if(outy<10){outy=10;}
	  

	  if(DEBUG==1){printf("We get info on box %d %d %d %d\n",inx-10,iny-10,outx-10,outy-10);}
	  
	  testx1=(double)((double)(IRegionSize/xunits)*(double)(inx-10));
	  testy1=(double)((double)(IRegionSize/yunits)*(double)(iny-10));
	  testx2=(double)((double)(IRegionSize/xunits)*(double)(outx-10));
	  testy2=(double)((double)(IRegionSize/yunits)*(double)(outy-10));

	  if(testx1<testx2){testx1=testx2-testx1;}else{testx1=testx1-testx2;}
	  if(testy1<testy2){testy1=testy2-testy1;}else{testy1=testy1-testy2;}
	  

	  


	  if(DEBUG==1){printf("Entering Describe region content....\n");}
	  
	  DO_DESCRIBE = 1;
      set_cursor(mydisplay,mywindow,WATCH);
	  
	  
	  if((inx==outx)&&(iny==outy))
	    {
	      


	      

	      InfoItemsQueried = 0;
	      SPECIAL_VERTEX   = -1;
		  NO_QUERY         = 1;

	      DescribeRegionContents
		( 
		 (double)((double)(IRegionSize/xunits)*(double)((inx-10)-5))+ llx_zoom,
		 (double)((double)(IRegionSize/yunits)*(double)((iny-10)-5))+ lly_zoom,
		 (double)((double)(IRegionSize/xunits)*(double)((outx-10)+5))+llx_zoom,
		 (double)((double)(IRegionSize/yunits)*(double)((outy-10)+5))+lly_zoom,
		 1
		 );

		  NO_QUERY         = 0;

		  HandlePostDescribe();
	    }
	  else
	    {
	      
	      

	      

	      
	      InfoItemsQueried = 0;
	      SPECIAL_VERTEX   = -1;
   		  NO_QUERY         = 1;

	      DescribeRegionContents
		( 
		 (double)((double)(IRegionSize/xunits)*(double)(inx-10))  + llx_zoom,
		 (double)((double)(IRegionSize/yunits)*(double)(iny-10))  + lly_zoom,
		 (double)((double)(IRegionSize/xunits)*(double)(outx-10)) + llx_zoom,
		 (double)((double)(IRegionSize/yunits)*(double)(outy-10)) + lly_zoom,
		 0
		 );
	      
		  NO_QUERY         = 0;
  		  HandlePostDescribe();


	      if(
		 (InfoItemsQueried==0)  &&
		 (InfoRoot==NULL)       &&
		 (info_window_up==1)
		 )
		{
		  
		  XtDestroyWidget(infohead);
		}
	    }

	  
	  

	  DO_DESCRIBE = 0;
	  
	  if(DEBUG==1){printf("....back\n");}
	  


  	  if(InfoItemsQueried>0)
	    {
	      ResetWidget(infohead);
	      XmUpdateDisplay(infohead);
	    }

      set_cursor(mydisplay,mywindow,GOOD);
	  LOCALBUSY = 0;
	  return;
	}
    
    

      if(PAN_MODE==1)
	{


	  if(BAD_PAN>0)
	    {
	      

	      printf("returning due to bad pan %d\n",BAD_PAN);

	      XCopyArea (mydisplay, pixmap, mywindow, mygc,
			 0, 0, width, height, 0, 0);
	      LOCALBUSY = 0;
          panx=-10000; pany=-10000; 
	      return;
	    }

	  if((abs(panx)<5)&&(abs(pany)<5))
	    {
	      printf("returning due to small pan %d %d\n",panx,pany);

	      XCopyArea (mydisplay, pixmap, mywindow, mygc,
			 0, 0, width, height, 0, 0);	      
	      LOCALBUSY = 0;
          panx=-10000; pany=-10000; 
	      return;
	    }


      if((panx>-5000)&&(pany>-5000)) 
	  {
	    PanScreen(panx,pany);
	  }
	  LOCALBUSY = 0;

      panx=-10000; pany=-10000; 

	  return;
	}





    
      if(ZOOM_MODE==1)
	{	  
	  if(ZOOMDEBUG==1)
	    {
	      printf("found BAD ZOOM? %d\n",BAD_ZOOM);
	    }
	  if(BAD_ZOOM==1)
	    {	      
	      LOCALBUSY = 0;
	      return;
	    }
	  if(BAD_ZOOM==2)
	    {
	      if(ZOOMDEBUG==1){printf("returning due to abnormal zoom\n");}
	      LOCALBUSY = 0;
	      return;
	    }
	  BAD_ZOOM=2;
	  if(DEBUG==1){printf("Not a bad zoom. start: %d %d\n",startzoomx,startzoomy);}
	  
	  
	  

	  
	  
	  XtVaGetValues (drawing_a, XmNwidth, &x1, XmNheight, &y1, NULL);
	  x1=x1-20; 
	  y1=y1-60;
	  
	  if(DEBUG==1){printf("xrange: %d yrange: %d\n",startzoomx-bevent->x,startzoomy-bevent->y);}

	
	  if( 
	     (abs(startzoomx-bevent->x)<5) &&
	     (abs(startzoomy-bevent->y)<5)
	     )
	    {
	      ZoomIt(startzoomx,startzoomy,2);
	      
	      

	      NOT_ZOOMED = 0;
	      LOCALBUSY = 0;
	      return;
	    }


	  NOT_ZOOMED = 0;


	  if(startzoomy>bevent->y)
	    {
	      tempint = startzoomy;
	      startzoomy = bevent->y;
	      bevent->y = tempint;
	      
	      tempint = startzoomx;
	      startzoomx = bevent->x;
	      bevent->x = tempint;
	    }


	  if(abs(startzoomx-bevent->x)<5)
	    {
	      if(startzoomx<=bevent->x)
		{
		  startzoomx = startzoomx - 2;
		  bevent->x = bevent->x + 2;
		}
	      else
		{
		  startzoomx = startzoomx + 2;
		  bevent->x = bevent->x - 2;
		}
	      
	    }
	
	  if(abs(startzoomy-bevent->y)<5)
	    {
	      if(startzoomy<=bevent->y)
		{
		  startzoomy = startzoomy - 2;
		  bevent->y = bevent->y + 2;
		}
	      else
		{
		  startzoomy = startzoomy + 2;
		  bevent->y = bevent->y - 2;
		}
	      
	    }
	
	  
	  
	  

	  set_shift(1);

	  
	  
	  
	  MAX_ZOOM   = 0;

	  xrange = (double)abs(startzoomx - bevent->x); 
	  yrange = (double)abs(startzoomy - bevent->y); 

	  

	  






	  
	  if((startzoomx<=12)&&(startzoomx<bevent->x))  
	    {
	      startzoomx = 7;
	    }
	  else if ((bevent->x<=12)&&(bevent->x<startzoomx))
	    {
	      bevent->x = 7;
	    }

	  if((startzoomy>bevent->y)&&(startzoomy>837))  
	    {
	      startzoomy = 843;
	    }
	  else if((bevent->y>startzoomy)&&(bevent->y>837))
	    {
	      bevent->y = 843;
	    }



	  
	  
	  if(DOALLCELLS==0){load_modules=0;}


	  	  
	  val1 = llx_zoom + (double)((double)(IRegionSize/xunits)*(double)(bevent->x -10.0));
	  val2 = lly_zoom + (double)((double)(IRegionSize/yunits)*(double)(height-bevent->y -10.0));
	  val3 = llx_zoom + (double)((double)(IRegionSize/xunits)*(double)(startzoomx-10.0));
	  val4 = lly_zoom + (double)((double)(IRegionSize/yunits)*(double)(height-startzoomy-10.0));

	  if(val1<val3)
	  {
        ErrLLX = val1;
		ErrURX = val3;
	  }
	  else
	  {
        ErrLLX = val3;
		ErrURX = val1;
	  }
	  if(val2<val4)
	  {
        ErrLLY = val2;
		ErrURY = val4;
	  }
	  else
	  {
        ErrLLY = val4;
		ErrURY = val2;
	  }

      SaveXScroll = ScrollPercent(1);
      SaveYScroll = ScrollPercent(2);

	  

	  SetZoomValues(ErrLLX,ErrLLY,ErrURX,ErrURY);

	  if(global_zoomed_too_far==1)
	  {
         PanScreen(GetIxmod()-((startzoomx+bevent->x)/2),
			 ((startzoomy+bevent->y)/2)-GetIymod());
         global_zoomed_too_far = 0;
		 LOCALBUSY = 0;
		 return;
	  }
	  else
	  {
	     
	   MakePixmap3();

	   set_color (drawing_a, "White",(XtPointer)NULL);
	   
	   XFillRectangle (XtDisplay (drawing_a), pixmap, mygc, 0, 0, x1+20,y1+60);
	   XFillRectangle (XtDisplay (drawing_a), mywindow, mygc, 0, 0, x1+20,y1+60);
	   set_color (drawing_a, "Black",(XtPointer)NULL); 
	  
	   if(GRID==1)
	    {
	      DrawGrid();
	    }

	   XFlush(mydisplay);
	   if(ZOOMDEBUG==1){printf("fromi, fromj, toi, toj: %d %d %d %d\n",FromI,FromJ,ToI,ToJ);}
	  }

	  
	}
	else
	{
	  SaveXScroll = ScrollPercent(1);
      SaveYScroll = ScrollPercent(2);
	}
      
      urx_zoom = llx_zoom+(1000.0/xunits)*IRegionSize;
      ury_zoom = lly_zoom+(850.0/yunits)*IRegionSize;
      
      SAVE_ZOOM_STATE(SaveXScroll,SaveYScroll); 
      DrawAll();
    }
  
  else if (!(strcmp (myarg, "right_down"))) 
    {
      if(DIST_MODE==1)   
	  {
		 if(num_dist_pts>0)
		 {
	       AddDistVertex(bevent->x,bevent->y,1);
		   LOCALBUSY = 0; 
		   return;
		 }
	  }

	  if( (dead_error==0)  || (dead_obhead[current_ob_head]==0) ) 
	  {
	    if(bevent!=NULL)
	    {
	      PopHighMenu(bevent);
	    }
	  }
      else if(PROFILE_MODE==1){	LOCALBUSY = 0; return;}
      else if(FAN_MODE==1)    {	LOCALBUSY = 0; return;}
      else if(INFO_MODE==1)
	{

	  myx= bevent->x;
	  myy = height-bevent->y;
	  

	  UseDMScoordinates = IUseDMScoordinates;
	      
	  if(
	     (GetPointElevation(
				(double)((double)(IRegionSize/xunits)*(double)(myx-10))+ llx_zoom,
				(double)((double)(IRegionSize/yunits)*(double)(myy-10))+ lly_zoom
				,&zz        )==1))
	    {
	      
	      if(DEBUG==1){printf("llxzoom: %lf llyzoom: %lf myx: %d myy: %d\n",llx_zoom,lly_zoom,myx,myy);}
	      
	      sprintf(help,"%s: %s",help4,
		      Coordinate3DtoString(
					   (double)((double)(IRegionSize/xunits)*(double)(myx-10))+llx_zoom,
					   (double)((double)(IRegionSize/yunits)*(double)(myy-10))+lly_zoom,zz));
	    }
	  else
	    {
	      sprintf(help,"%s: %s",help4,
		      Coordinate2DtoString(
					   (double)((double)(IRegionSize/xunits)*(double)(myx-10))+llx_zoom,
					   (double)((double)(IRegionSize/yunits)*(double)(myy-10))+lly_zoom));
	    }
	  UseDMScoordinates = 0;
	    
	  t1 = XmStringCreateLtoR (help,"TAG5");
	  
	  XtVaSetValues(TEXT_HELP,XmNlabelString,t1,NULL); 
	  LOCALBUSY = 0;
	  return; 
	}
    }

  else if (!(strcmp (myarg, "right_motion"))) 
    {
      if(PROFILE_MODE==1){ LOCALBUSY = 0; return;}
      if(FAN_MODE==1)    { LOCALBUSY = 0; return;}
      if(DIST_MODE==1)   { LOCALBUSY = 0; return;}

      if(INFO_MODE==1)
	{
	  if(bevent!=NULL)
	    {
	      PopHighMenu(bevent);
	    }


	  myx= bevent->x;
	  myy= height-bevent->y;

	  if((myx<10)||(myx>=(xnum*xunits+10))||(myy<10)||(myy>ynum*yunits+10))
	    {
	      if(DEBUG==1){printf("Out of bounds\n");} 
	      set_cursor(mydisplay,mywindow,PIRATE);
	      LOCALBUSY = 0;
	      return;
	    }
	
	  set_cursor(mydisplay,mywindow,GOOD);


	  UseDMScoordinates = IUseDMScoordinates;

	  if(GetPointElevation(
			       (double)((double)(IRegionSize/xunits)*(double)(myx-10))+llx_zoom,
			       (double)((double)(IRegionSize/yunits)*(double)(myy-10))+lly_zoom,
			       &zz)==0)
	    {	      
	      sprintf(help,"%s: %s                                       ",help4,
		      Coordinate2DtoString(
					   (double)((double)(IRegionSize/xunits)*(double)(myx-10))+llx_zoom,
					   (double)((double)(IRegionSize/yunits)*(double)(myy-10))+lly_zoom));  
	    }
	  else
	    {	  
	      sprintf(help,"%s: %s                                       ",help4,
		      Coordinate3DtoString(
					   (double)((double)(IRegionSize/xunits)*(double)(myx-10))+llx_zoom,
					   (double)((double)(IRegionSize/yunits)*(double)(myy-10))+lly_zoom,zz     
					   ));
	    }

	  UseDMScoordinates = 0;

	  t1 = XmStringCreateLtoR (help,"TAG5");
	  
	  XtVaSetValues(TEXT_HELP,XmNlabelString,t1,NULL); 	  
	}
    }
  
  else if (!(strcmp (myarg, "right_up"))) 
    {
      set_cursor(mydisplay,mywindow,GOOD);
      
      if(PROFILE_MODE==1){ LOCALBUSY = 0; return;}
      if(FAN_MODE==1)    { LOCALBUSY = 0; return;}
      if(DIST_MODE==1)   { LOCALBUSY = 0; return;}
    }


  else if (!(strcmp (myarg, "zoom_out"))) 
    {

      set_color (drawing_a, "White",(XtPointer)NULL);
      
      XtVaGetValues (drawing_a, XmNwidth, &x1, XmNheight, &y1, NULL);
      
      XFillRectangle (XtDisplay (drawing_a), pixmap, mygc, 0, 0, x1+10,y1+10);
      XFillRectangle (XtDisplay (drawing_a), mywindow, mygc, 0, 0, x1+10,y1+10);
      
      set_color (drawing_a, "Black",(XtPointer)NULL);
      
      llx_zoom=0;
      lly_zoom=0;
      
      
      ResetZoom();
      
      xunits = mydmax((double)PixDBWidth,(double)PixDBHeight);
      yunits = xunits;




      if(SAVE_TOPCHANGE>0)
	  {
	   

	   
	   RebuildTopImage(0);
	  }



      
      
      
      XCopyArea (mydisplay, pixmap2, pixmap, mygc,
		 0, 0, width, height, 0, 0);
      
      
      
      XCopyArea (mydisplay, pixmap, mywindow, mygc,
		 0, 0, width, height, 0, 0);
      
      NOT_ZOOMED = 1;
      
      SaveCleanPixmap();

      
      ShowRegionMarkers();
      
      
      DrawTopGrid();
      

	  
      sprintf(help1,
	      "%s Current extents: %s",
	      help3,
	      MakeUString2());
      
      
      message2 = XmStringCreate (help1, "TAG5");
      XtVaSetValues(TEXT_HELP,XmNlabelString,message2,NULL);
      XmStringFree(message2);

      set_shift(-1);
      
      set_cursor(mydisplay,mywindow,WATCH);
      
      sen1 = 0;
      sen2 = 0;
      
      TurnOnAll(0,&sen1,&sen2,0,0);
      
      BUSY=1;
      
      ResetZoom();
      
      if(info_window_up==1)
	{
	  
	  choose_specific_info((Widget)NULL,(XtPointer)NULL,(XtPointer)0);
	}
      
      cleanse_events();

      FlushMainScreen(0); 
      
      
      if(ABORT_ZOOM==0)  
	{
	  MyDrawErrors();
	}
      
      if(ADD_HIST==1)
	{
	  SaveXScroll = ScrollPercent(1);
      SaveYScroll = ScrollPercent(2);

	  SAVE_ZOOM_STATE(SaveXScroll,SaveYScroll);
	}
      
      BUSY=0;
      set_cursor(mydisplay,mywindow,GOOD);
      TurnOnAll(1,&ijunk,&ijunk,sen1,sen2);
      
      
      if(CURRENT_ZOOM==SAVED_VIEWS-1)
	{
	  
	  XtSetSensitive(toolbar[0],False);
	}
      else
	{
	  
	  XtSetSensitive(toolbar[0],True);
	}
      
      
      if(CURRENT_ZOOM==0)
	{
	  
	  XtSetSensitive(toolbar[1],False);
	}
      else
	{
	  
	  XtSetSensitive(toolbar[1],True);
	}      
      LOCALBUSY = 0;
      return;
    }
  LOCALBUSY = 0;
}






int realinfoprint(char msg[], int reallyprintit)    
{
  static XmTextPosition wpr_position;
  
  if(reallyprintit==0)
    {
      return ((int)wpr_position);
    }
  if(reallyprintit==-1)
    {
      
      wpr_position = 0;
      return 1;
    }
  
  XmTextInsert (text_output2, wpr_position, msg);
  wpr_position = wpr_position + (long int)(strlen (msg));
  XtVaSetValues (text_output2, XmNcursorPosition, wpr_position, NULL);
  XmTextShowPosition (text_output2, wpr_position);

  return ((int)wpr_position);
}


void infoprint(char msg[])    
{
  int end;
  static long int last_redraw=0,ThisTime;

  end = realinfoprint(msg, 1);

  
  ThisTime = time(NULL);
  
  if((ThisTime-last_redraw)>0) 
    {      
      real_periodic_redraw();
      last_redraw = ThisTime;
    }
}


void infoprintbold(char msg[])    
{
  int start,end;
  

  start = realinfoprint(msg, 0);
  end   = realinfoprint(msg, 1);
  end   = end-1; 

  
  highlight_starts[num_highlights%HIGHLIGHTMAX] = start;
  highlight_ends  [num_highlights%HIGHLIGHTMAX] = end;
  
  num_highlights++;
  
  XmTextSetHighlight(text_output2,start,end,XmHIGHLIGHT_SELECTED);
}


void infoprintunderline(char msg[])    
{
  int start,end;
  
  start = realinfoprint(msg, 0);
  end   = realinfoprint(msg, 1);
  end   = end-1; 


  
  highlight_starts[num_highlights%HIGHLIGHTMAX] = -1*start;
  highlight_ends  [num_highlights%HIGHLIGHTMAX] = -1*end;
  
  num_highlights++;


  XmTextSetHighlight(text_output2,start,end,XmHIGHLIGHT_SECONDARY_SELECTED);
}



void PutImageOnPixmap2(int image_num, int x, int y, Pixmap target_pixmap)
{
  
  static char *globeinsen[] =
  {
    
    "16 16 24 1",
    
    "A c #808080",
    "B c #008000",
    "C c #336600",
    "D c #339900",
    "E c #006633",
    "F c #339933",
    "G c #33CC33",
    "H c #009966",
    "I c #339966",
    "J c #33FF66",
    "K c #336699",
    "L c #339999",
    "M c #33CC99",
    "N c #3366CC",
    "O c #0099CC",
    "P c #33CCCC",
    "Q c #808080",
    "R c #33FFCC",
    "S c #3333FF",
    "T c #3366FF",
    "U c #0099FF",
    "V c #3399FF",
    "W c #33CCFF",
    "X c #33FFFF",
    
    "AAAAAAAAAAAAAAAA",
    "AAAAAAQDQDAAAAAA",
    "AAAAGQDQBQUVAAAA",
    "AAAGQFQWQUQHTAAA",
    "AAAADQWQUQGQTAAA",
    "AAQRQWQPQHQTQDAA",
    "AAXQWQUQFQNQGQAA",
    "AAQMQUQUQQQGQBAA",
    "AAJQUQUQVQGQDQAA",
    "AAQJQOQUQIQBQBAA",
    "AAJQGQDQTQDQBQAA",
    "AAAGQDQTQTQCQAAA",
    "AAAGDQEQSQLQKAAA",
    "AAAAFBQSQSQTAAAA",
    "AAAAAATQTQAAAAAA",
    "AAAAAAAAAAAAAAAA",
  };


  XColor mycolor;
  unsigned int RR,GG,BB;
  unsigned long newcolors2[128];
  int cols,rows,i,j,Ncolors,imod,jmod;
  char numstring[20],junk[20],junk1[20],tempa;
  char **temp;
  

  

  
  if(image_num==1)
    {
      temp = globeinsen;
    }
  else
    {
      printf("bad image num 1 %d\n",image_num);
      ExitWrapper(-1);
    }

  imod = x;
  jmod = y;
  
  sscanf(temp[0],"%d%d%d",&cols,&rows,&Ncolors);
  
  for(i=1;i<=Ncolors;i++)
    {
      sscanf(temp[i],"%s%s%s",junk1,junk,numstring);
      sscanf(numstring,"%c%2x%2x%2x",&junk[0],&RR,&GG,&BB);
      
      sscanf(junk1,"%c",&tempa);

      mycolor.red   = 255*RR;
      mycolor.green = 255*GG;
      mycolor.blue  = 255*BB;
      
      
      if (!XAllocColor (mydisplay, cmap, &mycolor)) 
	{printf("Couldnt allocate some colors....continuing anyway\n");}
      
      newcolors2[(int)tempa] = mycolor.pixel;
    }
  
  
  
  for(i=0;i<rows;i++)
    {
      for(j=0;j<cols;j++)
	{	  
	  XSetForeground(mydisplay,mygc, newcolors2[(int)temp[i+Ncolors+1][j]]);
	  
	  XDrawPoint (mydisplay, target_pixmap , mygc, j+jmod, i+imod );
	  
	}
    }
  
  
}




void PutImageOnPixmap(int image_num, int x, int y, Pixmap target_pixmap)
{
  static char *globe[] =
  {
    
    "16 16 30 2",
    
    "AA c #008000",
    "BA c #000000",
    "CA c #336600",
    "DA c #339900",
    "EA c #006633",
    "FA c #009933",
    "GA c #339933",
    "HA c #33CC33",
    "IA c #009966",
    "JA c #339966",
    "KA c #33FF66",
    "LA c #336699",
    "MA c #339999",
    "NA c #33CC99",
    "OA c #99CC99",
    "PA c #66CC99",
    "AB c #3333CC",
    "BB c #3366CC",
    "CB c #0099CC",
    "DB c #3399CC",
    "EB c #33CCCC",
    "FB c #99CCCC",
    "GB c #33FFCC",
    "HB c #66FF99",
    "IB c #3333FF",
    "JB c #3366FF",
    "KB c #0099FF",
    "LB c #3399FF",
    "MB c #33CCFF",
    "NB c #33FFFF",
    
    "BABABABABABABABABABABABABABABABA",
    "BABABABABABAHADAHADABABABABABABA",
    "BABABABAHADADANAAADBKBLBBABABABA",
    "BABABAHAHAGAMBMBKBKBEBIAJBBABABA",
    "BABABAPADADBMBMBKBMBHABBJBBABABA",
    "BABAMBGBGAMBMBEBCBIADAJBPADABABA",
    "BABANBMBMBMBKBPAGAKBBBDBHADABABA",
    "BABAKANAMBKBKBKBDBFBOAHADAAABABA",
    "BABAKAHBKBKBKBKBLBOAHADADAAABABA",
    "BABAKAKAFACBCBKBJBJADAAAAAAABABA",
    "BABAKAHAHADADAJBJBBBDAAAAAAABABA",
    "BABABAHAHADADAJBJBJBABCAAABABABA",
    "BABABAHADADAEAIBIBIBMAABLABABABA",
    "BABABABAGAAAABIBIBIBAAJBBABABABA",
    "BABABABABABAJBJBJBJBBABABABABABA",
    "BABABABABABABABABABABABABABABABA",
  };



  XColor mycolor;
  unsigned int RR,GG,BB;
  unsigned long newcolors2[128][128];
  int cols,rows,i,j,Ncolors,imod,jmod;
  char numstring[20],junk[20],junk1[20],tempa,tempb;
  char **temp;
  extern char *gait_logo  [];
  

  

  
  if(image_num==1)
    {
      temp = gait_logo;
      y = y + 90/2;
      x = x + 30;
    }
  else if(image_num==2)
    {
      temp = globe;
    }
  else
    {
      printf("bad image num 2 %d\n",image_num);
      ExitWrapper(-1);
    }

  imod = x;
  jmod = y;
  
  sscanf(temp[0],"%d%d%d",&cols,&rows,&Ncolors);
  
  for(i=1;i<=Ncolors;i++)
    {
      sscanf(temp[i],"%s%s%s",junk1,junk,numstring);
      sscanf(numstring,"%c%2x%2x%2x",&junk[0],&RR,&GG,&BB);
      
      sscanf(junk1,"%c%c",&tempa,&tempb);
       

      mycolor.red   = 255*RR;
      mycolor.green = 255*GG;
      mycolor.blue  = 255*BB;

      
      if (!XAllocColor (mydisplay, cmap, &mycolor)) 
	{printf("Couldnt allocate some colors....continuing anyway\n");}
      
      newcolors2[(int)tempa][(int)tempb] = mycolor.pixel;
    }
  
  
  
  for(i=0;i<rows;i++)
    {
      for(j=0;j<cols*2;j=j+2)
	{	  
	  XSetForeground(mydisplay,mygc, newcolors2[(int)temp[i+Ncolors+1][j]][(int)temp[i+Ncolors+1][j+1]]);
	  
	  XDrawPoint (mydisplay, target_pixmap , mygc, j/2+jmod, i+imod );
	  
	}
    }
}


void read_logo()
{ 


#if(NGA_TYPE==1)
    {
      PutImageOnPixmap(1,0,0,pixmap);
    }

#else

  XColor mycolor;
  unsigned int RR,GG,BB;
  unsigned long newcolors[100];
  int cols,rows,i,j,Ncolors,ALLPICS,imod=0,jmod=0,otherjmod;  
  char numstring[20],junk[20];
  char **temp;
  extern char *dmso_logo  [];
  extern char *ida_logo   [];
  extern char *seeit_logo [];
  extern char *sedris_logo[];
  
  for(ALLPICS=1;ALLPICS<=4;ALLPICS++)
	{
	  if(ALLPICS==1)
	    {
	      temp = ida_logo;
	      imod = 435;
	      jmod = 550;
	    }
	  if(ALLPICS==2)
	    {
	      temp = dmso_logo;
	      imod = 475;
	      jmod = 50;
	    }
	  if(ALLPICS==3)
	    {
	      temp = seeit_logo;
	      imod = 245 + 23;
	      jmod = 163+30;  
	    }
	  if(ALLPICS==4)
	    {
	      temp = sedris_logo;
	      imod = 20 + 32;
	      jmod = 267+30;
	    }
	  
	  
	  sscanf(temp[0],"%d%d%d",&cols,&rows,&Ncolors);
	  
	  for(i=1;i<=Ncolors;i++)
	    {
	      sscanf(temp[i],"%s%s%s",junk,junk,numstring);
	      sscanf(numstring,"%c%2x%2x%2x",&junk[0],&RR,&GG,&BB);
	      
	      mycolor.red   = 255*RR;
	      mycolor.green = 255*GG;
	      mycolor.blue  = 255*BB;
	      if (!XAllocColor (mydisplay, cmap, &mycolor)) 
		{printf("Couldnt allocate some colors....continuing anyway\n");}
	      
	      newcolors[i] = mycolor.pixel;
	    }
      
	  
	  
	  
	  
	  
	  
	  
	  for(i=0;i<rows;i++)
	    {
	      otherjmod=0;
	      for(j=0;j<cols;j++)
		{
		  switch(temp[i+Ncolors+1][j-otherjmod])
		    {
		    case '.':   
		      continue;
		    case '!':   
		      otherjmod+=14;
		      j+=14;
		      continue;
		    case '@':
		      otherjmod+=4;
		      j+=4;
		      continue;
		    case '#':
		      XSetForeground(mydisplay,mygc, newcolors[2]);
		      break;
		    default:
		      XSetForeground(mydisplay,mygc, newcolors[ temp[i+Ncolors+1][j-otherjmod] - 94 ]);
		    }	      
		  XDrawPoint (mydisplay, pixmap , mygc, j+jmod, i+imod );
		}
	    }
	}
#endif      




  if(batch_mode==0){XtDestroyWidget(beg_dialog);}

  entry1 = XmFontListEntryLoad (mydisplay, 
				"-*-courier-*-r-*--*-60-*", XmFONT_IS_FONT, "TAG5");
  fontlist = XmFontListAppendEntry (NULL, entry1);  
  XmFontListEntryFree (&entry1);

  SetColorRight();
}







void help_shade_callback(Widget w,XtPointer data,XtPointer callData)
{
  not_while_running(XtParent(w),
"This dialog is used to control the Sun Angle, Sun Azimuth,\n\
and Vertical Exaggeration shown on the screen when drawing\n\
shaded reliefs.\n\nIt can also be used to control the quality\n\
of the shaded relief when zooming in beyond the top level.\n\
This may be useful for speed purposes.",1234,"Shade Parameters Help",5);
}





void Help_sdcsCallback(Widget w,XtPointer data,XtPointer callData)
{

  if(NGA_TYPE==1)
    {
      not_while_running(w,"This window can be used to look up definitions for\n\
Feature Types and Attributes.\n\n\
To view the definition of a Feature Type or Attribute,\n\
locate it in the appropriate list, and click on it. It's \n\
definition will be shown in the text area at the bottom of the window.\n\n\
Enumerated values will be displayed for those Attributes that\n\
have them.\n\n\
To search for a search string (case insensitive),\n\
type the search string in the test entry area, and then\n\
select the appropriate search button from the search choices.",1237,"Attribution Definition Help",5);  
    }
  else
    {
      not_while_running(w,"This window can be used to look up definitions for\n\
Environmental Classification Codes (ECCs) and Environmental Attribute\n\
Codes (EACs).\n\n\
To view the definition of an ECC or EAC,\n\
locate it's label in the appropriate list, and click on it. It's \n\
definition will be shown in the text area at the bottom of the window.\n\n\
Enumerated values will be displayed for those EAs that\n\
have them.\n\n\
To search the EDCS for a search string (case insensitive),\n\
type the search string in the test entry area, and then\n\
select the appropriate search button from the search choices.",1238,"Attribution Definition Help",5);  
    }
}



Widget BuildAttrMenu(Widget parent,int menu_type,char *menu_title,MenuItem *items)
{
  Widget menu, cascade, widget;
  int i,n=0;
  XmString str;
  Arg args[5];
  
  XtSetArg (args[n], XmNpacking,    XmPACK_COLUMN); n++;
  XtSetArg (args[n], XmNnumColumns,             2); n++;

  menu = XmCreatePulldownMenu (parent, "_pulldown", args, n);

  str = XmStringCreateLocalized (menu_title);

  n = 0;

  XtSetArg (args[n], XmNsubMenuId, menu);  n++;
  XtSetArg (args[n], XmNlabelString, str); n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;
  
  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);

  for (i = 0; items[i].label != NULL; i++) 
    {
      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);
      
      if(
	     ((i==0) &&(ATTRIBUTION_INFO_TYPE==2))  || 

	     ((i==1) &&(ATTRIBUTION_INFO_TYPE==4))  || 

	     ((i==2) &&(ATTRIBUTION_INFO_TYPE==6))  || 

	     ((i==3) &&(ATTRIBUTION_INFO_TYPE==7))  || 
	     ((i==4) &&(ATTRIBUTION_INFO_TYPE==8))  || 

	     ((i==5) &&(ATTRIBUTION_INFO_TYPE==12)) || 

	     ((i==6) &&(ATTRIBUTION_INFO_TYPE==10)) || 
	     ((i==7) &&(ATTRIBUTION_INFO_TYPE==14)) || 

	     ((i==8) &&(ATTRIBUTION_INFO_TYPE==39)) || 

	     ((i==9)&&(ATTRIBUTION_INFO_TYPE==43))  || 

	     ((i==10)&&(ATTRIBUTION_INFO_TYPE==27)) || 

	     ((i==11)&&(ATTRIBUTION_INFO_TYPE==261))|| 

	     ((i==12)&&(ATTRIBUTION_INFO_TYPE==45)) || 

	     ((i==13)&&(ATTRIBUTION_INFO_TYPE==29)) || 

	     ((i==14)&&(ATTRIBUTION_INFO_TYPE==47)) || 

	     ((i==15)&&(ATTRIBUTION_INFO_TYPE==24)) || 
	     ((i==16)&&(ATTRIBUTION_INFO_TYPE==26))    

	    )
	{
	  XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);
	}
      
      if (items[i].callback)
	XtAddCallback (widget,
		       (items[i].cclass == &xmToggleButtonWidgetClass ||
			items[i].cclass == &xmToggleButtonWidgetClass) ?
		       XmNvalueChangedCallback : 
		       XmNactivateCallback,      
		       (XtCallbackProc)items[i].callback, items[i].callback_data);
    }
  return menu_type == XmMENU_POPUP ? menu : cascade;
}








Widget BuildImportPulldownMenu2(Widget parent, char *menu_title, char menu_mnemonic, 
		   Boolean tear_off, MenuItem *items)
{
  Widget PullDown, cascade,widget;
  int i;
  XmString str;
  
  PullDown = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);


  str = XmStringCreateLocalized (menu_title);
  cascade = XtVaCreateManagedWidget (menu_title,
				     xmCascadeButtonWidgetClass, parent,
				     XmNsubMenuId,   PullDown,
				     XmNlabelString, str,
				     XmNmnemonic,    menu_mnemonic,
  				     XmNtranslations, XtParseTranslationTable (toptrans),
				     NULL);
  XmStringFree (str);
  for (i = 0; items[i].label != NULL; i++) 
    {
	  widget = XtVaCreateManagedWidget (items[i].label,
					      *items[i].cclass, PullDown,
					      NULL);

      if (items[i].callback)
	{

	  XtAddCallback(widget,
			(items[i].cclass == &xmToggleButtonWidgetClass ||
			 items[i].cclass == &xmToggleButtonWidgetClass) ?
			XmNvalueChangedCallback : 
			XmNactivateCallback,      
			(XtCallbackProc)items[i].callback, items[i].callback_data);
	}
    }
  return cascade;
}






Widget BuildImportMenu(Widget parent,int menu_type,char *menu_title,MenuItem *items)
{
  Widget menu, cascade, widget;
  int i,n=0;
  XmString str;
  Arg args[5];



  XtSetArg (args[n], XmNpacking,    XmPACK_COLUMN); n++;
  XtSetArg (args[n], XmNnumColumns,             2); n++;

  menu = XmCreatePulldownMenu (parent, "_pulldown", args, n);
  

  str = XmStringCreateLocalized (menu_title);

  n = 0;

  XtSetArg (args[n], XmNsubMenuId, menu);  n++;
  XtSetArg (args[n], XmNlabelString, str); n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;



  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);




  for (i = 0; items[i].label != NULL; i++) 
    {

      if (items[i].subitems)
	{
	  widget = BuildImportPulldownMenu2 (menu, items[i].label, 
					 items[i].mnemonic, False, items[i].subitems);
	  continue;
	}

      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);


      
      if(
	 ((i==0)  && (TEMP_ATTRIBUTION_TYPE==0))  || 
	 ((i==1)  && (TEMP_ATTRIBUTION_TYPE==1))  || 
	 ((i==2)  && (TEMP_ATTRIBUTION_TYPE==3))  || 
	 ((i==3)  && (TEMP_ATTRIBUTION_TYPE==5))  || 
	 ((i==4)  && (TEMP_ATTRIBUTION_TYPE==7))  || 
	 ((i==5)  && (TEMP_ATTRIBUTION_TYPE==8))  || 
	 ((i==6)  && (TEMP_ATTRIBUTION_TYPE==11)) || 
	 ((i==7)  && (TEMP_ATTRIBUTION_TYPE==9 )) || 
	 ((i==8)  && (TEMP_ATTRIBUTION_TYPE==13)) || 

	 ((i==9)  && (TEMP_ATTRIBUTION_TYPE==39)) || 

	 ((i==10) && (TEMP_ATTRIBUTION_TYPE==43)) || 

	 ((i==11) && (TEMP_ATTRIBUTION_TYPE==27)) || 

	 ((i==12) && (TEMP_ATTRIBUTION_TYPE==26)) || 

	 ((i==13) && (TEMP_ATTRIBUTION_TYPE==45)) || 

	 ((i==14) && (TEMP_ATTRIBUTION_TYPE==29)) || 

	 ((i==15) && (TEMP_ATTRIBUTION_TYPE==47)) || 

	 ((i==16) && (TEMP_ATTRIBUTION_TYPE==23)) || 
	 ((i==17) && (TEMP_ATTRIBUTION_TYPE==25))    
	 )
	{
	  XtVaSetValues(cascade,
			XmNmenuHistory, widget,
			NULL);
	}


      if (items[i].callback)
	XtAddCallback (widget,
		       (items[i].cclass == &xmToggleButtonWidgetClass ||
			items[i].cclass == &xmToggleButtonWidgetClass) ?
		       XmNvalueChangedCallback : 
		       XmNactivateCallback,      
		       (XtCallbackProc)items[i].callback, items[i].callback_data);
    }
  return menu_type == XmMENU_POPUP ? menu : cascade;
}








Widget BuildMenu(Widget parent,int menu_type,char *menu_title,MenuItem *items)
{
  Widget menu, cascade, widget;
  int i,n=0;
  XmString str;
  Arg args[5];
  
  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);
  
  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId, menu);  n++;
  XtSetArg (args[n], XmNlabelString, str); n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;

  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);
  
  for (i = 0; items[i].label != NULL; i++) 
    {
      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);
      

      if(!strcmp( items[i].label,"Red"))
	{
	  XtVaSetValues(widget,				
			XmNarmColor,          mycolors[DRAW_COLOR_RED],
			XmNbackground,        mycolors[DRAW_COLOR_RED],
			NULL);
	}
      else if(!strcmp( items[i].label,"Green"))
	{
	  XtVaSetValues(widget,				
			XmNarmColor,          mycolors[DRAW_COLOR_MEDGREEN],
			XmNbackground,        mycolors[DRAW_COLOR_MEDGREEN],
			NULL);
	}
      else if(!strcmp( items[i].label,"Blue"))
	{
	  XtVaSetValues(widget,				
			XmNarmColor,          mycolors[DRAW_COLOR_BLUE],
			XmNbackground,        mycolors[DRAW_COLOR_BLUE],
			NULL);
	}
      else if(!strcmp( items[i].label,"Yellow"))
	{
	  XtVaSetValues(widget,				
			XmNarmColor,          mycolors[DRAW_COLOR_YELLOW],
			XmNbackground,        mycolors[DRAW_COLOR_YELLOW],
			NULL);
	}
      else if(!strcmp( items[i].label,"S1000"))
	{
	  XtSetSensitive(widget,False);
	}
      else if(!strcmp( items[i].label,"Other..."))
	{
	  XtSetSensitive(widget,False);
 	}
      if (items[i].callback)
	XtAddCallback (widget,
		       (items[i].cclass == &xmToggleButtonWidgetClass ||
			items[i].cclass == &xmToggleButtonWidgetClass) ?
		       XmNvalueChangedCallback : 
		       XmNactivateCallback,      
		       (XtCallbackProc)items[i].callback, items[i].callback_data);
    }
  return menu_type == XmMENU_POPUP ? menu : cascade;
}




Widget BuildPOIShapeMenu(Widget parent,int menu_type,char *menu_title,MenuItem *items)
{
  Widget menu, cascade, widget;
  int i,n=0;
  XmString str;
  Arg args[5];
  
  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);
  
  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId, menu);  n++;
  XtSetArg (args[n], XmNlabelString, str); n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;

  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);
  
  for (i = 0; items[i].label != NULL; i++) 
    {
      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);


      if(i==MARK_SHAPE)
	{
	  
	  XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);
	}

      if (items[i].callback)
	XtAddCallback (widget,
		       (items[i].cclass == &xmToggleButtonWidgetClass ||
			items[i].cclass == &xmToggleButtonWidgetClass) ?
		       XmNvalueChangedCallback : 
		       XmNactivateCallback,      
		       (XtCallbackProc)items[i].callback, items[i].callback_data);
    }
  return menu_type == XmMENU_POPUP ? menu : cascade;
}



Widget BuildPOIColorMenu(Widget parent,int menu_type,char *menu_title,MenuItem *items)
{
  Widget menu, cascade, widget;
  int i,n=0;
  XmString str;
  Arg args[5];
  
  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);
  
  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId, menu);  n++;
  XtSetArg (args[n], XmNlabelString, str); n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;

  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);
  
  for (i = 0; items[i].label != NULL; i++) 
    {
      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);


      if(!strcmp( items[i].label,"Red"))
	{
	  XtVaSetValues(widget,				
			XmNarmColor,          mycolors[DRAW_COLOR_RED],
			XmNbackground,        mycolors[DRAW_COLOR_RED],
			NULL);
	}
      else if(!strcmp( items[i].label,"Green"))
	{
	  XtVaSetValues(widget,				
			XmNarmColor,          mycolors[DRAW_COLOR_MEDGREEN],
			XmNbackground,        mycolors[DRAW_COLOR_MEDGREEN],
			NULL);
	}
      else if(!strcmp( items[i].label,"Blue"))
	{
	  XtVaSetValues(widget,				
			XmNarmColor,          mycolors[DRAW_COLOR_BLUE],
			XmNbackground,        mycolors[DRAW_COLOR_BLUE],
			NULL);
	}
      else if(!strcmp( items[i].label,"Yellow"))
	{
	  XtVaSetValues(widget,				
			XmNarmColor,          mycolors[DRAW_COLOR_YELLOW],
			XmNbackground,        mycolors[DRAW_COLOR_YELLOW],
			NULL);
	}

	  if(
		  ((i==0)&&(MARK_COLOR==1))  ||
		  ((i==1)&&(MARK_COLOR==50)) ||
		  ((i==2)&&(MARK_COLOR==55)) ||
		  ((i==3)&&(MARK_COLOR==28))
		)
	  { 
	  
	  XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);
	  } 

      if (items[i].callback)
	XtAddCallback (widget,
		       (items[i].cclass == &xmToggleButtonWidgetClass ||
			items[i].cclass == &xmToggleButtonWidgetClass) ?
		       XmNvalueChangedCallback : 
		       XmNactivateCallback,      
		       (XtCallbackProc)items[i].callback, items[i].callback_data);
    }
  return menu_type == XmMENU_POPUP ? menu : cascade;
}





Widget BuildColorMenu(Widget parent,int menu_type,char *menu_title,MenuItem *items)
{
  Widget menu, cascade, widget;
  int i,n=0,realcolor;
  XmString str;
  Arg args[5];
  
  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);
  
  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId, menu);  n++;
  XtSetArg (args[n], XmNlabelString, str); n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;

  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);
  
  for (i = 0; items[i].label != NULL; i++) 
    {
      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);

      realcolor = -1;
      if(!strncmp(items[i].label,"Green"     ,5)) {realcolor = 27;}
      if(!strncmp(items[i].label,"Blue"      ,4)) {realcolor = 55;}
      if(!strncmp(items[i].label,"Red"       ,3)) {realcolor = 1;}
      if(!strncmp(items[i].label,"Yellow"    ,6)) {realcolor = 28;}
      if(!strncmp(items[i].label,"Purple"    ,6)) {realcolor = 40;}
      if(!strncmp(items[i].label,"Dark Green",10)){realcolor = 50;}
      if(!strncmp(items[i].label,"Cyan"      ,4)) {realcolor = 30;}
      if(!strncmp(items[i].label,"Brown"     ,5)) {realcolor = 53;}
      if(!strncmp(items[i].label,"White"     ,5)) {realcolor = 255;}
      
      if(realcolor>0)
	{
	  XtVaSetValues(widget,				
			XmNarmColor,          mycolors[realcolor],
			XmNbackground,        mycolors[realcolor],
			NULL);
	}

      
      if(realcolor==attr_color)
	{
	  
	  XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);
	}

      if (items[i].callback)
	XtAddCallback (widget,
		       (items[i].cclass == &xmToggleButtonWidgetClass ||
			items[i].cclass == &xmToggleButtonWidgetClass) ?
		       XmNvalueChangedCallback : 
		       XmNactivateCallback,      
		       (XtCallbackProc)items[i].callback, items[i].callback_data);
    }
  return menu_type == XmMENU_POPUP ? menu : cascade;
}





void kill_all_model(Widget w,MyData *mydata,XtPointer call_data)
{
  real_kill_model(w,mydata,(XtPointer)1);

  
  if(CLONEDEBUG==1)
    {
      printf("kill all EC\n");
    }
}

void kill_attribute(Widget w,MyData *mydata,XtPointer call_data)
{
  real_kill_model(w,mydata,(XtPointer)4);

  
  if(CLONEDEBUG==1)
    {
      printf("kill selected attributes\n");
    }
}

void kill_model(Widget w,MyData *mydata,XtPointer call_data)
{
  real_kill_model(w,mydata,(XtPointer)5);

  
  if(CLONEDEBUG==1)
    {
      printf("kill selected ECs\n");
    }
}

void kill_all_attribute(Widget w,MyData *mydata,XtPointer call_data)
{
  real_kill_model(w,mydata,(XtPointer)2);

  
  if(CLONEDEBUG==1)
    {
      printf("kill all EA\n");
    }
}



void real_kill_model(Widget w,MyData *mydata,XtPointer call_data)
{   
  int num,i,flag=(int)call_data;
  XmString *selectlist;
  XmString *blanklist;
  int pos_count;
  int *pos_list;
  int cloneindex=-1;
  int errnum   = mydata->check_num;
  int axis     = mydata->axis;
  int ADDER    = mydata->ADDER;
  int clonenum = mydata->clonenum;
  int geomtype = 0;



  if((errnum+axis+ADDER)>0)
  {
	ResetMasterRun();
  }

  if(NGA_TYPE==1)
    {
      geomtype = mydata->geomtype;
    }


  if(clonenum>0)
    {
      cloneindex = GetCloneIndex(clonenum,errnum);
    }

  
  


  if(flag==1)
    {
      set_cursor(mydisplay,mywindow,WATCH);
      BUSY=1;
      

      if(clonenum==0)
	{
	  
	  for(i=0;i<ErrorLookup[errnum].model_index[axis][ADDER][geomtype];i++)
	    {
	      XmListAddItem(ErrorLookup[errnum].list2_w[axis][ADDER][geomtype],XmStringCreate("         ","mytag1"),
			    NumberOfModels+1);
	    }      
	  
	  
	  XmListDeleteItemsPos(ErrorLookup[errnum].list2_w[axis][ADDER][geomtype],ErrorLookup[errnum].model_index[axis][ADDER][geomtype],1); 
	  
	  ErrorLookup[errnum].model_index[axis][ADDER][geomtype]=0;
	}
      else
	{
	  
	  for(i=0;i<CloneErrorLookup[cloneindex].model_index[axis][ADDER][geomtype];i++)
	    {
	      XmListAddItem(CloneErrorLookup[cloneindex].list2_w[axis][ADDER][geomtype],XmStringCreate("         ","mytag1"),
			    NumberOfModels+1);
	    }      
	  
	  
	  XmListDeleteItemsPos(CloneErrorLookup[cloneindex].list2_w[axis][ADDER][geomtype],
			       CloneErrorLookup[cloneindex].model_index[axis][ADDER][geomtype],1); 
	  
	  CloneErrorLookup[cloneindex].model_index[axis][ADDER][geomtype]=0;
	}


      ScrubEDCSMarkerList(errnum,axis,ADDER,clonenum, cloneindex,geomtype);  
      
      BUSY=0;
      set_cursor(mydisplay,mywindow,GOOD);
      return;
    }
  else if(flag==2)
    {
      
      
      set_cursor(mydisplay,mywindow,WATCH);
      BUSY=1;
      
      
      if(clonenum==0)
	{
      


	  XmListAddItem(ErrorLookup[errnum].EASlist[axis][ADDER][geomtype],
			    XmStringCreate("         ","mytag1"),0); 


	  
	  XmListDeleteItemsPos(ErrorLookup[errnum].EASlist[axis][ADDER][geomtype],
			       ErrorLookup[errnum].sac_index[axis][ADDER][geomtype],1);
	  
	  ErrorLookup[errnum].sac_index[axis][ADDER][geomtype]=0;
	}
      else
	{
	  

	  XmListAddItem(CloneErrorLookup[cloneindex].EASlist[axis][ADDER][geomtype],
			    XmStringCreate("         ","mytag1"),0); 


	  
	  XmListDeleteItemsPos(CloneErrorLookup[cloneindex].EASlist[axis][ADDER][geomtype],
			       CloneErrorLookup[cloneindex].sac_index[axis][ADDER][geomtype],1);
	  
	  CloneErrorLookup[cloneindex].sac_index[axis][ADDER][geomtype]=0;
	}
	 

      ScrubEDCSMarkerList2(errnum,axis,ADDER,clonenum,cloneindex,geomtype);  

      BUSY=0;
      set_cursor(mydisplay,mywindow,GOOD);

      return;
    }
  else if(flag==3)
    {
      printf("kill model got called with 3!\n");
      return;
    }
  else if(flag==4)
    {
      if(clonenum==0)
	{
	  XtVaGetValues(ErrorLookup[errnum].EASlist[axis][ADDER][geomtype],XmNselectedItemCount,&num,NULL);
	  XtVaGetValues(ErrorLookup[errnum].EASlist[axis][ADDER][geomtype],XmNselectedItems,&selectlist,NULL);
	  XmListGetSelectedPos(ErrorLookup[errnum].EASlist[axis][ADDER][geomtype],&pos_list,&pos_count);
	}
      else
	{
	  XtVaGetValues(CloneErrorLookup[cloneindex].EASlist[axis][ADDER][geomtype],XmNselectedItemCount,&num,NULL);
	  XtVaGetValues(CloneErrorLookup[cloneindex].EASlist[axis][ADDER][geomtype],XmNselectedItems,&selectlist,NULL);
	  XmListGetSelectedPos(CloneErrorLookup[cloneindex].EASlist[axis][ADDER][geomtype],&pos_list,&pos_count);
	}




      if(num==0)
	{
	  not_while_running(w,"\
To remove attribute items from the list of selected attribute items,\n\
you must first select those items in the list you wish to remove.",1248,"Illegal Manuever",1);
	  return;
	}
      
      if(DEBUG==1){printf("trying to kill %d ECs, sent a %d\n",pos_count,flag);}
      
      set_cursor(mydisplay,mywindow,WATCH);
      BUSY=1;

      
      for(i=0;i<pos_count;i++)
	{
	  if(DeleteFromIMarkSACList(pos_list[i]-1-i,errnum,axis,ADDER,clonenum,cloneindex,geomtype)>0)
	    {
	      
	      
	      if(clonenum==0)
		  {
		  
		  ErrorLookup[errnum].sac_index[axis][ADDER][geomtype]--; 
		  }
	      else
		  {
		  
		  CloneErrorLookup[cloneindex].sac_index[axis][ADDER][geomtype]--; 
		  }
	    }
	}

      
      
      
      blanklist = (XmString *) (malloc(sizeof(XmString *) * num));
      if(blanklist==NULL){printf("bl3: out of allocation memory!\n"); ExitWrapper(-1);}
      
      for(i=0;i<num;i++)
	{
	  blanklist[i] = XmStringCreate("         ","mytag1"); 
	}
      
      if(clonenum==0)
	{
	  
	  XmListDeleteItems(ErrorLookup[errnum].EASlist[axis][ADDER][geomtype],selectlist,num); 
	  XmListAddItems(ErrorLookup[errnum].EASlist[axis][ADDER][geomtype],blanklist,num,0);
	}
      else
	{
	  
	  XmListDeleteItems(CloneErrorLookup[cloneindex].EASlist[axis][ADDER][geomtype],selectlist,num); 
	  XmListAddItems(CloneErrorLookup[cloneindex].EASlist[axis][ADDER][geomtype],blanklist,num,0);
	}


      for(i=0;i<num;i++)
	{
	  XmStringFree(blanklist[i]);
	}     
      free(blanklist);
	  BUSY=0;
      return;
    }
  else if(flag==5)
    {
      
      
      
      if(clonenum==0)
	{
	  XtVaGetValues(ErrorLookup[errnum].list2_w[axis][ADDER][geomtype],XmNselectedItemCount,&num,NULL);
	  XtVaGetValues(ErrorLookup[errnum].list2_w[axis][ADDER][geomtype],XmNselectedItems,&selectlist,NULL);
	  XmListGetSelectedPos(ErrorLookup[errnum].list2_w[axis][ADDER][geomtype],&pos_list,&pos_count);
	}
      else
	{
	  XtVaGetValues(CloneErrorLookup[cloneindex].list2_w[axis][ADDER][geomtype],XmNselectedItemCount,&num,NULL);
	  XtVaGetValues(CloneErrorLookup[cloneindex].list2_w[axis][ADDER][geomtype],XmNselectedItems,&selectlist,NULL);
	  XmListGetSelectedPos(CloneErrorLookup[cloneindex].list2_w[axis][ADDER][geomtype],&pos_list,&pos_count);
	}

      if(num==0)
	{
	  if(NGA_TYPE==1)
	  {
	   not_while_running(w,"To remove feature types from the list of selected feature types,\n\
you must first select those items in the list you wish to remove.",1249,"Illegal Manuever",1);
	  }
	  else
	  {
	   not_while_running(w,"To remove classification items, you must first select\n\
those selected items you wish to remove.",1249,"Illegal Manuever",1);
	  }
	  return;
	}
      

      
      set_cursor(mydisplay,mywindow,WATCH);
      BUSY=1;


      
      for(i=0;i<pos_count;i++)
	{

	  if(DeleteFromIMarkList(pos_list[i]-1-i,errnum,axis,ADDER,clonenum,cloneindex,geomtype)>0)
	    {	  
	      
	      
	      if(clonenum==0)
		{
		  
		  ErrorLookup[errnum].model_index[axis][ADDER][geomtype]--; 
		}
	      else
		{
		  
		  CloneErrorLookup[cloneindex].model_index[axis][ADDER][geomtype]--; 
		}
	    }
	}
      
      
      
      blanklist = (XmString *) (malloc(sizeof(XmString *) * num));
      if(blanklist==NULL){printf("bl3: out of allocation memory!\n"); ExitWrapper(-1);}
      
      for(i=0;i<num;i++)
	{
	  blanklist[i] = XmStringCreate("         ","mytag1"); 
	}
      
      if(clonenum==0)
	{
	  
	  XmListDeleteItems(ErrorLookup[errnum].list2_w[axis][ADDER][geomtype],selectlist,num); 
	  XmListAddItems(ErrorLookup[errnum].list2_w[axis][ADDER][geomtype],blanklist,num,NumberOfModels+1);
	}
      else
	{
	  
	  XmListDeleteItems(CloneErrorLookup[cloneindex].list2_w[axis][ADDER][geomtype],selectlist,num); 
	  XmListAddItems(CloneErrorLookup[cloneindex].list2_w[axis][ADDER][geomtype],blanklist,num,NumberOfModels+1);
	}

      for(i=0;i<num;i++)
	{
	  XmStringFree(blanklist[i]);
	}     
      free(blanklist);
	  BUSY=0;
    }
  else
    {
      printf("kill model got bad flag %d\n",flag);
    }
  
  BUSY=0;
  set_cursor(mydisplay,mywindow,GOOD);
}



void set_fcode(Widget w,XtPointer userData,XtPointer call_data)
{
  XmString *new_names;
  char temp[1000];
  int *pos_list;
  int pos_count,i,foundone,insertindex;


  

  XmListGetSelectedPos(BOlist_w,&pos_list,&pos_count);
  
  

  for(i=0;i<pos_count;i++)
    {
      

      foundone = 0;
 

      

      MdlNames[MdlNames[pos_list[i]-1].origindex].inout2 = 1;
    }



  new_names = (XmString *) (malloc(sizeof(XmString *) * NumberOfModels));
  if(new_names==NULL){printf("sacn4: out of allocation memory!\n"); ExitWrapper(-1);}

  insertindex = 0;

  for(i=0;i<NumberOfModels;i++)
    {
      if(MdlNames[i].inout2==1)
	{
	  if(NGA_TYPE==1)
	    {
	      sprintf(temp,"%s: %s %s (%d/%.0lf)",
		      GetECCCode(MdlNames[i].code),
		      GetECCLabel(MdlNames[i].code),
		      MdlNames[i].name,
		      MdlNames[i].inout,
		      MdlNames[i].occurrences);		  
	    }
	  else
	    {
	      sprintf(temp,"%s %s (%d/%.0lf)",
		      GetECCLabel(MdlNames[i].code),
		      MdlNames[i].name,
		      MdlNames[i].inout,
		      MdlNames[i].occurrences);	
	    }

	  new_names[insertindex] = XmStringCreate(temp,"mytag1");
	  insertindex = insertindex + 1;
	}
    }

  sprintf(temp,"         ");
  for(i=insertindex;i<NumberOfModels;i++)
    {
      new_names[i] = XmStringCreate(temp,"mytag1");
    }



  XmListDeleteAllItems(BOlist2_w);
  XmListAddItems(BOlist2_w, new_names, NumberOfModels,1);


  

}



void set_model(Widget w,MyData *mydata,XtPointer call_data)
{
  int num,i,good;
  XmString *selectlist;
  XmString *selectlist2;
  char *text;
  int *pos_list;
  int pos_count;
  int noinsert=0;
  struct IMarkList *cfl;
  int errnum=0;
  int axis=0;
  int ADDER=0;
  int cloneindex,clonenum,geomtype;
  int checkindex,j;

  errnum   = mydata->check_num;
  axis     = mydata->axis;
  ADDER    = mydata->ADDER;
  clonenum = mydata->clonenum;
  geomtype = 0;

  if(NGA_TYPE==1)
    {
      geomtype = mydata->geomtype;
    }

  if(clonenum>0)
    {
      cloneindex = GetCloneIndex(clonenum,errnum);
    }


  if((errnum+axis+ADDER)>0)
  {
	  ResetMasterRun();
  }


  

  if(clonenum==0)
    {
      XtVaGetValues(ErrorLookup[errnum].list_w[axis][ADDER][geomtype],XmNselectedItemCount,&num,NULL);
    }
  else
    {
      XtVaGetValues(CloneErrorLookup[cloneindex].list_w[axis][ADDER][geomtype],XmNselectedItemCount,&num,NULL);
    }


  
  if(num==0)
    {
	  if(NGA_TYPE==1)
	  {
      not_while_running(w,"To add feature types to the \"Selected Feature Types\" list, you must first\n\
choose those you wish to add in the \"Feature Types\" list with the mouse.",1250,"Illegal Manuever",1);
	  }
	  else
	  {
      not_while_running(w,"To add classification items, you must first choose those\n\
you wish to add in the Classification list with the mouse.",1250,"Illegal Manuever",1);
	  }
      return;
    }
  
  BUSY=1;
  set_cursor(mydisplay,mywindow,WATCH);
  

  if(clonenum==0)
    {
      XtVaGetValues(ErrorLookup[errnum].list_w[axis][ADDER][geomtype],XmNselectedItems,&selectlist,NULL);  
      XmListGetSelectedPos(ErrorLookup[errnum].list_w[axis][ADDER][geomtype],&pos_list,&pos_count);
    }
  else
    {
      XtVaGetValues(       CloneErrorLookup[cloneindex].list_w[axis][ADDER][geomtype],XmNselectedItems,&selectlist,NULL);  
      XmListGetSelectedPos(CloneErrorLookup[cloneindex].list_w[axis][ADDER][geomtype],&pos_list,&pos_count);
    }




  if((NGA_TYPE==1)&&(geomtype>0)) 
    {
      

      for(i=0;i<pos_count;i++)
	{
	  checkindex = 0;
	  

	  

	  
	  for (j = 0; j < NumberOfModels ; j++)
	    {

	      if(
		 ((geomtype==C_AREA)&&(!strcmp(MdlNames[j].name,"(AREA)")))  ||
		 ((geomtype==C_LINE)&&(!strcmp(MdlNames[j].name,"(LINE)")))  ||
		 ((geomtype==C_POFE)&&(!strcmp(MdlNames[j].name,"(POINT)"))) ||
		 ((geomtype==C_GRID)&&(!strcmp(MdlNames[j].name,"(GRID)")))
		 )
		{

		  if(checkindex==pos_list[i]-1)
		    {
		      

		      

		      pos_list[i] = j+1; 

		      break;
		    }
		  
		  checkindex = checkindex + 1;
		}
	    }
	}
    }





  for(i=0;i<num;i++)
    {
      noinsert=0;      

      if (
	  ((clonenum==0) && (ErrorLookup[errnum].IMarkRoot[axis][ADDER][geomtype]!=NULL))  ||
	  ((clonenum>0)  && (CloneErrorLookup[cloneindex].IMarkRoot[axis][ADDER][geomtype]!=NULL))
	  )
	{

	  if(clonenum==0)
	    {
	      cfl = ErrorLookup[errnum].IMarkRoot[axis][ADDER][geomtype];
	    }
	  else
	    {
	      cfl = CloneErrorLookup[cloneindex].IMarkRoot[axis][ADDER][geomtype];
	    }


	  while(cfl!=NULL)
	    {
	      if((pos_list[i]-1)==cfl->origSCCindex)
		{
		  noinsert=1;
		  if(MODELDEBUG==1)
		    {
		      printf("NOT inserting ECC indexed %d\n",pos_list[i]-1);
		    }
		  break;
		}
	      cfl = cfl->next;
	    }
	}
      
      if(noinsert==1)
	{
	  selectlist[i]=XmStringCreate("","mytag1");
	  continue;
	}
      
      

      
      
      cfl = (struct IMarkList *) malloc(sizeof(struct IMarkList));
      if(cfl == NULL)
	{ printf("Imark: Out of allocation memory\n"); ExitWrapper(-1); }
      cfl->origSCCindex = pos_list[i]-1;

      


      if(clonenum==0)
	{
	  cfl->next = ErrorLookup[errnum].IMarkRoot[axis][ADDER][geomtype];
	  ErrorLookup[errnum].IMarkRoot[axis][ADDER][geomtype] = cfl;
	}
      else
	{
	  cfl->next = CloneErrorLookup[cloneindex].IMarkRoot[axis][ADDER][geomtype];
	  CloneErrorLookup[cloneindex].IMarkRoot[axis][ADDER][geomtype] = cfl;
	}

      if(MODELDEBUG==1){printf("%d\n",i);}
    }
  
  if(clonenum==0)
    {
      ErrorLookup[errnum].model_index[axis][ADDER][geomtype]++;
    }
  else
    {
      CloneErrorLookup[cloneindex].model_index[axis][ADDER][geomtype]++;
    }

  

  
  
  selectlist2 = (XmString *) (malloc(sizeof(XmString *) * num));
  if(selectlist2==NULL){printf("sl: out of allocation memory!\n"); ExitWrapper(-1);}
  
  i=0;
  good=0;
  while(i<num)
    {
      XmStringGetLtoR(selectlist[i],"mytag1", &text);
      if(strlen(text)>0)
	{
	  selectlist2[good]=selectlist[i];
	  good++;
	}
      i++;
      XtFree(text);
    }

  if(clonenum==0)
    {
      XmListReplaceItemsPos(ErrorLookup[errnum].list2_w[axis][ADDER][geomtype],selectlist2,good,
			    ErrorLookup[errnum].model_index[axis][ADDER][geomtype]);
      ErrorLookup[errnum].model_index[axis][ADDER][geomtype]=ErrorLookup[errnum].model_index[axis][ADDER][geomtype]+good-1;
    }
  else
    {
      XmListReplaceItemsPos(CloneErrorLookup[cloneindex].list2_w[axis][ADDER][geomtype],selectlist2,good,
			    CloneErrorLookup[cloneindex].model_index[axis][ADDER][geomtype]);
      CloneErrorLookup[cloneindex].model_index[axis][ADDER][geomtype]=CloneErrorLookup[cloneindex].model_index[axis][ADDER][geomtype]+good-1;
    }
  



  
  free(selectlist2);
  




  BUSY=0;
  set_cursor(mydisplay,mywindow,GOOD);
}








int GetEECount(int SCC, int SAC, int errnum, int axis, int ADDER)
{
  int i,numfound=0;
  int thisindex,index;
  
  index = MdlNames[SCC].UniqueAttr[SAC];
  
  
  
  for(i=0;i<MdlNames[SCC].numattributes;i++)
    {
      thisindex = MdlNames[SCC].AttrIndices[i];
      
      if(thisindex==index)
	{
	  numfound = numfound + 1;
	}
    }
  return numfound;
}


char * GetIntervalValue()
{
  extern char GetOpen(int i);
  extern char GetClose(int i);
  static char retstring[1000];
 
  
  sprintf(retstring,"%c%lf-%lf%c",
	  GetOpen(edcsstruct.intervaltype),
	  edcsstruct.value,
	  edcsstruct.value2,
	  GetClose(edcsstruct.intervaltype)
	  );
  return retstring;
}



void GetEDCSInfo(int SCC, int SAC, int EEnum, int errnum, int axis, int ADDER)
{
  int i;
  int thisindex,index,thatindex,otherindex;

  static int istart = 0;
  static int num=-1;



  if(do_long_way==1)
    {
      istart = 0;
      num = -1;
  }


  if(EEnum==-2)
  {
	  
	  edcsstruct.type = 1;
	  return;
  }


  index = MdlNames[SCC].UniqueAttr[SAC];



  for(i=istart;i<MdlNames[SCC].numattributes;i++)
    {
      istart = i+1;

      thisindex  = MdlNames[SCC].AttrIndices[i];
      thatindex  = MdlNames[SCC].ValueIndices[i]; 
      otherindex = (int) MdlNames[SCC].ValueCounts[i]; 

      if(thisindex==index)
	{
	  num++;
	  
	  if(num==EEnum)
	    {
	      edcsstruct.intervaltype = MdlNames2[thisindex].values[thatindex].intervaltype;
	      edcsstruct.type         = MdlNames2[thisindex].values[thatindex].type;
	      edcsstruct.value2       = MdlNames2[thisindex].values[thatindex].value2;
	      edcsstruct.value        = MdlNames2[thisindex].values[thatindex].value;
	      edcsstruct.scale        = MdlNames2[thisindex].values[thatindex].scale;
	      edcsstruct.uom          = MdlNames2[thisindex].values[thatindex].uom;
	      edcsstruct.count        = otherindex;
	      if(edcsstruct.type==2)
		{
		  sprintf(edcsstruct.label,"%s",MdlNames2[thisindex].values[thatindex].label);
		}
	      return;
	    }
	}
    }
}






int FindInteresting(int SAC,int position)
{
  int i;
  int interesting=-1;

  if(MdlNames2[SAC].count<0)
    {
      return -2; 
    }
  
  for(i=0;i<MdlNames2[SAC].count;i++)
    {
      if(MdlNames2[SAC].values[i].uniqueoccurrences > 0)
	{
	  interesting++;
	  if(interesting==position)
	    {
	      return i;
	    }
	}
    }
  printf("failed to find %d for %d\n",position,SAC);
  return 0;
}










void set_sac(Widget w,MyData *mydata,int list_flag)
{
  XmString *oldselectlist;
  XmString *selectlist;
  XmString *selectlist2;
  char *text;
  char temp[500],newstring[1000];
  int *pos_list;
  int i,good,interesting,pos_count,totalnum,lastspace,noinsert=0,allvalues,len,
    SAC, SCC,errnum,axis,ADDER,clonenum,cloneindex=-1,geomtype=0,do_list_stuff,
    checkindex,j;
  struct IMarkSACList *cfl;
  extern char GetOpen(int i);
  extern char GetClose(int i);

  


  if(list_flag==99999)
    {
      do_list_stuff = 1;
    }
  else
    {
      do_list_stuff=0;
    }


  errnum   = mydata->check_num;
  axis     = mydata->axis;
  ADDER    = mydata->ADDER;
  clonenum = mydata->clonenum;
  
  if(NGA_TYPE==1)
    {
      geomtype = mydata->geomtype;
    }

  if((errnum+axis+ADDER)>0)
  {
	  ResetMasterRun();
  }


  if(clonenum>0)
    {
      cloneindex = GetCloneIndex(clonenum,errnum);
    }



  if(clonenum==0) 
    {
      if(ErrorLookup[errnum].DO_EDCS_COMBO[axis][ADDER][geomtype]==1)
	{
	  
	  
	  XmListGetSelectedPos(ErrorLookup[errnum].list_w[axis][ADDER][geomtype],&pos_list,&pos_count);
	  if(pos_count==0)
	    {
		  if(NGA_TYPE==1)
		  {
	        not_while_running(w,"No Feature Type is selected in the Feature Types list.  \n\
One must be selected.",1251,"Illegal Manuever",1);
		  }
		  else
		  {
	        not_while_running(w,"No Classifier is selected in the Classification list.  \n\
One must be selected.",1251,"Illegal Manuever",1);
		  }
	      return;
	    }
	  
	  if((NGA_TYPE==0)||(geomtype==0))
	    {
	      SCC = pos_list[0]-1;  
	    }
	  else
	    {
	      if((NGA_TYPE==1)&&(geomtype>0)) 
		{	  
		  
		  
		  
		  
		  i = 0;
		  
		  checkindex = 0;
		  
		  
		  
		  
		  for (j = 0; j < NumberOfModels ; j++)
		    {
		      if(
			 ((geomtype==C_AREA)&&(!strcmp(MdlNames[j].name,"(AREA)")))  ||
			 ((geomtype==C_LINE)&&(!strcmp(MdlNames[j].name,"(LINE)")))  ||
			 ((geomtype==C_POFE)&&(!strcmp(MdlNames[j].name,"(POINT)"))) ||
			 ((geomtype==C_GRID)&&(!strcmp(MdlNames[j].name,"(GRID)")))
			 )
			{
			  if(checkindex==pos_list[i]-1)
			    {
			      
			      
			      pos_list[i] = j+1; 
			      
			      break;
			    }
			  
			  checkindex = checkindex + 1;
			}
		    }
		  SCC = pos_list[0] -1;
		}
	    }
	}
      else
	{
	  SCC = -1;
	}
      
      XmListGetSelectedPos(ErrorLookup[errnum].EAlist[axis][ADDER][geomtype],&pos_list,&pos_count);
    }
  else
    {
      if(CloneErrorLookup[cloneindex].DO_EDCS_COMBO[axis][ADDER][geomtype]==1)
	{
	  
	  
	  XmListGetSelectedPos(CloneErrorLookup[cloneindex].list_w[axis][ADDER][geomtype],&pos_list,&pos_count);
	  if(pos_count==0)
	    {
		  if(NGA_TYPE==1)
		  {
	        not_while_running(w,"No Feature Type is selected in the Feature Types list.  \n\
One must be selected.",1252,"Illegal Manuever",1);
		  }
		  else
		  {
	        not_while_running(w,"No Classifier is selected in the Classification list.  \n\
One must be selected.",1252,"Illegal Manuever",1);
		  }
	      return;
	    }

	  if((NGA_TYPE==0)||(geomtype==0))
	    {
	      SCC = pos_list[0]-1;  
	    }
	  else
	    {
	      if((NGA_TYPE==1)&&(geomtype>0)) 
		{	  
		  
		  
		  
		  
		  
		  i = 0;
		  
		  checkindex = 0;
		  
		  
		  
		  
		  for (j = 0; j < NumberOfModels ; j++)
		    {
		      if(
			 ((geomtype==C_AREA)&&(!strcmp(MdlNames[j].name,"(AREA)")))  ||
			 ((geomtype==C_LINE)&&(!strcmp(MdlNames[j].name,"(LINE)")))  ||
			 ((geomtype==C_POFE)&&(!strcmp(MdlNames[j].name,"(POINT)"))) ||
			 ((geomtype==C_GRID)&&(!strcmp(MdlNames[j].name,"(GRID)")))
			 )
			{
			  if(checkindex==pos_list[i]-1)
			    {
			      
			      
			      pos_list[i] = j+1; 
			      
			      break;
			    }
			  
			  checkindex = checkindex + 1;
			}
		    }
		  SCC = pos_list[0] -1;
		}
	    }
	}
      else
	{
	  SCC = -1;
	}
      
      XmListGetSelectedPos(CloneErrorLookup[cloneindex].EAlist[axis][ADDER][geomtype],&pos_list,&pos_count);
    }




  



  if(pos_count==0)
    {
	  if(NGA_TYPE==1)
	  {
      not_while_running(w,"To add attribute items to the \"Selected Attribute Items\" list, you must first\n\
choose those you wish to add in the attribute item list with the mouse.",1253,"Illegal Manuever",1);
	  }
	  else
	  {
      not_while_running(w,"To select EAs, you must first highlight those\n\
EAs you wish to add in the EA label list\n\
with the mouse.",1253,"Illegal Manuever",1);
	  }
      return;
    }





  SAC = pos_list[0]-1;  


  
  if(clonenum==0)
    {
      XmListGetSelectedPos(ErrorLookup[errnum].EAVlist[axis][ADDER][geomtype],&pos_list,&pos_count);

      XtVaGetValues(ErrorLookup[errnum].EAVlist[axis][ADDER][geomtype],
		    XmNselectedItems    ,&oldselectlist,
		    NULL);
    }
  else
    {
      XmListGetSelectedPos(CloneErrorLookup[cloneindex].EAVlist[axis][ADDER][geomtype],&pos_list,&pos_count);

      XtVaGetValues(CloneErrorLookup[cloneindex].EAVlist[axis][ADDER][geomtype],
		    XmNselectedItems    ,&oldselectlist,
		    NULL);
    }

  if(pos_count==0)
    {
      allvalues = 1;
    }
  else
    {
      allvalues = 0;
    }


  if(  (allvalues==1)&& ((errnum+axis+ADDER)>0) )
  {
    not_while_running(w,"\
When specifying inspection participants using attributes, you must select\n\
specific attribute value(s) in the \"Values for SELECTED attribute\" area\n\n\
No attribute values currently specified.",1483,"No attribute values selected",1);
	return;
  }


  set_cursor(XtDisplay(modelhead),XtWindow(modelhead),WATCH);
  set_cursor(mydisplay,mywindow,WATCH);


  
  selectlist = (XmString *) (malloc(sizeof(XmString *) * (pos_count+5)));
  if(selectlist==NULL){printf("sl: out of allocation memory!\n"); ExitWrapper(-1);}
  

  BUSY=1;
  set_cursor(mydisplay,mywindow,WATCH);

  

  if(allvalues==1)
    {
      if(
	 ((clonenum==0) && (     ErrorLookup[errnum]    .IMarkSACRoot[axis][ADDER][geomtype]!=NULL))  ||
	 ((clonenum>0) &&  (CloneErrorLookup[cloneindex].IMarkSACRoot[axis][ADDER][geomtype]!=NULL))  
	 )
	{
	  
	  if(clonenum==0)
	    {
	      cfl = ErrorLookup[errnum].IMarkSACRoot[axis][ADDER][geomtype];
	    }
	  else
	    {
	      cfl = CloneErrorLookup[cloneindex].IMarkSACRoot[axis][ADDER][geomtype];
	    }

	  while(cfl!=NULL)
	    {
	      if(
		 (cfl->SCCindex==SCC) &&
		 (cfl->SACindex==SAC) 
		 )
		{
		  noinsert=1;
		  if(cfl->EEindex != -1) 
		    {
		      
		      not_while_running(w,"You cannot specify that all values for an attribute be highlighted when\n\
that attribute is already on the selected list with specific values.",1254,"Illegal Entry",1);
		    }
		  break;
		}	      
	      cfl = cfl->next;
	    }
	}

    
      if(noinsert==1)
	{
	  selectlist[0]=XmStringCreate("","mytag1");
	}
      else
	{
	  if(
	     ((clonenum==0) && (     ErrorLookup[errnum]    .DO_EDCS_COMBO[axis][ADDER][geomtype]==1))  ||
	     ((clonenum> 0) && (CloneErrorLookup[cloneindex].DO_EDCS_COMBO[axis][ADDER][geomtype]==1))
	     )
	    {
	      if(NGA_TYPE==1)
		{
		  sprintf(temp,"ALL values for Classifier %s: %s, Attribute %s: %s",
			  GetECCCode (MdlNames[SCC].code),
			  GetECCLabel(MdlNames[SCC].code),
			  GetEACCode (GetCode(SCC,SAC)),
			  GetEACLabel(GetCode(SCC,SAC)));
		}
	      else
		{
		  sprintf(temp,"ALL values for EC %s %s, EA %s",
			  GetECCLabel(MdlNames[SCC].code),
			  MdlNames[SCC].name,
			  GetEACLabel(GetCode(SCC,SAC)));
		}
	    }
	  else
	    {
	      if(NGA_TYPE==1)
		{
		  sprintf(temp,"ALL values for Attribute %s: %s",
			  GetEACCode (MdlNames2[SAC].code),
			  GetEACLabel(MdlNames2[SAC].code));
		}
	      else
		{
		  sprintf(temp,"ALL values for EA %s",
			  GetEACLabel(MdlNames2[SAC].code));
		}
	    }	  
	  selectlist[0]=XmStringCreate(temp,"mytag1");
	  
	  cfl = (struct IMarkSACList *) malloc(sizeof(struct IMarkSACList));
	  if(cfl == NULL)
	    { printf("Imark: Out of allocation memory\n"); ExitWrapper(-1); }
	  cfl->SCCindex = SCC;
	  cfl->SACindex = SAC;
	  cfl->EEindex = -1; 

	  if(clonenum==0)
	    {
	      cfl->next = ErrorLookup[errnum].IMarkSACRoot[axis][ADDER][geomtype];
	      ErrorLookup[errnum].IMarkSACRoot[axis][ADDER][geomtype] = cfl;
	    }
	  else
	    {
	      cfl->next = CloneErrorLookup[cloneindex].IMarkSACRoot[axis][ADDER][geomtype];
	      CloneErrorLookup[cloneindex].IMarkSACRoot[axis][ADDER][geomtype] = cfl;
	    }

	  
	}

    }
  else
    {
      for(i=0;i<pos_count;i++)
	{
	  noinsert=0;
	  
	  
	  
	  if(
	     ((clonenum==0) && (     ErrorLookup[errnum]    .DO_EDCS_COMBO[axis][ADDER][geomtype]==1))  ||
	     ((clonenum>0)  && (CloneErrorLookup[cloneindex].DO_EDCS_COMBO[axis][ADDER][geomtype]==1))
	     )
	    {
	      if(MdlNames2[MdlNames[SCC].UniqueAttr[SAC]].count<0)
		{
		  interesting = -2; 
		}
	      else
		{
		  interesting = pos_list[i] - 1;
		}
	    }
	  else 
	    {
	      interesting = FindInteresting(SAC,pos_list[i]-1);
	    }



	  if(interesting==-2)
	    {
	      
	      
          
		  
	      XmStringGetLtoR(oldselectlist[i],
			      (XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
	      
          
		  
	      

		  
	      len = strlen(text);
		  lastspace = len; 
	      for(j=7;j<len;j++)
		{
		  newstring[j-7] = text[j];
		  if(text[j]==' ')
		    {
		      lastspace = j-7;
		    }
		}

	      newstring[lastspace] = '\0';
	      

		  
	      XtFree(text);
	      
	      
	      
	      
	    }
	  
	  
	  
	  

	  if(
	     ((clonenum==0) && (     ErrorLookup[errnum]    .IMarkSACRoot[axis][ADDER][geomtype]!=NULL))  ||
	     ((clonenum>0)  && (CloneErrorLookup[cloneindex].IMarkSACRoot[axis][ADDER][geomtype]!=NULL))
	     )
	    {
	      if(clonenum==0)
		{
		  cfl = ErrorLookup[errnum].IMarkSACRoot[axis][ADDER][geomtype];
		}
	      else
		{
		  cfl = CloneErrorLookup[cloneindex].IMarkSACRoot[axis][ADDER][geomtype];
		}

	      while((cfl!=NULL)&&(pos_count<10000))
		{
		  if(
		     (cfl->SCCindex==SCC) &&
		     (cfl->SACindex==SAC)
		     )
		    {

		      if(cfl->EEindex==-1)
			{
			  not_while_running(w,"You cannot specify that specific values for an attribute be highlighted when\n\
that attribute is already on the selected list with all values.",1255,"Illegal Entry",1);
			  noinsert=1;
			  
			  break;
			}
		      else if(cfl->EEindex == interesting)
			{
			  if(interesting==-2)
			    {
			      if(!strcmp(newstring,cfl->saveval))
				{
				  noinsert=1;
				  printf("NOT inserting long value %s\n",newstring);
				  break;
				}
			    }
			  else
			    {
			      noinsert=1;
			      printf("NOT inserting EA/EE indexed %d %d\n",SAC,interesting);
			      break;
			    }
			}
		    }
		  cfl = cfl->next;
		}
	    }
	
	  if(noinsert==1)
	    {
	      selectlist[i]=XmStringCreate("","mytag1");
	      continue;
	    }
	  else
	    {
	      if(
		 ( (clonenum==0) && (     ErrorLookup[errnum]    .DO_EDCS_COMBO[axis][ADDER][geomtype]==1))  ||
		 ( (clonenum>0)  && (CloneErrorLookup[cloneindex].DO_EDCS_COMBO[axis][ADDER][geomtype]==1))
		 )
		{


		  if(interesting==-2)
		    {
		      
		      if(NGA_TYPE==1)
			{
			  sprintf(temp,"%s: %s: %s",
				  GetECCCode (MdlNames[SCC].code),
				  
				  GetEACCode (GetCode(SCC,SAC)),
				  
				  newstring);
			}
		      else
			{
			  sprintf(temp,"EC: %s %s, EA %s, value %s",
				  GetECCLabel(MdlNames[SCC].code),
				  MdlNames[SCC].name,
				  GetEACLabel(GetCode(SCC,SAC)),
				  newstring);
			}


		    }
		  else
		    {		  
		      GetEDCSInfo(SCC,SAC,interesting, errnum, axis, ADDER);
		      

		      if(edcsstruct.type==0)
			{
			  if(NGA_TYPE==1)
			    {
			      sprintf(temp,"Classifier: %s: %s, Attribute %s: %s, value %d",
				      GetECCCode (MdlNames[SCC].code),
				      GetECCLabel(MdlNames[SCC].code),
				      GetEACCode (GetCode(SCC,SAC)),
				      GetEACLabel(GetCode(SCC,SAC)),
				      (int)edcsstruct.value);
			    }
			  else
			    {
			      sprintf(temp,"EC: %s %s, EA %s, value %d",
				      GetECCLabel(MdlNames[SCC].code),
				      MdlNames[SCC].name,
				      GetEACLabel(GetCode(SCC,SAC)),
				      (int)edcsstruct.value);
			    }
			}
		      else if(edcsstruct.type==1)
			{
			  if(NGA_TYPE==1)
			    {
			      sprintf(temp,"Classifier: %s: %s, Attribute %s: %s, value %lf",
				      GetECCCode (MdlNames[SCC].code),
				      GetECCLabel(MdlNames[SCC].code),
				      GetEACCode (GetCode(SCC,SAC)),
				      GetEACLabel(GetCode(SCC,SAC)),
				      edcsstruct.value);
			    }
			  else
			    {
			      sprintf(temp,"EC: %s %s, EA %s, value %lf",
				      GetECCLabel(MdlNames[SCC].code),
				      MdlNames[SCC].name,
				      GetEACLabel(GetCode(SCC,SAC)),
				      edcsstruct.value);
			    }
			}
		      else if(edcsstruct.type==2)
			{
			  if(NGA_TYPE==1)
			    {
			      sprintf(temp,"Classifier: %s: %s, Attribute %s: %s, value %s",
				      GetECCCode (MdlNames[SCC].code),
				      GetECCLabel(MdlNames[SCC].code),
				      GetEACCode (GetCode(SCC,SAC)),
				      GetEACLabel(GetCode(SCC,SAC)),
				      edcsstruct.label);
			    }
			  else
			    {
			      sprintf(temp,"EC: %s %s, EA %s, value %s",
				      GetECCLabel(MdlNames[SCC].code),
				      MdlNames[SCC].name,
				      GetEACLabel(GetCode(SCC,SAC)),
				      edcsstruct.label);
			    }
			}
		      else if(edcsstruct.type==3)
			{
			  if(NGA_TYPE==1)
			    {
			      sprintf(temp,"Classifier: %s: %s, Attribute %s: %s, value %s",
				      GetECCCode (MdlNames[SCC].code),
				      GetECCLabel(MdlNames[SCC].code),
				      GetEACCode (GetCode(SCC,SAC)),
				      GetEACLabel(GetCode(SCC,SAC)),
				      GetEELabel(GetCode(SCC,SAC),
						 (int)edcsstruct.value));
			    }
			  else
			    {
			      sprintf(temp,"EC: %s %s, EA %s, value %s",
				      GetECCLabel(MdlNames[SCC].code),
				      MdlNames[SCC].name,
				      GetEACLabel(GetCode(SCC,SAC)),
				      GetEELabel(GetCode(SCC,SAC),
						 (int)edcsstruct.value));
			    }
			}
		      else if(edcsstruct.type==4)
			{
			  if(NGA_TYPE==1)
			    {
			      printf("shouldnt be here EM2\n");
			    }
			  else
			    {
			      sprintf(temp,"EC: %s %s, EA %s, value %s",
				      GetECCLabel(MdlNames[SCC].code),
				      MdlNames[SCC].name,
				      GetEACLabel(GetCode(SCC,SAC)),
				      GetEMLabel((int)edcsstruct.value));
			    }
			}
		      
		      else if(
			      (edcsstruct.type==5) ||
			      (edcsstruct.type==6) ||
			      (edcsstruct.type==7) 
			      )
			{
			  if(NGA_TYPE==1)
			    {
			      printf("shouldnt be here INT2\n");
			    }
			  else
			    {
			      sprintf(temp,"EC: %s %s, EA %s, value %s",
				      GetECCLabel(MdlNames[SCC].code),
				      MdlNames[SCC].name,
				      GetEACLabel(GetCode(SCC,SAC)),
				      GetIntervalValue());
			    }
			}
		      else
			{
			  printf("bad type on MdlNames[%d].attributes[%d].values[%d].type = %d\n",
				 SCC, SAC, interesting,edcsstruct.type);
			  set_cursor(XtDisplay(modelhead),XtWindow(modelhead),ARROW);
              set_cursor(mydisplay,mywindow,GOOD);
			  return;
			}
		    } 

		} 



	      else  
		{
		  if(interesting==-2)
		    {
		      

		      if(NGA_TYPE==1)
			{
              

			  
			  sprintf(temp,"%s: %s",
				  GetEACCode (MdlNames2[SAC].code),
				  newstring);
			  }
		      else
			{
			  sprintf(temp,"EA %s, value %s",
				  GetEACLabel(MdlNames2[SAC].code),
				  newstring);
			}




		    }
		  else
		    {
		      if(MdlNames2[SAC].values[interesting].type==0)
			{
			  if(NGA_TYPE==1)
			    {
			      sprintf(temp,"Attribute %s: %s, value %d",
				      GetEACCode (MdlNames2[SAC].code),
				      GetEACLabel(MdlNames2[SAC].code),
				      (int)MdlNames2[SAC].values[interesting].value);
			    }
			  else
			    {
			      sprintf(temp,"EA %s, value %d",
				      GetEACLabel(MdlNames2[SAC].code),
				      (int)MdlNames2[SAC].values[interesting].value);
			    }
			}
		      else if(MdlNames2[SAC].values[interesting].type==1)
			{
			  if(NGA_TYPE==1)
			    {
			      sprintf(temp,"Attribute %s: %s, value %lf",
				      GetEACCode (MdlNames2[SAC].code),
				      GetEACLabel(MdlNames2[SAC].code),
				      MdlNames2[SAC].values[interesting].value);
			    }
			  else
			    {
			      sprintf(temp,"EA %s, value %lf",
				      GetEACLabel(MdlNames2[SAC].code),
				      MdlNames2[SAC].values[interesting].value);
			    }
			}
		      else if(MdlNames2[SAC].values[interesting].type==2)
			{
			  if(NGA_TYPE==1)
			    {
			      sprintf(temp,"Attribute %s: %s, value %s",
				      GetEACCode (MdlNames2[SAC].code),
				      GetEACLabel(MdlNames2[SAC].code),
				      MdlNames2[SAC].values[interesting].label);
			    }
			  else
			    {
			      sprintf(temp,"EA %s, value %s",
				      GetEACLabel(MdlNames2[SAC].code),
				      MdlNames2[SAC].values[interesting].label);
			    }
			}
		      else if(MdlNames2[SAC].values[interesting].type==3)
			{
			  if(NGA_TYPE==1)
			    {
			      sprintf(temp,"Attribute %s: %s, value %s",
				      GetEACCode (MdlNames2[SAC].code),
				      GetEACLabel(MdlNames2[SAC].code),
				      GetEELabel(MdlNames2[SAC].code,
						 (int)MdlNames2[SAC].values[interesting].value));
			    }
			  else
			    {
			      sprintf(temp,"EA %s, value %s",
				      GetEACLabel(MdlNames2[SAC].code),
				      GetEELabel(MdlNames2[SAC].code,
						 (int)MdlNames2[SAC].values[interesting].value));
			    }
			}
		      else if(MdlNames2[SAC].values[interesting].type==4)
			{
			  if(NGA_TYPE==1)
			    {
			      printf("shouldnt be here EM3\n");
			    }
			  else
			    {
			      sprintf(temp,"EA %s, value %s",
				      GetEACLabel(MdlNames2[SAC].code),
				      GetEMLabel((int)MdlNames2[SAC].values[interesting].value));
			    }
			}
		      else if(MdlNames2[SAC].values[interesting].type==5)
			{
			  if(NGA_TYPE==1)
			    {
			      printf("shouldnt be here INT3\n");
			    }
			  else
			    {
			      sprintf(temp,"EA %s, value: %c%lf-%lf%c",
				      GetEACLabel(MdlNames2[SAC].code),
				      GetOpen(MdlNames2[SAC].values[interesting].intervaltype),
				      MdlNames2[SAC].values[interesting].value,
				      MdlNames2[SAC].values[interesting].value2,
				      GetClose(MdlNames2[SAC].values[interesting].intervaltype));
			    }
			}
		      else if(
			      (MdlNames2[SAC].values[interesting].type==6) ||
			      (MdlNames2[SAC].values[interesting].type==7)
			      )
			{
			  if(NGA_TYPE==1)
			    {
			      printf("shouldnt be here INT3.1\n");
			    }
			  else
			    {
			      sprintf(temp,"EA %s, value: %c%d-%d%c",
				      GetEACLabel(MdlNames2[SAC].code),
				      GetOpen(MdlNames2[SAC].values[interesting].intervaltype),
				      (int)MdlNames2[SAC].values[interesting].value,
				      (int)MdlNames2[SAC].values[interesting].value2,
				      GetClose(MdlNames2[SAC].values[interesting].intervaltype));
			    }
			}
		      else
			{
			  printf("bad type on MdlNames2[%d].values[%d].type = %d\n",
				 SAC, interesting,MdlNames2[SAC].values[interesting].type);
			  set_cursor(XtDisplay(modelhead),XtWindow(modelhead),ARROW);
              set_cursor(mydisplay,mywindow,GOOD);
			  return;
			} 
		    } 
		} 



	      selectlist[i]=XmStringCreate(temp,"mytag1");
	    }
	  	  


	  
	  
	  
	  
	  cfl = (struct IMarkSACList *) malloc(sizeof(struct IMarkSACList));
	  if(cfl == NULL)
	    { printf("Imark: Out of allocation memory\n"); ExitWrapper(-1); }
	  cfl->SCCindex = SCC;
	  cfl->SACindex = SAC;
	  cfl->EEindex  = interesting;
	  cfl->saveval  = NULL;

	  if(interesting==-2)
	  {
	    cfl->saveval = (char *)malloc(strlen(newstring)+3);
	    sprintf(cfl->saveval,"%s",newstring);
	  }


	  if(clonenum==0)
	    {
	      cfl->next = ErrorLookup[errnum].IMarkSACRoot[axis][ADDER][geomtype];
	      ErrorLookup[errnum].IMarkSACRoot[axis][ADDER][geomtype] = cfl;
	    }
	  else
	    {
	      cfl->next = CloneErrorLookup[cloneindex].IMarkSACRoot[axis][ADDER][geomtype];
	      CloneErrorLookup[cloneindex].IMarkSACRoot[axis][ADDER][geomtype] = cfl;
	    }

	  if(MODELDEBUG==1){printf("%d\n",i);}
	}
    }

    
  if(clonenum==0)
    {
      ErrorLookup[errnum].sac_index[axis][ADDER][geomtype]++;
    }
  else
    {
      CloneErrorLookup[cloneindex].sac_index[axis][ADDER][geomtype]++;
    }

  

  if(allvalues==1)
    {
      totalnum = 1;
    }
  else
    {
      totalnum = pos_count;
    }
  
  selectlist2 = (XmString *) (malloc(sizeof(XmString *) * totalnum));
  if(selectlist2==NULL){printf("sl: out of allocation memory!\n"); ExitWrapper(-1);}
  
  good=0;
  for(i=0;i<totalnum;i++)
    {
      XmStringGetLtoR(selectlist[i],"mytag1", &text);
      if(strlen(text)>0)
	{
	  selectlist2[good]=selectlist[i];
	  good++;
	}
      XtFree(text);
    }


  

  if(clonenum==0)
    {
      XmListAddItems(ErrorLookup[errnum].EASlist[axis][ADDER][geomtype],
		     selectlist2,good,ErrorLookup[errnum].sac_index[axis][ADDER][geomtype]);
      
      ErrorLookup[errnum].sac_index[axis][ADDER][geomtype]=ErrorLookup[errnum].sac_index[axis][ADDER][geomtype]+good-1;

      XmListDeselectAllItems(ErrorLookup[errnum].EAVlist[axis][ADDER][geomtype]);
    }
  else
    {
      XmListAddItems(CloneErrorLookup[cloneindex].EASlist[axis][ADDER][geomtype],
		     selectlist2,good,CloneErrorLookup[cloneindex].sac_index[axis][ADDER][geomtype]);
      
      CloneErrorLookup[cloneindex].sac_index[axis][ADDER][geomtype]=CloneErrorLookup[cloneindex].sac_index[axis][ADDER][geomtype]+good-1;
      XmListDeselectAllItems(CloneErrorLookup[cloneindex].EAVlist[axis][ADDER][geomtype]);
    }






  for (i = 0; i <  pos_count; i++)
    {
      XmStringFree (selectlist[i]);
    }
  free(selectlist);

  
  free(selectlist2);



  BUSY=0;
  set_cursor(XtDisplay(modelhead),XtWindow(modelhead),ARROW);
  set_cursor(mydisplay,mywindow,GOOD);
}




int NUM_CHECK(char *value)
{
  int dots=0,i;
  
  for(i=0;i<(int)(strlen(value));i++)
    {
      if((value[i]<'0')||(value[i]>'9'))
	{
	  if(value[i]=='.')
	    {
	      dots++;
	      if(dots<2){continue;}
	    }
	  if(value[i]=='-')
	    {
	      if(i==0){continue;}
	    }
	  return 0; 
	}
    }
  if(strlen(value)==0)
    {
      return 0;
    }
  return 1;
}



void mapCallback(Widget w,XtPointer data,XtPointer callData)
{
  char *chx,*chy;
  int check;
  char message[500],annotation[1000];
  double x,y;
  double minxval,maxxval,minyval,maxyval;

  if((int)data==1)
    {
      if(DEBUG==1){printf("get coords from map\n");}
      AOI_MODE=1;
      return;
    }
  else if((int)data==2)
    {
      if(DEBUG==1){printf("get coords from map\n");}
      AOI_MODE=0;
      return;
    }
  else if((int)data==3)
    {
      XtVaGetValues(MARKtext_w2,XmNvalue,&chx,NULL);
      XtVaGetValues(MARKtext_w3,XmNvalue,&chy,NULL);
      
      check = NUM_CHECK(chx);
      
      if(check!=1)
	{
          sprintf(message,"The X-coordinate you have entered is not a number.\n\
You must enter a number.");
	  not_while_running(w,message,1256,"Illegal Entry",1);
	  return;
	} 
      
      
      sscanf(chx,"%lf",&x);
      
      
      
      if(Ctype()==2)
	{
	  minxval = MinXindex*RegionSize     + Xtranslation;
	  minyval = MinYindex*RegionSize     + Ytranslation;
	  maxxval = (MaxXindex+1)*RegionSize + Xtranslation;
	  maxyval = (MaxYindex+1)*RegionSize + Ytranslation;
	}
      else if(Ctype()==1)
	{
	  minxval = (MinXindex*RegionSize)    /100000.0 + Xtranslation;
	  minyval = (MinYindex*RegionSize)    /100000.0 + Ytranslation;
	  maxxval = ((MaxXindex+1)*RegionSize)/100000.0 + Xtranslation;
	  maxyval = ((MaxYindex+1)*RegionSize)/100000.0 + Ytranslation;
	}
      else
	{
	  printf("aoi got bad coord sys flag %d\n",CoordinateSystem);
	}

      if( (x<minxval)  ||  (x>maxxval)  )
	{
	  sprintf(message,"The X-coordinate you have entered is out of range.\n\
You must enter a valid number from %lf to %lf\n",minxval,maxxval);
	  not_while_running(w,message,1257,"Illegal Entry",1);
	  return;
	}
            
      check = NUM_CHECK(chy);
      
      if(check!=1)
	{
          sprintf(message,"The Y-coordinate you have entered is not a number.\n\
You must enter a number.");
	  not_while_running(w,message,1258,"Illegal Entry",1);
	  return;
	}

      
      sscanf(chy,"%lf",&y);
      
      if( (y<minyval)  ||  (y>maxyval)  )	
	{
	  sprintf(message,"The Y-coordinate you have entered is out of range.\n\
You must enter a valid number from %lf to %lf\n",minyval,maxyval);
	  not_while_running(w,message,1259,"Illegal Entry",1);
	  return;
	}
      
      if(DEBUG==1){printf("Success! %lf %lf\n",x,y);}
      
      
      

      UnTranslateCoords(&x,&y);
    }
  else if((int)data==4)
    {
      x = thex;
      y = they;
    }  


  annotation[0] = '\0';
  sprintf(annotation,"%s",XmTextFieldGetString(point_text_button));
  if(!strcmp(annotation,"<Enter Annotation Here>"))
    {
      sprintf(annotation,"<No Annotation>");
    }
  annotation[240] = '\0'; 





  if((MARK_SHAPE==0)&&(MARK_COLOR==1))
    {
      sprintf(message,"%s: \"%s\": Red Triangle",Coordinate2DtoString(x,y),annotation);
      AddToAOIList(13,annotation,x,y);
    }
  
  else if((MARK_SHAPE==1)&&(MARK_COLOR==1))
    {
      sprintf(message,"%s: \"%s\": Red Star",Coordinate2DtoString(x,y),annotation);
      AddToAOIList(9,annotation,x,y);
    }
  
  else if((MARK_SHAPE==2)&&(MARK_COLOR==1))
    {
      sprintf(message,"%s: \"%s\": Red X-Mark",Coordinate2DtoString(x,y),annotation);
      AddToAOIList(1,annotation,x,y);
    }
  else if((MARK_SHAPE==3)&&(MARK_COLOR==1))
    {
      sprintf(message,"%s: \"%s\": Red Circle",Coordinate2DtoString(x,y),annotation);
      AddToAOIList(5,annotation,x,y);
    }
  
  else if((MARK_SHAPE==0)&&(MARK_COLOR==50))
    {
      sprintf(message,"%s: \"%s\": Green Triangle",Coordinate2DtoString(x,y),annotation);
      AddToAOIList(15,annotation,x,y);
    }
  
  else if((MARK_SHAPE==1)&&(MARK_COLOR==50))
    {
      sprintf(message,"%s: \"%s\": Green Star",Coordinate2DtoString(x,y),annotation);
      AddToAOIList(11,annotation,x,y);
    }
  
  else if((MARK_SHAPE==2)&&(MARK_COLOR==50))
    {
      sprintf(message,"%s: \"%s\": Green X-Mark",Coordinate2DtoString(x,y),annotation);
      AddToAOIList(3,annotation,x,y);
    }
  else if((MARK_SHAPE==3)&&(MARK_COLOR==50))
    {
      sprintf(message,"%s: \"%s\": Green Circle",Coordinate2DtoString(x,y),annotation);
      AddToAOIList(7,annotation,x,y);
    }
  
  else if((MARK_SHAPE==0)&&(MARK_COLOR==55))
    {
      sprintf(message,"%s: \"%s\": Blue Triangle",Coordinate2DtoString(x,y),annotation);
      AddToAOIList(14,annotation,x,y);
    }
  
  else if((MARK_SHAPE==1)&&(MARK_COLOR==55))
    {
      sprintf(message,"%s: \"%s\": Blue Star",Coordinate2DtoString(x,y),annotation);
      AddToAOIList(10,annotation,x,y);
    }
  
  else if((MARK_SHAPE==2)&&(MARK_COLOR==55))
    {
      sprintf(message,"%s: \"%s\": Blue X-Mark",Coordinate2DtoString(x,y),annotation);
      AddToAOIList(2,annotation,x,y);
    }
  else if((MARK_SHAPE==3)&&(MARK_COLOR==55))
    {
      sprintf(message,"%s: \"%s\": Blue Circle",Coordinate2DtoString(x,y),annotation);
      AddToAOIList(6,annotation,x,y);
    }
  
  else if((MARK_SHAPE==0)&&(MARK_COLOR==28))
    {
      sprintf(message,"%s: \"%s\": Yellow Triangle",Coordinate2DtoString(x,y),annotation);
      AddToAOIList(16,annotation,x,y);
    }
  
  else if((MARK_SHAPE==1)&&(MARK_COLOR==28))
    {
      sprintf(message,"%s: \"%s\": Yellow Star",Coordinate2DtoString(x,y),annotation);
      AddToAOIList(12,annotation,x,y);
    }
  
  else if((MARK_SHAPE==2)&&(MARK_COLOR==28))
    {
      sprintf(message,"%s: \"%s\": Yellow X-Mark",Coordinate2DtoString(x,y),annotation);
      AddToAOIList(4,annotation,x,y);
    }
  else if((MARK_SHAPE==3)&&(MARK_COLOR==28))
    {
      sprintf(message,"%s: \"%s\": Yellow Circle",Coordinate2DtoString(x,y),annotation);
      AddToAOIList(8,annotation,x,y);
    }
  else {XBell(mydisplay,50); printf("trouble with AOIs\n");}
  
  area_index++;
  XmListAddItem(list_point,STRING(message),area_index);


  ShowRegionMarkers();

  FlushMainScreen(1);
}


void delete_aoiCallback(Widget w,XtPointer data,XtPointer callData)
{
  int i,num;
  int *pos_list;
  XmString *blanklist;

  
  if((int)data==1)
    {
      
      
      XmListDeleteItemsPos(list_point,area_index,1);
      area_index=0;
      
      DeleteAOIList();
    }
  else
    {
      if(DEBUG==1){printf("Kill the selected aois\n");}
      
      XmListGetSelectedPos(list_point,&pos_list,&num);
      
      
      if(num==0)
	{
	  not_while_running(w,"To remove points, you must first select\n\
those points you wish to remove.",1260,"Illegal Manuever",1);
	  return;
	}
      
      for(i=0;i<num;i++)
	{	
	  if(pos_list[i]>area_index)
	    {
	      
	      continue;
	    }

	  DeleteSingleAOI(pos_list[i]);
	  area_index--;
	}

      
      for(i=num-1;i>=0;i--)
	{
	  
	  XmListDeleteItemsPos(list_point,1,pos_list[i]);
	}

            
      blanklist = (XmString *) (malloc(sizeof(XmString *) * num));
      if(blanklist==NULL){printf("bl4: out of allocation memory!\n"); ExitWrapper(-1);}

      for(i=0;i<num;i++)
	{
	  blanklist[i] = XmStringCreateLocalized("         "); 
	}
      
      


      

      XmListAddItems(list_point,blanklist,num,area_index+1);
      
      XmListDeselectAllItems(list_point);
      
      for(i=0;i<num;i++)
	{
	  XmStringFree(blanklist[i]);
	}
      free(blanklist);
    }

  
  
  refreshCallback((Widget)NULL,(XtPointer)NULL,(XtPointer)NULL);
}


void AOIhelpCallback(Widget w,XtPointer data,XtPointer callData)
{
  not_while_running(w,"This window can be used to manage points to highlight.\n\
To add points, either type a specific location, then click\n\
the button labeled \"Add Point\", OR click the button\n\
labeled \"Mark Points on Map with Mouse\", and then use the\n\
mouse to click locations on the map.  These locations will be\n\
added to the list.\n\n\
The symbol and color used for marking are taken from the\n\
on-screen menus.  To remove items from the selected list,\n\
select them in the list and click \"Remove Selected Point(s)\".\n\
Or, use the \"Remove All Points\" button to remove them all.\n\n\
Point sets may be saved and loaded using the \"Save Points...\"\n\
and \"Load Points...\" buttons.",1261,"Points Of Interest Help",5);
}


void shape_cb(Widget menu_item,XtPointer client_data,XtPointer call_data)
{
  int item_no = (int) client_data;
  
  
  MARK_SHAPE=item_no;
}





void color_cb(Widget menu_item,XtPointer client_data,XtPointer call_data)
{
  int item_no = (int) client_data;
  
  if(item_no==0)
    {item_no=1;}
  else if(item_no==1)
    {item_no=50;}
  else if(item_no==2)
    {item_no=55;}
  else if(item_no==3)
    {item_no=28;}
  
  XtVaSetValues(color_menu,
		XmNforeground,       mycolors[item_no],
		XmNtopShadowColor,   mycolors[item_no],
		XmNbottomShadowColor,mycolors[item_no],
		NULL);
  
  MARK_COLOR=item_no;
}


char * ParseCoordSystem(int coordflag)
{
  static char answer[100];

  if(NGA_TYPE==1)
    {
      if     (coordflag==1) {return "GDC (Longitude,Latitude,Elevation)";}

      XBell(mydisplay,50);
      printf("Unexpected Coordinate ststem %d\n",(int)coordflag);
      sprintf(answer,"Unknown coordinate system flag %d!\n",coordflag);
      return answer;
    }

  if     (coordflag==1) {return "SRM_SRFT_CELESTIODETIC (Longitude,Latitude,Elevation)";}
  else if(coordflag==2) {return "SRM_SRFT_TRANSVERSE_MERCATOR (meters)";}
  else if(coordflag==3) {return "SRM_SRFS_UNIVERSAL_TRANSVERSE_MERCATOR (meters)";}
  else if(coordflag==4) {return "LSRM_SRFT_LAMBERT_CONFORMAL_CONIC (meters)";}
  else if(coordflag==5) {return "SRM_SRFT_EQUIDISTANT_CYLINDRICAL (meters)";}
  else if(coordflag==6) {return "SRM_SRFT_POLAR_STEREOGRAPHIC (meters)";}
  else if(coordflag==7) {return "SRM_SRFT_SOLAR_ECLIPTIC (Longitude,Latitude,Radius)";}
  else if(coordflag==8) {return "SRM_SRFT_CELESTIOMAGNETIC (GM_Longitude,GM_Latitude,Radius)";}
  else if(coordflag==9) {return "SRM_SRFT_SOLAR_MAGNETOSPHERIC (Longitude,Latitude,Radius)";}
  else if(coordflag==10){return "SRM_SRFT_SOLAR_MAGNETIC (Longitude,Latitude,Radius)";}
  else if(coordflag==11){return "SRM_SRFT_OBLIQUE_MERCATOR (meters)";}
  else if(coordflag==12){return "SRM_SRFT_LOCAL_TANGENT_SPACE_EUCLIDEAN (meters)";}
  else if(coordflag==13){return "SRM_SRFT_MERCATOR (meters)";}
  else if(coordflag==14){return "SRM_SRFT_LOCAL_SPACE_RECT_3D (meters)";}
  else if(coordflag==15){return "SRM_SRFT_LOCAL_SPACE_RECT_2D (meters)";}
  else if(coordflag==16){return "SRM_SRFS_GTRS_GLOBAL_COORDINATE_SYSTEM (meters)";}
  else
    {
      sprintf(answer,"Unknown coordinate system flag %d!\n",coordflag);
      return answer;
    }
}





void AttrErrCallback(int attr_err_type)
{
  FILE *badattr, *badattr2;
  char badattrstr[1000];
  char badstr[1000];
  char aline[1000];
  char hugestring[100000];
  int totallen=0,realtotallen=0,badtype=0,countingonly,line,i,len;
  int abortlen=10000;
  extern int REPORT_BEZIER;


  hugestring[0] = '\0';


  

  if(input_source==0)
    {
      not_while_running(drawing_a,"You must open a GAIT project\n\
before you can see attribution errors for it.",1262,"No input directory",1);
      return;
    }

  if(REPORT_BEZIER==0)
  {
    if(attr_err_type==30)
	{
      printf("Error:  Should not call ATECB with 30 with RB 0\n");
	  return;
	}
  }


  if(attr_err_type==1)
    {
      sprintf(badattrstr,"%sbadattr.txt",outattrdirectory);
    }
  else if (attr_err_type==2)
    {
      sprintf(badattrstr,"%sValueRangeErr.txt",outattrdirectory);
    }
  else if (attr_err_type==3)
    {
      sprintf(badattrstr,"%sPickListErr.txt",outattrdirectory);
    }
  else if (attr_err_type==5)
    {
      sprintf(badattrstr,"%sUnexpectedAttr.txt",outattrdirectory);
    }
  else if (attr_err_type==6)
    {
      sprintf(badattrstr,"%sbadfcode.txt",outattrdirectory);
    }
  else if (attr_err_type==7)
    {
      sprintf(badattrstr,"%sMetaDataErr.txt",outattrdirectory);
    }
  else if (attr_err_type==8)
    {
      sprintf(badattrstr,"%sbadshapes.txt",outattrdirectory);
    }
  else if(attr_err_type==10)
    {
      sprintf(badattrstr,"%sbadcase.txt",outattrdirectory);
    }
  else if(attr_err_type==11)
    {
      sprintf(badattrstr,"%snullshp.txt",outattrdirectory);
    }
  else if(attr_err_type==12)
    {
      sprintf(badattrstr,"%sbadcoord.txt",outattrdirectory);
    }
  else if(attr_err_type==13)
    {
      sprintf(badattrstr,"%sUnexpectedGeom.txt",outattrdirectory);
    }
  else if(attr_err_type==14)
    {
      sprintf(badattrstr,"%sMissingAttribute.txt",outattrdirectory);
    }
  else if(attr_err_type==16)
    {
      sprintf(badattrstr,"%sbadhole.txt",outattrdirectory);
    }
  else if(attr_err_type==17)
    {
      sprintf(badattrstr,"%sunkcolumn.txt",outattrdirectory);
    }
  else if(attr_err_type==18)
    {
      sprintf(badattrstr,"%sDependencyErr.txt",outattrdirectory);
    }
  else if(attr_err_type==19)
    {
      sprintf(badattrstr,"%snofcodecolumn.txt",outattrdirectory);
    }
  else if(attr_err_type==20)
    {
      sprintf(badattrstr,"%sbadmgcpfilename.txt",outattrdirectory);
    }
  else if(attr_err_type==21)
    {
      sprintf(badattrstr,"%sbadshapetype.txt",outattrdirectory);
    }
  else if(attr_err_type==22)
    {
      sprintf(badattrstr,"%sblankattrval.txt",outattrdirectory);
    }
  else if(attr_err_type==23)
    {
      sprintf(badattrstr,"%smgcpmixednull.txt",outattrdirectory);
    }
  else if(attr_err_type==24)
    {
      sprintf(badattrstr,"%sbadtype.txt",outattrdirectory);
    }
  else if(attr_err_type==25)
    {
      sprintf(badattrstr,"%sbadlen.txt",outattrdirectory);
    }
  else if(attr_err_type==26)
    {
      sprintf(badattrstr,"%sReqAttrNullValueErr.txt",outattrdirectory);
    }
  else if(attr_err_type==27)
    {
      sprintf(badattrstr,"%semptyshapes.txt",outattrdirectory);
    }
  else if(attr_err_type==28)
    {
      sprintf(badattrstr,"%sID_FormatErr.txt",outattrdirectory);
    }
  else if(attr_err_type==29)
    {
      sprintf(badattrstr,"%sbadutf.txt",outattrdirectory);
    }
  else if(attr_err_type==30)
    {
      sprintf(badattrstr,"%sbadcurves.txt",outattrdirectory);
    }
  else
    {
      XBell(mydisplay,50);
      printf("got invalid attr_err_type value %d\n",attr_err_type);
	  return;
    }


  badattr = fopen(badattrstr,"r");
  if(badattr==NULL)
    {
      badtype = 1;
      if(attr_err_type==1)
	{
	  sprintf(badstr,"No \"Non Domain Specific Pick-List\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==2)
	{
	  sprintf(badstr,"No \"Value Range\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==3)
	{
	  sprintf(badstr,"No \"Domain Specific Pick-List\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==5)
	{
	  sprintf(badstr,"No \"Unexpected Attribute\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==6)
	{
	  sprintf(badstr,"No \"FCODE\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==7)
	{
	  sprintf(badstr,"No \"Metadata\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==8)
	{
	  sprintf(badstr,"No \"Zero-Part Area/Line\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==10)
	{
	  sprintf(badstr,"No \"Invalid case\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==11)
	{
	  sprintf(badstr,"No \"Null Feature\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==12)
	{
	  sprintf(badstr,"No \"Invalid Coordinate\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==13)
	{
	  sprintf(badstr,"No \"Unexpected FCODE-Geometry Pair\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==14)
	{
	  sprintf(badstr,"No \"Missing Attribute Field Or Value\" errors were recorded for this project\n\n");
	}
       else if (attr_err_type==16)
	{
	  sprintf(badstr,"No \"Invalid Cut-Out\" errors were recorded for this project\n\n");
	}
       else if (attr_err_type==17)
	{
	  sprintf(badstr,"No \"Unrecognized Column Names\" were recorded for this project\n\n");
	}
       else if (attr_err_type==18)
	{
	  sprintf(badstr,"No \"Attribute Dependency\" errors were recorded for this project\n\n");
	}
       else if (attr_err_type==19)
	{
	  sprintf(badstr,"No \"MGCP 'No FCODE Column'\" errors were recorded for this project\n\n");
	}
       else if (attr_err_type==20)
	{
	  sprintf(badstr,"No \"MGCP shapefile naming\" errors were recorded for this project\n\n");
	}
       else if (attr_err_type==21)
	{
	  sprintf(badstr,"No \"MGCP 'Shape Type'\" errors were recorded for this project\n\n");
	}
       else if (attr_err_type==22)
	{
	  sprintf(badstr,"No \"Blank Attribute\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==23)
	{
	  sprintf(badstr,"No MGCP \"Mixed Null/Non-Null optional attribute\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==24)
	{
	  sprintf(badstr,"No \"Invalid Data Type\" errors were recorded for this project\n\n");
	} 
      else if (attr_err_type==25)
	{
	  sprintf(badstr,"No \"MGCP 'Invalid Field Length'\" errors were recorded for this project\n\n");
	} 
      else if (attr_err_type==26)
	{
	  sprintf(badstr,"No \"MGCP 'Required Attribute Assigned Null Value'\" errors were recorded for this project\n\n");
	} 
      else if (attr_err_type==27)
	{
	  sprintf(badstr,"No \"Empty or Invalid Shapefiles or Tables\" were recorded for this project\n\n");
	} 
    else if (attr_err_type==28)
	{
	  
	} 
    else if (attr_err_type==29)
	{
	  sprintf(badstr,"No \"UTF-8 Encoding\" anomalies were recorded for this project\n\n");
	} 
    else if (attr_err_type==30)
	{
	  sprintf(badstr,"No \"Geodatabase Bezier/Circle/Ellipse features\" were recorded for this project\n\n");
	} 

    }


  
  if(INFO_WINDOW==0)
    {
      MakeInfo(1);
    }
  else
    {
      ResetWidget(shellhead2);
    }
  
  
  
  
  if(badtype==1)
    {
	  if(attr_err_type!=28)
	  {
        infoprint(badstr);
	  }
      return;
    }




  if(attr_err_type==17)
    {
      

      sprintf(badattrstr,"%sunkcolumnG.txt",outattrdirectory);

      badattr2 = fopen(badattrstr,"r");
      if(badattr2!=NULL)
	{

	  strcat(hugestring,"List of all unrecognized column names in the data (alphabetically sorted):\n\n");
	  
	  fgets(aline,1000,badattr2);
	  
	  while(!feof(badattr2))
	    {
	      strcat(hugestring,aline);
	      
	      totallen = totallen + strlen(aline);
	      realtotallen = realtotallen + strlen(aline);
	      
	      if(totallen>99000)
		{
		  infoprint(hugestring);
		  totallen = 0;
		  hugestring[0] = '\0';
		}
	      fgets(aline,1000,badattr2);
	    }
	  fclose(badattr2);
	}

      strcat(hugestring,"\n\nList of unrecognized column names in the data, by layer (each layer's list of unrecognized columns is sorted by the order the column names appear in the layer):\n");
    }



  
  fgets(aline,1000,badattr);
  line = 1;
  countingonly = 0;

  while(!feof(badattr))
    {
      
      
      len = strlen(aline);
      for(i=0;i<len;i++)
	{
	  if((aline[i]<0)||(aline[i]>126))  
	    {
	      aline[i] = '^';
	    }
	}



      if(countingonly==0)
	{
	  strcat(hugestring,aline);
	}

      if(line>=abortlen)
	{
	  countingonly = 1;
	}

      if(
	 ((line==1)&&(attr_err_type==19)) ||
	 ((line==1)&&(attr_err_type==20)) ||
	 ((line <3)&&(attr_err_type==2))  ||
	 ((line <3)&&(attr_err_type==3))  ||
	 ((line <3)&&(attr_err_type==4))  ||
	 ((line <3)&&(attr_err_type==5))  ||
	 ((line <3)&&(attr_err_type==7))  ||
	 ((line <3)&&(attr_err_type==13)) ||
	 ((line <3)&&(attr_err_type==14)) ||
	 ((line <3)&&(attr_err_type==18)) 
	 )
	{
	}
      else
	  {
		
        totallen = totallen + strlen(aline);
        realtotallen = realtotallen + strlen(aline);
	  }

      if((totallen>99000)&&(countingonly==0))
	{
	  infoprint(hugestring);
	  totallen = 0;
	  hugestring[0] = '\0';
	}
      fgets(aline,1000,badattr);
	  line = line + 1;

    }

    if(countingonly==1)
	{
		if(attr_err_type==22)
		{
			
			line = line - 2;
		}
		if(attr_err_type==28)
		{
			
			line = line - 1;
		}


		totallen = 100;
		sprintf(aline,"Aborting display of this error type after %d/%d lines\n",abortlen,line);
        strcat(hugestring,aline);
		sprintf(aline,"See %s\nfor a list of all the lines.\n\n",badattrstr);
        strcat(hugestring,aline);
	}


  if(totallen>2) 
    {
      infoprint(hugestring);
    }


  if((realtotallen<3)&&(attr_err_type!=28))
    {
      if(attr_err_type==1)
	{
	  sprintf(badstr,"No \"Non Domain Specific Pick-List\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==2)
	{
	  sprintf(badstr,"No \"Value Range\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==3)
	{
	  sprintf(badstr,"No \"Domain Specific Pick-List\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==4)
	{
	  sprintf(badstr,"No \"Data Type\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==5)
	{
	  sprintf(badstr,"No \"Unexpected Attribute\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==6)
	{
	  sprintf(badstr,"No \"FCODE\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==7)
	{
	  sprintf(badstr,"No \"Metadata\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==8)
	{
	  sprintf(badstr,"No \"Zero-Part Area/Line\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==10)
	{
	  sprintf(badstr,"No \"Invalid case\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==11)
	{
	  sprintf(badstr,"No \"Null Feature\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==12)
	{
	  sprintf(badstr,"No \"Invalid Coordinate\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==13)
	{
	  sprintf(badstr,"No \"Unexpected FCODE-Geometry Pair\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==14)
	{
	  sprintf(badstr,"No \"Missing Attribute Field Or Value\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==16)
	{
	  sprintf(badstr,"No \"Invalid Cut-Out\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==17)
	{
	  sprintf(badstr,"No \"Unrecognized Column Names\" were recorded for this project\n\n");
	}
      else if (attr_err_type==18)
	{
	  sprintf(badstr,"No \"Attribute Dependency\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==19)
	{
	  sprintf(badstr,"No \"MGCP 'No FCODE Column'\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==20)
	{
	  sprintf(badstr,"No \"MGCP shapefile naming\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==21)
	{
	  sprintf(badstr,"No \"MGCP 'Shape Type'\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==22)
	{
	  sprintf(badstr,"No \"Blank Attribute\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==23)
	{
	  sprintf(badstr,"No \"MGCP 'Mixed Null/Non-Null optional attribute'\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==24)
	{
	  sprintf(badstr,"No \"Invalid Data Type\" errors were recorded for this project\n\n");
	}
      else if (attr_err_type==25)
	{
	  sprintf(badstr,"No \"MGCP 'Invalid Field Length'\" errors were recorded for this project\n\n");
	} 
     else if (attr_err_type==26)
	{
	  sprintf(badstr,"No \"MGCP 'Required Attribute Assigned Null Value'\" errors were recorded for this project\n\n");
	} 
     else if (attr_err_type==27)
	{
	  sprintf(badstr,"No \"Empty or Invalid Shapefiles or Tables\" were recorded for this project\n\n");
	} 
     else if (attr_err_type==29)
	{
	  sprintf(badstr,"No \"UTF-8 Encoding\" anomalies were recorded for this project\n\n");
	} 
     else if (attr_err_type==30)
	{
	  sprintf(badstr,"No \"Geodatabase Bezier/Circle/Ellipse features\" were recorded for this project\n\n");
	} 




      infoprint(badstr);
    }
  fclose(badattr);
}





void AttrErr1Callback(Widget w,XtPointer data,XtPointer callData)
{
  AttrErrCallback(1);
}

void AttrErr2Callback(Widget w,XtPointer data,XtPointer callData)
{
  AttrErrCallback(2);
}

void AttrErr3Callback(Widget w,XtPointer data,XtPointer callData)
{
  AttrErrCallback(3);
}



void AttrErr5Callback(Widget w,XtPointer data,XtPointer callData)
{
  AttrErrCallback(5);
}

void AttrErr6Callback(Widget w,XtPointer data,XtPointer callData)
{
  AttrErrCallback(6);
}

void AttrErr7Callback(Widget w,XtPointer data,XtPointer callData)
{
  AttrErrCallback(7);
  AttrErrCallback(28);
}

void AttrErr8Callback(Widget w,XtPointer data,XtPointer callData)
{
  AttrErrCallback(8);
}

void AttrErr10Callback(Widget w,XtPointer data,XtPointer callData)
{
  AttrErrCallback(10);
}
void AttrErr11Callback(Widget w,XtPointer data,XtPointer callData)
{
  AttrErrCallback(11);
}
void AttrErr12Callback(Widget w,XtPointer data,XtPointer callData)
{
  AttrErrCallback(12);
}
void AttrErr13Callback(Widget w,XtPointer data,XtPointer callData)
{
  AttrErrCallback(13);
}

void AttrErr14Callback(Widget w,XtPointer data,XtPointer callData)
{
  AttrErrCallback(14);
}



void AttrErr16Callback(Widget w,XtPointer data,XtPointer callData)
{
  
  AttrErrCallback(16);
}

void AttrErr17Callback(Widget w,XtPointer data,XtPointer callData)
{
  
  AttrErrCallback(17);
}

void AttrErr18Callback(Widget w,XtPointer data,XtPointer callData)
{
  
  AttrErrCallback(18);
}


void AttrErr19Callback(Widget w,XtPointer data,XtPointer callData)
{
  
  AttrErrCallback(19);
}


void AttrErr20Callback(Widget w,XtPointer data,XtPointer callData)
{
  
  AttrErrCallback(20);
}

void AttrErr21Callback(Widget w,XtPointer data,XtPointer callData)
{
  
  AttrErrCallback(21);
}

void AttrErr22Callback(Widget w,XtPointer data,XtPointer callData)
{
  
  AttrErrCallback(22);
}

void AttrErr23Callback(Widget w,XtPointer data,XtPointer callData)
{
  
  AttrErrCallback(23);
}

void AttrErr24Callback(Widget w,XtPointer data,XtPointer callData)
{
  
  AttrErrCallback(24);
}

void AttrErr25Callback(Widget w,XtPointer data,XtPointer callData)
{
  
  AttrErrCallback(25);
}

void AttrErr26Callback(Widget w,XtPointer data,XtPointer callData)
{
  
  AttrErrCallback(26);
}

void AttrErr27Callback(Widget w,XtPointer data,XtPointer callData)
{
  
  AttrErrCallback(27);
}




void AttrErr29Callback(Widget w,XtPointer data,XtPointer callData)
{
  
  AttrErrCallback(29);
}

void AttrErr30Callback(Widget w,XtPointer data,XtPointer callData)
{
  
  AttrErrCallback(30);
}



void AttrErr9Callback(Widget w,XtPointer data,XtPointer callData)
{
  FILE *readfile;
  char aline[1000];
  char hugestring[10000];
  int  totallen=0;
  int  realtotallen=0;

  hugestring[0] = '\0';

  WriteSummaryReport(2);



  if(INFO_WINDOW==0)
    {
      MakeInfo(1);
    }
  else
    {
      ResetWidget(shellhead2);
    }


  sprintf(aline,"%stemp.txt",indirectory);
  readfile = fopen(aline,"r");
    
  if(readfile==NULL)
    {
      printf("could not open %s for read\n",aline);
      return;
    }
    

  fgets(aline,1000,readfile);

  while(!feof(readfile))
    {
      strcat(hugestring,aline);
      totallen = totallen + strlen(aline);
      realtotallen = realtotallen + strlen(aline);
      if(totallen>9000)
	{
	  infoprint(hugestring);
	  totallen = 0;
	  hugestring[0] = '\0';
	}
      fgets(aline,1000,readfile);
    }
  
  if(totallen>0)
    {
      infoprint(hugestring);
    }
  
  fclose(readfile);
}







char *GetElevRangeString(double minx,double miny,double maxx, double maxy)
{
  char temp[1000];
  int is2D=0,is3D=0;
  static char result[1000];
  extern double db_min_z2,db_max_z2;

  extern void GetNumFeat(char *name,long int *nfeat, unsigned long int *ngrid,int *is2D, int *is3D);


  result[0] = '\0';

  if((Total2DPoint+Total2DLine+Total2DArea)>0)
  {
	is2D = 1;
  }
  if((Total3DPoint+Total3DLine+Total3DArea)>0)
  {
	is3D = 1;
  }


  if((is2D==1)&&(is3D==0))
  {
	sprintf(temp,"2D Dataset                                   :\n");
  }
  else if((is2D==0)&&(is3D==1))
  {
	sprintf(temp,"3D Dataset                                   :\n");
  }
  else if((is2D==1)&&(is3D==1))
  {
	sprintf(temp,"Mixed 2D&3D Dataset                          :\n");
  }
  else
  {
	
	sprintf(temp,"3D Dataset                                   :\n");
	is3D = 1; 
  }

  strcat(result,temp);

  sprintf(temp,"SW corner of data                            : (%.7lf,%.7lf)\n",minx,miny);
  strcat(result,temp);

  sprintf(temp,"NE corner of data                            : (%.7lf,%.7lf)\n",maxx,maxy);
  strcat(result,temp);


  if((is3D==1)&&(ATTRTYPE_TREX()==0))
  {
    
    sprintf(temp,"Z-Value Range                                : [%.7lf - %.7lf]\n",db_min_z2,db_max_z2);
    strcat(result,temp);
  }

  return result;
}


char *SegmentLongString(char *longstr)
{
  int LONG_LIMIT=60,i,thischunk,len,insertindex;
  static char retval[1000];

  insertindex = 0;
  thischunk = 0;
  len = strlen(longstr);

  if(len>LONG_LIMIT)
  {
    for(i=0;i<len;i++)
	{
      if(i>900)
	  {
        XBell(mydisplay,50);
        printf("Too long pathname (%d): %s\n",len,longstr);
        break;
	  }

      if(thischunk<LONG_LIMIT)
	  {
        retval[insertindex]=longstr[i];
		insertindex = insertindex + 1;
		thischunk = thischunk + 1;
	  }
	  else if((longstr[i]=='\\')||(longstr[i]=='/'))
	  {
        retval[insertindex]=longstr[i];
		insertindex = insertindex + 1;
        retval[insertindex]='\n';
		insertindex = insertindex + 1;
        thischunk = 0;
	  }
	  else
	  {
        retval[insertindex]=longstr[i];
		insertindex = insertindex + 1;
	  }
	}
	retval[insertindex] = '\0';
  }
  else
  {
    sprintf(retval,"%s",longstr);
  }

  return retval;
}



char *GetTRExType(char *projectpath)
{
  FILE *tempfile;
  char temp[1000];
  static char result[100];
  
  sprintf(temp,     "%sinternal_data%stimp2.bin",projectpath,GetSlash());
  tempfile = fopen(temp,"r");
  if(tempfile==NULL)
  { 
	printf("error: unable to open %s for reading\n",temp);
	return "Error: See console";
  } 

  fgets(result,90,tempfile);
  fclose(tempfile);

  return result;
}


void SummaryCallback(Widget w,XtPointer data,XtPointer callData)
{
  FILE *headfile;
  char temp[1000], message[2000], aline[1000], tempjunk[1000],
    message1[1000], message2[1000], message3[1000],class_str[1000],class_value[1000];
  char test1[100],test2[100],test3[100];
  double MINYREAD, MINXREAD, MAXYREAD, MAXXREAD, MINY_P_READ, MINX_P_READ, MAXY_P_READ, MAXX_P_READ;
  long int POINT_POINTSREAD, LINEAR_POINTSREAD, AREAL_POINTSREAD;
  unsigned int TERRAINPOLYSREAD,GRIDPOINTSREAD;
  int GRIDSREAD, coordflag, num_long_entries,num_short_entries, num_line_features=0,len,i,
    num_area_features=0,num_area_cutout=0,tempint = 0, Ijunk, num_point_features=0,level,
	attrinstype=-999;
  int mpfeatures[5], mpcounts[5];
  extern int GetClassLevelStrings(int testclass,char retval1[],char retval2[],char retval3[]);


  if(input_source==0)
    {
      if(NGA_TYPE==1)
	{
	  not_while_running(w,"You must open a GAIT project\n\
before you can see summary information about it.",1263,"No input directory",1);
	}
      else
	{
	  not_while_running(w,"You must select an input data directory\n\
before you can see summary information about it.",1264,"No input directory",1);
	}
      return;
    }
  
  sprintf(temp,"%sheader.txt",indirectory);

  headfile = fopen(temp,"r");
  if(headfile==NULL)
    {
      sprintf(message,"Couldnt open %s for read.\n",temp); 
      not_while_running(drawing_a,message,1265,"Couldnt open file",1);
      return;
    }
  
  fscanf(headfile,"%d %lf %lf %lf %lf %lf %lf %lf %lf %u %u %ld %ld %ld %d %d %d\n",
	 &coordflag,
	 &MINXREAD,&MINYREAD,&MAXXREAD,&MAXYREAD,
	 &MINX_P_READ,&MINY_P_READ,&MAXX_P_READ,&MAXY_P_READ,
	 &TERRAINPOLYSREAD,
	 &GRIDPOINTSREAD,&POINT_POINTSREAD,&LINEAR_POINTSREAD,&AREAL_POINTSREAD,&GRIDSREAD,
	 &num_long_entries,&num_short_entries);

  fclose(headfile);


  tempint = 0;
  sprintf(temp,"%slinearinfo.txt",indirectory);
  headfile = fopen(temp,"r");
  if(headfile==NULL)
    {
      sprintf(message,"Couldnt open %s for read.\n",temp); 
      not_while_running(drawing_a,message,1265,"Couldnt open file",1);
      return;
    }
  
  fscanf(headfile,"%d",&tempint);
  while(!feof(headfile))
    {
      num_line_features = num_line_features + tempint;
      fscanf(headfile,"%d",&tempint);
    }
  fclose(headfile);
  




  tempint = 0;
  sprintf(temp,"%sarealinfo.txt",indirectory);
  headfile = fopen(temp,"r");
  if(headfile==NULL)
    {
      sprintf(message,"Couldnt open %s for read.\n",temp); 
      not_while_running(drawing_a,message,1265,"Couldnt open file",1);
      return;
    }
  
  fscanf(headfile,"%d",&tempint);
  while(!feof(headfile))
    {
      num_area_features = num_area_features + tempint;
      fscanf(headfile,"%d",&tempint);
    }

  fclose(headfile);


    tempint = 0;
  sprintf(temp,"%spointinfo.txt",indirectory);
  headfile = fopen(temp,"r");
  if(headfile==NULL)
    {
      sprintf(message,"Couldnt open %s for read.\n",temp); 
      not_while_running(drawing_a,message,1265,"Couldnt open file",1);
      return;
    }
  
  fscanf(headfile,"%d",&tempint);
  while(!feof(headfile))
    {
      num_point_features = num_point_features + tempint;
      fscanf(headfile,"%d",&tempint);
    }

  fclose(headfile);





  sprintf(temp,"%smultiinfo.txt",indirectory);
  headfile = fopen(temp,"r");
  if(headfile==NULL)
    {
      sprintf(message,"Couldnt open %s for read.\n",temp); 
      not_while_running(drawing_a,message,1265,"Couldnt open file",1);
      return;
    }
  
  fscanf(headfile,"%d",&Ijunk);           
  fscanf(headfile,"%d",&Ijunk);           
  fscanf(headfile,"%d",&Ijunk);           
  fscanf(headfile,"%d",&Ijunk);           
  fscanf(headfile,"%d",&Ijunk);           
  fscanf(headfile,"%d",&mpfeatures[0]);   
  fscanf(headfile,"%d",&mpfeatures[1]);   
  fscanf(headfile,"%d",&mpfeatures[2]);   
  fscanf(headfile,"%d",&mpcounts[0]);     
  fscanf(headfile,"%d",&mpcounts[1]);     
  fscanf(headfile,"%d",&mpcounts[2]);     
  fscanf(headfile,"%d",&num_area_cutout); 
  fscanf(headfile,"%d",&attrinstype);     
  fgets(class_str,1000,headfile);         
  fgets(class_str,1000,headfile);         
  fgets(class_value,1000,headfile);       

  fclose(headfile);


  if((MINXREAD<MAXXREAD)&&(MINYREAD<MAXYREAD))
    {
      if(NGA_TYPE==1)
	{
	  
	  sprintf(message1,"Project: %s\n\n\
Point Features                               : %d\n\
Line Features                                : %d\n\
Area Features                                : %d\n\
Total Features                               : %d\n\n",
		  indirectory,
		  num_point_features,
		  num_line_features,
		  num_area_features,
		  num_point_features+num_line_features+num_area_features);

	  message2[0] = '\0';
	  if(mpfeatures[0]>0)
	    {
	      sprintf(tempjunk,"Number of multi-part point features          : %d (%d total parts)\n",
		      mpfeatures[0],mpcounts[0]);
	      strcat(message2,tempjunk);
	    }

	  if(mpfeatures[1]>0)
	    {
	      sprintf(tempjunk,"Number of multi-part line features           : %d (%d total parts)\n",
		      mpfeatures[1],mpcounts[1]);
	      strcat(message2,tempjunk);
	    }

	  if(mpfeatures[2]>0)
	    {
	      sprintf(tempjunk,"Number of multi-part area features           : %d (%d total parts)\n",
		      mpfeatures[2],mpcounts[2]);
	      strcat(message2,tempjunk);
	    }

	  if(num_area_cutout>0)
	    {
	      sprintf(tempjunk,"Number of area feature cut-outs              : %d\n",
		      num_area_cutout);
	      strcat(message2,tempjunk);
	    }
	  



	  if(coordflag==2)
	  {
	  sprintf(message3,"Grids                                        : %d\n\
%ss                                        : %u\n\n%s\n\
Coordinate System                            : TM/UTM\n",
		  GRIDSREAD,GetECCLabel(0),GRIDPOINTSREAD,
		  GetElevRangeString(MINXREAD,MINYREAD,MAXXREAD,MAXYREAD));
	  }
	  else
	  {
	  sprintf(message3,"Grids                                        : %d\n\
%ss                                        : %u\n\n%s\n\
Coordinate System                            : Longitude, Latitude, Elevation\n",
		  GRIDSREAD,GetECCLabel(0),GRIDPOINTSREAD,
		  GetElevRangeString(MINXREAD,MINYREAD,MAXXREAD,MAXYREAD));
	  }



	  if(strlen(message2)>5)
	    {
	      sprintf(message,"%s%s\n%s",message1,message2,message3);
	    }
	  else
	    {
	      sprintf(message,"%s%s",message1,message3);
	    }
	}
      else
	{
	  sprintf(message,"Database: %s\n\n\
Point Features              : %ld\n\
Linear Features (Vertices)  : %d (%ld)\n\
Areal Features (Vertices)   : %d (%ld)\n\
Polygons                    : %d\n\
Grids                       : %d\n\
Grid Points                 : %d\n\n\
Lower left corner of data   : (%lf,%lf)\n\
Upper right corner of data  : (%lf,%lf)\n\n\
Database Coordinate System  : %s\n",
		  indirectory,POINT_POINTSREAD,
		  num_line_features,LINEAR_POINTSREAD,
		  num_area_features,AREAL_POINTSREAD,
		  TERRAINPOLYSREAD,GRIDSREAD,GRIDPOINTSREAD,
		  MINXREAD,MINYREAD,MAXXREAD,MAXYREAD,ParseCoordSystem(coordflag));
	}
    }

  else if((MINX_P_READ<MAXX_P_READ)&&(MINY_P_READ<MAXY_P_READ))
    {
      if (MINX_P_READ < MINXREAD) 
	MINXREAD = MINX_P_READ;
      if (MAXX_P_READ < MAXXREAD) 
	MAXXREAD = MAXX_P_READ;
      if (MINY_P_READ < MINYREAD) 
	MINYREAD = MINY_P_READ;
      if (MAXY_P_READ < MAXYREAD) 
	MAXYREAD = MAXY_P_READ;
  
      if(NGA_TYPE==1)
	{
	  sprintf(message1,"Project: %s\n\n\
Point Features                               : %ld\n\
Line Features                                : %d\n\
Area Features                                : %d\n\
Total Features                               : %ld\n\n",
		  indirectory,POINT_POINTSREAD,
		  num_line_features,
		  num_area_features,
		  POINT_POINTSREAD+num_line_features+num_area_features);

	  message2[0] = '\0';
	  if(mpfeatures[0]>0)
	    {
	      sprintf(tempjunk,"Number of multi-part point features: %d (%d total parts)\n",
		      mpfeatures[0],mpcounts[0]);
	      strcat(message2,tempjunk);
	    }

	  if(mpfeatures[0]>0)
	    {
	      sprintf(tempjunk,"Number of multi-part line features: %d (%d total parts)\n",
		      mpfeatures[1],mpcounts[1]);
	      strcat(message2,tempjunk);
	    }

	  if(mpfeatures[0]>0)
	    {
	      sprintf(tempjunk,"Number of multi-part area features: %d (%d total parts)\n",
		      mpfeatures[2],mpcounts[2]);
	      strcat(message2,tempjunk);
	    }

	  if(num_area_cutout>0)
	    {
	      sprintf(tempjunk,"Number of area feature cut-outs: %d\n",
		      num_area_cutout);
	      strcat(message2,tempjunk);
	    }
	  



	  sprintf(message3,"Grids                                        : %d\n\
%ss                                        : %d\n\n%s\n\
Coordinate System                            : Longitude, Latitude, Elevation\n",
		  GRIDSREAD,GetECCLabel(0),GRIDPOINTSREAD,
		  GetElevRangeString(MINXREAD,MINYREAD,MAXXREAD,MAXYREAD));


	  if(strlen(message2)>5)
	    {
	      sprintf(message,"%s%s\n%s",message1,message2,message3);
	    }
	  else
	    {
	      sprintf(message,"%s%s",message1,message3);
	    }

	}
      else
	{
	  sprintf(message,"Database: %s\n\n\
Point Features             : %ld\n\
Linear Features (Vertices) : %d (%ld)\n\
Areal Features (Vertices:  : %d (%ld)\n\
Polygons                   : %d\n\
Grids                      : %d\n\
Grid Points                : %d\n\n\
Lower left corner of data  : (%lf,%lf)\n\
Upper right corner of data : (%lf,%lf)\n\n\
Database Coordinate System : %s\n",
		  indirectory,POINT_POINTSREAD,
		  num_line_features,LINEAR_POINTSREAD,
		  num_area_features,AREAL_POINTSREAD,
		  TERRAINPOLYSREAD,GRIDSREAD,GRIDPOINTSREAD,
		  MINXREAD,MINYREAD,MAXXREAD,MAXYREAD,ParseCoordSystem(coordflag));
	}
    }
  else
    {
      if(NGA_TYPE==1)
	{
	  
	  printf("Error in SI generation\n");
	  XBell(mydisplay,50);
	}
      else
	{
	  sprintf(message,"Database: %s\n\n\
Point Features             : %ld\n\
Linear Features (Vertices) : %d (%ld)\n\
Areal Features (Vertices)  : %d (%ld)\n\
Polygons                   : %d\n\
Grids                      : %d\n\
Grid Points                : %d\n\n\
Lower left corner of data  : <no coordinates found>\n\
Upper right corner of data : <no coordinates found>\n\n\
Database Coordinate System : %s\n",
		  indirectory,POINT_POINTSREAD,
		  num_line_features,LINEAR_POINTSREAD,
		  num_area_features,AREAL_POINTSREAD,
		  TERRAINPOLYSREAD,GRIDSREAD,GRIDPOINTSREAD,
		  ParseCoordSystem(coordflag));      
	}
    }
  


  temp[0] = '\0';

  if(NGA_TYPE==1)
    {
      sprintf(temp,"\nAttribution Schema in effect for this project: %s\n",ParseAttributionType(ATTRIBUTION_TYPE));
      strcat(message,temp);
    }

  if( ((ATTRTYPE_NFDD())||(ATTRTYPE_DFDD()))  &&  (ATTRTYPE_TREX()==0)  )
  {

    if((ATTRTYPE_NFDD()))
	{
      strcat(message,"\nAdditional attribution analyses may be specified for NFDD projects:\n");
	}
    else if((ATTRTYPE_DFDD()))
	{
      strcat(message,"Additional attribution analyses may be specified for DFDD projects:\n");
	}

    if(attrinstype==1)
	{
      strcat(message,"  No additional attribution analyses were performed\n");
    }
    else if(attrinstype==2)
	{
      strcat(message,"  Built-in NAS-based additional attribution analyses were performed\n");
    }
    else if(attrinstype==3)
	{
      strcat(message,"  User-specified additional attribution analyses were performed, based on\n");
      if((ATTRTYPE_NFDD()))
	  {
        strcat(message,"  specifications in \"NFDD.csv\" and \"NFDD_domains.csv\".  These files have\n");
		strcat(message,"  been copied into this project's \"attribution_errors\" foler.\n");
	  }
      else if((ATTRTYPE_DFDD()))
	  {
        strcat(message,"  specifications in \"DFDD.csv\" and \"DFDD_domains.csv\".  These files have\n");
		strcat(message,"  been copied into this project's \"attribution_errors\" foler.\n");
	  }
    }
    else if(attrinstype==4)
	{
      strcat(message,"  User-specified additional attribution analyses were performed, based on\n");
      if((ATTRTYPE_NFDD()))
	  {
        strcat(message,"  specifications in \"NFDD.csv\" and \"NFDD_domains.csv\".  These files have\n");
		strcat(message,"  been copied into this project's \"attribution_errors\" foler.\n");
	  }
      else if((ATTRTYPE_DFDD()))
	  {
        strcat(message,"  specifications in \"DFDD.csv\" and \"DFDD_domains.csv\".  These files have\n");
		strcat(message,"  been copied into this project's \"attribution_errors\" foler.\n");
	  }

      strcat(message,"  User-specified valid value analyses were performed, based on\n");
      if((ATTRTYPE_NFDD()))
	  {
        strcat(message,"  specifications in \"NFDD_VV.csv\" and \"NFDD_VVdomains.csv\".  These files have\n");
		strcat(message,"  been copied into this project's \"attribution_errors\" foler.\n");
	  }
      else if((ATTRTYPE_DFDD()))
	  {
        strcat(message,"  specifications in \"DFDD_VV.csv\" and \"DFDD_VVdomains.csv\".  These files have\n");
		strcat(message,"  been copied into this project's \"attribution_errors\" foler.\n");
	  }
    }
	else
	{
      sprintf(tempjunk,"  Error: failed to parse value %d\n",attrinstype);
      strcat(message,tempjunk);
	}
  }

  sprintf(temp,"%smetatype.txt",indirectory);
  headfile = fopen(temp,"r");
  if(headfile==NULL)
    {
      printf("Failed to generate summary info: couldnt open %s\n",temp); 
    }
  else
    {
      fgets(aline,1000,headfile);
      len = strlen(aline);
      for(i=0;i<len;i++)
	{
	  if(aline[i]<32)
	    {
	      aline[i] = '\n';
	    }
	}
      
      
      if(NGA_TYPE==1)
	{
      if(
		  (ATTRTYPE_D4()) || 
		  (ATTRTYPE_FACC()) || 
		  (ATTRTYPE_VMAP()) || 
		  (ATTRTYPE_UFD1()) || 
		  (ATTRTYPE_UFD2()) || 
		  (ATTRTYPE_UFD3())
		  )
	    {
	      sprintf(temp,"Metadata naming convention for this project  : %s\n",aline);
	      strcat(message,temp);
	    }
	  else
	    {
	      strcat(message,"\n");
	    }
	}
      fgets(aline,1000,headfile);
      len = strlen(aline);
      for(i=0;i<len;i++)
	{
	  if(aline[i]<32)
	    {
	      aline[i] = '\n';
	    }
	}


	if(ATTRTYPE_TREX())
	{
	  sprintf(temp,"TREx GeoCell      : %s\n",GetTRExSubName2(indirectory,1));
	  strcat(message,temp);

	  sprintf(temp,"TREx analysis type: %s\n\n",GetTRExType(indirectory));
	  strcat(message,temp);
	}

    if(strncmp(class_str,"zzZZzzZZ_____",13))
	  {
		level = strlen(class_value);
		if(level>1)
		{
          if(class_value[level-2]<32)
		  {
            class_value[level-2] = '\0';
		  }
          else if(class_value[level-1]<32)
		  {
            class_value[level-1] = '\0';
		  }
		}
		else
		{
          printf("Error: bad CV (%d) = %s\n",level,class_value);
		}
		

        level = GetClassLevelStrings(ThisClassLevel,test1,test2,test3);

		if(!strcmp(test1,"TREX"))
		{
		  sprintf(message2,"\
Maximum classification found: %s\n\
 in TREX XML: %s\n",class_value,SegmentLongString(class_str));
		}
		else
		{
		  sprintf(message2,"\
Maximum classification found:\n\
  Attribute Code, Value, Meaning: \"%s\", \"%s\", \"%s\"\n\
  Found in file/location:\n   %s\n",test1,class_value,test3,SegmentLongString(class_str));
		}


		strcat(message,message2);
	}

    sprintf(temp,"Time to create this project  : %s\n",aline);
    strcat(message,temp);



    fclose(headfile);
  }

  not_while_running(w,message,1266,"Summary Info",5);
}



void AOILoadsettingCallback(Widget w,Widget list_w,XtPointer unused)
{
  XmString *selectlist;
  FILE *modfile;
  char *text;
  char message[1000],newname[1000],aline[1000],fname[1000],badout[1000],annotation[1000];
  double x,y;
  int filecoordtype,type,totalobjs,insertindex,numspaces,len,i,num_lines=0,old_aoi_num=0;
  struct POIList *cfl;


  sprintf(annotation,"fix this");
  
  
  XtVaGetValues(list_w,
		XmNselectedItemCount,&totalobjs,
		XmNselectedItems    ,&selectlist,
		NULL);
  
  
  if(totalobjs!=1)
    {
      sprintf(message,"To load a point set, select one from\n\
the list, and then click \"Load Selected Point Set\",\n\
or double-click it in the list.");

      not_while_running(w,message,1437,"Load Points Help",5);
      
      return;
    }
  
  XmStringGetLtoR(selectlist[0],
		  (XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
  
  
  sscanf(text,"%s",newname);
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(fname,"%spoints_of_interest_files\\%s",indirectory,newname);
    }
  else
    {
      sprintf(fname,"%spoints_of_interest_files/%s",indirectory,newname);
    }


    
  XtDestroyWidget(aoi_dialog);
  modfile = fopen(fname,"r");
  if(modfile==NULL)
    {
      sprintf(badout,"unable to open %s for read\n",fname);
      not_while_running(regionhead,badout,1268,"Unable to read",1);
      return;
    }


  
  
  fgets(aline,1000,modfile);
  sscanf(aline,"%d",&filecoordtype);
  if(filecoordtype!=CoordinateSystem)
    {
      sprintf(badout,"The file:\n %s\n\
is either invalid or was created for a different coordinate system than\n\
the coordinate system of this database.  Aborting attempt to use it.\n\
(%s and %s)\n",fname,
	      ParseCoordSystem(filecoordtype),
	      ParseCoordSystem(CoordinateSystem)
	      );
      not_while_running(regionhead,badout,1269,"Bad coord system",1);
      return;
    }
  
  if(feof(modfile))
    {
      not_while_running(regionhead,"No points found in selected file",1270,"No points",1);
      return;
    }
  
  old_aoi_num = 0;
  cfl = POIRoot;
  while(cfl!=NULL)
  {
    cfl = cfl->next;
	old_aoi_num = old_aoi_num + 1;
  }

  printf("Adding POIs to the existing list of %d POIs\n",old_aoi_num);

  fgets(aline,1000,modfile);
  while(!feof(modfile))
    {

      num_lines = num_lines + 1;

	  if((old_aoi_num+num_lines+20)>MAX_POI_NUM)
	  {
        printf("Error: More than %d points of interest requested...termininating after %d POIs\n",MAX_POI_NUM,MAX_POI_NUM);
		break;
	  }


      sscanf(aline,"%d%lf%lf",&type,&x,&y);


      

      numspaces = 0; 
      insertindex = 0;
      len = strlen(aline);
      for(i=0;i<len;i++)
	{
	  if(numspaces<3)
           { 
	     if(aline[i]==' ')
	       {
		 numspaces = numspaces + 1;
	       }
	   }
	  else if((aline[i]>=32)&&(aline[i]<=126)) 
	   {
	     annotation[insertindex] = aline[i];
	     insertindex = insertindex + 1;
	   }
	}

      annotation[insertindex] = '\0';
 

      if(Ctype()==1)
	{
	  x = x - Xtranslation;
	  y = y - Ytranslation;
	  
	  x = x * 100000;
	  y = y * 100000;
	}
      
      if(type==13)
	{
	  sprintf(message,"%s: \"%s\": Red Triangle",Coordinate2DtoString(x,y),annotation);
	}  
      else if(type==9)
	{
	  sprintf(message,"%s: \"%s\": Red Star",Coordinate2DtoString(x,y),annotation);
	}
      else if(type==1)  
	{
	  sprintf(message,"%s: \"%s\": Red X-Mark",Coordinate2DtoString(x,y),annotation);
	}
      else if(type==5)
	{
	  sprintf(message,"%s: \"%s\": Red Circle",Coordinate2DtoString(x,y),annotation);
	}
      else if(type==15)
	{
	  sprintf(message,"%s: \"%s\": Green Triangle",Coordinate2DtoString(x,y),annotation);
	}
      else if(type==11)
	{
	  sprintf(message,"%s: \"%s\": Green Star",Coordinate2DtoString(x,y),annotation);
	}
      else if(type==3)
	{
	  sprintf(message,"%s: \"%s\": Green X-Mark",Coordinate2DtoString(x,y),annotation);
	}
      else if(type==7)
	{
	  sprintf(message,"%s: \"%s\": Green Circle",Coordinate2DtoString(x,y),annotation);
	}
      else if(type==14)
	{
	  sprintf(message,"%s: \"%s\": Blue Triangle",Coordinate2DtoString(x,y),annotation);
	}
      else if(type==10)
        {
          sprintf(message,"%s: \"%s\": Blue Star",Coordinate2DtoString(x,y),annotation);
        }
      else if(type==2)
        {
          sprintf(message,"%s: \"%s\": Blue X-Mark",Coordinate2DtoString(x,y),annotation);
        }
      else if(type==6)
        {
          sprintf(message,"%s: \"%s\": Blue Circle",Coordinate2DtoString(x,y),annotation);
        }
      else if(type==16)
        {
          sprintf(message,"%s: \"%s\": Yellow Triangle",Coordinate2DtoString(x,y),annotation);
        }
      else if(type==12)
        {
          sprintf(message,"%s: \"%s\": Yellow Star",Coordinate2DtoString(x,y),annotation);
        }
      else if(type==4)
        {
          sprintf(message,"%s: \"%s\": Yellow X-Mark",Coordinate2DtoString(x,y),annotation);
        }
      else if(type==8)
        {
          sprintf(message,"%s: \"%s\": Yellow Circle",Coordinate2DtoString(x,y),annotation);
        }
      else 
        {
          XBell(mydisplay,50); 
          printf("trouble with AOIs\n");
        }
 
      area_index++;
      XmListAddItem(list_point,STRING(message),area_index);
	  
      AddToAOIList(type,annotation,x,y);
      fgets(aline,1000,modfile);
    }

   ShowRegionMarkers();

   FlushMainScreen(1);

  fclose(modfile);
}


void AOISaveCallback(Widget w,XtPointer data,XtPointer callData)
{
  static Widget dialog;
  Widget rc,form,label1,button;
  Arg resources[15];
  int n=0;

  if(POIRoot==NULL)
   {  
     not_while_running(w,"There are no current points to save!",1433,"No points to save",1);
     return;
   }
 

  if(AOI_SAVE_UP==1)
    {
      ResetWidget(dialog);
      return;
    }



  n=0;
  XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++;
  XtSetArg(resources[n],  XmNmaxWidth,       800);       n++;
  

  dialog = XtCreatePopupShell("Save Points",topLevelShellWidgetClass,w,resources,n);

  
  rc = XtVaCreateManagedWidget
    (
     "XformWidget", xmPanedWindowWidgetClass, dialog,
     XmNrubberPositioning, False,
     XmNresizable,         True,
     XmNseparatorOn,       False,
     XmNsashHeight,        1,
     NULL
     );
  
  form = XtVaCreateWidget ("form7", xmFormWidgetClass, rc,
			   XmNpaneMinimum,     35,
			   XmNpaneMaximum,     35,
			   XmNseparatorOn,     False,
			   XmNfractionBase,    100,  
			   NULL);
  
  
  label1 = XtVaCreateManagedWidget ("Enter name for saved points:",
				    xmLabelWidgetClass,  form,
				    XmNrightAttachment,  XmATTACH_POSITION,
				    XmNrightPosition,    50,
				    XmNleftAttachment,   XmATTACH_POSITION,
				    XmNleftPosition,     0,
				    XmNalignment,        XmALIGNMENT_CENTER,
				    XmNtopAttachment,    XmATTACH_FORM,
				    XmNbottomAttachment, XmATTACH_FORM,
				    LABELWTRANSLATE,
				    NULL);
  XtManageChild(label1);
  
  


  
  aoi_save_wid = XtVaCreateManagedWidget ("text_w",
				     xmTextFieldWidgetClass, form,	  
				     XmNvalue,               SaveAOIName,
				     XmNmaxLength,           24,
				     XmNtraversalOn,         True,
				     XmNrightAttachment,     XmATTACH_POSITION,
				     XmNrightPosition,       99,
				     XmNleftAttachment,      XmATTACH_POSITION,
				     XmNleftPosition,        51,
				     XmNtopAttachment,       XmATTACH_FORM,
				     XmNbottomAttachment,    XmATTACH_FORM,
                     XmNtranslations,        XtParseTranslationTable ( translations_paste ) ,
				     NULL);
  
  XtAddCallback (aoi_save_wid, XmNactivateCallback,
		 EnterFileCallback, (XtPointer)22);
  XtManageChild(aoi_save_wid);
  XtManageChild(form);
  
  
  
  
  
  form = XtVaCreateWidget ("form174", xmFormWidgetClass, rc,
			   XmNpaneMinimum,   25,
			   XmNpaneMaximum,   25,
			   XmNseparatorOn,   False,
			   XmNfractionBase,  100,  
			   NULL);      

  button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
				    XmNlabelString,       STRING("Help"),
				    XmNtopAttachment,     XmATTACH_FORM,
				    XmNbottomAttachment,  XmATTACH_FORM,
				    XmNrightAttachment,   XmATTACH_POSITION,
				    XmNrightPosition,     33,
				    XmNleftAttachment,    XmATTACH_POSITION,
				    XmNleftPosition,      1,
				    XmNtraversalOn,       False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    );
  
  XtAddCallback(button, XmNactivateCallback, saveaoihelpCallback, (XtPointer) NULL);
  XtManageChild(button);
  
  

  button  = XtVaCreateManagedWidget("SCR3",xmPushButtonWidgetClass,form,
				    XmNlabelString,       STRING("Cancel"),
				    XmNtopAttachment,     XmATTACH_FORM,
				    XmNbottomAttachment,  XmATTACH_FORM,
				    XmNrightAttachment,   XmATTACH_POSITION,
				    XmNrightPosition,     66,
				    XmNleftAttachment,    XmATTACH_POSITION,
				    XmNleftPosition,      33,
				    XmNtraversalOn,       False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    );

  XtAddCallback(button, XmNactivateCallback, die_callback, (XtPointer)1022);
  XtManageChild(button);




  button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
				    XmNlabelString,       STRING("Save/Done"),
				    XmNtopAttachment,     XmATTACH_FORM,
				    XmNbottomAttachment,  XmATTACH_FORM,
				    XmNrightAttachment,   XmATTACH_POSITION,
				    XmNrightPosition,     99,
				    XmNleftAttachment,    XmATTACH_POSITION,
				    XmNleftPosition,      66,
				    XmNtraversalOn,       False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    ); 
  
  XtAddCallback(button, XmNactivateCallback, saveaoiCallback, (XtPointer) NULL);
  XtManageChild(button); 
  XtManageChild(form);


  XtManageChild(rc);
  MyPopup(dialog); 
  XtAddCallback(dialog,XmNdestroyCallback,ShellDeath,(XtPointer)296);
  AOI_SAVE_UP = 1;
}





void AOILoadCallback(Widget w, XtPointer userData, XtPointer callData)
{
  static Widget dialog;
  int num,i;
  char startdirectory[1000],message[1000];
  
  
  if(AOI_LOAD_UP==1)
    {
      ResetWidget(dialog);
      return;
    }
  
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(startdirectory,"%spoints_of_interest_files\\",indirectory);
    }
  else
    {
      sprintf(startdirectory,"%spoints_of_interest_files/",indirectory);
    }
  
  num = GetFolders(startdirectory,5,1);


  if(num==0)
    {
      sprintf(message,"No saved points were found in the current GAIT project.\n");
      
      not_while_running(w,message,1436,"No Saved Points Found",1);   
      return;
    }
  else
    {
      


      SortAOIList(0,num-1,4);


      
    }


  ModifyAOIList(num);



       
  
  aoi_dialog = MakePicker(w,5,num,-1,-1); 
  dialog     = aoi_dialog;

  AOI_LOAD_UP = 1;
  
  for(i=0;i<num;i++)
    {
      free(GAITAOIList[i]);
    }
  free(GAITAOIList);
  GAITAOIList = NULL;
}



void set_annot(Widget widget,XtPointer client_data,XtPointer call_data)
{  
  DrawAnnotations = !DrawAnnotations;
}




void choose_specific_poi(Widget widget,XtPointer client_data,XtPointer call_data)
{ 
  int *pos_list;
  int pos_count,i=0,count;
  double tmpLLX,tmpURX,tmpLLY,tmpURY;
  static int LOCALBUSY = 0;
  struct POIList *cfl;


  if(ZoomToPOIs==0)
    {
      return;
    }


  if(LOCALBUSY==1)
    {
      
      return;
    }

  LOCALBUSY         = 1;

  
  XmListGetSelectedPos(widget,&pos_list,&pos_count);

  if(pos_count!=1)
    {
      LOCALBUSY = 0;
      return;
    }


  

  cfl = POIRoot;
  count = 0;
  while(cfl != NULL)
    {
      if(count==area_index-pos_list[i])
	{
	  break;
	}
      count = count + 1;
      cfl = cfl->next;
    }

  if(cfl==NULL)
    {
      LOCALBUSY = 0;
      return;
    }

  
  
  tmpLLX = cfl->x - PPAD_DIST;
  tmpLLY = cfl->y - PPAD_DIST;
  tmpURX = cfl->x + PPAD_DIST;
  tmpURY = cfl->y + PPAD_DIST;
  
 
  SaveXScroll = ScrollPercent(1);
  SaveYScroll = ScrollPercent(2);

  SetZoomValues(tmpLLX,tmpLLY,tmpURX,tmpURY);

  MakePixmap3();
  set_color (drawing_a, "White",(XtPointer)NULL);
  XFillRectangle (XtDisplay (drawing_a), pixmap,   mygc, 0, 0, width, height);
  XFillRectangle (XtDisplay (drawing_a), mywindow, mygc, 0, 0, width, height);
  SetColorRight();
  
  NOT_ZOOMED = 0; 
  
  SAVE_ZOOM_STATE(SaveXScroll,SaveYScroll); 
  DrawAll();

  LOCALBUSY = 0;
}




void SaveAOIShapes()
{
  char outname[1000],message[1000];

  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      sprintf(outname,"%spoints_of_interest_files\\%s",indirectory,SaveAOIShapeName);
    }
  else
    {
      sprintf(outname,"%spoints_of_interest_files/%s",indirectory,SaveAOIShapeName);
    }



  if(WriteAOIShapes(XtParent(XtParent(XtParent(aoi_shape_wid))),outname)==1)
    {
      XtDestroyWidget(XtParent(XtParent(XtParent(aoi_shape_wid))));
      
      sprintf(message,"Saved %d points to %s\n",area_index,outname);
      
      not_while_running(list_point,message,1468,"Saved points to shapefile",5);
    }
  else
    {
      
      XtDestroyWidget(XtParent(XtParent(XtParent(aoi_shape_wid))));
    }

}



void shapeaoiCallback(Widget w, XtPointer userData, XtPointer callData)
{
  EnterFileCallback(aoi_shape_wid, (XtPointer)25,(XtPointer)25);
}



void shapeaoihelpCallback(Widget w,XtPointer data,XtPointer callData)
{
  not_while_running(w,"Put help here",1467,"Put help here",5);
  
}



void AOIShapeCallback(Widget w,XtPointer data,XtPointer callData)
{
  static Widget dialog;
  Widget rc,form,label1,button;
  Arg resources[15];
  int n=0;
  
  if(POIRoot==NULL)
    {  
      not_while_running(w,"There are no current points to save!",1466,"No points to export",1);
      return;
    }
  
  
  if(AOI_SHAPE_UP==1)
    {
      ResetWidget(dialog);
      return;
    }
  


  n=0;
  XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++;
  XtSetArg(resources[n],  XmNmaxWidth,       800);       n++;
  

  dialog = XtCreatePopupShell("Export Points to Shapefile",topLevelShellWidgetClass,w,resources,n);

  
  rc = XtVaCreateManagedWidget
    (
     "XformWidget", xmPanedWindowWidgetClass, dialog,
     XmNrubberPositioning, False,
     XmNresizable,         True,
     XmNseparatorOn,       False,
     XmNsashHeight,        1,
     NULL
     );
  
  form = XtVaCreateWidget ("form7", xmFormWidgetClass, rc,
			   XmNpaneMinimum,     35,
			   XmNpaneMaximum,     35,
			   XmNseparatorOn,     False,
			   XmNfractionBase,    100,  
			   NULL);
  
  
  label1 = XtVaCreateManagedWidget ("Enter name for shapefile:",
				    xmLabelWidgetClass,  form,
				    XmNrightAttachment,  XmATTACH_POSITION,
				    XmNrightPosition,    50,
				    XmNleftAttachment,   XmATTACH_POSITION,
				    XmNleftPosition,     0,
				    XmNalignment,        XmALIGNMENT_CENTER,
				    XmNtopAttachment,    XmATTACH_FORM,
				    XmNbottomAttachment, XmATTACH_FORM,
				    LABELWTRANSLATE,
				    NULL);
  XtManageChild(label1);
  
  
  
  
  
  aoi_shape_wid = XtVaCreateManagedWidget ("text_w",
				     xmTextFieldWidgetClass, form,	  
				     XmNvalue,               SaveAOIShapeName,
				     XmNmaxLength,           24,
				     XmNtraversalOn,         True,
				     XmNrightAttachment,     XmATTACH_POSITION,
				     XmNrightPosition,       99,
				     XmNleftAttachment,      XmATTACH_POSITION,
				     XmNleftPosition,        51,
				     XmNtopAttachment,       XmATTACH_FORM,
				     XmNbottomAttachment,    XmATTACH_FORM,
                     XmNtranslations,        XtParseTranslationTable ( translations_paste ) ,
				     NULL);
  
  XtAddCallback (aoi_shape_wid, XmNactivateCallback,
		 EnterFileCallback, (XtPointer)25);
  XtManageChild(aoi_shape_wid);
  XtManageChild(form);

  
  
  
  
  form = XtVaCreateWidget ("form175", xmFormWidgetClass, rc,
			   XmNpaneMinimum,   25,
			   XmNpaneMaximum,   25,
			   XmNseparatorOn,   False,
			   XmNfractionBase,  100,  
			   NULL);      

  button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
				    XmNlabelString,       STRING("Help"),
				    XmNtopAttachment,     XmATTACH_FORM,
				    XmNbottomAttachment,  XmATTACH_FORM,
				    XmNrightAttachment,   XmATTACH_POSITION,
				    XmNrightPosition,     33,
				    XmNleftAttachment,    XmATTACH_POSITION,
				    XmNleftPosition,      1,
				    XmNtraversalOn,       False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    );
  
  XtAddCallback(button, XmNactivateCallback, shapeaoihelpCallback, (XtPointer) NULL);
  XtManageChild(button);
  
  

  button  = XtVaCreateManagedWidget("SCR3",xmPushButtonWidgetClass,form,
				    XmNlabelString,       STRING("Cancel"),
				    XmNtopAttachment,     XmATTACH_FORM,
				    XmNbottomAttachment,  XmATTACH_FORM,
				    XmNrightAttachment,   XmATTACH_POSITION,
				    XmNrightPosition,     66,
				    XmNleftAttachment,    XmATTACH_POSITION,
				    XmNleftPosition,      33,
				    XmNtraversalOn,       False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    );

  XtAddCallback(button, XmNactivateCallback, die_callback, (XtPointer)1029);
  XtManageChild(button);



  button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
				    XmNlabelString,       STRING("Save/Done"),
				    XmNtopAttachment,     XmATTACH_FORM,
				    XmNbottomAttachment,  XmATTACH_FORM,
				    XmNrightAttachment,   XmATTACH_POSITION,
				    XmNrightPosition,     99,
				    XmNleftAttachment,    XmATTACH_POSITION,
				    XmNleftPosition,      66,
				    XmNtraversalOn,       False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    ); 
  
  XtAddCallback(button, XmNactivateCallback, shapeaoiCallback, (XtPointer) NULL);
  XtManageChild(button); 
  XtManageChild(form);


  XtManageChild(rc);
  MyPopup(dialog); 
  
  XtAddCallback(dialog,XmNdestroyCallback,ShellDeath,(XtPointer)298);

  AOI_SHAPE_UP = 1;
}











void AOIButtonCallback(Widget w,XtPointer data,XtPointer callData)
{  
  Widget  MARKtext_w,MARKtext_ul,form,rowcol,button,option_menu,tog;
  Arg args[15];
  int n=0,i;
  char temp[200];
  struct POIList *cfl;
  XmString *blank_list;
  int old_area_index;  

  
  MenuItem drawing_shapes[] = {
    { "Triangle", &xmPushButtonWidgetClass,'!',NULL,NULL,(void (*)())shape_cb, (XtPointer)0, (MenuItem *) NULL },
    { "Star",     &xmPushButtonWidgetClass,'!',NULL,NULL,(void (*)())shape_cb, (XtPointer)1, (MenuItem *) NULL },
    { "X-Mark",   &xmPushButtonWidgetClass,'!',NULL,NULL,(void (*)())shape_cb, (XtPointer)2, (MenuItem *) NULL },
    { "Circle",   &xmPushButtonWidgetClass,'!',NULL,NULL,(void (*)())shape_cb, (XtPointer)3, (MenuItem *) NULL },
    {NULL},
  };
  
  MenuItem drawing_colors[] = {
    { "Red",   &xmPushButtonWidgetClass,'!',NULL,NULL, (void (*)())color_cb, (XtPointer)0, (MenuItem *) NULL },
    { "Green", &xmPushButtonWidgetClass,'!',NULL,NULL, (void (*)())color_cb, (XtPointer)1, (MenuItem *) NULL },
    { "Blue",  &xmPushButtonWidgetClass,'!',NULL,NULL, (void (*)())color_cb, (XtPointer)2, (MenuItem *) NULL },
    { "Yellow",&xmPushButtonWidgetClass,'!',NULL,NULL, (void (*)())color_cb, (XtPointer)3, (MenuItem *) NULL },
    {NULL},
  };

  if(input_source==0)
    {
      if(NGA_TYPE==1)
	{
	  not_while_running(w,"You must open a GAIT project\n\
before you can manipulate points of interest.",1271,"Illegal Manuever",1);
	}
      else
	{
	  not_while_running(w,"You must select an input data directory\n\
before you can manipulate points of interest.",1272,"Illegal Manuever",1);
	}

      return;
    }
  
  if(output_source==0)
    {
      not_while_running(w,"You must select an output file location\n\
before you can manipulate points of interest.",1273,"Illegal Manuever",1);
      return;
    }
  
  if(load_reg==0)
    {
      n=0;

      XtSetArg(args[n],  XmNwidth,     600);            n++;  
      XtSetArg(args[n],  XmNdeleteResponse, XmDESTROY); n++;
      

      regionhead = XtCreatePopupShell("Points Of Interest",
				topLevelShellWidgetClass,sw,args,n);
      

      rowcol = XtVaCreateManagedWidget
	(
	 "XformWidget", xmPanedWindowWidgetClass, regionhead,
	 XmNrubberPositioning, False,
	 XmNresizable,         True,
	 XmNseparatorOn,       False,
	 XmNsashHeight,        1,
	 NULL
	 );
      

      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,     15,
			       XmNpaneMaximum,     15,
			       XmNfractionBase,  100,  
			       NULL);
      
      MARKtext_w = XtVaCreateManagedWidget ("Points Of Interest:",
					    xmLabelWidgetClass,  form,
					    XmNtraversalOn,      True,
					    XmNrightAttachment,  XmATTACH_POSITION,
					    XmNrightPosition,    99,
					    XmNleftAttachment,   XmATTACH_POSITION,
					    XmNleftPosition,     1,
					    LABELWTRANSLATE,
					    NULL);
      
      XtManageChild(form);
      
      blank_list = (XmString *) (malloc(sizeof(XmString *) * MAX_POI_NUM));
      if(blank_list==NULL){printf("bl6: out of allocation memory!\n"); ExitWrapper(-1);}

      old_area_index = area_index;
      area_index=0;
      
      for(i=0;i<MAX_POI_NUM;i++)
	  { 
	    blank_list[i] = XmStringCreateLocalized ("                ");
	  } 
      
      if(POIRoot!=NULL)
	{
	  cfl = POIRoot;
	  
	  while(cfl != NULL)
	    {
	      if((cfl->type >=1)&&(cfl->type<=16))
		{
		  

		  
		  if(cfl->type==1)      sprintf(temp,"%s: \"%s\": Red X-Mark",
                        Coordinate2DtoString( cfl->x, cfl->y), cfl->annotation);
		  else if(cfl->type==2) sprintf(temp,"%s: \"%s\": Blue X-Mark",
                        Coordinate2DtoString( cfl->x, cfl->y), cfl->annotation);
		  else if(cfl->type==3) sprintf(temp,"%s: \"%s\": Green X-Mark",
                        Coordinate2DtoString( cfl->x, cfl->y), cfl->annotation);
		  else if(cfl->type==4) sprintf(temp,"%s: \"%s\": Yellow X-Mark",
                        Coordinate2DtoString( cfl->x, cfl->y), cfl->annotation);
		  else if(cfl->type==5) sprintf(temp,"%s: \"%s\": Red Circle",
                        Coordinate2DtoString( cfl->x, cfl->y), cfl->annotation);
		  else if(cfl->type==6) sprintf(temp,"%s: \"%s\": Blue Circle",
                        Coordinate2DtoString( cfl->x, cfl->y), cfl->annotation);
		  else if(cfl->type==7) sprintf(temp,"%s: \"%s\": Green Circle",
                        Coordinate2DtoString( cfl->x, cfl->y), cfl->annotation);
		  else if(cfl->type==8) sprintf(temp,"%s: \"%s\": Yellow Circle",
                        Coordinate2DtoString( cfl->x, cfl->y), cfl->annotation);
		  else if(cfl->type==9) sprintf(temp,"%s: \"%s\": Red Star",
                        Coordinate2DtoString( cfl->x, cfl->y), cfl->annotation);
		  else if(cfl->type==10)sprintf(temp,"%s: \"%s\": Blue Star",
                        Coordinate2DtoString( cfl->x, cfl->y), cfl->annotation);
		  else if(cfl->type==11)sprintf(temp,"%s: \"%s\": Green Star",
                        Coordinate2DtoString( cfl->x, cfl->y), cfl->annotation);
		  else if(cfl->type==12)sprintf(temp,"%s: \"%s\": Yellow Star",
                        Coordinate2DtoString( cfl->x, cfl->y), cfl->annotation);
		  else if(cfl->type==13)sprintf(temp,"%s: \"%s\": Red Triangle",
                        Coordinate2DtoString( cfl->x, cfl->y), cfl->annotation);
		  else if(cfl->type==14)sprintf(temp,"%s: \"%s\": Blue Triangle",
                        Coordinate2DtoString( cfl->x, cfl->y), cfl->annotation);
		  else if(cfl->type==15)sprintf(temp,"%s: \"%s\": Green Triangle",
                        Coordinate2DtoString( cfl->x, cfl->y), cfl->annotation);
		  else if(cfl->type==16)sprintf(temp,"%s: \"%s\": Yellow Triangle",
                        Coordinate2DtoString( cfl->x, cfl->y), cfl->annotation);
		  if(DEBUG==1)
		    {
		      printf("found %s %s %d %lf %lf...index %d\n",
			      cfl->annotation, Coordinate2DtoString( cfl->x, cfl->y),
			     cfl->type,cfl->x,cfl->y,old_area_index-area_index-1);
		    }
		  
		  blank_list[old_area_index-area_index-1] = XmStringCreateLocalized (temp);
		  area_index++;
		}
	      else
		{
		  printf("bad poi %d\n",cfl->type);
		}

	      cfl=cfl->next;
	    }
	}



	  n = 0;

	  
      XtSetArg(args[n], XmNlistSizePolicy,   XmRESIZE_IF_POSSIBLE);     n++;

      list_point = XmCreateScrolledList (rowcol, "AOI list",args,n);

      n = 0;

      XtVaSetValues (list_point,             
		     XmNitemCount,        MAX_POI_NUM,
		     XmNvisibleItemCount, 10,
             XmNitems,            blank_list,
		     XmNselectionPolicy,  XmEXTENDED_SELECT,
		     XmNtranslations,     XtParseTranslationTable (list_translations21),
		     NULL);


      XtAddCallback (list_point, XmNextendedSelectionCallback, choose_specific_poi, (XtPointer)NULL);

      XtManageChild (list_point);


      XtVaGetValues(list_point,XmNverticalScrollBar,&vert_scroll[AOI_SCROLL],NULL);


            
      for(i=0;i<200;i++)
	{
	  XmStringFree(blank_list[i]);
	}
      free(blank_list);





      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   35,
			       XmNpaneMaximum,   35,
			       XmNfractionBase,  100,  
			       NULL);
            
      MARKtext_ul = XtVaCreateManagedWidget ("(X,Y):",
					     xmLabelWidgetClass,  form,
					     XmNtraversalOn,      True,
					     XmNleftAttachment,   XmATTACH_FORM,
					     XmNtopAttachment,    XmATTACH_FORM,
					     XmNbottomAttachment, XmATTACH_FORM,
					     LABELWTRANSLATE,
					     NULL);
      

      MARKtext_w2 = XtVaCreateManagedWidget ("text_w",
					     xmTextFieldWidgetClass, form,	  
					     XmNvalue, "0.00",
					     XmNtraversalOn,     True,
					     XmNleftAttachment,  XmATTACH_POSITION,
					     XmNleftPosition,    10,
					     XmNrightAttachment, XmATTACH_POSITION,
					     XmNrightPosition,   30,
					     XmNmaxLength,       12,
                         XmNtranslations,    XtParseTranslationTable ( translations_paste ) ,
					     NULL);
      
      MARKtext_w3 = XtVaCreateManagedWidget ("text_w",
					     xmTextFieldWidgetClass, form,	  
					     XmNvalue,            "0.00",
					     XmNtraversalOn,      True,
					     XmNleftAttachment,   XmATTACH_POSITION,
					     XmNleftPosition,     30,
					     XmNrightAttachment,  XmATTACH_POSITION,
					     XmNrightPosition,    50,
					     XmNmaxLength,        12,
                         XmNtranslations,     XtParseTranslationTable ( translations_paste ) ,
					     NULL);
      
      
      option_menu = BuildPOIShapeMenu (form, XmMENU_OPTION, " ", drawing_shapes);
      XtManageChild (option_menu);
      
      XtVaSetValues(option_menu,
		    XmNleftAttachment, XmATTACH_WIDGET,
		    XmNleftWidget,     MARKtext_w3,
		    NULL);
      
      
      color_menu = BuildPOIColorMenu (form, XmMENU_OPTION, " ", drawing_colors);
      XtManageChild (color_menu);
      
      XtVaSetValues(color_menu,				
		    
		    XmNleftAttachment, XmATTACH_WIDGET,
		    XmNleftWidget,     option_menu,
		    XmNrightAttachment, XmATTACH_FORM,
		    NULL);


      XtManageChild(form);
      







      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   35,
			       XmNpaneMaximum,   35,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget ("Annotation:",
					 xmLabelWidgetClass,  form,
					 XmNtraversalOn,      True,
					 XmNleftAttachment,   XmATTACH_FORM,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNbottomAttachment, XmATTACH_FORM,
					LABELWTRANSLATE,
					 NULL);
      
      
      point_text_button = XtVaCreateManagedWidget ("text_w",
						   xmTextFieldWidgetClass, form,	  
						   XmNvalue, "<Enter Annotation Here>",
						   XmNtraversalOn,     True,
						   XmNleftAttachment,  XmATTACH_WIDGET,
						   XmNleftWidget,      button,
						   XmNrightAttachment, XmATTACH_POSITION,
						   XmNrightPosition,   99,
						   XmNmaxLength,       240,
                           XmNtranslations,    XtParseTranslationTable ( translations_paste ) ,
						   NULL);
      
      XtManageChild(form);
 







      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget ("Draw line between points with the same symbol and color",
					xmToggleButtonWidgetClass, form,
					XmNtraversalOn,      False,
					XmNleftAttachment,   XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    100,
					XmNlabelString,      STRING("Draw line between points with the same symbol and color"),
					XmNtraversalOn,      False,
					TOGGLETRANSLATE,     TOGGLEINCLUDE,
					NULL);
      
      XtAddCallback (button, XmNvalueChangedCallback, poi_connect_toggle, NULL);
      XtManageChild(button);
      
      XmToggleButtonSetState(button,(Boolean)POI_CONNECT,(Boolean)0);
      
      XtManageChild(form);



      
      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget ("Center Zoom on Individual Points",
					xmToggleButtonWidgetClass, form,
					XmNtraversalOn,      False,
					XmNleftAttachment,   XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    50,
					XmNlabelString,      STRING("Zoom to individual points"),
					XmNtraversalOn,      False,
					TOGGLETRANSLATE,     TOGGLEINCLUDE,
					NULL);
      
      XtAddCallback (button, XmNvalueChangedCallback, poi_toggle, NULL);
      XtManageChild(button);
      
      XmToggleButtonSetState(button,(Boolean)ZoomToPOIs,(Boolean)0);
      
      button  = XtVaCreateManagedWidget("Set Vertex Zoom Pad Distance",xmPushButtonWidgetClass,form,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    50,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,   100,
					XmNlabelString,     STRING("Set Pad Distance..."),
					XmNtraversalOn,     False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
      
      XtAddCallback (button, XmNactivateCallback,
		     set_ppad_distance, (XtPointer)NULL);
      
      XtManageChild(button);
      XtManageChild(form);












          
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   27, 
			       XmNpaneMaximum,   27,
			       XmNfractionBase,  100,  
			       NULL);
      

      tog = XtVaCreateManagedWidget ("combo_test",
				     xmToggleButtonWidgetClass, form,
				     XmNtopAttachment,    XmATTACH_FORM,
				     XmNtraversalOn,      False,
				     XmNbottomAttachment, XmATTACH_FORM,
				     XmNlabelString,      STRING("Display Annotations"),
				     XmNleftAttachment,   XmATTACH_FORM,
				     XmNrightAttachment,  XmATTACH_POSITION,
				     XmNrightPosition,    50,
				     TOGGLETRANSLATE,     TOGGLEINCLUDE,
				     NULL);

      XtAddCallback (tog, XmNvalueChangedCallback, set_annot, (XtPointer)1);
      XmToggleButtonSetState(tog,(Boolean)DrawAnnotations,(Boolean)0);




      button = XtVaCreateManagedWidget("Add Point",xmPushButtonWidgetClass,form,
				       XmNlabelString,     STRING("Add Point"),
				       XmNorientation,     XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    50,
				       XmNrightAttachment, XmATTACH_POSITION,
				       XmNrightPosition,   100,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      
      XtAddCallback(button, XmNactivateCallback,
		    mapCallback, (XtPointer)3);
      XtManageChild(button);
      XtManageChild(form);

            
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget("Mark Points on Map with Mouse",xmPushButtonWidgetClass,form,
				       XmNlabelString,     STRING("Mark Points on Map with Mouse"),
				       XmNorientation,     XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    1,
				       XmNrightAttachment, XmATTACH_POSITION,
				       XmNrightPosition,   50,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      
      XtAddCallback(button, XmNactivateCallback,
		    mapCallback, (XtPointer)1);
      XtManageChild(button);

      
      button = XtVaCreateManagedWidget("Stop Marking Points on Map",xmPushButtonWidgetClass,form,
				       XmNlabelString,     STRING("Stop Marking Points on Map"),
				       XmNorientation,     XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    50,
				       XmNrightAttachment, XmATTACH_POSITION,
				       XmNrightPosition,   99,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      
      XtAddCallback(button, XmNactivateCallback,
		    mapCallback, (XtPointer)2);
      XtManageChild(button);
      XtManageChild(form);
            
      form = XtVaCreateWidget ("form3", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);

      button  = XtVaCreateManagedWidget("Remove Selected Points",xmPushButtonWidgetClass,form,
					XmNlabelString, STRING("Remove Selected Points"),
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    1,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    50,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
      
      XtAddCallback(button, XmNactivateCallback,
		    delete_aoiCallback, (XtPointer) 0);
      XtManageChild(button);
      
      button  = XtVaCreateManagedWidget("Remove All Points",xmPushButtonWidgetClass,form,
					XmNlabelString, STRING("Remove All Points"),
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    50,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    99,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
      
      XtAddCallback(button, XmNactivateCallback,
		    delete_aoiCallback, (XtPointer) 1);
      XtManageChild(button);
      XtManageChild(form);







      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget("Help",xmPushButtonWidgetClass,form,
				       XmNlabelString,     STRING("Save Points..."),
				       XmNorientation,     XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    1,
				       XmNrightAttachment, XmATTACH_POSITION,
				       XmNrightPosition,   33,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      
      XtAddCallback(button, XmNactivateCallback,
		    AOISaveCallback, (XtPointer)NULL);
      XtManageChild(button);
      
      button = XtVaCreateManagedWidget("Done",xmPushButtonWidgetClass,form,
				       XmNlabelString,     STRING("Load Points..."),
				       XmNorientation,     XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    33,
				       XmNrightAttachment, XmATTACH_POSITION,
				       XmNrightPosition,   66,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      

      XtAddCallback(button, XmNactivateCallback,
		    AOILoadCallback, (XtPointer)NULL);
      XtManageChild(button);
      XtManageChild(form);


      button = XtVaCreateManagedWidget("Help",xmPushButtonWidgetClass,form,
				       XmNlabelString,     STRING("Save to Shapefile..."),
				       XmNorientation,     XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    66,
				       XmNrightAttachment, XmATTACH_POSITION,
				       XmNrightPosition,   99,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      
      XtAddCallback(button, XmNactivateCallback,
		    AOIShapeCallback, (XtPointer)NULL);
      XtManageChild(button);






      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget("Help",xmPushButtonWidgetClass,form,
				       XmNlabelString, STRING("Help"),
				       XmNorientation, XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    1,
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    50,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      
      XtAddCallback(button, XmNactivateCallback,
		    AOIhelpCallback, (XtPointer)NULL);
      XtManageChild(button);
      
      button = XtVaCreateManagedWidget("Done",xmPushButtonWidgetClass,form,
				       XmNlabelString, STRING("Done"),
				       XmNorientation, XmVERTICAL,
				       XmNleftAttachment,  XmATTACH_POSITION,
				       XmNleftPosition,    50,
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    99,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				       NULL
				       ); 
      
      XtAddCallback(button, XmNactivateCallback,
		    die_callback, (XtPointer)1003);
      XtManageChild(button);
      XtManageChild(form);
      XtManageChild(rowcol);
      MyPopup(regionhead);
      XtAddCallback(regionhead,XmNdestroyCallback,ShellDeath,(XtPointer)4066);
      load_reg = 1;
      
      


      XtVaSetValues(color_menu,				
		    XmNforeground,mycolors[MARK_COLOR],
		    XmNtopShadowColor,mycolors[MARK_COLOR],
		    XmNbottomShadowColor,mycolors[MARK_COLOR],
		    NULL);
    }
  else
    {
      ResetWidget(regionhead);
    }
}





void set_scc(Widget w,XtPointer data,XtPointer callData)
{
  int flag=(int)data,changeattr=0,save_attr_type;
  Widget active;
  int *pos_list;
  int pos_count;
  char *messagestring;
  char header[1000];

  if(flag==1)
    {
      active   = S_list_w;
      XmListDeselectAllItems(S_list2_w);
    }
  else if(flag==2)
    {
      active   = S_list2_w;
      XmListDeselectAllItems(S_list_w);
    }
  else
    {
      printf("bad flag sent to set_ECC %d\n",flag);
      XBell(mydisplay,50); 
      return;
    }

  XmListGetSelectedPos(active,&pos_list,&pos_count);
  
  if(pos_count==0){return;}

  if(pos_count!=1)
    {
      if(flag==1){printf("error-detected %d selected items in ECC list\n",pos_count);}
      if(flag==2){printf("error-detected %d selected items in EAC list\n",pos_count);}
      if(flag==3){printf("error-detected %d selected items in p-f list\n",pos_count);}
      return;
    }





  if(ATTRIBUTION_TYPE!=ATTRIBUTION_INFO_TYPE)
    {
      changeattr = 1;
      save_attr_type = ATTRIBUTION_TYPE;
      ATTRIBUTION_TYPE = ATTRIBUTION_INFO_TYPE;
      InitializeAttribution();
    }
  

  messagestring = (char *)malloc(SAC_MAX);


  if(flag==1)
    { 
      if(EDCSDEBUG==1){printf("HERE WE DESCRIBE ECC %d\n",pos_list[0]);}


      if(NGA_TYPE==1)
	{
	  sprintf(header,"Feature Name: %s\n\
Feature Code: %s\n\n\
Definition:\n\n",
		  GetECCLabel(pos_list[0]),
		  GetECCCode(pos_list[0]));
	}
      else
	{
	  sprintf(header,"Classification label: %s\n\n\
Definition:\n\n",
		  GetECCLabel(pos_list[0]));
	}

      sprintf(messagestring,"%s%s",header,SCCARRAY[pos_list[0]].desc);
    }
  else if(flag==2)
    {
      if(EDCSDEBUG==1){printf("calling the EAC stuff on EAC: %d\n",pos_list[0]);}


      if(NGA_TYPE==1)
	{
	  
	  sprintf(header,"Attribute Name: %s\n\
Attribute Code: %s\n\n\
Definition:\n\n",
		  GetEACLabel(pos_list[0]),
		  GetEACCode(pos_list[0]));
	}
      else
	{
	  sprintf(header,"EA label: %s\n\
Value type: %s\n\
Equivalence class label: %s\n\nDefinition:\n\n",
		  GetEACLabel(pos_list[0]),
		  GetEAValueType(pos_list[0]),
		  GetEAEQclass(pos_list[0]));
	}


      if(strlen(SACARRAY[pos_list[0]].enums)>2)
	{
	  sprintf(messagestring,"%s%s%s",header,SACARRAY[pos_list[0]].desc,SACARRAY[pos_list[0]].enums);
	}
      else
	{
	  sprintf(messagestring,"%s%s",header,SACARRAY[pos_list[0]].desc);
	}
    }  
  else if(flag==3)
    {
      printf("poly flag found\n");
    }
  XmTextSetString(text_area,messagestring);	      



  if(changeattr==1)
    {
      ATTRIBUTION_TYPE = save_attr_type;
      InitializeAttribution();
    }
  
  free(messagestring);
}






int HyperGetNum(char *touse)
{
  int i,len;
  char ecc[1000];

  if(NGA_TYPE==1)
    {
      

      len = strlen(touse);
      for(i=0;i<len;i++)
	{
	  if(touse[i]==':')
	    {
	      ecc[i] = '\0';
	      return  SilentGetCodeIndex(ecc);
	    }
	  ecc[i] = touse[i];
	}
            
    }
  else
    {
      sprintf(ecc,"%s",touse);
      
      for(i=0;i<GIFD_CLASS_NUM;i++)
	{
	  if(!strcmp(ecc,gifd_class_names[i]))
	    {
	      return (i+1);
	    }
	}
    }

  return -1;
}


int HyperGetNum2(char *touse)
{
  int i,len;
  char eac[1000];

  if(NGA_TYPE==1)
    {
      
      
      len = strlen(touse);
      for(i=0;i<len;i++)
	{
	  if(touse[i]==':')
	    {
	      eac[i] = '\0';
	      return SilentGetAttrIndex(eac);
	    }
	  eac[i] = touse[i];
	}
            
    }
  else
    {
      sprintf(eac,"%s",touse);

      for(i=0;i<GIFD_ATTR_NUM;i++)
	{
	  if(!strcmp(eac,gifd_attr_names[i]))
	    {
	      return (i+1);
	    }
	}
    }

  return -11;
}




void BadHyperAttr(int type, char badname[])
{
  char message[1000];

  if(type==1)
    {
      sprintf(message,"The feature name \"%s\" is not defined in the\n\
currently selected \"attribution help\" schema: %s\n",badname,ParseAttributionType(ATTRIBUTION_INFO_TYPE));
    }
  else
    {
      sprintf(message,"The attribute name \"%s\" is not defined in the\n\
currently selected \"attribution help\" schema: %s\n",badname,ParseAttributionType(ATTRIBUTION_INFO_TYPE));
    }


  if(INFO_WINDOW==1)
    {
      not_while_running(shellhead2,message,1440,"Wrong Attribution Schema",1);
    }


}




void HyperAttribute(int SCCSAC,char attribute[])
{
  Widget rowcol,tmphead,text_tmp,form,button;
  Arg resources[20];
  int n,changeattr=0,save_attr_type,newcode;
  char *thedesc, header[500];


  thedesc = (char *)malloc(SAC_MAX);

  BuildSCCArray();  
  BuildSACArray();  


  if(ATTRIBUTION_TYPE!=ATTRIBUTION_INFO_TYPE)
    {
      changeattr = 1;
      save_attr_type = ATTRIBUTION_TYPE;
      ATTRIBUTION_TYPE = ATTRIBUTION_INFO_TYPE;
      InitializeAttribution();
    }
  


  if (SCCSAC==1)
    {
      newcode = HyperGetNum(attribute);

      if(newcode<0)
	{
	  BadHyperAttr(1,attribute);

	  if(changeattr==1)
	    {
	      ATTRIBUTION_TYPE = save_attr_type;
	      InitializeAttribution();
	    }
	  free(thedesc);
  	  return;
	}
      
      if(HyperClassUp[newcode]==1)
	{
	  if(changeattr==1)
	    {
	      ATTRIBUTION_TYPE = save_attr_type;
	      InitializeAttribution();
	    }
	  free(thedesc);
  	  return;
	}

      HyperClassUp[newcode] = 1;


      if(NGA_TYPE==1)
	{
	  sprintf(header,"Description of %s",attribute);
	  
	  sprintf(thedesc,"Feature Name: %s\n\
Feature Code: %s\n\n\
Definition:\n\n%s",
		  GetECCLabel(newcode),
		  GetECCCode (newcode),
		  SCCARRAY[newcode].desc);
	}
      else
	{
	  sprintf(header,"Description of ECL %s",attribute);
	  
	  sprintf(thedesc,"Classification label: %s\n\n\
Definition:\n\n%s",
		  GetECCLabel(newcode),
		  SCCARRAY[newcode].desc);
	}



    }
  else if(SCCSAC==2)
    {
      newcode = HyperGetNum2(attribute);
      if(newcode<0)
	{
	  BadHyperAttr(2,attribute);

	  if(changeattr==1)
	    {
	      ATTRIBUTION_TYPE = save_attr_type;
	      InitializeAttribution();
	    }
	  free(thedesc);
  	  return;
	}
      
      
      if(HyperAttrUp[newcode]==1)
	{
	  if(changeattr==1)
	    {
	      ATTRIBUTION_TYPE = save_attr_type;
	      InitializeAttribution();
	    }
	  free(thedesc);
  	  return;
	}

      HyperAttrUp[newcode] = 1;
    
      if(NGA_TYPE==1)
	{
	  sprintf(header,"Description of attribute %s",attribute);
	  
	  sprintf(thedesc,"Attribute Name: %s\n\
Attribute Code: %s\n\n\
Definition:\n\n%s",
		  GetEACLabel(newcode),
		  GetEACCode (newcode),
		  SACARRAY[newcode].desc);

	  if(SACARRAY[newcode].enums!=NULL)
	    {
	      if(strlen(SACARRAY[newcode].enums)>2)
		{
		  strcat(thedesc,SACARRAY[newcode].enums);
		}
	    }
	}
      else
	{
	  sprintf(header,"Description of EAL %s",attribute);
	  
	  sprintf(thedesc,"EA label: %s\n\
Value type: %s\n\
Equivalence class label: %s\n\nDefinition:\n\n",
		  GetEACLabel(newcode),
		  GetEAValueType(newcode),
		  GetEAEQclass(newcode));

	  
	  strcat(thedesc,SACARRAY[newcode].desc);
	  
	  if(strlen(SACARRAY[newcode].enums)>2)
	    {
	      strcat(thedesc,SACARRAY[newcode].enums);
	    }
	}
    }
  


  
  n=0;
  XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++;
  
  tmphead = 
    XtCreatePopupShell(header,topLevelShellWidgetClass,drawing_a,resources,n);
  
  
  
  rowcol = XtVaCreateManagedWidget
    (
     "XformWidget", xmPanedWindowWidgetClass, tmphead,
     XmNrubberPositioning, False,
     XmNresizable,         True,
     XmNseparatorOn,       False,
     XmNsashHeight,        1,
     NULL
     );


  form = XtVaCreateWidget ("form176", xmFormWidgetClass, rowcol,
			   XmNfractionBase,  100,  
			   NULL);      
  
  n = 0;
  
  XtSetArg(resources[n], XmNscrollBarDisplayPolicy, XmSTATIC);          n++;

  XtSetArg(resources[n], XmNrows,                   20);                n++;
  XtSetArg(resources[n], XmNcolumns,                50);                n++;

  XtSetArg(resources[n], XmNvalue,                  thedesc);           n++;
  XtSetArg(resources[n], XmNeditable,               False);             n++;
  XtSetArg(resources[n], XmNeditMode,               XmMULTI_LINE_EDIT); n++;
  XtSetArg(resources[n], XmNwordWrap,               True);              n++;
  XtSetArg(resources[n], XmNcursorPositionVisible,  False);             n++;
  XtSetArg(resources[n], XmNscrollHorizontal,       False);             n++; 
  XtSetArg(resources[n], XmNtraversalOn,            False);             n++;
  XtSetArg(resources[n], XmNleftAttachment,         XmATTACH_FORM);     n++;
  XtSetArg(resources[n], XmNrightAttachment,        XmATTACH_FORM);     n++;
  XtSetArg(resources[n], XmNtopAttachment,          XmATTACH_FORM);     n++;
  XtSetArg(resources[n], XmNbottomAttachment,       XmATTACH_FORM);     n++;

  text_tmp = XmCreateScrolledText(form, "text_tmp", resources, n);
  XtManageChild (text_tmp);
  XtManageChild(form);




  form = XtVaCreateWidget ("form177", xmFormWidgetClass, rowcol,
			   XmNpaneMinimum,   25,
			   XmNpaneMaximum,   25,
			   XmNfractionBase,  100,  
			   NULL);
  
  button  = XtVaCreateManagedWidget("SCR33",xmPushButtonWidgetClass,form,
				    XmNlabelString, STRING("Done"),
				    XmNbottomAttachment, XmATTACH_FORM,		    
				    XmNrightAttachment,  XmATTACH_POSITION,
				    XmNrightPosition,    99,
				    XmNleftAttachment,   XmATTACH_POSITION,
				    XmNleftPosition,     1,
				    XmNtraversalOn,      False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    ); 
  
  XtAddCallback(button, XmNactivateCallback, die_callback, (XtPointer) 1025);
  XtManageChild(button); 
  XtManageChild(form);


  XtManageChild (rowcol);
  MyPopup(tmphead);


  if(SCCSAC==1)
    {
      XtAddCallback(tmphead,XmNdestroyCallback,ShellDeath,(XtPointer)(9000+newcode));
    }
  else
    {
      XtAddCallback(tmphead,XmNdestroyCallback,ShellDeath,(XtPointer)(11000+newcode));
    }
 

  XtAddCallback (text_tmp, XmNmotionVerifyCallback, get_double, (XtPointer)NULL);


  if(changeattr==1)
    {
      ATTRIBUTION_TYPE = save_attr_type;
      InitializeAttribution();
    }

  free(thedesc);
}



void get_double(Widget w,XtPointer data,XtPointer callData)
{
  char *theselection = XmTextGetSelection(w);
  char *wholestring = XmTextGetString(w);
  char selected[1000];
  int SAC=0,SCC=0,i,len;
  XmTextPosition left,right;
  static int LOCALBUSY = 0;


  if(LOCALBUSY==1)
    {
      printf("busy returning\n");
      return;
    }

  LOCALBUSY = 1;


  if(theselection==NULL){ LOCALBUSY = 0; return;}
  if(wholestring==NULL) { LOCALBUSY = 0; return;}

  XtFree(theselection);



  XmTextGetSelectionPosition(w,&left,&right);
  right = right -1;


  

  for(i=left;i>=0;i--)
    {
      if(wholestring[i]=='<')
	{
	  left = i;
	  break;
	}
      if(wholestring[i]=='>')
	{
	  XtFree(wholestring);
	  LOCALBUSY = 0;
	  return;
	}
    }


  len = strlen(wholestring);

  for(i=right;i<len;i++)
    {
      if(wholestring[i]=='>')
	{
	  right = i;
	  break;
	}
      if(wholestring[i]=='<')
	{
	  XtFree(wholestring);
	  LOCALBUSY = 0;
	  return;
	}
    }


  if((right-left)>110) 
    {
      
      XtFree(wholestring);
      LOCALBUSY = 0;
      return;
    }

  
  if((left>0)&&(wholestring[left-1]=='<'))
    {
      left = left - 1;
    }

  if((right<(len-1))&&(wholestring[right+1]=='>'))
    {
      right = right + 1;
    }


  for(i=left;i<=right;i++)
    {
      selected[i-left] = wholestring[i];
    }
  selected[i-left] = '\0';


    

  len = strlen(selected);
  
  if(len<3)
    {      
      LOCALBUSY = 0;
      return;
    }

  if(selected[0]!='<')
    {
      LOCALBUSY = 0;
      return;
    }

  if(selected[1]=='<')
    {
      SAC = 1;
    }
  else
    {
      SCC = 1;
    }

  
  if(selected[2]=='<')
    {
      
      LOCALBUSY = 0;
      return;
    }


  if(SCC==1)
    {
      selected[len-1] = '\0';
      HyperAttribute(1,&selected[1]);
    }
  else if(SAC==1)
    {
      selected[len-2] = '\0';
      HyperAttribute(2,&selected[2]);
    }

  LOCALBUSY = 0;

}






void ReBuildInfoWindow()
{

  int i,changeattr=0,save_attr_type;
  XmString *scc_names,*sac_names; 
  char temp[100],junk2[1000];


  

  BuildSCCArray();  
  BuildSACArray();  
  


  


  if(ATTRIBUTION_TYPE!=ATTRIBUTION_INFO_TYPE)
    {
      changeattr = 1;
      save_attr_type = ATTRIBUTION_TYPE;
      ATTRIBUTION_TYPE = ATTRIBUTION_INFO_TYPE;
      InitializeAttribution();
    }
  
  
  scc_names = (XmString *) (malloc(sizeof(XmString *) * INscc_loop));
  if(scc_names==NULL){printf("sccn4: out of allocation memory!\n"); ExitWrapper(-1);}
  for(i=1;i<INscc_loop;i++)
    {
      if(NGA_TYPE==1)
	{
	  sprintf(junk2,"%s: %s",GetECCCode(i),SCCARRAY[i].scc);
	}
      else
	{
	  sprintf(junk2,"%s",SCCARRAY[i].scc);
	}
      scc_names[i-1] = XmStringCreate(junk2,"mytag1");
    }
  
  
  sac_names = (XmString *) (malloc(sizeof(XmString *) * INsac_loop));
  if(sac_names==NULL){printf("sacn4: out of allocation memory!\n"); ExitWrapper(-1);}
  for(i=1;i<INsac_loop;i++)
    {
      if(NGA_TYPE==1)
	{
	  sprintf(junk2,"%s: %s",GetEACCode(i),SACARRAY[i].sac);
	}
      else
	{
	  sprintf(junk2,"%s",SACARRAY[i].sac);
	}
      sac_names[i-1] = XmStringCreate(junk2,"mytag1");
    }

  
  sprintf(temp,"(%d Definitions)",INscc_loop-1);      
  XtVaSetValues(info_scc_defs,XmNlabelString,STRING(temp),NULL);

  sprintf(temp,"(%d Definitions)",INsac_loop-1);
  XtVaSetValues(info_sac_defs,XmNlabelString,STRING(temp),NULL);


  XmListDeleteAllItems(S_list_w);
  XmListDeleteAllItems(S_list2_w);

  XmListAddItems(S_list2_w, sac_names, INsac_loop-1,1);
  XmListAddItems(S_list_w,  scc_names, INscc_loop-1,1);

  if(changeattr==1)
    {
      ATTRIBUTION_TYPE = save_attr_type;
      InitializeAttribution();
    }

  
  XmTextSetString(text_area,"");


}


void attr_info_cb(Widget menu_item,XtPointer client_data,XtPointer call_data)
{
  int item_no = (int) client_data;
  

  if(item_no!=ATTRIBUTION_INFO_TYPE)
    {
      ATTRIBUTION_INFO_TYPE=item_no;
      
      
      
      ReBuildInfoWindow();
    }
}



void sdcsCallback(Widget w,XtPointer data,XtPointer callData)
{
  int n=0,i,startpos,endpos,changeattr=0,save_attr_type;
  Arg resources[20];  
  Widget rc,Done,form,label1,text_w,attr_type_menu;
  XmString *scc_names,*sac_names; 
  char temp[100],junk2[1000];


  MenuItem attribution_type[] = {
    {ParseAttributionType(1),  &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_info_cb, (XtPointer)2, (MenuItem *) NULL},
    {ParseAttributionType(3),  &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_info_cb, (XtPointer)4, (MenuItem *) NULL},
    {ParseAttributionType(5),  &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_info_cb, (XtPointer)6, (MenuItem *) NULL},
    {ParseAttributionType(7),  &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_info_cb, (XtPointer)7, (MenuItem *) NULL},
    {ParseAttributionType(8),  &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_info_cb, (XtPointer)8, (MenuItem *) NULL},
    {ParseAttributionType(11), &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_info_cb, (XtPointer)12,(MenuItem *) NULL},
    {ParseAttributionType(9),  &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_info_cb, (XtPointer)10, (MenuItem *) NULL},
    {ParseAttributionType(13), &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_info_cb, (XtPointer)14,(MenuItem *) NULL},

    
	{ParseAttributionType(39), &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_info_cb, (XtPointer)39,(MenuItem *) NULL},
    
    	

    

	
	{ParseAttributionType(43), &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_info_cb, (XtPointer)43,(MenuItem *) NULL},
    
	
	
    {ParseAttributionType(27), &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_info_cb, (XtPointer)27,(MenuItem *) NULL},

	
    {"TREx", &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_info_cb, (XtPointer)261,(MenuItem *) NULL},


	
    {ParseAttributionType(45), &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_info_cb, (XtPointer)45,(MenuItem *) NULL},

	
    {ParseAttributionType(29), &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_info_cb, (XtPointer)29,(MenuItem *) NULL},

	
    {ParseAttributionType(47), &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_info_cb, (XtPointer)47,(MenuItem *) NULL},



	
	{ParseAttributionType(23), &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_info_cb, (XtPointer)24,(MenuItem *) NULL},
	
    {ParseAttributionType(25), &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())attr_info_cb, (XtPointer)26,(MenuItem *) NULL},


    {NULL},
  };



  if(dead_sdcs==1)
    {


      if(ATTRIBUTION_TYPE!=ATTRIBUTION_INFO_TYPE)
	{
	  changeattr = 1;
	  save_attr_type = ATTRIBUTION_TYPE;
	  ATTRIBUTION_TYPE = ATTRIBUTION_INFO_TYPE;
	  InitializeAttribution();
	}
  

      set_cursor(mydisplay,mywindow,WATCH);
      BUSY=1;


      BuildSCCArray();  
      BuildSACArray();  


      scc_names = (XmString *) (malloc(sizeof(XmString *) * INscc_loop));
      if(scc_names==NULL){printf("sccn4: out of allocation memory!\n"); ExitWrapper(-1);}
      for(i=1;i<INscc_loop;i++)
	{
	  if(NGA_TYPE==1)
	    {
	      sprintf(junk2,"%s: %s",GetECCCode(i),SCCARRAY[i].scc);
	    }
	  else
	    {
	      sprintf(junk2,"%s",SCCARRAY[i].scc);
	    }
	  scc_names[i-1] = XmStringCreate(junk2,"mytag1");
	}

      
      sac_names = (XmString *) (malloc(sizeof(XmString *) * INsac_loop));
      if(sac_names==NULL){printf("sacn4: out of allocation memory!\n"); ExitWrapper(-1);}
      for(i=1;i<INsac_loop;i++)
	{
	  if(NGA_TYPE==1)
	    {
	      sprintf(junk2,"%s: %s",GetEACCode(i),SACARRAY[i].sac);
	    }
	  else
	    {
	      sprintf(junk2,"%s",SACARRAY[i].sac);
	    }
	  sac_names[i-1] = XmStringCreate(junk2,"mytag1");
	}









      

      n=0;
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++;
      
      sdcshead = XtCreatePopupShell("Attribution Information Window",
				    topLevelShellWidgetClass,drawing_a,resources,n);

      
      
      rc = XtVaCreateManagedWidget
      (
	  "XformWidget", xmPanedWindowWidgetClass, sdcshead,
	  XmNrubberPositioning, False,
	  XmNresizable,         True,
	  XmNseparatorOn,       False,
	  XmNsashHeight,        1,
	  NULL
	  );








      form = XtVaCreateWidget ("formola", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       XmNpaneMinimum,    20,
			       XmNpaneMaximum,    20,
			       NULL);
      
      startpos = 50;
      endpos = 100;


      sprintf(temp,"Feature Types:");
      label1 = XtVaCreateManagedWidget (temp,
					xmLabelWidgetClass, form,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,   startpos,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    0,
					XmNalignment,       XmALIGNMENT_CENTER,
					XmNlabelString,     STRING(temp),
					XmNtraversalOn,     False, 
					LABELWTRANSLATE,
					NULL);
      sprintf(temp,"Attributes:");
      label1 = XtVaCreateManagedWidget (temp,
					xmLabelWidgetClass, form,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,   endpos,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    startpos,
					XmNalignment,       XmALIGNMENT_CENTER,
					XmNlabelString,     STRING(temp),
					XmNtraversalOn,     False, 
					LABELWTRANSLATE,
					NULL);

      XtManageChild(form);


      form = XtVaCreateWidget ("formola", xmFormWidgetClass, rc,
			       XmNpaneMinimum,     15,
			       XmNpaneMaximum,     15,
			       XmNfractionBase,  100,  
			       NULL);
      
      sprintf(temp,"(%d Definitions)",INscc_loop-1);      
      info_scc_defs = XtVaCreateManagedWidget (temp,
					xmLabelWidgetClass, form,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,   startpos,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    0,
					XmNalignment,       XmALIGNMENT_CENTER,
					XmNlabelString,     STRING(temp),
					XmNtraversalOn,     False, 
				        LABELWTRANSLATE,
					NULL);

      sprintf(temp,"(%d Definitions)",INsac_loop-1);
      info_sac_defs = XtVaCreateManagedWidget (temp,
					xmLabelWidgetClass, form,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,   endpos,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    startpos,
					XmNalignment,       XmALIGNMENT_CENTER,
					XmNlabelString,     STRING(temp),
					XmNtraversalOn,     False, 
					LABELWTRANSLATE,
					NULL);

      if(NGA_TYPE==0)
	 {
	   sprintf(temp,"(%d Definitions)",FLAGSIZE);
	   label1 = XtVaCreateManagedWidget (temp,
					     xmLabelWidgetClass, form,
					     XmNrightAttachment, XmATTACH_POSITION,
					     XmNrightPosition,   100,
					     XmNleftAttachment,  XmATTACH_POSITION,
					     XmNleftPosition,    66,
					     XmNalignment,       XmALIGNMENT_CENTER,
					     XmNlabelString,     STRING(temp),
					     XmNtraversalOn,     False, 
					     LABELWTRANSLATE,
					     NULL);      
	 }

      XtManageChild(form);

      
      form = XtVaCreateWidget ("formola", xmFormWidgetClass, rc,

			       XmNfractionBase,  100,  
			       NULL);
      n=0;
      XtSetArg(resources[n], XmNlistSizePolicy,   XmCONSTANT);        n++;
      XtSetArg(resources[n], XmNvisibleItemCount, 10);                n++;
      XtSetArg(resources[n], XmNselectionPolicy,  XmSINGLE_SELECT);   n++;
      XtSetArg(resources[n], XmNleftAttachment,   XmATTACH_FORM);     n++;
      XtSetArg(resources[n], XmNrightAttachment,  XmATTACH_POSITION); n++;
      XtSetArg(resources[n], XmNtopAttachment,    XmATTACH_FORM);     n++;
      XtSetArg(resources[n], XmNbottomAttachment, XmATTACH_FORM);     n++;
      XtSetArg(resources[n], XmNrightPosition,    startpos);          n++;
      XtSetArg(resources[n], XmNtraversalOn,      False);             n++;
      XtSetArg(resources[n], XmNtranslations, XtParseTranslationTable (list_translations4)); n++;

      S_list_w = XmCreateScrolledList (form, "list", resources,n);
      XtAddCallback (S_list_w, XmNsingleSelectionCallback, set_scc, (XtPointer)1);
      XtManageChild (S_list_w);

      n=0;
      XtSetArg(resources[n], XmNlistSizePolicy,   XmCONSTANT);         n++;
      XtSetArg(resources[n], XmNvisibleItemCount, 10);                 n++;
      XtSetArg(resources[n], XmNselectionPolicy,  XmSINGLE_SELECT);    n++;
      XtSetArg(resources[n], XmNleftAttachment,   XmATTACH_POSITION);  n++;
      XtSetArg(resources[n], XmNleftPosition,     startpos);           n++;
      XtSetArg(resources[n], XmNrightAttachment,  XmATTACH_POSITION);  n++;
      XtSetArg(resources[n], XmNtopAttachment,    XmATTACH_FORM);     n++;
      XtSetArg(resources[n], XmNbottomAttachment, XmATTACH_FORM);     n++;
      XtSetArg(resources[n], XmNrightPosition,    endpos);             n++;
      XtSetArg(resources[n], XmNtraversalOn,      False);              n++;
      XtSetArg(resources[n], XmNtranslations, XtParseTranslationTable (list_translations5)); n++;

      S_list2_w = XmCreateScrolledList (form, "list", resources,n);    
      XtAddCallback (S_list2_w, XmNsingleSelectionCallback, set_scc, (XtPointer)2);
      XtManageChild (S_list2_w);


      XtVaGetValues(S_list_w    ,XmNverticalScrollBar,&vert_scroll[ATT1_SCROLL ] ,NULL);
      XtVaGetValues(S_list2_w   ,XmNverticalScrollBar,&vert_scroll[ATT2_SCROLL ] ,NULL);





      XtManageChild(form);

     


      form = XtVaCreateWidget ("form3", xmFormWidgetClass, rc,
			       XmNpaneMinimum,     175,
			       XmNpaneMaximum,     175,
			       XmNfractionBase,  100,
			       NULL);
      
      n = 0;
      XtSetArg(resources[n], XmNscrollBarDisplayPolicy , XmSTATIC);          n++;
      XtSetArg(resources[n], XmNrows,                    10);                n++;
      XtSetArg(resources[n], XmNcolumns,                 30);                n++;
      XtSetArg(resources[n], XmNleftAttachment,          XmATTACH_FORM);     n++;
      XtSetArg(resources[n], XmNrightAttachment,         XmATTACH_FORM);     n++;
      XtSetArg(resources[n], XmNeditable,                False);             n++;
      XtSetArg(resources[n], XmNeditMode,                XmMULTI_LINE_EDIT); n++;
      XtSetArg(resources[n], XmNscrollHorizontal,        False);             n++;
      XtSetArg(resources[n], XmNwordWrap,                True);              n++;
      XtSetArg(resources[n], XmNcursorPositionVisible,   False);             n++;
      XtSetArg(resources[n], XmNtraversalOn,      False);                    n++;
      XtSetArg(resources[n], XmNtranslations, XtParseTranslationTable (list_translations6)); n++;

      text_area = XmCreateScrolledText(form, "text_area", resources, n);
      XtManageChild (text_area);


      XtAddCallback (text_area, XmNmotionVerifyCallback, get_double, (XtPointer)NULL);


      
      XtVaGetValues(XtParent(text_area)   ,XmNverticalScrollBar,&vert_scroll[ATT3_SCROLL ] ,NULL);


      XtManageChild(form);




      if(NGA_TYPE==1)
	{
	  form = XtVaCreateWidget ("form", xmFormWidgetClass, rc,
			       XmNpaneMinimum,     35,
			       XmNpaneMaximum,     35,
				   XmNfractionBase,  100,
				   NULL);
	  
	  attr_type_menu = BuildAttrMenu (form, XmMENU_OPTION, "Attribution Schema:", attribution_type);
	  
	  XtManageChild (attr_type_menu);
	  XtManageChild(form);
	}



      form = XtVaCreateWidget ("form3", xmFormWidgetClass, rc,
			       XmNpaneMinimum,     35,
			       XmNpaneMaximum,     35,
			       XmNfractionBase,  100,  
			       NULL);
      
      text_w = XtVaCreateManagedWidget ("Search string:",
					xmLabelWidgetClass, form,
					XmNtraversalOn,      True,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,  25,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,
					LABELWTRANSLATE,
					NULL);
      XtManageChild(text_w);

      search_w = XtVaCreateManagedWidget ("text_w",
				      xmTextFieldWidgetClass, form,	  
				      XmNvalue, "",
				      XmNtraversalOn,      True,
				      XmNrightAttachment,  XmATTACH_POSITION,
				      XmNrightPosition,    99,
				      XmNleftAttachment,   XmATTACH_POSITION,
				      XmNleftPosition,     26,
				      XmNtopAttachment,    XmATTACH_FORM,
				      XmNbottomAttachment, XmATTACH_FORM,
				      XmNmaxLength,        150,
                      XmNtranslations,     XtParseTranslationTable ( translations_paste ) ,
				      NULL);

      XtManageChild(search_w);
      XtManageChild(form);


      form = XtVaCreateWidget ("form3", xmFormWidgetClass, rc,
			       XmNpaneMinimum,     25,
			       XmNpaneMaximum,     25,
			       XmNfractionBase,  100,  
			       NULL);

      if(NGA_TYPE==1)
	{
	  Done  = XtVaCreateManagedWidget("Search EDCS Names",xmPushButtonWidgetClass,form,
					  XmNleftAttachment,   XmATTACH_POSITION,
					  XmNleftPosition,     1,
					  XmNrightAttachment,  XmATTACH_POSITION,
					  XmNrightPosition,    50,
					  XmNlabelString,      STRING("Search Feature Names/Codes"),
					  XmNtopAttachment,    XmATTACH_FORM,
					  XmNbottomAttachment, XmATTACH_FORM,
					  XmNtraversalOn,      False, 
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					  NULL
					  ); 
	  
	  XtAddCallback(Done, XmNactivateCallback,
			searchEDCS_callback, (XtPointer) 1);
	  XtManageChild(Done);
	  
	  
	  Done  = XtVaCreateManagedWidget("Search EDCS Definitions",xmPushButtonWidgetClass,form,
					  XmNleftAttachment,   XmATTACH_POSITION,
					  XmNleftPosition,     50,
					  XmNrightAttachment,  XmATTACH_POSITION,
					  XmNrightPosition,    99,
					  XmNlabelString,      STRING("Search Feature Definitions"),
					  XmNtopAttachment,    XmATTACH_FORM,
					  XmNbottomAttachment, XmATTACH_FORM,
					  XmNtraversalOn,      False, 
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					  NULL
					  ); 
	}
      else
	{
	  Done  = XtVaCreateManagedWidget("Search EDCS Names",xmPushButtonWidgetClass,form,
					  XmNleftAttachment,   XmATTACH_POSITION,
					  XmNleftPosition,     1,
					  XmNrightAttachment,  XmATTACH_POSITION,
					  XmNrightPosition,    50,
					  XmNlabelString,      STRING("Search Classification Labels"),
					  XmNtopAttachment,    XmATTACH_FORM,
					  XmNbottomAttachment, XmATTACH_FORM,
					  XmNtraversalOn,      False, 
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					  NULL
					  ); 
	  
	  XtAddCallback(Done, XmNactivateCallback,
			searchEDCS_callback, (XtPointer) 1);
	  XtManageChild(Done);
	  
	  
	  Done  = XtVaCreateManagedWidget("Search EDCS Definitions",xmPushButtonWidgetClass,form,
					  XmNleftAttachment,   XmATTACH_POSITION,
					  XmNleftPosition,     50,
					  XmNrightAttachment,  XmATTACH_POSITION,
					  XmNrightPosition,    99,
					  XmNlabelString,      STRING("Search Classification Definitions"),
					  XmNtopAttachment,    XmATTACH_FORM,
					  XmNbottomAttachment, XmATTACH_FORM,
					  XmNtraversalOn,      False, 
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					  NULL
					  ); 
	}


      XtAddCallback(Done, XmNactivateCallback,
		    searchEDCS_callback, (XtPointer) 2);
      XtManageChild(Done);
      XtManageChild(form);

      form = XtVaCreateWidget ("form3", xmFormWidgetClass, rc,
			       XmNpaneMinimum,     25,
			       XmNpaneMaximum,     25,
			       XmNfractionBase,  100,  
			       NULL);

      if(NGA_TYPE==1)
	{
	  Done  = XtVaCreateManagedWidget("Search EDCS Names",xmPushButtonWidgetClass,form,
					  XmNleftAttachment,   XmATTACH_POSITION,
					  XmNleftPosition,     1,
					  XmNrightAttachment,  XmATTACH_POSITION,
					  XmNrightPosition,    50,
					  XmNlabelString,      STRING("Search Attribute Names/Codes"),
					  XmNtopAttachment,    XmATTACH_FORM,
					  XmNbottomAttachment, XmATTACH_FORM,
					  XmNtraversalOn,      False, 
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					  NULL
					  ); 
	}
      else
	{
	  Done  = XtVaCreateManagedWidget("Search EDCS Names",xmPushButtonWidgetClass,form,
					  XmNleftAttachment,   XmATTACH_POSITION,
					  XmNleftPosition,     1,
					  XmNrightAttachment,  XmATTACH_POSITION,
					  XmNrightPosition,    50,
					  XmNlabelString,      STRING("Search Attribute Labels"),
					  XmNtopAttachment,    XmATTACH_FORM,
					  XmNbottomAttachment, XmATTACH_FORM,
					  XmNtraversalOn,      False, 
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					  NULL
					  ); 
	}

      XtAddCallback(Done, XmNactivateCallback,
		    searchEDCS_callback, (XtPointer) 11);
      XtManageChild(Done);


      Done  = XtVaCreateManagedWidget("Search EDCS Definitions",xmPushButtonWidgetClass,form,
				      XmNleftAttachment,   XmATTACH_POSITION,
				      XmNleftPosition,     50,
				      XmNrightAttachment,  XmATTACH_POSITION,
				      XmNrightPosition,    99,
				      XmNlabelString,      STRING("Search Attribute Definitions"),
				      XmNtopAttachment,    XmATTACH_FORM,
				      XmNbottomAttachment, XmATTACH_FORM,
				      XmNtraversalOn,      False, 
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 

      XtAddCallback(Done, XmNactivateCallback,
		    searchEDCS_callback, (XtPointer) 12);
      XtManageChild(Done);
      XtManageChild(form);



      form = XtVaCreateWidget ("form3", xmFormWidgetClass, rc,
			       XmNpaneMinimum,     25,
			       XmNpaneMaximum,     25,
			       XmNfractionBase,  100,  
			       NULL);
      
      Done  = XtVaCreateManagedWidget("Search EDCS Definitions",xmPushButtonWidgetClass,form,
				      XmNleftAttachment,   XmATTACH_POSITION,
				      XmNleftPosition,     1,
				      XmNrightAttachment,  XmATTACH_POSITION,
				      XmNrightPosition,    50,
				      XmNlabelString,      STRING("Search Enumerant Labels"),
				      XmNtopAttachment,    XmATTACH_FORM,
				      XmNbottomAttachment, XmATTACH_FORM,
				      XmNtraversalOn,      False, 
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 

      XtAddCallback(Done, XmNactivateCallback,
		    searchEDCS_callback, (XtPointer) 13);
      XtManageChild(Done);



      if(NGA_TYPE==1)
	{
	  Done  = XtVaCreateManagedWidget("Search EDCS Names",xmPushButtonWidgetClass,form,
					  XmNleftAttachment,   XmATTACH_POSITION,
					  XmNleftPosition,     50,
					  XmNrightAttachment,  XmATTACH_POSITION,
					  XmNrightPosition,    99,
					  XmNlabelString,      STRING("Search Everything"),
					  XmNtopAttachment,    XmATTACH_FORM,
					  XmNbottomAttachment, XmATTACH_FORM,
					  XmNtraversalOn,      False, 
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					  NULL
					  ); 
	  XtAddCallback(Done, XmNactivateCallback,
			searchEDCS_callback, (XtPointer) 999);
	  XtManageChild(Done);
	}
      else
	{
	  Done  = XtVaCreateManagedWidget("Search EDCS Names",xmPushButtonWidgetClass,form,
					  XmNleftAttachment,   XmATTACH_POSITION,
					  XmNleftPosition,     50,
					  XmNrightAttachment,  XmATTACH_POSITION,
					  XmNrightPosition,    99,
					  XmNlabelString,      STRING("Search Enumerant Definitions"),
					  XmNtopAttachment,    XmATTACH_FORM,
					  XmNbottomAttachment, XmATTACH_FORM,
					  XmNtraversalOn,      False, 
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					  NULL
					  ); 
	  
	  XtAddCallback(Done, XmNactivateCallback,
			searchEDCS_callback, (XtPointer) 14);
	  XtManageChild(Done);
	}
      
      XtManageChild(form);
	  
	  



      if(NGA_TYPE==0)
	{
	  form = XtVaCreateWidget ("form3", xmFormWidgetClass, rc,
				   XmNpaneMinimum,     25,
				   XmNpaneMaximum,     25,
				   XmNfractionBase,  100,  
				   NULL);
	  
	  Done  = XtVaCreateManagedWidget("Search EDCS Names",xmPushButtonWidgetClass,form,
					  XmNleftAttachment,   XmATTACH_POSITION,
					  XmNleftPosition,     1,
					  XmNrightAttachment,  XmATTACH_POSITION,
					  XmNrightPosition,    99,
					  XmNlabelString,      STRING("Search Everything"),
					  XmNtopAttachment,    XmATTACH_FORM,
					  XmNbottomAttachment, XmATTACH_FORM,
					  XmNtraversalOn,      False, 
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					  NULL
					  ); 
	  XtAddCallback(Done, XmNactivateCallback,
			searchEDCS_callback, (XtPointer) 999);
	  XtManageChild(Done);
	  XtManageChild(form);
	}









      edcsstring[0] = '\0';

      form = XtVaCreateWidget ("form3", xmFormWidgetClass, rc,
			       XmNpaneMinimum,     25,
			       XmNpaneMaximum,     25,
			       XmNfractionBase,  100,  
			       NULL);
      
      Done  = XtVaCreateManagedWidget("Help",xmPushButtonWidgetClass,form,
				      XmNleftAttachment,   XmATTACH_POSITION,
				      XmNleftPosition,     1,
				      XmNrightAttachment,  XmATTACH_POSITION,
				      XmNrightPosition,    50,
				      XmNlabelString,      STRING("Help"),
				      XmNtopAttachment,    XmATTACH_FORM,
				      XmNbottomAttachment, XmATTACH_FORM,
				      XmNtraversalOn,      False, 
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 
      XtAddCallback(Done, XmNactivateCallback,
		    Help_sdcsCallback, (XtPointer) NULL);
      XtManageChild(Done);

      Done  = XtVaCreateManagedWidget("Done7",xmPushButtonWidgetClass,form,
				      XmNleftAttachment,   XmATTACH_POSITION,
				      XmNleftPosition,     50,
				      XmNrightAttachment,  XmATTACH_POSITION,
				      XmNrightPosition,    99,
				      XmNlabelString,      STRING("Done"),
				      XmNtopAttachment,    XmATTACH_FORM,
				      XmNbottomAttachment, XmATTACH_FORM,
				      XmNtraversalOn,      False, 
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 

      XtAddCallback(Done, XmNactivateCallback,
		    die_callback, (XtPointer) 1008);
      XtManageChild(Done);
      XtManageChild(form);


      XtManageChild(rc);
      MyPopup(sdcshead); 
      XtAddCallback(sdcshead,XmNdestroyCallback,ShellDeath,(XtPointer)4067);
      dead_sdcs=0;
      


      XmListAddItems(S_list2_w, sac_names, INsac_loop-1,1);
      XmListAddItems(S_list_w,  scc_names, INscc_loop-1,1);


      set_cursor(mydisplay,mywindow,GOOD);
      BUSY=0;

      if(changeattr==1)
	{
	  ATTRIBUTION_TYPE = save_attr_type;
	  InitializeAttribution();
	}
    }
  else
    {
      ResetWidget(sdcshead);
    }
}


void choose_specific_fcode(Widget w,XtPointer userData,XtPointer callData)
{
  printf("in choose_specific_fcode\n");
}


void choose_specific_model(Widget w,MyData *mydata,XtPointer callData)
{
  int pos_count,modelindex,i;
  int *pos_list;
  XmString *new_items;
  XmString empty_item[1];
  char temp[1000];
  int cloneindex=-1;
  int errnum   = mydata->check_num;
  int axis     = mydata->axis;
  int ADDER    = mydata->ADDER;
  int clonenum = mydata->clonenum;
  int geomtype = 0;
  int checkindex,j;


  if(NGA_TYPE==1)
    {
      geomtype = mydata->geomtype;
    }

  if(clonenum>0)
    {
      cloneindex = GetCloneIndex(clonenum,errnum);
    }



  if(clonenum==0)
    {
      XmListGetSelectedPos(ErrorLookup[errnum].list_w[axis][ADDER][geomtype],&pos_list,&pos_count);
    }
  else
    {
      XmListGetSelectedPos(CloneErrorLookup[cloneindex].list_w[axis][ADDER][geomtype],&pos_list,&pos_count);
    }

  if(pos_count!=1)
    {
      

      return;
    }



  if(
     ( (clonenum==0) && (ErrorLookup[errnum].DO_EDCS_COMBO[axis][ADDER][geomtype]==1))          ||    
     ( (clonenum!=0) && (CloneErrorLookup[cloneindex].DO_EDCS_COMBO[axis][ADDER][geomtype]==1))
     )  
    {
      if((NGA_TYPE==1)&&(geomtype>0)) 
	{
	  
	  
	  
	  
	  
	  i = 0;
	  
	  checkindex = 0;
	  
	  
	  
	  
	  for (j = 0; j < NumberOfModels ; j++)
	    {
	      if(
		 ((geomtype==C_AREA)&&(!strcmp(MdlNames[j].name,"(AREA)")))  ||
		 ((geomtype==C_LINE)&&(!strcmp(MdlNames[j].name,"(LINE)")))  ||
		 ((geomtype==C_POFE)&&(!strcmp(MdlNames[j].name,"(POINT)"))) ||
		 ((geomtype==C_GRID)&&(!strcmp(MdlNames[j].name,"(GRID)")))
		 )
		{
		  if(checkindex==pos_list[i]-1)
		    {
		      		      
		      
		      pos_list[i] = j+1; 
		      
		      break;
		    }
		  
		  checkindex = checkindex + 1;
		}
	    }
	}
    }


  modelindex = pos_list[0]-1; 


  
  


  new_items = (XmString *) (malloc(sizeof(XmString *) * MdlNames[modelindex].numuniqueAttr));
  if(new_items==NULL){printf("new_items: out of allocation memory!\n"); ExitWrapper(-1);}
  
  for(i=0;i<MdlNames[modelindex].numuniqueAttr;i++)
    {

      if(NGA_TYPE==1)
	  {
	    sprintf(temp,"%s: %s (%.0lf)",
		  GetEACCode(GetCode(modelindex,i)),
		  GetEACLabel(GetCode(modelindex,i)),
		  MdlNames[modelindex].UniqueCounts[i]
		  );
	  } 
      else
	  { 
	    sprintf(temp,"%s (%.0lf)",
		  GetEACLabel(GetCode(modelindex,i)),
		  MdlNames[modelindex].UniqueCounts[i]
		  );
	  } 

      new_items[i] = XmStringCreateLocalized (temp);
    }
  
  
  empty_item[0] =  XmStringCreate("                                                                                                                                            ","mytag1");
  
  if(clonenum==0)
    {
      XtVaSetValues (ErrorLookup[errnum].EAlist[axis][ADDER][geomtype],
		     XmNitems,             new_items,
		     XmNitemCount,         MdlNames[modelindex].numuniqueAttr,
		     NULL);
      sprintf(temp,"(%d definitions):",MdlNames[modelindex].numuniqueAttr);


      XtVaSetValues(ErrorLookup[errnum].EAstring1,XmNlabelString,     STRING(temp),NULL);


	  if(MdlNames[modelindex].numuniqueAttr<=0)
	  {
         XtSetSensitive(ErrorLookup[errnum].EAlist[axis][ADDER][geomtype],False);
	  }
	  else
	  {
         XtSetSensitive(ErrorLookup[errnum].EAlist[axis][ADDER][geomtype],True);
	  }


      
      XtVaSetValues (ErrorLookup[errnum].EAVlist[axis][ADDER][geomtype],
		     XmNitems,             empty_item,
		     XmNitemCount,         1,
		     NULL);
      XtVaSetValues(ErrorLookup[errnum].EAstring2,XmNlabelString,     STRING("(No attribute selected):"),NULL);
      
      
      for (i=0;i<MdlNames[modelindex].numuniqueAttr;i++)
	{
	  XmStringFree (new_items[i]);
	}     
      free(new_items);
      
      XmListDeselectAllItems(ErrorLookup[errnum].EAlist[axis][ADDER][geomtype]);
      XmListDeselectAllItems(ErrorLookup[errnum].EAVlist[axis][ADDER][geomtype]);
    }
  else
    {
      XtVaSetValues (CloneErrorLookup[cloneindex].EAlist[axis][ADDER][geomtype],
		     XmNitems,             new_items,
		     XmNitemCount,         MdlNames[modelindex].numuniqueAttr,
		     NULL);
      sprintf(temp,"(%d definitions):",MdlNames[modelindex].numuniqueAttr);
      XtVaSetValues(CloneErrorLookup[cloneindex].EAstring1,XmNlabelString,     STRING(temp),NULL);


   	  if(MdlNames[modelindex].numuniqueAttr<=0)
	  {
         XtSetSensitive(CloneErrorLookup[cloneindex].EAlist[axis][ADDER][geomtype],False);
	  }
	  else
	  {
         XtSetSensitive(CloneErrorLookup[cloneindex].EAlist[axis][ADDER][geomtype],True);
	  }


      
      XtVaSetValues (CloneErrorLookup[cloneindex].EAVlist[axis][ADDER][geomtype],
		     XmNitems,             empty_item,
		     XmNitemCount,         1,
		     NULL);
      XtVaSetValues(CloneErrorLookup[cloneindex].EAstring2,XmNlabelString,     STRING("(No attribute selected):"),NULL);
      
      
      for (i=0;i<MdlNames[modelindex].numuniqueAttr;i++)
	{
	  XmStringFree (new_items[i]);
	}     
      free(new_items);
      
      XmListDeselectAllItems(CloneErrorLookup[cloneindex].EAlist[axis][ADDER][geomtype]);
      XmListDeselectAllItems(CloneErrorLookup[cloneindex].EAVlist[axis][ADDER][geomtype]);
    }
}




char *PadNumber(int type, int number, double dval)
{
  static char temp[100];
 
  

  if(type==1)
    {
      sprintf(temp,"(%d)",number);
    }
  else if(type==2)
    {
      sprintf(temp,"(%.0lf)",dval);
    }
  else
    {
      printf("bad type %d to PN: %d %lf\n",type,number,dval);
      XBell(mydisplay,50);
    }

  return temp;
}





int GetLongAttrType(int code, int silent)
{
  char tempval[1000];

  sprintf(tempval,"%s",GetEACCode(code));

  if     (((ATTRTYPE_D4())) &&(!strcmp(tempval,"ARE_"))){return LONG_ATTR_AREA;}
  else if(((ATTRTYPE_FACC())) &&(!strcmp(tempval,"ARE"))) {return LONG_ATTR_AREA;}
  else if(((ATTRTYPE_VMAP())) &&(!strcmp(tempval,"ARA"))) {return LONG_ATTR_AREA;}
  else if(((ATTRTYPE_MGCP3()) ||(ATTRTYPE_MGCP4())) &&(!strcmp(tempval,"ARA"))) {return LONG_ATTR_AREA;}
  
  else if(((ATTRTYPE_ANY_TDS()))&&(!strcmp(tempval,"ARA"))) {return LONG_ATTR_AREA;}
  else if(((ATTRTYPE_NFDD()))&&(!strcmp(tempval,"ARA"))) {return LONG_ATTR_AREA;}
  else if(((ATTRTYPE_DFDD()))&&(!strcmp(tempval,"ARA"))) {return LONG_ATTR_AREA;}
  else if(((ATTRTYPE_SAC()))&&(!strcmp(tempval,"ARA"))) {return LONG_ATTR_AREA;}
  else if(((ATTRTYPE_ANY_GGDM()))&&(!strcmp(tempval,"ARA"))) {return LONG_ATTR_AREA;}


  else if(((ATTRTYPE_D4())) &&(!strcmp(tempval,"HGT"))) {return LONG_ATTR_HGT;}
  else if(((ATTRTYPE_FACC())) &&(!strcmp(tempval,"HGT"))) {return LONG_ATTR_HGT;}
  else if(((ATTRTYPE_VMAP())) &&(!strcmp(tempval,"HGT"))) {return LONG_ATTR_HGT;}
  else if(((ATTRTYPE_MGCP3()) ||(ATTRTYPE_MGCP4())) &&(!strcmp(tempval,"HGT"))) {return LONG_ATTR_HGT;}
  else if(((ATTRTYPE_UFD2()))&&(!strcmp(tempval,"HGT"))) {return LONG_ATTR_HGT;}
  else if(((ATTRTYPE_UFD1()))&&(!strcmp(tempval,"HGT"))) {return LONG_ATTR_HGT;}
  else if(((ATTRTYPE_UFD3()))&&(!strcmp(tempval,"HGT"))) {return LONG_ATTR_HGT;}
  else if(((ATTRTYPE_ANY_TDS()))&&(!strcmp(tempval,"HGT"))) {return LONG_ATTR_HGT;}
  else if(((ATTRTYPE_NFDD()))&&(!strcmp(tempval,"HGT"))) {return LONG_ATTR_HGT;}
  else if(((ATTRTYPE_DFDD()))&&(!strcmp(tempval,"HGT"))) {return LONG_ATTR_HGT;}
  else if(((ATTRTYPE_SAC()))&&(!strcmp(tempval,"HGT"))) {return LONG_ATTR_HGT;}
  else if(((ATTRTYPE_ANY_GGDM()))&&(!strcmp(tempval,"HGT"))) {return LONG_ATTR_HGT;}



  else if(((ATTRTYPE_D4())) &&(!strcmp(tempval,"LEN_"))) {return LONG_ATTR_LEN;}
  else if(((ATTRTYPE_FACC())) &&(!strcmp(tempval,"LEN"))) {return LONG_ATTR_LEN;}
  else if(((ATTRTYPE_VMAP())) &&(!strcmp(tempval,"LEN"))) {return LONG_ATTR_LEN;}
  else if(((ATTRTYPE_MGCP3()) ||(ATTRTYPE_MGCP4())) &&(!strcmp(tempval,"LEN"))) {return LONG_ATTR_LEN;}
  else if(((ATTRTYPE_UFD2()))&&(!strcmp(tempval,"LEN"))) {return LONG_ATTR_LEN;}
  else if(((ATTRTYPE_UFD1()))&&(!strcmp(tempval,"LEN"))) {return LONG_ATTR_LEN;}
  else if(((ATTRTYPE_UFD3()))&&(!strcmp(tempval,"LEN"))) {return LONG_ATTR_LEN;}
  else if(((ATTRTYPE_ANY_TDS()))&&(!strcmp(tempval,"LZN"))) {return LONG_ATTR_LEN;}
  else if(((ATTRTYPE_NFDD()))&&(!strcmp(tempval,"LZN"))) {return LONG_ATTR_LEN;}
  else if(((ATTRTYPE_DFDD()))&&(!strcmp(tempval,"LEN"))) {return LONG_ATTR_LEN;}
  else if(((ATTRTYPE_SAC()))&&(!strcmp(tempval,"LEN"))) {return LONG_ATTR_LEN;}
  else if(((ATTRTYPE_ANY_GGDM()))&&(!strcmp(tempval,"LZN"))) {return LONG_ATTR_LEN;}


  else if(((ATTRTYPE_D4())) &&(!strcmp(tempval,"NAM"))) {return LONG_ATTR_NAM;}
  else if(((ATTRTYPE_FACC())) &&(!strcmp(tempval,"NAM"))) {return LONG_ATTR_NAM;}
  else if(((ATTRTYPE_VMAP())) &&(!strcmp(tempval,"NAM"))) {return LONG_ATTR_NAM;}
  else if(((ATTRTYPE_MGCP3()) ||(ATTRTYPE_MGCP4())) &&(!strcmp(tempval,"NAM"))) {return LONG_ATTR_NAM;}
  else if(((ATTRTYPE_UFD2()))&&(!strcmp(tempval,"NAM"))) {return LONG_ATTR_NAM;}
  else if(((ATTRTYPE_UFD1()))&&(!strcmp(tempval,"NAM"))) {return LONG_ATTR_NAM;}
  else if(((ATTRTYPE_UFD3()))&&(!strcmp(tempval,"NAM"))) {return LONG_ATTR_NAM;}
  else if(((ATTRTYPE_ANY_TDS()))&&(!strcmp(tempval,"ZI005_FNA"))) {return LONG_ATTR_NAM;}
  else if(((ATTRTYPE_DFDD()))&&(!strcmp(tempval,"NAM"))) {return LONG_ATTR_NAM;}
  else if(((ATTRTYPE_ANY_GGDM()))&&(!strcmp(tempval,"ZI005_FNA"))) {return LONG_ATTR_NAM;}
  



  else if(((ATTRTYPE_D4())) &&(!strcmp(tempval,"ZV2"))) {return LONG_ATTR_ZV2;}
  else if(((ATTRTYPE_FACC())) &&(!strcmp(tempval,"ZV2"))) {return LONG_ATTR_ZV2;}
  else if(((ATTRTYPE_VMAP())) &&(!strcmp(tempval,"ZV2"))) {return LONG_ATTR_ZV2;}
  
  else if(((ATTRTYPE_UFD2()))&&(!strcmp(tempval,"ZV2"))) {return LONG_ATTR_ZV2;}
  else if(((ATTRTYPE_UFD1()))&&(!strcmp(tempval,"ZV2"))) {return LONG_ATTR_ZV2;}
  else if(((ATTRTYPE_UFD3()))&&(!strcmp(tempval,"ZV2"))) {return LONG_ATTR_ZV2;}
  else if(((ATTRTYPE_ANY_TDS()))&&(!strcmp(tempval,"ZVH"))) {return LONG_ATTR_ZV2;}
  else if(((ATTRTYPE_NFDD()))&&(!strcmp(tempval,"ZVH"))) {return LONG_ATTR_ZV2;}
  else if(((ATTRTYPE_DFDD()))&&(!strcmp(tempval,"ZVH"))) {return LONG_ATTR_ZV2;}
  else if(((ATTRTYPE_SAC()))&&(!strcmp(tempval,"ZV7"))) {return LONG_ATTR_ZV2;}
  else if(((ATTRTYPE_ANY_GGDM()))&&(!strcmp(tempval,"ZVH"))) {return LONG_ATTR_ZV2;}


  else if(((ATTRTYPE_D4())) &&(!strcmp(tempval,"GFID")))  {return LONG_ATTR_ID;}
  else if(((ATTRTYPE_FACC())) &&(!strcmp(tempval,"FLDBID"))){return LONG_ATTR_ID;}
  
  else if(((ATTRTYPE_MGCP3()) ||(ATTRTYPE_MGCP4())) &&(!strcmp(tempval,"UID")))   {return LONG_ATTR_ID;}
  else if(((ATTRTYPE_UFD2()))&&(!strcmp(tempval,"GFID")))  {return LONG_ATTR_ID;}
  else if(((ATTRTYPE_UFD1()))&&(!strcmp(tempval,"GFID")))  {return LONG_ATTR_ID;}
  else if(((ATTRTYPE_UFD3()))&&(!strcmp(tempval,"GFID")))  {return LONG_ATTR_ID;}
  else if(((ATTRTYPE_ANY_TDS()))&&(!strcmp(tempval,"UFI")))   {return LONG_ATTR_ID;}
  else if(((ATTRTYPE_NFDD()))&&(!strcmp(tempval,"UFI")))   {return LONG_ATTR_ID;}
  else if(((ATTRTYPE_DFDD()))&&(!strcmp(tempval,"UID")))   {return LONG_ATTR_ID;}
  else if(((ATTRTYPE_SAC()))&&(!strcmp(tempval,"UUID_1")))   {return LONG_ATTR_ID;}
  else if(((ATTRTYPE_ANY_GGDM()))&&(!strcmp(tempval,"UFI")))   {return LONG_ATTR_ID;}
  
  if(silent==0)
    {
      printf("Error in GLAT for %d (%s): could not locate\n",code,tempval);
    }

  return -1;
}



int PartitionLongCValList(int p,int r, int type)
{
  
  char *x;
  int i,j;
  
  char *temp;

  

  x = LongValueList[p];


  i = p-1;
  j = r+1;
  while(1)
    {
      do{j=j-1;}
      while(strcmp(LongValueList[j],x)>0);  
      
      do{i=i+1;}
      while(strcmp(LongValueList[i],x)<0);
      
      if(i<j)
	{
	  

	  temp = LongValueList[i];
	  LongValueList[i] = LongValueList[j];
	  LongValueList[j] = temp;

	}
      else
	{
	  return j;
	}
    }
}


int PartitionLongDValList(int p,int r)
{
  double x,Dtemp;
  int i,j;
  char *temp;

  x = LongDValueList[p];

  i = p-1;
  j = r+1;
  while(1)
    {
      do{j=j-1;}
      while(LongDValueList[j]>x); 
      
      do{i=i+1;}
      while(LongDValueList[i]<x);
      
      if(i<j)
	{
	  temp = LongValueList[i];
	  LongValueList[i] = LongValueList[j];
	  LongValueList[j] = temp;

	  Dtemp = LongDValueList[i];
	  LongDValueList[i] = LongDValueList[j];
	  LongDValueList[j] = Dtemp;
	}
      else
	{
	  return j;
	}
    }
}


int IsGreater(double a, double b, int index, int index2)
{
  int firstd  = -1;
  int secondd = -1;

  if(a!=b)
  {
	if(a>b) { return 1;}
	return 0;
  }

  


  


  
  if(strstr(LongValueList[index],"."))
  {
	  firstd = 1;
  }
  if(strstr(LongValueList[index2],"."))
  {
	  secondd = 1;
  }


  if((firstd<0)&&(secondd>0))
  {
	  
	  return 1;
  }

  return 0;
}






int RealIsLess(double a, double b, int index, int index2)
{
  int firstd  = -1;
  int secondd = -1;

  if(a!=b)
  {
	if(a<b) { return 1;}
	return 0;
  }


  

  


  
  if(strstr(LongValueList[index],"."))
  {
	  firstd = 1;
  }
  if(strstr(LongValueList[index2],"."))
  {
	  secondd = 1;
  }


  if((firstd>0)&&(secondd<0))
  {
	  
	  return 1;
  }

  return 0;
}







int IsLess(double a, double b, int index, int index2)
{
  int result;

  result = RealIsLess(a,b,index,index2);

  

  return result;
}






int PartitionLongMDValList(int p,int r)
{
  double pivot,Dtemp;
  int i,j;
  char *temp;

  pivot = LongDValueList[p];

  i = p-1;
  j = r+1;
  while(1)
    {
      do{j=j-1;}
      while(
		     (IsGreater(LongDValueList[j],pivot,j,p)==1) &&
			 (j>p)
		   );

      
      do{i=i+1;}
      while(
		     (IsLess(LongDValueList[i],pivot,i,p)==1) &&
			 (i<r)
		   );
      
      if(i<j)
	{
	  temp = LongValueList[i];
	  LongValueList[i] = LongValueList[j];
	  LongValueList[j] = temp;

	  Dtemp = LongDValueList[i];
	  LongDValueList[i] = LongDValueList[j];
	  LongDValueList[j] = Dtemp;
	}
      else
	{
	  return j;
	}
    }
}


void SortLongCValList(int p,int r, int type)
{
  int q;
  
  
  if(p<r)
    {
      q = PartitionLongCValList(p,r,type);

      SortLongCValList(p,q,type);
      SortLongCValList(q+1,r,type);
    }
}


void SortLongDValList(int p,int r)
{
  int q;
  
  
  if(p<r)
    {
      q = PartitionLongDValList(p,r);

      SortLongDValList(p,q);
      SortLongDValList(q+1,r);
    }
}


void SortLongMDValList(int p,int r)
{
  int q;
  
  if(p<r)
    {
      q = PartitionLongMDValList(p,r);

      SortLongMDValList(p,q);
      SortLongMDValList(q+1,r);
    }
}



int BuildLongAttrValList(int SCC,int longcode,XmString new_items[], int doxmstring, int specialtype)
{
  char temp[1000],lastvalue[1000],Cval[1000];
  int i,thistype,Ival,totalvalues,thisvaluecount,
    insertindex,firstinsertindex,numfound,charfound,thisecc,
	targetecc,thisgeom,targetgeom,intfound,doublefound;
  double Dval;
  int type;
  static int totalcalls=0;
  static int interior_manager = -1;


  

  if(specialtype==2)
  {
    
	if(interior_manager>=0)
	{
      End_LongFiles(interior_manager);
	}
	interior_manager = -1;
	return 0; 
  }



  type = GetLongAttrType(longcode,0);

  if(type<0)
    {
      return -1;
    }
  




  if(SCC>=0)
    {
      
      
	  

      targetecc = MdlNames[SCC].code;
	  targetgeom = GetGeom(MdlNames[SCC].name);

	  global_target_ecc  = targetecc;
      global_target_geom = targetgeom;
    }

  
  
  
  LongValueList  = (char **) malloc(sizeof(char *)*LLFidTableCount);
  LongDValueList = (double *)malloc(SzD*LLFidTableCount);
  
  


  if(specialtype==0) 
  {
    Begin_LongFiles(type);
  }
  else if(specialtype==1) 
  {
      

	if(interior_manager<0)
	{
	  
      Begin_LongFiles(type);
	  interior_manager = type;
	}
	else if(interior_manager!=type)
	{
	  
	   

      

      End_LongFiles(interior_manager);
      Begin_LongFiles(type);
	  interior_manager = type;
	}
  }
  


  numfound         = 0;
  charfound        = 0;
  intfound         = 0;
  doublefound      = 0;
  firstinsertindex = 0;

  totalcalls = totalcalls + 1;

  for(i=0;i<LLFidTableCount;i++)
    {
      LongDValueList[i] = -9823456.78;


      if(i%2000000==0)
	  {
		if(i>0)
		{
	      printf("%d/%d   (type %d) (total %d) \n",i,LLFidTableCount,type,totalcalls);
		}
	  }
      
      
      if(SCC>=0)
	{

	  if(LLFidTable[i]<0)
	  {
		 
		 continue;
	  }

	  thisecc  = SCCtable[CrsWlk[LLFidTable[i]].LtoSmapping].ECC;
	  thisgeom =          CrsWlk[LLFidTable[i]].geomtype;

	  if((thisecc!=targetecc)||(thisgeom!=targetgeom))
	  {
		continue;
	  }
	}


      thistype = GetLongAttrVal(type,i,&Ival,&Dval,&Cval[0]);


      if(thistype==NOTYPE)
	{
	}
      else if(thistype==C_TYPE)
	{
	  LongValueList[firstinsertindex] = (char *)malloc(strlen(Cval)+5); 
	  sprintf(LongValueList[firstinsertindex],"\"%s\"",Cval);
	  charfound = 1;
	  firstinsertindex = firstinsertindex + 1;
	}
      else if(thistype==I_TYPE)
	{
	  LongValueList[firstinsertindex] = (char *)malloc(25);
	  LongDValueList[firstinsertindex] = Ival;
	  sprintf(LongValueList[firstinsertindex],"%d",Ival);
	  numfound = 1;
	  intfound = 1;
	  firstinsertindex = firstinsertindex + 1;
	}
      else if(thistype==D_TYPE)
	{

	  LongValueList[firstinsertindex]  = (char *)malloc(25);
	  LongDValueList[firstinsertindex] = Dval;
	  sprintf(LongValueList[firstinsertindex],"%lf",Dval);
	  numfound = 1;
	  doublefound = 1;
	  firstinsertindex = firstinsertindex + 1;
	}

    }






  if(specialtype==0)
  {
    End_LongFiles(type);
    
  }
  
  global_target_ecc  = -1;
  global_target_geom = -1;

  



  
  

  if((numfound==1)&&(charfound==0)&&((intfound+doublefound)==1))
    {
      SortLongDValList(0,firstinsertindex-1);
    }
  else if((numfound==1)&&(charfound==0)&&((intfound+doublefound)==2))
    {
      SortLongMDValList(0,firstinsertindex-1);
    }
  else
    {
      SortLongCValList(0,firstinsertindex-1,7);
    }



  if(doxmstring==0)
  {
	  return firstinsertindex;
  }

  





  

  totalvalues    = 1;
  thisvaluecount = 1;
  insertindex    = 0;


  sprintf(lastvalue,"%s",LongValueList[0]);

  if(firstinsertindex==1)
    {
      
      sprintf(temp,"Value: %s (1)",lastvalue);      
      new_items[0] = XmStringCreateLocalized (temp);
      free(LongValueList[0]);
    }
  else
    {
      free(LongValueList[0]);

      for(i=1;i<firstinsertindex;i++)
	{
	  
	  if(!strcmp(lastvalue,LongValueList[i]))
	    {
	      thisvaluecount = thisvaluecount + 1;
	    }
	  else
	    {
       
	      sprintf(temp,"Value: %s (%d)",lastvalue,thisvaluecount);      
	      new_items[insertindex] = XmStringCreateLocalized (temp);
	      
	      insertindex = insertindex + 1;
	      
	      	  	  
	      sprintf(lastvalue,"%s",LongValueList[i]);
	      totalvalues    = totalvalues + 1;
	      thisvaluecount = 1;	  
	    }
	  
	  
	  if(i==(firstinsertindex-1))
	    {
	      
	      sprintf(temp,"Value: %s (%d)",lastvalue,thisvaluecount);      
	      new_items[insertindex] = XmStringCreateLocalized (temp);
	      	  
	    }
	  
	  free(LongValueList[i]);
	}
    }
  
  free(LongValueList);
  LongValueList = NULL;

  free(LongDValueList);
  LongDValueList = NULL;
  

  return totalvalues;
}





void choose_specific_attribute(Widget w,MyData *mydata,XtPointer callData)
{
  int pos_count,i,SCC,SAC,numattributes,type_found,num_ee;
  int *pos_list;
  XmString *new_items;
  char temp[500];
  int nonunique;
  int cloneindex=-1;
  int errnum   = mydata->check_num;
  int axis     = mydata->axis;
  int ADDER    = mydata->ADDER;
  int clonenum = mydata->clonenum;
  int geomtype = 0;
  int checkindex,j;
  int long_type;

  extern char GetOpen(int i);
  extern char GetClose(int i);




  if(NGA_TYPE==1)
    {
      geomtype = mydata->geomtype;
    }


  if(clonenum>0)
    {
      cloneindex = GetCloneIndex(clonenum,errnum);
    }


  
      
  if(clonenum==0)
    {
      XmListGetSelectedPos(ErrorLookup[errnum].EAlist[axis][ADDER][geomtype],&pos_list,&pos_count);
    }
  else
    {
      XmListGetSelectedPos(CloneErrorLookup[cloneindex].EAlist[axis][ADDER][geomtype],&pos_list,&pos_count);
    }

  if(pos_count!=1)
    {
      
      return;
    }
  
  SAC = pos_list[0] -1;
      

  if(MdlNames2[SAC].count<0)
    {
      long_type = 1;
    }
  else
    {
      long_type = 0;
    }

  

  set_cursor(XtDisplay(modelhead),XtWindow(modelhead),WATCH);
  set_cursor(mydisplay,mywindow,WATCH);



  if(
     ((clonenum==0) && (     ErrorLookup[errnum]    .DO_EDCS_COMBO[axis][ADDER][geomtype]==0))  ||
     ((clonenum>0)  && (CloneErrorLookup[cloneindex].DO_EDCS_COMBO[axis][ADDER][geomtype]==0))
     )
    {
      if(long_type==1)
	{
	  new_items = (XmString *) (malloc(sizeof(XmString *) * LLFidTableCount));
	  if(new_items==NULL){printf("new_items: out of allocation memory!\n"); ExitWrapper(-1);}

	  numattributes = BuildLongAttrValList(-1,MdlNames2[SAC].code,new_items,1,0);
	  if(numattributes<0)
	    {
	      free(new_items);
	      set_cursor(XtDisplay(modelhead),XtWindow(modelhead),ARROW);
	      set_cursor(mydisplay,mywindow,GOOD);
	      return;
	    }
	}
      else
	{
	  nonunique = 0;
	  
	  
	  new_items = (XmString *) (malloc(sizeof(XmString *) * MdlNames2[SAC].count));
	  if(new_items==NULL){printf("new_items: out of allocation memory!\n"); ExitWrapper(-1);}
	  
	  for(i=0;i<MdlNames2[SAC].count;i++)
	    {
	      
	      if(MdlNames2[SAC].values[i].uniqueoccurrences > 0)
		{
		  if(MdlNames2[SAC].values[i].type==0)
		    {
		      if(NGA_TYPE==1)
			{
			  sprintf(temp,"Value: %d %s",
				  (int)MdlNames2[SAC].values[i].value,
				  PadNumber(2,0,MdlNames2[SAC].values[i].uniqueoccurrences)
				  );
			}
		      else
			{
			  sprintf(temp,"Value: %d %s Scale: %s Units: %s",
				  (int)MdlNames2[SAC].values[i].value,
				  PadNumber(2,0,MdlNames2[SAC].values[i].uniqueoccurrences),
				  GetScaleLabel(MdlNames2[SAC].values[i].scale),
				  GetUnitsLabel(MdlNames2[SAC].values[i].uom)
				  );
			}
		    }
		  else if(MdlNames2[SAC].values[i].type==1)
		    {
		      if(NGA_TYPE==1)
			{
			  sprintf(temp,"Value: %lf %s",
				  MdlNames2[SAC].values[i].value,
				  PadNumber(2,0,MdlNames2[SAC].values[i].uniqueoccurrences)
				  );
			}
		      else
			{
			  sprintf(temp,"Value: %lf %s Scale: %s Units: %s",
				  MdlNames2[SAC].values[i].value,
				  PadNumber(2,0,MdlNames2[SAC].values[i].uniqueoccurrences),
				  GetScaleLabel(MdlNames2[SAC].values[i].scale),
				  GetUnitsLabel(MdlNames2[SAC].values[i].uom)
				  );
			}
		    }
		  else if(MdlNames2[SAC].values[i].type==2)
		    {
		      sprintf(temp,"Value: %s %s",
			      MdlNames2[SAC].values[i].label,
			      PadNumber(2,0,MdlNames2[SAC].values[i].uniqueoccurrences)
			      );
		      
		    }
		  else if(MdlNames2[SAC].values[i].type==3)
		    {
		      sprintf(temp,"Value: %s %s",
			      GetEELabel(MdlNames2[SAC].code,
					 (int)MdlNames2[SAC].values[i].value),
			      PadNumber(2,0,MdlNames2[SAC].values[i].uniqueoccurrences)	 
			      );
		      
		      
		    }
		  else if(MdlNames2[SAC].values[i].type==4)
		    {
		      sprintf(temp,"Value: %s %s",
			      GetEMLabel((int)MdlNames2[SAC].values[i].value),
			      PadNumber(2,0,MdlNames2[SAC].values[i].uniqueoccurrences)	 
			      );
		    }	  
		  else if (MdlNames2[SAC].values[i].type==5) 		 
		    {
		      sprintf(temp,"Value: %c%lf-%lf%c %s Scale: %s Units: %s",
			      GetOpen(MdlNames2[SAC].values[i].intervaltype),
			      MdlNames2[SAC].values[i].value,
			      MdlNames2[SAC].values[i].value2,
			      GetClose(MdlNames2[SAC].values[i].intervaltype),
			      PadNumber(2,0,MdlNames2[SAC].values[i].uniqueoccurrences),
			      GetScaleLabel(MdlNames2[SAC].values[i].scale),
			      GetUnitsLabel(MdlNames2[SAC].values[i].uom)
			      );
		    }
		  else if(
			  (MdlNames2[SAC].values[i].type==6) ||
			  (MdlNames2[SAC].values[i].type==7) 
			  )
		    {
		      sprintf(temp,"Value: %c%d-%d%c %s Scale: %s Units: %s",
			      GetOpen(MdlNames2[SAC].values[i].intervaltype),
			      (int)MdlNames2[SAC].values[i].value,
			      (int)MdlNames2[SAC].values[i].value2,
			      GetClose(MdlNames2[SAC].values[i].intervaltype),
			      PadNumber(2,0,MdlNames2[SAC].values[i].uniqueoccurrences),
			      GetScaleLabel(MdlNames2[SAC].values[i].scale),
			      GetUnitsLabel(MdlNames2[SAC].values[i].uom)
			      );
		    }
		  else
		    {
		      printf("bad type at %d\n",MdlNames2[SAC].values[i].type);
		    }
		  new_items[i-nonunique] = XmStringCreateLocalized (temp);
		}
	      else
		{
		  nonunique = nonunique + 1;
		}
	    }
	  numattributes = MdlNames2[SAC].count - nonunique;
	}
    }
  else
    {
      
      
      if(clonenum==0)
	{
	  XmListGetSelectedPos(ErrorLookup[errnum].list_w[axis][ADDER][geomtype],&pos_list,&pos_count);
	}
      else
	{
	  XmListGetSelectedPos(CloneErrorLookup[cloneindex].list_w[axis][ADDER][geomtype],&pos_list,&pos_count);
	}

      if(pos_count!=1)
	{
	  if(NGA_TYPE==1)
	    {
	  not_while_running(w,"With \"Locate COMBINATIONS of features and attributes\"\n\
selected, you must select an item from the Feature Type\n\
list before you can select attributes in the attribute list.",1274,"Illegal Manuever",1);
	    }
	  else
	    {
	  not_while_running(w,"With \"Locate COMBINATIONS of classification and attributes\"\n\
selected, you must select an item from the classification\n\
list before you can select attributes in the attribute list.",1274,"Illegal Manuever",1);
	    }

	  set_cursor(XtDisplay(modelhead),XtWindow(modelhead),ARROW);
	  set_cursor(mydisplay,mywindow,GOOD);
	  return;
	}



      
      
      
      
      if((NGA_TYPE==1)&&(geomtype>0)) 
	{	  
	  
	  
	  
	  
	  i = 0;
	  
	  checkindex = 0;
	  
	  
	  
	  
	  for (j = 0; j < NumberOfModels ; j++)
	    {
	      if(
		 ((geomtype==C_AREA)&&(!strcmp(MdlNames[j].name,"(AREA)")))  ||
		 ((geomtype==C_LINE)&&(!strcmp(MdlNames[j].name,"(LINE)")))  ||
		 ((geomtype==C_POFE)&&(!strcmp(MdlNames[j].name,"(POINT)"))) ||
		 ((geomtype==C_GRID)&&(!strcmp(MdlNames[j].name,"(GRID)")))
		 )
		{
		  if(checkindex==pos_list[i]-1)
		    {
		      
		      
		      
		      pos_list[i] = j+1; 
		      
		      break;
		    }
		  
		  checkindex = checkindex + 1;
		}
	    }
	}
    
      SCC = pos_list[0] -1;

    




    
      
      
      
      
      num_ee = GetEECount(SCC,SAC, errnum, axis, ADDER);

      if(num_ee==0)
	{
	  


	  new_items = (XmString *) (malloc(sizeof(XmString *) * LLFidTableCount));
	  if(new_items==NULL){printf("new_items: out of allocation memory!\n"); ExitWrapper(-1);}
	  
	  numattributes = BuildLongAttrValList(SCC,GetCode(SCC,SAC),new_items,1,0);
	  if(numattributes<0)
	    {
	      free(new_items);
	      set_cursor(XtDisplay(modelhead),XtWindow(modelhead),ARROW);
	      set_cursor(mydisplay,mywindow,GOOD);
	      return;
	    }
	}
      else
	{
	  
	  new_items = (XmString *) (malloc(sizeof(XmString *) * num_ee));
	  if(new_items==NULL){printf("new_items: out of allocation memory!\n"); ExitWrapper(-1);}
	  
	  
	  for(i=0;i<num_ee;i++)
	    {
	      
	      
	      
	      GetEDCSInfo(SCC,SAC,i, errnum, axis, ADDER);
	      
	      if(i>0)
		{
		  do_long_way = 0;
		}
	      
	      
	      type_found = edcsstruct.type;
	      
	      if(type_found==0)
		{
		  if(NGA_TYPE==1)
		    {
		      sprintf(temp,"Value: %d %s",
			      (int)        edcsstruct.value,
			      PadNumber    (1,edcsstruct.count,0.0)
			      );
		    }
		  else
		    {
		      sprintf(temp,"Value: %d %s Scale: %s Units: %s",
			      (int)        edcsstruct.value,
			      PadNumber    (1,edcsstruct.count,0.0),
			      GetScaleLabel(edcsstruct.scale),
			      GetUnitsLabel(edcsstruct.uom)
			      );
		    }
		}
	      else if(type_found==1)
		{
		  if(NGA_TYPE==1)
		    {
		      sprintf(temp,"Value: %lf %s",
			      edcsstruct.value,
			      PadNumber(1,edcsstruct.count,0.0)
			      );
		    }
		  else
		    {
		      sprintf(temp,"Value: %lf %s Scale: %s Units: %s",
			      edcsstruct.value,
			      PadNumber(1,edcsstruct.count,0.0),
			      GetScaleLabel(edcsstruct.scale),
			      GetUnitsLabel(edcsstruct.uom)
			      );
		    }
		}
	      else if(type_found==2)
		{
		  sprintf(temp,"Value: %s %s",
			  edcsstruct.label,
			  PadNumber(1,edcsstruct.count,0.0)
			  );
		}
	      else if(type_found==3)
		{
		  sprintf(temp,"Value: %s %s",
			  GetEELabel(GetCode(SCC,SAC),
				     (int)edcsstruct.value),
			  PadNumber(1,edcsstruct.count,0.0)
			  );
		}
	      else if(type_found==4)
		{
		  sprintf(temp,"Value: %s %s",
			  GetEMLabel((int)edcsstruct.value),
			  PadNumber(1,edcsstruct.count,0.0)
			  );
		}
	      else if(
		      (type_found==5)||
		      (type_found==6)||
		      (type_found==7)
		      )
		{
		  sprintf(temp,"Value: %s %s",
			  GetIntervalValue(),
			  PadNumber(1,edcsstruct.count,0.0)
			  );
		}
	      
	      
	      new_items[i] = XmStringCreateLocalized (temp);
	    }
	  do_long_way = 1;
	  
	  numattributes = num_ee;

	}
    }


  
  

  if(clonenum==0)
    {
      XtVaSetValues (ErrorLookup[errnum].EAVlist[axis][ADDER][geomtype],
		     XmNitems,             new_items,
		     XmNitemCount,         numattributes,
		     NULL);
      
      sprintf(temp,"(%d definitions):",numattributes);
      XtVaSetValues(ErrorLookup[errnum].EAstring2,XmNlabelString,     STRING(temp),NULL);
      
      XmListDeselectAllItems(ErrorLookup[errnum].EAVlist[axis][ADDER][geomtype]);
    }
  else
    {
      XtVaSetValues (CloneErrorLookup[cloneindex].EAVlist[axis][ADDER][geomtype],
		     XmNitems,             new_items,
		     XmNitemCount,         numattributes,
		     NULL);
      
      sprintf(temp,"(%d definitions):",numattributes);
      XtVaSetValues(CloneErrorLookup[cloneindex].EAstring2,XmNlabelString,     STRING(temp),NULL);
      
      XmListDeselectAllItems(CloneErrorLookup[cloneindex].EAVlist[axis][ADDER][geomtype]);
    }

  for (i=0;i<numattributes;i++)
    {
      XmStringFree (new_items[i]);
    }     
  free(new_items);


  set_cursor(XtDisplay(modelhead),XtWindow(modelhead),ARROW);
  set_cursor(mydisplay,mywindow,GOOD);
}






int MY_MODEL_UP(MyData *mydata, int set)
{
  static int errnum  [100];
  static int axis    [100];
  static int adder   [100];
  static int type    [100];
  static int clonenum[100];
  static int geomtype[100];

  int CLONENUM = mydata->clonenum;
  int ERRNUM   = mydata->check_num;
  int AXIS     = mydata->axis;
  int ADDER    = mydata->ADDER;
  int TYPE     = mydata->type;
  int GEOMTYPE = 0;

  static int index=0;
  int i,j;


  if(NGA_TYPE==1)
    {
      GEOMTYPE = mydata->geomtype;
    }



  if(set==1)
    {
      if(CLONEDEBUG==1)
	{
	  printf("ADDING %d %d %d %d %d\n",CLONENUM,ERRNUM,AXIS,ADDER,TYPE);
	}
      
      clonenum[index] = CLONENUM;
      errnum  [index] = ERRNUM;
      axis    [index] = AXIS;
      adder   [index] = ADDER;
      type    [index] = TYPE;
      geomtype[index] = GEOMTYPE;

      index++;
    }
  else if(set==0)
    {
      if(CLONEDEBUG==1)
	{
	  printf("checking for %d %d %d %d %d\n",CLONENUM,ERRNUM,AXIS,ADDER,TYPE);
	}
      
      for(i=0;i<index;i++)
	{
	  if(
	     (clonenum[i]==CLONENUM) &&
	     (axis    [i]==AXIS)     &&
	     (adder   [i]==ADDER)    &&
	     (type    [i]==TYPE)     &&
	     (errnum  [i]==ERRNUM)   &&
	     (geomtype[i]==GEOMTYPE)
	     )
	    {
	      if(CLONEDEBUG==1)
		{
		  printf("FOUND\n");
		}
	      return 1;
	    }
	}
      if(CLONEDEBUG==1)
	{
	  printf("NOT FOUND\n");
	}
      return 0;
    }
  else if(set==-1)
    {
      if(CLONEDEBUG==1)
	{
	  printf("KILLING %d %d %d %d %d\n",CLONENUM,ERRNUM,AXIS,ADDER,TYPE);
	}

      
      for(i=0;i<index;i++)
	{
	  if(
	     (clonenum[i]==CLONENUM) &&
	     (axis    [i]==AXIS)     &&
	     (adder   [i]==ADDER)    &&
	     (type    [i]==TYPE)     &&
	     (errnum  [i]==ERRNUM)   &&
	     (geomtype[i]==GEOMTYPE)
	     )
	    {
	      for(j=i;j<index-1;j++)
		{
		  clonenum[j] = clonenum[j+1];
		  errnum  [j] = errnum  [j+1];
		  axis    [j] = axis    [j+1];
		  adder   [j] = adder   [j+1];
		  type    [j] = type    [j+1];
		  geomtype[j] = geomtype[j+1];
		}
	      index--;
	      if(CLONEDEBUG==1)
		{
		  printf("KILLED\n");
		}
	      return 1;
	    }
	}
      return 0;
    }
  return 1;
}






void ModelButtonCallback(Widget w,MyData  *myolddata,XtPointer callData, int ADDER)
{
  
  
  int n=0,i,max=0;
  Arg resources[20];
  static Widget viewonlyhead;
  Widget rc,Done,form,label1,button,tog;
  XmString *model_names,*model_names2,*model_names3;
  XmString bignames[1];
  char temp[500];
  struct IMarkList *cfl;
  struct IMarkSACList *cflS;
  int old_model_num,old_sac_num,numsac,SCC,SAC,EEC;
  Dimension y1;
  XmString tempXS;
  XmString *sac_names;
  int errnum,axis,cloneindex,clonenum,geomtype;
  int NumberOfRealModels = 0, insertindex,viewonly;
  char headtxt[1000],tttemp[1000];
  MyData *mydata;
  extern char GetOpen(int i);
  extern char GetClose(int i);



  mydata  = (MyData *) (malloc(sizeof(MyData)));
  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
  
  if(myolddata==NULL)
    {
      
      viewonly = 1;
      mydata->check_num = 0;
      mydata->axis      = 0;
      mydata->ADDER     = 0;
      mydata->viewonly  = 1;
      mydata->clonenum  = 0;
      mydata->type      = 0;
      mydata->geomtype  = 0;
    }
  else
    {
      viewonly = 0;
      mydata->check_num = myolddata->check_num;
      mydata->axis      = myolddata->element;
      mydata->ADDER     = ADDER;
      mydata->viewonly  = 0;
      mydata->clonenum  = myolddata->clonenum;
      mydata->type      = 1;
      mydata->geomtype  = myolddata->geomtype;

      
    }



  
  clonenum = mydata->clonenum;
  errnum   = mydata->check_num;
  axis     = mydata->axis;

  if(NGA_TYPE==1)
    {
      geomtype = mydata->geomtype;
    }
  else
    {
      geomtype = 0;
    }


  if(clonenum > 0)
    {
      cloneindex = GetCloneIndex(clonenum,errnum);
    }



  if(input_source==0)
    {
      if(NGA_TYPE==1)
	{
	  not_while_running(w,"You must open a GAIT project\n\
before you can view By Attribution.",1275,"Illegal Manuever",1);
	}
      else
	{
	  not_while_running(w,"You must select an input data directory\n\
before you can view By Attribution.",1276,"Illegal Manuever",1);
	}

      return;
    }


  if(output_source==0)
    {
      not_while_running(w,"You must select an output file location\n\
before you can view By Attribution.",1277,"Illegal Manuever",1);
      return;
    }


  set_cursor(mydisplay,mywindow,WATCH);

  if((NGA_TYPE==1)&&(geomtype>0))  
    {
      
      
      for (i = 0; i < NumberOfModels ; i++)
	{

	  if(
	     ((geomtype==C_AREA)&&(!strcmp(MdlNames[i].name,"(AREA)")))  ||
	     ((geomtype==C_LINE)&&(!strcmp(MdlNames[i].name,"(LINE)")))  ||
	     ((geomtype==C_POFE)&&(!strcmp(MdlNames[i].name,"(POINT)"))) ||
	     ((geomtype==C_GRID)&&( strstr(MdlNames[i].name,"(GRID)")))
	     )
	    {
	      

	      NumberOfRealModels = NumberOfRealModels + 1;
	    }
	}
    }
  else
    {
      NumberOfRealModels = NumberOfModels;
    }





  model_names =  (XmString *) (malloc(sizeof(XmString *) * NumberOfRealModels));
  if(model_names==NULL){printf("mn1: out of allocation memory!\n"); ExitWrapper(-1);}

  model_names2 = (XmString *) (malloc(sizeof(XmString *) * NumberOfRealModels));
  if(model_names2==NULL){printf("mn2: out of allocation memory!\n"); ExitWrapper(-1);}





  if ( MY_MODEL_UP(mydata,0)==0)
    {

      n=0;
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++;
      
      
      if(mydata->type==1)
	{
	  if(NGA_TYPE==1)
	    {
	      if(ADDER==1)
		{
		  if(IsNetCheck(errnum))
		  {
		    sprintf(headtxt,"INCLUSIONS for network creation, participant %s, geometry %s",
			  ParseAxisName(axis), CNAME[mydata->geomtype]);
		  }
		  else
		  {
		    sprintf(headtxt,"INCLUSIONS for condition %s, participant %s, geometry %s",
			  ParseErrName(errnum),ParseAxisName(axis), CNAME[mydata->geomtype]);
		  }
		}
	      else
		{
		  if(IsNetCheck(errnum))
		  {
		    sprintf(headtxt,"SUBTRACTIONS for network creation, participant %s, geometry %s",
			  ParseAxisName(axis), CNAME[mydata->geomtype]);
		  }
		  else
		  {
		    sprintf(headtxt,"SUBTRACTIONS for condition %s, participant %s, geometry %s",
			  ParseErrName(errnum),ParseAxisName(axis), CNAME[mydata->geomtype]);
		  }
		}
	    }
	  else
	    {
	      if(ADDER==1)
		{
		  sprintf(headtxt,"INCLUSIONS for condition %s, participant %s",
			  ParseErrName(errnum),ParseAxisName(axis));
		}
	      else
		{
		  sprintf(headtxt,"SUBTRACTIONS for condition %s, participant %s",
			  ParseErrName(errnum),ParseAxisName(axis));
		}
	    }
	}
      else
	{
	  sprintf(headtxt,"Attribution Highlighting");
	}


      modelhead = 
	XtCreatePopupShell(headtxt,topLevelShellWidgetClass,w,resources,n);
      
      
      

      rc = XtVaCreateManagedWidget
	(
	 "XformWidget", xmPanedWindowWidgetClass, modelhead,
	 XmNrubberPositioning, False,
	 XmNresizable,         True,
	 XmNseparatorOn,       False,
	 XmNsashHeight,        1,
	 NULL
	 );






      form = XtVaCreateWidget ("formola", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   17,
			       XmNpaneMaximum,   17,
			       XmNfractionBase,  100,  
			       NULL);
      
      if(NGA_TYPE==1)
	{
	  if(geomtype>0)
	    {
		  if(NumberOfRealModels==1)
		  {
	        sprintf(temp,"Feature Types (%d Definition of this geometry)",NumberOfRealModels);
		  }
		  else
		  {
	        sprintf(temp,"Feature Types (%d Definitions of this geometry)",NumberOfRealModels);
		  }
	    }
	  else
	    {
		  if(NumberOfRealModels==1)
		  {
	        sprintf(temp,"Feature Types (%d Definition)",NumberOfRealModels);
		  }
		  else
		  {
	        sprintf(temp,"Feature Types (%d Definitions)",NumberOfRealModels);
		  }
	    }
	}
      else
	{
	  if(geomtype>0)
	    {
	      sprintf(temp,"Classifiers (%d Definitions of this geometry)",NumberOfRealModels);
	    }
	  else
	    {
	      sprintf(temp,"Classifiers (%d Definitions)",NumberOfRealModels);
	    }
	}


      label1 = XtVaCreateManagedWidget (temp,
					xmLabelWidgetClass, form,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,   50,
					XmNleftAttachment,  XmATTACH_FORM,
					XmNalignment,       XmALIGNMENT_CENTER,
					XmNlabelString,     STRING(temp),
					XmNtraversalOn,     False,
					LABELWTRANSLATE,
					NULL);

      if(NGA_TYPE==1)
	{
	  label1 = XtVaCreateManagedWidget ("Selected Feature Types:",
					    xmLabelWidgetClass, form,
					    XmNrightAttachment, XmATTACH_FORM,
					    XmNleftAttachment,  XmATTACH_POSITION,
					    XmNleftPosition,    50,
					    XmNalignment,       XmALIGNMENT_CENTER,
					    XmNlabelString,     STRING("Selected Feature Types:"),
					    XmNtraversalOn,     False,
					    LABELWTRANSLATE,
					    NULL);
	}
      else
	{
	  label1 = XtVaCreateManagedWidget ("Selected classification Items:",
					    xmLabelWidgetClass, form,
					    XmNrightAttachment, XmATTACH_FORM,
					    XmNleftAttachment,  XmATTACH_POSITION,
					    XmNleftPosition,    50,
					    XmNalignment,       XmALIGNMENT_CENTER,
					    XmNlabelString,     STRING("Selected classification items:"),
					    XmNtraversalOn,     False,
					    LABELWTRANSLATE,
					    NULL);
	}

      XtManageChild(form);
      




      insertindex = 0;

      for (i = 0; i < NumberOfModels ; i++)
	{
	  if((NGA_TYPE==1)&&(geomtype>0)) 
	    {
	      if(
		 ((geomtype==C_AREA)&&(!strcmp(MdlNames[i].name,"(AREA)")))  ||
		 ((geomtype==C_LINE)&&(!strcmp(MdlNames[i].name,"(LINE)")))  ||
		 ((geomtype==C_POFE)&&(!strcmp(MdlNames[i].name,"(POINT)"))) ||
		 ((geomtype==C_GRID)&&( strstr(MdlNames[i].name,"(GRID)")))
		 )
		{
		  sprintf(temp,"%s: %s %s (%.0lf)                                          ",
			  GetECCCode(MdlNames[i].code),
			  GetECCLabel(MdlNames[i].code),
			  MdlNames[i].name,
			  MdlNames[i].occurrences);		  
		  
		  model_names[insertindex] = XmStringCreate(temp,"mytag1");
		  if((int)(strlen(temp))>max){max=strlen(temp);}
		  
		  insertindex = insertindex + 1;
		}
	    }
	  else if(geomtype==0)
	    {
	      if(NGA_TYPE==1)
		{
		  sprintf(temp,"%s: %s %s (%.0lf)                                           ",
			  GetECCCode(MdlNames[i].code),
			  GetECCLabel(MdlNames[i].code),
			  MdlNames[i].name,
			  MdlNames[i].occurrences);		  
		}
	      else
		{
		  sprintf(temp,"%s %s (%.0lf)                                               ",
			  GetECCLabel(MdlNames[i].code),
			  MdlNames[i].name,
			  MdlNames[i].occurrences);		  
		}


	      model_names[insertindex] = XmStringCreate(temp,"mytag1");
	      if((int)(strlen(temp))>max){max=strlen(temp);}
	      
	      insertindex = insertindex + 1;
	    }
	  else
	    {
	      if(NGA_TYPE==1)
		{
		  sprintf(temp,"%s: %s %s (%.0lf)",
			  GetECCCode (MdlNames[i].code),
			  GetECCLabel(MdlNames[i].code),
			  MdlNames[i].name,
			  MdlNames[i].occurrences);
		}
	      else
		{
		  sprintf(temp,"%s %s (%.0lf)",
			  GetECCLabel(MdlNames[i].code),
			  MdlNames[i].name,
			  MdlNames[i].occurrences);
		}

	      model_names[insertindex] = XmStringCreate(temp,"mytag1");
	      if((int)(strlen(temp))>max){max=strlen(temp);}
	      
	      insertindex = insertindex + 1;
	    }
	}
      





      for(i=0;i<max;i++)
	{		 
	  temp[i]=' ';
	}
      temp[i]='\0';
      
      form = XtVaCreateWidget ("formola", xmFormWidgetClass, rc,
			       			       XmNfractionBase,  100,  
			       NULL);
      n=0;
      XtSetArg(resources[n],  XmNlistSizePolicy,   XmCONSTANT);        n++;
      XtSetArg(resources[n],  XmNvisibleItemCount, 10);                n++;






      if(clonenum==0)
	{
	  if(ErrorLookup[errnum].DO_EDCS_COMBO[axis][ADDER][geomtype]==0)
	    {
	      XtSetArg(resources[n],  XmNselectionPolicy,   XmEXTENDED_SELECT); n++;
	      XtSetArg(resources[n],  XmNleftAttachment,    XmATTACH_FORM);     n++;
	      XtSetArg(resources[n],  XmNrightAttachment,   XmATTACH_POSITION); n++;
	      XtSetArg(resources[n],  XmNrightPosition,     47);                n++;
	      XtSetArg(resources[n],  XmNtopAttachment,     XmATTACH_FORM);     n++;
	      XtSetArg(resources[n],  XmNbottomAttachment,  XmATTACH_FORM);     n++;
	      XtSetArg(resources[n],  XmNtraversalOn,       True);              n++;
	      XtSetArg(resources[n],  XmNeditable,          False);             n++;
          XtSetArg(resources[n],  XmNtranslations,      XtParseTranslationTable (list_translations16)); n++;
	    }
	  else
	    {
	      XtSetArg(resources[n],  XmNselectionPolicy,   XmSINGLE_SELECT);   n++;
	      XtSetArg(resources[n],  XmNleftAttachment,    XmATTACH_FORM);     n++;
	      XtSetArg(resources[n],  XmNrightAttachment,   XmATTACH_POSITION); n++;
	      XtSetArg(resources[n],  XmNrightPosition,     47);                n++;
	      XtSetArg(resources[n],  XmNtopAttachment,     XmATTACH_FORM);     n++;
	      XtSetArg(resources[n],  XmNbottomAttachment,  XmATTACH_FORM);     n++;
	      XtSetArg(resources[n],  XmNtraversalOn,       True);              n++;
	      XtSetArg(resources[n],  XmNtranslations,      XtParseTranslationTable (list_translations62)); n++;
	    }


	  ErrorLookup[errnum].list_w[axis][ADDER][geomtype]  = XmCreateScrolledList (form, "list",resources,n);


	  XtManageChild (ErrorLookup[errnum].list_w[axis][ADDER][geomtype]);

	  XtAddCallback (ErrorLookup[errnum].list_w[axis][ADDER][geomtype], XmNsingleSelectionCallback,   
			 (XtCallbackProc)choose_specific_model,
			 mydata);


	  for (i = 0; i <  NumberOfRealModels; i++)
	    {
	      sprintf(tttemp,"%s                                                         ",temp);
	      model_names2[i] = XmStringCreate(tttemp,"mytag1");
	    }     
	  
	  old_model_num=ErrorLookup[errnum].model_index[axis][ADDER][geomtype];       
	  ErrorLookup[errnum].model_index[axis][ADDER][geomtype] = 0;
	  
	  
	  old_sac_num=ErrorLookup[errnum].sac_index[axis][ADDER][geomtype];       
	  ErrorLookup[errnum].sac_index[axis][ADDER][geomtype] = 0;
	  

	  if(ErrorLookup[errnum].IMarkRoot[axis][ADDER][geomtype]!=NULL)
	    {
	      cfl = ErrorLookup[errnum].IMarkRoot[axis][ADDER][geomtype];
	      
	      while(cfl!=NULL)
		{
		  if(NGA_TYPE==1)
		    {
		      sprintf(temp,"%s: %s %s (%.0lf)",
			      GetECCCode(MdlNames[cfl->origSCCindex].code),
			      GetECCLabel(MdlNames[cfl->origSCCindex].code),
			      MdlNames[cfl->origSCCindex].name,
			      MdlNames[cfl->origSCCindex].occurrences);
		    }
		  else
		    {
		      sprintf(temp,"%s %s (%.0lf)",
			      GetECCLabel(MdlNames[cfl->origSCCindex].code),
			      MdlNames[cfl->origSCCindex].name,
			      MdlNames[cfl->origSCCindex].occurrences);
		    }

		  model_names2[old_model_num-ErrorLookup[errnum].model_index[axis][ADDER][geomtype]-1] = 
		    XmStringCreate(temp,"mytag1");
		  ErrorLookup[errnum].model_index[axis][ADDER][geomtype]++;
		  
		  cfl=cfl->next;
		}
	    }
	  
	  
	  numsac=0;
	  if(ErrorLookup[errnum].IMarkSACRoot[axis][ADDER][geomtype]!=NULL)
	    {
	      cflS = ErrorLookup[errnum].IMarkSACRoot[axis][ADDER][geomtype];
	      while(cflS!=NULL)
		{
		  numsac++;
		  cflS = cflS->next;
		}
	    }
	}
      else
	{
	  if(CloneErrorLookup[cloneindex].DO_EDCS_COMBO[axis][ADDER][geomtype]==0)
	  { 
	    XtSetArg(resources[n],  XmNselectionPolicy,  XmEXTENDED_SELECT);                             n++;
        XtSetArg(resources[n],  XmNtranslations,     XtParseTranslationTable (list_translations16)); n++;
	  }
	  else
	  { 
	    XtSetArg(resources[n],  XmNselectionPolicy,  XmSINGLE_SELECT);                               n++;
        XtSetArg(resources[n],  XmNtranslations,     XtParseTranslationTable (list_translations62)); n++;
	  }
	  
	  XtSetArg(resources[n],  XmNleftAttachment,   XmATTACH_FORM);     n++;
	  XtSetArg(resources[n],  XmNrightAttachment,  XmATTACH_POSITION); n++;
	  XtSetArg(resources[n],  XmNrightPosition,    47);                n++;
	  XtSetArg(resources[n],  XmNtopAttachment,    XmATTACH_FORM);     n++;
	  XtSetArg(resources[n],  XmNbottomAttachment, XmATTACH_FORM);     n++;
	  XtSetArg(resources[n],  XmNtraversalOn,      True);              n++;


	  CloneErrorLookup[cloneindex].list_w[axis][ADDER][geomtype]  = XmCreateScrolledList (form, "list",resources,n);
	  
	  
	  XtManageChild (CloneErrorLookup[cloneindex].list_w[axis][ADDER][geomtype]);
	  

	  XtAddCallback (CloneErrorLookup[cloneindex].list_w[axis][ADDER][geomtype], XmNsingleSelectionCallback,   
			 (XtCallbackProc)choose_specific_model,
			 mydata);


	  
	  for (i = 0; i <  NumberOfRealModels; i++)
	    {
	      model_names2[i] = XmStringCreate(temp,"mytag1");
	    }     
	  
	  old_model_num=CloneErrorLookup[cloneindex].model_index[axis][ADDER][geomtype];       
	  CloneErrorLookup[cloneindex].model_index[axis][ADDER][geomtype] = 0;
	  
	  
	  old_sac_num=CloneErrorLookup[cloneindex].sac_index[axis][ADDER][geomtype];       
	  CloneErrorLookup[cloneindex].sac_index[axis][ADDER][geomtype] = 0;
	  
	  if(CloneErrorLookup[cloneindex].IMarkRoot[axis][ADDER][geomtype]!=NULL)
	    {
	      cfl = CloneErrorLookup[cloneindex].IMarkRoot[axis][ADDER][geomtype];

	      while(cfl!=NULL)
		{
		  if(NGA_TYPE==1)
		    {
		      sprintf(temp,"%s: %s %s (%.0lf)",
			      GetECCCode(MdlNames[cfl->origSCCindex].code),
			      GetECCLabel(MdlNames[cfl->origSCCindex].code),
			      MdlNames[cfl->origSCCindex].name,
			      MdlNames[cfl->origSCCindex].occurrences);
		    }
		  else
		    {
		      sprintf(temp,"%s %s (%.0lf)",
			      GetECCLabel(MdlNames[cfl->origSCCindex].code),
			      MdlNames[cfl->origSCCindex].name,
			      MdlNames[cfl->origSCCindex].occurrences);
		    }
		  model_names2[old_model_num-CloneErrorLookup[cloneindex].model_index[axis][ADDER][geomtype]-1] = 
		    XmStringCreate(temp,"mytag1");
		  CloneErrorLookup[cloneindex].model_index[axis][ADDER][geomtype]++;
		  
		  cfl=cfl->next;
		}
	    }
	  
	  
	  numsac=0;
	  if(CloneErrorLookup[cloneindex].IMarkSACRoot[axis][ADDER][geomtype]!=NULL)
	    {
	      cflS = CloneErrorLookup[cloneindex].IMarkSACRoot[axis][ADDER][geomtype];
	      while(cflS!=NULL)
		{
		  numsac++;
		  cflS = cflS->next;
		}
	    }
	}	



      model_names3 = (XmString *) (malloc(sizeof(XmString *) * numsac));
      if(model_names3==NULL){printf("mn2: out of allocation memory!\n"); ExitWrapper(-1);}



      
      if(
	 ((clonenum==0) && (ErrorLookup[errnum].IMarkSACRoot[axis][ADDER][geomtype]!=NULL))  ||
	 ((clonenum>0) &&  (CloneErrorLookup[cloneindex].IMarkSACRoot[axis][ADDER][geomtype]!=NULL)) 
	 )	
	{

	  if(clonenum==0)
	    {
	      cflS = ErrorLookup[errnum].IMarkSACRoot[axis][ADDER][geomtype];
	    }
	  else
	    {
	      cflS = CloneErrorLookup[cloneindex].IMarkSACRoot[axis][ADDER][geomtype];
	    }



	  while(cflS!=NULL)
	    {
	      SCC = cflS->SCCindex; 
	      SAC = cflS->SACindex; 
	      EEC = cflS->EEindex;

	      
	      if(SCC==-1)  
		{
		  if(EEC==-1)
		    {
		      if(NGA_TYPE==1)
			{
			  sprintf(temp,"ALL values for Attribute %s: %s",
				  GetEACCode(MdlNames2[SAC].code),
				  GetEACLabel(MdlNames2[SAC].code));
			}
		      else
			{
			  sprintf(temp,"ALL values for EA %s",
				  GetEACLabel(MdlNames2[SAC].code));
			}
		    }
		  else if(EEC==-2)
		    {
		      if(NGA_TYPE==1)
			{
			  sprintf(temp,"Attribute %s: %s, value %s",
				  GetEACCode(MdlNames2[SAC].code),
				  GetEACLabel(MdlNames2[SAC].code),
				  cflS->saveval);
			}
		      else
			{
			  sprintf(temp,"EA %s, value %s",
				  GetEACLabel(MdlNames2[SAC].code),
				  cflS->saveval);
			}
		    }

		  else if(MdlNames2[SAC].values[EEC].type==0)
		    {
		      if(NGA_TYPE==1)
			{
			  sprintf(temp,"Attribute %s: %s, value %d",
				  GetEACCode(MdlNames2[SAC].code),
				  GetEACLabel(MdlNames2[SAC].code),
				  (int)MdlNames2[SAC].values[EEC].value
				  );
			}
		      else
			{
			  sprintf(temp,"EA %s, value %d",
				  GetEACLabel(MdlNames2[SAC].code),
				  (int)MdlNames2[SAC].values[EEC].value
				  );
			}
		    }
		  else if(MdlNames2[SAC].values[EEC].type==1)
		    {
		      if(NGA_TYPE==1)
			{
			  sprintf(temp,"Attribute %s: %s, value %lf",
				  GetEACCode(MdlNames2[SAC].code),
				  GetEACLabel(MdlNames2[SAC].code),
				  MdlNames2[SAC].values[EEC].value
				  );
			}
		      else
			{
			  sprintf(temp,"EA %s, value %lf",
				  GetEACLabel(MdlNames2[SAC].code),
				  MdlNames2[SAC].values[EEC].value
				  );
			}
		    }
		  else if(MdlNames2[SAC].values[EEC].type==2)
		    {
		      if(NGA_TYPE==1)
			{
			  sprintf(temp,"Attribute %s: %s, value %s",
				  GetEACCode(MdlNames2[SAC].code),
				  GetEACLabel(MdlNames2[SAC].code),
				  MdlNames2[SAC].values[EEC].label
				  );
			}
		      else
			{
			  sprintf(temp,"EA %s, value %s",
				  GetEACLabel(MdlNames2[SAC].code),
				  MdlNames2[SAC].values[EEC].label
				  );
			}
		    }
		  else if(MdlNames2[SAC].values[EEC].type==3)
		    {
		      if(NGA_TYPE==1)
			{
			  sprintf(temp,"Attribute %s: %s, value %s",
				  GetEACCode(MdlNames2[SAC].code),
				  GetEACLabel(MdlNames2[SAC].code),
				  GetEELabel(MdlNames2[SAC].code,
					     (int)MdlNames2[SAC].values[EEC].value));
			}
		      else
			{
			  sprintf(temp,"EA %s, value %s",
				  GetEACLabel(MdlNames2[SAC].code),
				  GetEELabel(MdlNames2[SAC].code,
					     (int)MdlNames2[SAC].values[EEC].value));
			}
		    }
		  else if(MdlNames2[SAC].values[EEC].type==4)
		    {
		      if(NGA_TYPE==1)
			{
			  printf("shouldnt be here 1\n");
			}
		      else
			{
			  sprintf(temp,"EA %s, value %s",
				  GetEACLabel(MdlNames2[SAC].code),
				  GetEMLabel((int)MdlNames2[SAC].values[EEC].value));
			}
		    }
		  else if(MdlNames2[SAC].values[EEC].type==5)
		    {
		      if(NGA_TYPE==1)
			{
			  printf("shouldnt be here 2\n");
			}
		      else
			{
			  sprintf(temp,"EA %s, value: %c%lf-%lf%c",
				  GetEACLabel(MdlNames2[SAC].code),
				  GetOpen(MdlNames2[SAC].values[EEC].intervaltype),
				  MdlNames2[SAC].values[EEC].value,
				  MdlNames2[SAC].values[EEC].value2,
				  GetClose(MdlNames2[SAC].values[EEC].intervaltype)
				  );
			}
		    }
		  else if(
			  (MdlNames2[SAC].values[EEC].type==6) ||
			  (MdlNames2[SAC].values[EEC].type==7)
			  )
		    {
		      if(NGA_TYPE==1)
			{
			  printf("shouldnt be here 3\n");
			}
		      else
			{
			  sprintf(temp,"EA %s, value: %c%d-%d%c",
				  GetEACLabel(MdlNames2[SAC].code),
				  GetOpen(MdlNames2[SAC].values[EEC].intervaltype),
				  (int)MdlNames2[SAC].values[EEC].value,
				  (int)MdlNames2[SAC].values[EEC].value2,
				  GetClose(MdlNames2[SAC].values[EEC].intervaltype)
			      );
			}
		    }
		  else
		    {
		      printf("bad type on MdlNames2[%d].values[%d].type = %d\n",
			     SAC,EEC,MdlNames2[SAC].values[EEC].type);
			  set_cursor(mydisplay,mywindow,GOOD);
		      return;
		    } 
		}
	      else
		{
		
		  GetEDCSInfo(SCC,SAC,EEC, errnum, axis, ADDER);
		  
		  
		  if(EEC==-1)
		    {
		      if(NGA_TYPE==1)
			  {
			  sprintf(temp,"ALL values for Classifier %s: %s, Attribute %s: %s",
				  GetECCCode(MdlNames[SCC].code),
				  GetECCLabel(MdlNames[SCC].code),
				  GetEACCode(GetCode(SCC,SAC)),
				  GetEACLabel(GetCode(SCC,SAC)));
			  }
		      else
			  {
			  sprintf(temp,"ALL values for EC %s %s, EA %s",
				  GetECCLabel(MdlNames[SCC].code),
				  MdlNames[SCC].name,
				  GetEACLabel(GetCode(SCC,SAC)));
			  }
		    }
		  else if(EEC==-2)
		   {
		     if(NGA_TYPE==1)
			  {
			    sprintf(temp,"%s: %s: %s",
				  GetECCCode(MdlNames[SCC].code),
				  GetEACCode(GetCode(SCC,SAC)),
				  cflS->saveval);
			  }
		   }
		  else if(edcsstruct.type==0)
		    {
		      if(NGA_TYPE==1)
			{
			  sprintf(temp,"Classifier: %s: %s, Attribute %s: %s, value %d",
				  GetECCCode(MdlNames[SCC].code),
				  GetECCLabel(MdlNames[SCC].code),
				  GetEACCode(GetCode(SCC,SAC)),
				  GetEACLabel(GetCode(SCC,SAC)),
				  (int)edcsstruct.value);
			}
		      else
			{
			  sprintf(temp,"EC: %s %s, EA %s, value %d",
				  GetECCLabel(MdlNames[SCC].code),
				  MdlNames[SCC].name,
				  GetEACLabel(GetCode(SCC,SAC)),
				  (int)edcsstruct.value);
			}
		    }
		  else if(edcsstruct.type==1)
		    {
		      if(NGA_TYPE==1)
			{
			  sprintf(temp,"Classifier: %s: %s, Attribute %s: %s, value %lf",
				  GetECCCode(MdlNames[SCC].code),
				  GetECCLabel(MdlNames[SCC].code),
				  GetEACCode(GetCode(SCC,SAC)),
				  GetEACLabel(GetCode(SCC,SAC)),
				  edcsstruct.value);
			}
		      else
			{
			  sprintf(temp,"EC: %s %s, EA %s, value %lf",
				  GetECCLabel(MdlNames[SCC].code),
				  MdlNames[SCC].name,
				  GetEACLabel(GetCode(SCC,SAC)),
				  edcsstruct.value);
			}
		    }
		  else if(edcsstruct.type==2)
		    {
		      if(NGA_TYPE==1)
			{
			  sprintf(temp,"Classifier: %s: %s, Attribute %s: %s, value %s",
				  GetECCCode (MdlNames[SCC].code),
				  GetECCLabel(MdlNames[SCC].code),
				  GetEACCode (GetCode(SCC,SAC)),
				  GetEACLabel(GetCode(SCC,SAC)),
				  edcsstruct.label);
			}
		      else
			{
			  sprintf(temp,"EC: %s %s, EA %s, value %s",
				  GetECCLabel(MdlNames[SCC].code),
				  MdlNames[SCC].name,
				  GetEACLabel(GetCode(SCC,SAC)),
				  edcsstruct.label);
			}
		    }
		  else if(edcsstruct.type==3)
		    {
		      if(NGA_TYPE==1)
			{
			  sprintf(temp,"Classifier: %s: %s, Attribute %s: %s, value %s",
				  GetECCCode(MdlNames[SCC].code),
				  GetECCLabel(MdlNames[SCC].code),
				  GetEACCode(GetCode(SCC,SAC)),
				  GetEACLabel(GetCode(SCC,SAC)),
				  GetEELabel(GetCode(SCC,SAC),
					     (int)edcsstruct.value));
			}
		      else
			{
			  sprintf(temp,"EC: %s %s, EA %s, value %s",
				  GetECCLabel(MdlNames[SCC].code),
				  MdlNames[SCC].name,
				  GetEACLabel(GetCode(SCC,SAC)),
				  GetEELabel(GetCode(SCC,SAC),
					     (int)edcsstruct.value));
			}
		    }
		  else if(edcsstruct.type==4)
		    {
		      if(NGA_TYPE==1)
			{
			  printf("shouldne be here EM\n");
			}
		      else
			{
			  sprintf(temp,"EC: %s %s, EA %s, value %s",
				  GetECCLabel(MdlNames[SCC].code),
				  MdlNames[SCC].name,
				  GetEACLabel(GetCode(SCC,SAC)),
				  GetEMLabel((int)edcsstruct.value)
				  );
			}
		    }

		  else if(
			  (edcsstruct.type==5) ||
			  (edcsstruct.type==6) ||
			  (edcsstruct.type==7)
			  )
		    {
		      if(NGA_TYPE==1)
			{
			  printf("shouldne be here INT\n");
			}
		      else
			{
			  sprintf(temp,"EC: %s %s, EA %s, value %s",
				  GetECCLabel(MdlNames[SCC].code),
				  MdlNames[SCC].name,
				  GetEACLabel(GetCode(SCC,SAC)),
				  GetIntervalValue()
				  );
			}
		    }
		  else
		    {
		      printf("I: bad type on MdlNames[%d].attributes[%d].values[%d].type = %d\n",
			     SCC, SAC, EEC,edcsstruct.type);
			  set_cursor(mydisplay,mywindow,GOOD);
		      return;
		    }
		}

	      if(clonenum==0)
		{
		  model_names3[old_sac_num-ErrorLookup[errnum].sac_index[axis][ADDER][geomtype]-1] = XmStringCreate(temp,"mytag1");
		  ErrorLookup[errnum].sac_index[axis][ADDER][geomtype]++;
		}
	      else
		{
		  model_names3[old_sac_num-CloneErrorLookup[cloneindex].sac_index[axis][ADDER][geomtype]-1] = 
		    XmStringCreate(temp,"mytag1");
		  CloneErrorLookup[cloneindex].sac_index[axis][ADDER][geomtype]++;
		}

	      cflS=cflS->next;
	    }
	}
    



      button = XtVaCreateManagedWidget ("arrow1",
					xmArrowButtonWidgetClass, form,
					XmNarrowDirection,    XmARROW_RIGHT,
					XmNleftAttachment,    XmATTACH_POSITION,
					XmNleftPosition,      47,
					XmNrightAttachment,   XmATTACH_POSITION,
					XmNrightPosition,     53,
					XmNtopAttachment,     XmATTACH_FORM,
					XmNbottomAttachment,  XmATTACH_FORM,
					XmNtraversalOn,       False,
					NULL);
      
      XtAddCallback (button, XmNactivateCallback, (XtCallbackProc)set_model, 
		     mydata);

      if(XCG==1)
	  { 
	    if(NGA_TYPE==1)
		{ 
          XcgLiteClueAddWidget(ToolTipMaster, button, "Add selected Feature Types to selected list", 0, 0);
		}
	    else
		{
          XcgLiteClueAddWidget(ToolTipMaster, button, "Add selected Classification items to selected list", 0, 0);
		}
	  }

      n=0;
      XtSetArg(resources[n],  XmNlistSizePolicy,   XmCONSTANT);        n++;
      XtSetArg(resources[n],  XmNvisibleItemCount, 10);                n++;
      XtSetArg(resources[n],  XmNselectionPolicy,  XmEXTENDED_SELECT); n++;
      XtSetArg(resources[n],  XmNleftAttachment,   XmATTACH_POSITION); n++;
      XtSetArg(resources[n],  XmNleftPosition,     53);                n++;
      XtSetArg(resources[n],  XmNrightAttachment,  XmATTACH_POSITION); n++;
      XtSetArg(resources[n],  XmNrightPosition,    99);                n++;
      XtSetArg(resources[n],  XmNtopAttachment,    XmATTACH_FORM);     n++;
      XtSetArg(resources[n],  XmNbottomAttachment, XmATTACH_FORM);     n++;
      XtSetArg(resources[n],  XmNtraversalOn,      True);              n++;
      XtSetArg(resources[n],  XmNtranslations,     XtParseTranslationTable (list_translations16)); n++;
	  


      if(clonenum==0)
	{
	  ErrorLookup[errnum].list2_w[axis][ADDER][geomtype] = 
	    XmCreateScrolledList (form, "list", resources,n);	  
	  XtManageChild (ErrorLookup[errnum].list2_w[axis][ADDER][geomtype]);
	}
      else
	{
	  CloneErrorLookup[cloneindex].list2_w[axis][ADDER][geomtype] = 
	    XmCreateScrolledList (form, "list", resources,n);	  
	  XtManageChild (CloneErrorLookup[cloneindex].list2_w[axis][ADDER][geomtype]);
	}




      XtManageChild (form);





      

      form = XtVaCreateWidget ("formola", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   17,
			       XmNpaneMaximum,   17,
			       XmNfractionBase,  100,  
			       NULL);
      
      if(clonenum==0)
	{
	  if(ErrorLookup[errnum].DO_EDCS_COMBO[axis][ADDER][geomtype]==1)
	    {
	      if(NGA_TYPE==1)
		{
		  sprintf(temp,"Attributes for SELECTED Feature Type");
		}
	      else
		{
		  sprintf(temp,"Attributes for SELECTED Classifier");
		}
	    }
	  else
	    {
	      sprintf(temp,"Attributes found");
	    }
	}
      else
	{
	  if(CloneErrorLookup[cloneindex].DO_EDCS_COMBO[axis][ADDER][geomtype]==1)
	    {
	      if(NGA_TYPE==1)
		{
		  sprintf(temp,"Attributes for SELECTED Feature Type");
		}
	      else
		{
		  sprintf(temp,"Attributes for SELECTED Classifier");
		}
	    }
	  else
	    {
	      sprintf(temp,"Attributes found");
	    }
	}
      
	  if(clonenum==0)
	  {
        ErrorLookup[errnum].EAstring3 = XtVaCreateManagedWidget (temp,
					   xmLabelWidgetClass, form,
					   XmNrightAttachment, XmATTACH_POSITION,
					   XmNrightPosition,   34,
					   XmNleftAttachment,  XmATTACH_FORM,
					   XmNalignment,       XmALIGNMENT_CENTER,
					   XmNlabelString,     STRING(temp),
					   XmNtraversalOn,     False,
					   LABELWTRANSLATE,
					   NULL);
      }
	  else
	  {
        CloneErrorLookup[cloneindex].EAstring3 = XtVaCreateManagedWidget (temp,
					   xmLabelWidgetClass, form,
					   XmNrightAttachment, XmATTACH_POSITION,
					   XmNrightPosition,   34,
					   XmNleftAttachment,  XmATTACH_FORM,
					   XmNalignment,       XmALIGNMENT_CENTER,
					   XmNlabelString,     STRING(temp),
					   XmNtraversalOn,     False,
					   LABELWTRANSLATE,
					   NULL);
 	  }


      
      sprintf(temp,"Values for SELECTED attribute");
      
      label1 = XtVaCreateManagedWidget (temp,
					xmLabelWidgetClass, form,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,   62,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    34,
					XmNalignment,       XmALIGNMENT_CENTER,
					XmNlabelString,     STRING(temp),
					XmNtraversalOn,     False,
					LABELWTRANSLATE,
					NULL);
      
      XtManageChild(form);
      


      



      form = XtVaCreateWidget ("formola", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       XmNpaneMinimum,   17,
			       XmNpaneMaximum,   17,
			       NULL);
      
      if(clonenum==0)
	{
	  if(ErrorLookup[errnum].DO_EDCS_COMBO[axis][ADDER][geomtype]==1)
	    {
	      if(NGA_TYPE==1)
		{
		  sprintf(temp,"(No Feature Type selected):");
		}
	      else
		{
		  sprintf(temp,"(No Classifier selected):");
		}
	    }
	  else
	    {
	      sprintf(temp,"(%d definitions found):",NumberOfAttributesEntries);
	    }
	}
      else
	{
	  if(CloneErrorLookup[cloneindex].DO_EDCS_COMBO[axis][ADDER][geomtype]==1)
	    {
	      if(NGA_TYPE==1)
		{
		  sprintf(temp,"(No Feature Type selected):");
		}
	      else
		{
		  sprintf(temp,"(No Classifier selected):");
		}
	    }
	  else
	    {
	      sprintf(temp,"(%d definitions found):",NumberOfAttributesEntries);
	    }
	}


      if(clonenum==0)
	  {
        ErrorLookup[errnum].EAstring1 = XtVaCreateManagedWidget (temp,
					   xmLabelWidgetClass, form,
					   XmNrightAttachment, XmATTACH_POSITION,
					   XmNrightPosition,   31,
					   XmNleftAttachment,  XmATTACH_FORM,
					   XmNalignment,       XmALIGNMENT_CENTER,
					   XmNlabelString,     STRING(temp),
					   XmNtraversalOn,     False,
					   LABELWTRANSLATE,
					   NULL);
      
        ErrorLookup[errnum].EAstring2 = XtVaCreateManagedWidget ("(No attribute selected):",
					   xmLabelWidgetClass, form,
					   XmNrightAttachment, XmATTACH_POSITION,
					   XmNrightPosition,   62,
					   XmNleftAttachment,  XmATTACH_POSITION,
					   XmNleftPosition,    31,
					   XmNalignment,       XmALIGNMENT_CENTER,
					   XmNlabelString,     STRING("(No attribute selected):"),
					   XmNtraversalOn,     False,
					   LABELWTRANSLATE,
					   NULL);
	  }
	  else
	  {
        CloneErrorLookup[cloneindex].EAstring1 = XtVaCreateManagedWidget (temp,
					   xmLabelWidgetClass, form,
					   XmNrightAttachment, XmATTACH_POSITION,
					   XmNrightPosition,   31,
					   XmNleftAttachment,  XmATTACH_FORM,
					   XmNalignment,       XmALIGNMENT_CENTER,
					   XmNlabelString,     STRING(temp),
					   XmNtraversalOn,     False,
					   LABELWTRANSLATE,
					   NULL);
      
        CloneErrorLookup[cloneindex].EAstring2 = XtVaCreateManagedWidget ("(No attribute selected):",
					   xmLabelWidgetClass, form,
					   XmNrightAttachment, XmATTACH_POSITION,
					   XmNrightPosition,   62,
					   XmNleftAttachment,  XmATTACH_POSITION,
					   XmNleftPosition,    31,
					   XmNalignment,       XmALIGNMENT_CENTER,
					   XmNlabelString,     STRING("(No attribute selected):"),
					   XmNtraversalOn,     False,
					   LABELWTRANSLATE,
					   NULL);
      }
      
      label1 = XtVaCreateManagedWidget ("Selected Attribute Items:",
					xmLabelWidgetClass, form,
					XmNrightAttachment, XmATTACH_FORM,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    69,
					XmNalignment,       XmALIGNMENT_CENTER,
					XmNlabelString,     STRING("Selected Attribute Items:"),
					XmNtraversalOn,     False,
					LABELWTRANSLATE,
					NULL);

      XtManageChild(form);
      











      form = XtVaCreateWidget ("formola", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);
      n=0;
      XtSetArg(resources[n],  XmNlistSizePolicy,   XmCONSTANT);        n++;
      XtSetArg(resources[n],  XmNvisibleItemCount, 10);                n++;

      XtSetArg(resources[n],  XmNselectionPolicy,  XmSINGLE_SELECT);   n++;

      XtSetArg(resources[n],  XmNleftAttachment,   XmATTACH_FORM);     n++;
      XtSetArg(resources[n],  XmNrightAttachment,  XmATTACH_POSITION); n++;
      XtSetArg(resources[n],  XmNrightPosition,    31);                n++;
      XtSetArg(resources[n],  XmNtopAttachment,    XmATTACH_FORM);     n++;
      XtSetArg(resources[n],  XmNbottomAttachment, XmATTACH_FORM);     n++;
      XtSetArg(resources[n],  XmNtraversalOn,      True);              n++;
      XtSetArg(resources[n],  XmNtranslations,     XtParseTranslationTable (list_translations62)); n++;



      if(clonenum==0)
	{
	  ErrorLookup[errnum].EAlist[axis][ADDER][geomtype] = XmCreateScrolledList (form, "list",resources,n);
	  XtManageChild (ErrorLookup[errnum].EAlist[axis][ADDER][geomtype]);
	  
	  
	  XtAddCallback (ErrorLookup[errnum].EAlist[axis][ADDER][geomtype], XmNsingleSelectionCallback, 
			 (XtCallbackProc)choose_specific_attribute, mydata);

	}
      else
	{
	  CloneErrorLookup[cloneindex].EAlist[axis][ADDER][geomtype] = XmCreateScrolledList (form, "list",resources,n);
	  XtManageChild (CloneErrorLookup[cloneindex].EAlist[axis][ADDER][geomtype]);
	  
	  
	  XtAddCallback (CloneErrorLookup[cloneindex].EAlist[axis][ADDER][geomtype], XmNsingleSelectionCallback, 
			 (XtCallbackProc)choose_specific_attribute, mydata);
	}


    
      n=0;
      XtSetArg(resources[n],  XmNlistSizePolicy,   XmCONSTANT);        n++;
      XtSetArg(resources[n],  XmNvisibleItemCount, 10);                n++;
      XtSetArg(resources[n],  XmNselectionPolicy,  XmEXTENDED_SELECT); n++;
      XtSetArg(resources[n],  XmNleftAttachment,   XmATTACH_POSITION); n++;
      XtSetArg(resources[n],  XmNleftPosition,     31);                n++;
      XtSetArg(resources[n],  XmNrightAttachment,  XmATTACH_POSITION); n++;
      XtSetArg(resources[n],  XmNrightPosition,    62);                n++;
      XtSetArg(resources[n],  XmNtopAttachment,    XmATTACH_FORM);     n++;
      XtSetArg(resources[n],  XmNbottomAttachment, XmATTACH_FORM);     n++;
      XtSetArg(resources[n],  XmNtraversalOn,      True);              n++;
      XtSetArg(resources[n],  XmNtranslations,     XtParseTranslationTable (list_translations16)); n++;

      if(clonenum==0)
	{
	  ErrorLookup[errnum].EAVlist[axis][ADDER][geomtype] = XmCreateScrolledList (form, "list",resources,n);
	  XtManageChild (ErrorLookup[errnum].EAVlist[axis][ADDER][geomtype]);
	}
      else
	{
	  CloneErrorLookup[cloneindex].EAVlist[axis][ADDER][geomtype] = XmCreateScrolledList (form, "list",resources,n);
	  XtManageChild (CloneErrorLookup[cloneindex].EAVlist[axis][ADDER][geomtype]);
	}


      button = XtVaCreateManagedWidget ("arrow1",
					xmArrowButtonWidgetClass, form,
					XmNarrowDirection,    XmARROW_RIGHT,
					XmNleftAttachment,    XmATTACH_POSITION,
					XmNleftPosition,      62,
					XmNrightAttachment,   XmATTACH_POSITION,
					XmNrightPosition,     69,
					XmNtopAttachment,     XmATTACH_FORM,
					XmNbottomAttachment,  XmATTACH_FORM,
					XmNtraversalOn,       False,
					NULL);
      
      XtAddCallback (button, XmNactivateCallback, (XtCallbackProc)set_sac, mydata);

      if(XCG==1)
	  { 
         XcgLiteClueAddWidget(ToolTipMaster, button, "Add selected attribute items to selected list", 0, 0);
	  } 

      n=0;
      XtSetArg(resources[n],  XmNlistSizePolicy,   XmCONSTANT);        n++;
      XtSetArg(resources[n],  XmNvisibleItemCount, 10);                n++;
      XtSetArg(resources[n],  XmNselectionPolicy,  XmEXTENDED_SELECT); n++;
      XtSetArg(resources[n],  XmNleftAttachment,   XmATTACH_POSITION); n++;
      XtSetArg(resources[n],  XmNleftPosition,     69);                n++;
      XtSetArg(resources[n],  XmNrightAttachment,  XmATTACH_FORM);     n++;
      XtSetArg(resources[n],  XmNtopAttachment,    XmATTACH_FORM);     n++;
      XtSetArg(resources[n],  XmNbottomAttachment, XmATTACH_FORM);     n++;
      XtSetArg(resources[n],  XmNtraversalOn,      True);              n++;
      XtSetArg(resources[n],  XmNtranslations,     XtParseTranslationTable (list_translations16)); n++;
	    
      if(clonenum==0)
	{
	  ErrorLookup[errnum].EASlist[axis][ADDER][geomtype] = XmCreateScrolledList (form, "list", resources,n);
	  XtManageChild (ErrorLookup[errnum].EASlist[axis][ADDER][geomtype]);
	}
      else
	{
	  CloneErrorLookup[cloneindex].EASlist[axis][ADDER][geomtype] = XmCreateScrolledList (form, "list", resources,n);
	  XtManageChild (CloneErrorLookup[cloneindex].EASlist[axis][ADDER][geomtype]);
	}

      XtManageChild (form);


      
      form = XtVaCreateWidget ("form3", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  10,  
			       NULL);
      

      if(NGA_TYPE==1)
       {   
         tempXS = XmStringCreateLtoR ("Locate COMBINATIONS of features and attributes","mytag3");
       }
      else
       {
         tempXS = XmStringCreateLtoR ("Locate COMBINATIONS of classification and attributes","mytag3");
       }

      tog = XtVaCreateManagedWidget ("combo_test",
				     xmToggleButtonWidgetClass, form,
				     XmNtopAttachment,    XmATTACH_FORM,
				     XmNtraversalOn,      False,
				     XmNbottomAttachment, XmATTACH_FORM,
				     XmNalignment,        XmALIGNMENT_BEGINNING,			
				     XmNlabelString,      tempXS,
				     XmNrightPosition,    XmATTACH_FORM,
				     XmNleftAttachment,   XmATTACH_POSITION,
				     XmNleftPosition,     0,
				     TOGGLETRANSLATE,     TOGGLEINCLUDE,
				     NULL);

      XtAddCallback (tog, XmNvalueChangedCallback, (XtCallbackProc)toggle_combo, mydata);


      if((NGA_TYPE==1)&&(geomtype>0))
	 {
	   
	   XtSetSensitive(tog,False);
	 }



      if(clonenum==0)
	{
	  XmToggleButtonSetState(tog,(Boolean)ErrorLookup[errnum].DO_EDCS_COMBO[axis][ADDER][geomtype],(Boolean)0);
	}
      else
	{
	  XmToggleButtonSetState(tog,(Boolean)CloneErrorLookup[cloneindex].DO_EDCS_COMBO[axis][ADDER][geomtype],(Boolean)0);
	}

      XtManageChild(tog);
      XtManageChild(form);

 


       
      form = XtVaCreateWidget ("form3", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
       if(NGA_TYPE==1) 
        {
	  Done  = XtVaCreateManagedWidget("De-SelModels",xmPushButtonWidgetClass,form,
					  XmNleftAttachment,  XmATTACH_FORM,
					  XmNrightAttachment, XmATTACH_POSITION,
					  XmNrightPosition,   50,
					  XmNlabelString,     STRING("Remove Selected Feature Types"),
					  XmNtraversalOn,     False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					  NULL
					  ); 
	  
	  XtAddCallback(Done, XmNactivateCallback, (XtCallbackProc)kill_model, mydata);
	  
	  
	  XtManageChild(Done);
	  
	  Done  = XtVaCreateManagedWidget("DeSelectALLModels",xmPushButtonWidgetClass,form,
					  XmNleftAttachment,  XmATTACH_POSITION,
					  XmNleftPosition,    50,
					  XmNrightAttachment, XmATTACH_FORM,
					  XmNlabelString,     STRING("Remove ALL Feature Types"),
					  XmNtraversalOn,     False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					  NULL
					  ); 
	}
       else
        {
	  Done  = XtVaCreateManagedWidget("De-SelModels",xmPushButtonWidgetClass,form,
					  XmNleftAttachment,  XmATTACH_FORM,
					  XmNrightAttachment, XmATTACH_POSITION,
					  XmNrightPosition,   50,
					  XmNlabelString,     STRING("Remove Selected Classification Items"),
					  XmNtraversalOn,     False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					  NULL
					  ); 
	  
	  XtAddCallback(Done, XmNactivateCallback, (XtCallbackProc)kill_model, mydata);
	  
	  
	  XtManageChild(Done);
	  
	  Done  = XtVaCreateManagedWidget("DeSelectALLModels",xmPushButtonWidgetClass,form,
					  XmNleftAttachment,  XmATTACH_POSITION,
					  XmNleftPosition,    50,
					  XmNrightAttachment, XmATTACH_FORM,
					  XmNlabelString,     STRING("Remove ALL classification items"),
					  XmNtraversalOn,     False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					  NULL
					  ); 
	}

      XtAddCallback(Done, XmNactivateCallback, (XtCallbackProc)kill_all_model, mydata);


      XtManageChild(Done);

      XtManageChild(form);






      form = XtVaCreateWidget ("form3", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
      Done  = XtVaCreateManagedWidget("De-SelModels",xmPushButtonWidgetClass,form,
				      XmNleftAttachment,  XmATTACH_FORM,
				      XmNrightAttachment, XmATTACH_POSITION,
				      XmNrightPosition,   50,
				      XmNlabelString,     STRING("Remove Selected Attribute Items"),
				      XmNtraversalOn,     False,
					  XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 

      XtAddCallback(Done, XmNactivateCallback,
		    (XtCallbackProc)kill_attribute, mydata);
		    



      XtManageChild(Done);

      Done  = XtVaCreateManagedWidget("DeSelectALLModels",xmPushButtonWidgetClass,form,
				      XmNleftAttachment,  XmATTACH_POSITION,
				      XmNleftPosition,    50,
				      XmNrightAttachment, XmATTACH_FORM,
				      XmNlabelString,     STRING("Remove ALL Attribute Items"),
				      XmNtraversalOn,     False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 

      XtAddCallback(Done, XmNactivateCallback,
		    (XtCallbackProc)kill_all_attribute, mydata);
      

      XtManageChild(Done);
      XtManageChild(form);








      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);



      if(mydata->viewonly==1)
	{
      Done  = XtVaCreateManagedWidget("Help",xmPushButtonWidgetClass,form,
				      XmNleftAttachment,  XmATTACH_FORM,
				      XmNrightAttachment, XmATTACH_POSITION,
				      XmNrightPosition,   25,
				      XmNlabelString,     STRING("Help"),
				      XmNtraversalOn,     False,
				 	  XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 
      XtAddCallback(Done, XmNactivateCallback,
		    Help_modCallback, (XtPointer) NULL);
      XtManageChild(Done);


     Done  = XtVaCreateManagedWidget("Done7",xmPushButtonWidgetClass,form,
					  XmNleftAttachment,  XmATTACH_POSITION,
					  XmNleftPosition,    25,
					  XmNrightAttachment, XmATTACH_POSITION,
					  XmNrightPosition,   50,
					  XmNlabelString,     STRING("Apply/Refresh View"),
					  XmNtraversalOn,     False,
					  XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					  NULL
					  );
	  XtAddCallback(Done, XmNactivateCallback,
		    (XtCallbackProc)kill_model_callback2, mydata);  
      XtManageChild(Done);



     Done  = XtVaCreateManagedWidget("Done7",xmPushButtonWidgetClass,form,
					  XmNleftAttachment,  XmATTACH_POSITION,
					  XmNleftPosition,    50,
					  XmNrightAttachment, XmATTACH_POSITION,
					  XmNrightPosition,   75,
					  XmNlabelString,     STRING("Done (No Refresh)"),
					  XmNtraversalOn,     False,
					  XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					  NULL
					  );
 
	  XtAddCallback(Done, XmNactivateCallback,
		    (XtCallbackProc)kill_model_callback3, mydata);  
      XtManageChild(Done);
	  
	  
	  
	  Done  = XtVaCreateManagedWidget("Done7",xmPushButtonWidgetClass,form,
					  XmNleftAttachment,  XmATTACH_POSITION,
					  XmNleftPosition,    75,
					  XmNrightAttachment, XmATTACH_FORM,
					  XmNlabelString,     STRING("Done/Refresh View"),
					  XmNtraversalOn,     False,
					  XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					  NULL
					  );

	  XtAddCallback(Done, XmNactivateCallback,
		    (XtCallbackProc)kill_model_callback, mydata); 
 


	 
 
	}
      else
	{

	  Done  = XtVaCreateManagedWidget("Help",xmPushButtonWidgetClass,form,
				      XmNleftAttachment,  XmATTACH_FORM,
				      XmNrightAttachment, XmATTACH_POSITION,
				      XmNrightPosition,   50,
				      XmNlabelString,     STRING("Help"),
				      XmNtraversalOn,     False,
					  XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 
      XtAddCallback(Done, XmNactivateCallback,
		    Help_modCallback, (XtPointer) NULL);
      XtManageChild(Done);


	  Done  = XtVaCreateManagedWidget("Done7",xmPushButtonWidgetClass,form,
					  XmNleftAttachment,  XmATTACH_POSITION,
					  XmNleftPosition,    50,
					  XmNrightAttachment, XmATTACH_FORM,
					  XmNlabelString,     STRING("Done / Apply"),
					  XmNtraversalOn,     False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					  NULL
					  );

	  XtAddCallback(Done, XmNactivateCallback,
		    (XtCallbackProc)kill_model_callback, mydata);

      XtManageChild(Done);
 	}

       XtManageChild(form);


      bignames[0] =  XmStringCreate("                                                                                                                                            ","mytag1");
      



      if(clonenum==0)
	{
	  if(ErrorLookup[errnum].DO_EDCS_COMBO[axis][ADDER][geomtype]==0)
	    {
	      
	      
	      sac_names =  (XmString *) (malloc(sizeof(XmString *) * NumberOfAttributesEntries));
	      if(sac_names==NULL){printf("mne1: out of allocation memory!\n"); ExitWrapper(-1);}
	      
	      for(i=0;i<NumberOfAttributesEntries;i++)
		{
		  if(NGA_TYPE==1)
		    {
		      sprintf(temp,"%s: %s (%.0lf)",
			      GetEACCode(MdlNames2[i].code),
			      GetEACLabel(MdlNames2[i].code),
			      MdlNames2[i].occurrences);
		    }
		  else
		    {
		      sprintf(temp,"%s (%.0lf)",GetEACLabel(MdlNames2[i].code),MdlNames2[i].occurrences);
		    }
		  sac_names[i] = XmStringCreate(temp,"mytag1");
		}	  
	      XmListAddItems(ErrorLookup[errnum].EAlist[axis][ADDER][geomtype],  sac_names ,NumberOfAttributesEntries,1); 
	      
	      for (i = 0; i <  NumberOfAttributesEntries; i++)
		{
		  XmStringFree (sac_names[i]);
		}
	      free(sac_names);	  
	    }
	  
	  XmListAddItems(ErrorLookup[errnum].EAVlist[axis][ADDER][geomtype], bignames ,1,1); 
	  XmListAddItems(ErrorLookup[errnum].EASlist[axis][ADDER][geomtype], bignames ,1,1); 
	}
      else
	{
	  if(CloneErrorLookup[cloneindex].DO_EDCS_COMBO[axis][ADDER][geomtype]==0)
	    {
	      
	      
	      sac_names =  (XmString *) (malloc(sizeof(XmString *) * NumberOfAttributesEntries));
	      if(sac_names==NULL){printf("mne1: out of allocation memory!\n"); ExitWrapper(-1);}
	      
	      for(i=0;i<NumberOfAttributesEntries;i++)
		{
		  if(NGA_TYPE==1)
		    {
		      sprintf(temp,"%s: %s (%.0lf)",
			      GetEACCode(MdlNames2[i].code),
			      GetEACLabel(MdlNames2[i].code),
			      MdlNames2[i].occurrences);
		    }
		  else
		    {
		      sprintf(temp,"%s (%.0lf)",GetEACLabel(MdlNames2[i].code),MdlNames2[i].occurrences);
		    }
		  sac_names[i] = XmStringCreate(temp,"mytag1");
		}	  
	      XmListAddItems(CloneErrorLookup[cloneindex].EAlist[axis][ADDER][geomtype],  sac_names ,NumberOfAttributesEntries,1); 
	      
	      for (i = 0; i <  NumberOfAttributesEntries; i++)
		{
		  XmStringFree (sac_names[i]);
		}
	      free(sac_names);	  
	    }
	  
	  XmListAddItems(CloneErrorLookup[cloneindex].EAVlist[axis][ADDER][geomtype], bignames ,1,1); 
	  XmListAddItems(CloneErrorLookup[cloneindex].EASlist[axis][ADDER][geomtype], bignames ,1,1); 
	}



      XtManageChild(rc);
      MyPopup(modelhead); 

      if(viewonly==1)
	{
	  viewonlyhead = modelhead;
	}


      XtAddCallback(modelhead,XmNdestroyCallback,(XtCallbackProc)ModelDeath,mydata);       
      MY_MODEL_UP(mydata,1);


      if(clonenum==0)
	{
	  XmListAddItems(ErrorLookup[errnum].list2_w[axis][ADDER][geomtype], model_names2,NumberOfRealModels,1);

	  XmListAddItems(ErrorLookup[errnum].list_w [axis][ADDER][geomtype], model_names ,NumberOfRealModels,1);
	  XmListAddItems(ErrorLookup[errnum].EASlist[axis][ADDER][geomtype], model_names3,numsac,        1);


      
      XmListSelectPos(ErrorLookup[errnum].list2_w[axis][ADDER][geomtype],1,False);
      XmListDeselectAllItems(ErrorLookup[errnum].list2_w[axis][ADDER][geomtype]);



	  
	  
	  XtAddCallback (ErrorLookup[errnum].list_w[axis][ADDER][geomtype],  XmNdefaultActionCallback, 
			 (XtCallbackProc)set_model, 
			 mydata);

	  XtAddCallback (ErrorLookup[errnum].EAlist[axis][ADDER][geomtype], XmNdefaultActionCallback, 
			 (XtCallbackProc)set_sac, 
			 mydata);

	  XtAddCallback (ErrorLookup[errnum].EAVlist[axis][ADDER][geomtype], XmNdefaultActionCallback, 
			 (XtCallbackProc)set_sac, 
			 mydata);



	  if(NumberOfRealModels<=0)
	  {
        XtSetSensitive(ErrorLookup[errnum].list_w[axis][ADDER][geomtype],False);
        XtSetSensitive(ErrorLookup[errnum].list2_w[axis][ADDER][geomtype],False);
	  }
	  else
	  {
        XmListSelectPos(ErrorLookup[errnum].list_w[axis][ADDER][geomtype],1,True);
	  }

	  if((NumberOfAttributesEntries<=0)||(NumberOfRealModels<=0))
	  {
        XtSetSensitive(ErrorLookup[errnum].EAlist[axis][ADDER][geomtype],False);
        XtSetSensitive(ErrorLookup[errnum].EAVlist[axis][ADDER][geomtype],False);
        XtSetSensitive(ErrorLookup[errnum].EASlist[axis][ADDER][geomtype],False);
	  }
	  else
	  {
        XmListSelectPos(ErrorLookup[errnum].EAlist[axis][ADDER][geomtype],1,True);
	  }

	}
      else
	{
	  XmListAddItems(CloneErrorLookup[cloneindex].list2_w[axis][ADDER][geomtype], model_names2,NumberOfRealModels,1);
	  XmListAddItems(CloneErrorLookup[cloneindex].list_w [axis][ADDER][geomtype], model_names ,NumberOfRealModels,1);
	  XmListAddItems(CloneErrorLookup[cloneindex].EASlist[axis][ADDER][geomtype], model_names3,numsac,        1);


      
      XmListSelectPos(CloneErrorLookup[cloneindex].list2_w[axis][ADDER][geomtype],1,False);
      XmListDeselectAllItems(CloneErrorLookup[cloneindex].list2_w[axis][ADDER][geomtype]);


	  
	  
	  XtAddCallback (CloneErrorLookup[cloneindex].list_w[axis][ADDER][geomtype],  XmNdefaultActionCallback, 
			 (XtCallbackProc)set_model, 
			 mydata);

	  XtAddCallback (CloneErrorLookup[cloneindex].EAlist[axis][ADDER][geomtype], XmNdefaultActionCallback, 
			 (XtCallbackProc)set_sac, 
			 mydata);

	  XtAddCallback (CloneErrorLookup[cloneindex].EAVlist[axis][ADDER][geomtype], XmNdefaultActionCallback, 
			 (XtCallbackProc)set_sac, 
			 mydata);

	  

	  

	  if(NumberOfRealModels<=0)
	  {
        XtSetSensitive(CloneErrorLookup[cloneindex].list_w[axis][ADDER][geomtype],False);
        XtSetSensitive(CloneErrorLookup[cloneindex].list2_w[axis][ADDER][geomtype],False);
	  }
	  else
	  {
        XmListSelectPos(CloneErrorLookup[cloneindex].list_w[axis][ADDER][geomtype],1,True);
	  }

	  if((NumberOfAttributesEntries<=0)||(NumberOfRealModels<=0))
	  {
        XtSetSensitive(CloneErrorLookup[cloneindex].EAlist[axis][ADDER][geomtype],False);
        XtSetSensitive(CloneErrorLookup[cloneindex].EAVlist[axis][ADDER][geomtype],False);
        XtSetSensitive(CloneErrorLookup[cloneindex].EASlist[axis][ADDER][geomtype],False);
	  }
	  else
	  {
        XmListSelectPos(CloneErrorLookup[cloneindex].EAlist[axis][ADDER][geomtype],1,True);
	  }


	}



     for (i = 0; i <  NumberOfRealModels; i++)
	{
	  XmStringFree (model_names[i]);
	  XmStringFree (model_names2[i]);
	}
     for (i = 0; i <  numsac; i++)
	{
	  XmStringFree (model_names3[i]);
	}


     free(model_names);
     free(model_names2);
     free(model_names3);

     

     XtVaGetValues (modelhead, XmNheight, &y1, NULL);

     XtVaSetValues (modelhead, XmNminHeight, y1+30, NULL);


     

    }
  else
    {
      
      

      if(viewonly==1)
	{
	  ResetWidget(viewonlyhead);
	}
    }
  set_cursor(mydisplay,mywindow,GOOD);
}







void ModelButton2Callback(Widget w,MyData  *mydata,XtPointer callData)
{
  

  ModelButtonCallback(w,mydata,callData,0);
}

void ModelButton3Callback(Widget w,MyData  *mydata,XtPointer callData)
{
  

  ModelButtonCallback(w,mydata,callData,1);
}

void ModelButton4Callback(Widget w,XtPointer clientData,XtPointer callData)
{
  

  ModelButtonCallback(w,NULL,callData,0);
}
  





void ErrorSelectionCallback(Widget w,XtPointer data,XtPointer callData)
{
  GenerateErrorEditor(1);
}



void out_grid_info(Widget w,XtPointer data,XtPointer callData)
{
  int type=(int)data;
  

  if(type==10)
    {
      not_while_running(w,"Sun Azimuth:\n\
Units:  Degrees (0-359)\n\n\
This parameter describes the \"direction\" from which the light from the\n\
sun emanates when drawing shaded reliefs.  It is measured in degrees,\n\
with 0 representing due north, then proceeding clockwise.  Examples:\n\n\
0:    north\n\
45:   northeast\n\
90:   east \n\
135:  southeast\n\
180:  south\n\
225:  southwest\n\
270:  west\n\
315:  northwest\n\
",1174,"Sun Azimuth Help",5);
    }  
  
    
  else if(type==11)
    {
      not_while_running(w,"Sun Angle:\n\
Units: Degrees (15-75)\n\n\
This parameter is the angle above the horizon that the sun is to be\n\
represented when drawing shaded reliefs.\n\n\
The horizon is 0 degrees, and directly overhead is 90 degrees.",1175,"Sun Angle Help",5);
    }  
  
   
  else if(type==12)
    {
      not_while_running(w,"Vertical Exaggeration:\n\
Units:  Integer (.1-1000)\n\n\
This parameter represents a scalar value to multiply elevations\n\
by, resulting in exaggerated elevations if a value greater than 1\n\
is entered.",1176,"Vertical Exaggeration Help",5);
    }  

}




void shade_type_cb(Widget menu_item,XtPointer client_data,XtPointer call_data)
{
  int item_no = (int) client_data;

  if((item_no>=1)&&(item_no<=4))
  {
    if(item_no!=USE_GREY)
	{
      NEED_SHADE_REDRAW = 1;
	}
    USE_GREY = item_no;
  }
  else
  {
    printf("Bad USE_GREY %d!\n",item_no);
	XBell(mydisplay,50);
  }
}






Widget BuildShadeMenu(Widget parent,int menu_type,char *menu_title,MenuItem *items)
{
  Widget menu, cascade, widget;
  int i,n=0;
  XmString str;
  Arg args[5];
  
  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);
  
  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId, menu);  n++;
  XtSetArg (args[n], XmNlabelString, str); n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;

  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);

  for (i = 0; items[i].label != NULL; i++) 
    {
      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);

    
      if(USE_GREY==i+1) 
	{
	  XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);
	}

      if (items[i].callback)
	XtAddCallback (widget,
		       (items[i].cclass == &xmToggleButtonWidgetClass ||
			items[i].cclass == &xmToggleButtonWidgetClass) ?
		       XmNvalueChangedCallback : 
		       XmNactivateCallback,      
		       (XtCallbackProc)items[i].callback, items[i].callback_data);
    }

  return menu_type == XmMENU_POPUP ? menu : cascade;
}




void ShadeCallback(Widget w,XtPointer data,XtPointer callData)
{
  static Widget shadehead;
  Widget rc,form,button;
  Dimension Pheight;
  Arg resources[20];
  int n;
  char temp[100];



  MenuItem color_type[] = {
    {"Grey Shaded",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())shade_type_cb, (XtPointer)1, (MenuItem *) NULL},
    {"Red Shaded",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())shade_type_cb, (XtPointer)2, (MenuItem *) NULL},
    {"Green Shaded",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())shade_type_cb, (XtPointer)3, (MenuItem *) NULL},
    {"Blue Shaded",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())shade_type_cb, (XtPointer)4, (MenuItem *) NULL},
    {NULL},
  };


  if(dead_shade==1)
    {
      n=0;
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++;
      XtSetArg(resources[n],  XmNmaxWidth,            800);  n++;

      shadehead = XtCreatePopupShell("Shading Parameters Window",topLevelShellWidgetClass,w,resources,n);
      
      rc = XtVaCreateWidget ("rowcol",xmRowColumnWidgetClass, shadehead, NULL);
      
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);
      
      sprintf(temp,"%d",ZoomSunAzimuth);
      
      sun_az_w_z = XtVaCreateManagedWidget ("Sun Azimuth",
					  xmTextFieldWidgetClass, form,	  
					  XmNvalue,            temp,
					  XmNtraversalOn,      True,
					  XmNrightAttachment,  XmATTACH_POSITION,
					  XmNrightPosition,    100,
					  XmNleftAttachment,   XmATTACH_POSITION,
					  XmNleftPosition,     60,
                      XmNtranslations,     XtParseTranslationTable ( translations_paste ) ,
					  NULL);
      XtManageChild(sun_az_w_z);

      

      button = XtVaCreateManagedWidget ("GX",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    60,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     0,
					XmNlabelString,      STRING("Sun Azimuth"),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtManageChild(button);
      XtAddCallback (button, XmNactivateCallback,
		     out_grid_info, (XtPointer)10);      
      XtManageChild(form);
      
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);
      
      sprintf(temp,"%d",ZoomSunAngle);
      
      sun_angle_w_z = XtVaCreateManagedWidget ("Sun Angle",
					      xmTextFieldWidgetClass, form,	  
					      XmNvalue,            temp,
					      XmNtraversalOn,      True,
					      XmNrightAttachment,  XmATTACH_POSITION,
					      XmNrightPosition,    100,
					      XmNleftAttachment,   XmATTACH_POSITION,
					      XmNleftPosition,     60,
                          XmNtranslations,     XtParseTranslationTable ( translations_paste ) ,
					      NULL);
      XtManageChild(sun_angle_w_z);

      

      button = XtVaCreateManagedWidget ("Sun Angle",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    60,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     0,
					XmNlabelString,      STRING("Sun Angle"),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtManageChild(button);
      XtAddCallback (button, XmNactivateCallback,
		     out_grid_info, (XtPointer)11);      
      XtManageChild(form);
      


     form = XtVaCreateWidget ("form", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);
      
      sprintf(temp,"%.2lf",ZoomVertExag);
      
      vert_ex_w_z = XtVaCreateManagedWidget ("vert_ex_w_z",
					      xmTextFieldWidgetClass, form,	  
					      XmNvalue,            temp,
					      XmNtraversalOn,      True,
					      XmNrightAttachment,  XmATTACH_POSITION,
					      XmNrightPosition,    100,
					      XmNleftAttachment,   XmATTACH_POSITION,
					      XmNleftPosition,     60,
                          XmNtranslations,     XtParseTranslationTable ( translations_paste ) ,
					      NULL);
      XtManageChild(vert_ex_w_z);

      
      button = XtVaCreateManagedWidget ("Vertical Exag",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    60,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     0,
					XmNlabelString,      STRING("Vertical Exaggeration"),
					XmNtranslations, XtParseTranslationTable (translations_global) ,
					NULL);
      XtManageChild(button);
      XtAddCallback (button, XmNactivateCallback,
		     out_grid_info, (XtPointer)12);      
      XtManageChild(form);





       form = XtVaCreateWidget ("form", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);

       button = BuildShadeMenu (form, XmMENU_OPTION, "Shaded relief color:",color_type);
      
       XtVaSetValues(button,
		    XmNtopAttachment,          XmATTACH_FORM,
		    XmNbottomAttachment,       XmATTACH_FORM,
		    XmNleftAttachment,         XmATTACH_FORM,
		    NULL);

       XtManageChild (button);
       XtManageChild(form);






       form = XtVaCreateWidget ("form", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);

       XtVaCreateManagedWidget ("Hit return",
			       xmLabelWidgetClass, form,
			       XmNtopAttachment,    XmATTACH_FORM,
			       XmNbottomAttachment, XmATTACH_FORM,
			       XmNrightAttachment,  XmATTACH_FORM,
			       XmNleftAttachment,  XmATTACH_FORM,
			       XmNalignment,        XmALIGNMENT_CENTER,
			       XmNlabelString, STRING("Click \"Apply/Done\" to make changes take effect."),
			       LABELWTRANSLATE,
			       NULL);
      XtManageChild(form);



      form = XtVaCreateWidget ("form", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);
      
      button  = XtVaCreateManagedWidget("Done8",xmPushButtonWidgetClass,form,
					XmNlabelString,     STRING("Help"),
					XmNorientation,     XmVERTICAL,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    1,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,   50,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
      
      XtAddCallback(button, XmNactivateCallback,
		    help_shade_callback, (XtPointer)NULL);



      button  = XtVaCreateManagedWidget("Done8",xmPushButtonWidgetClass,form,
					XmNlabelString,     STRING("Apply/Done"),
					XmNorientation,     XmVERTICAL,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    50,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,   99,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
      
      XtAddCallback(button, XmNactivateCallback,
		    die_callback, (XtPointer) 16);


      XtManageChild(button);
      XtManageChild(form);
      XtManageChild(rc);
      MyPopup(shadehead); 
      XtAddCallback(shadehead,XmNdestroyCallback,ShellDeath,(XtPointer)279);
      

      XtVaGetValues(shadehead,  XmNheight,     &Pheight, NULL);
      XtVaSetValues(shadehead,  XmNminHeight,   Pheight, NULL);
      XtVaSetValues(shadehead,  XmNmaxHeight,   Pheight, NULL);
      XtVaSetValues(shadehead,  XmNmaxWidth,   1000, NULL);

      XtAddEventHandler(shadehead,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)Pheight));


      dead_shade=0;
    }  
  else
    {
      ResetWidget(shadehead);
    }
}


int GetTesterValues(int x,int y,int *outx, int *outy)
{

  if(x%2==0)
    {
      *outx = x/2;
    }
  else
    {
      *outx = (x-1)/2;	      
    }
  if(y%2==0)
    {
      *outy = y/2;
    }
  else
    {
      *outy = (y-1)/2;	      
    }

  if(*outx<INFO_BUFFER)
    {
      return 0;
    }
  if(*outy<INFO_BUFFER)
    {
      return 0;
    }
  if(*outx>=1000)
    {
      return 0;
    }
  if(*outy>=850)
    {
      return 0;
    }
  return 1;
}


void RememberCondition(short int x1, short int y1, short int x2, short int y2, int type)
{
  XImage *myimage;
  short int llx,ury;
  int xrange,yrange,xmid,ymid,i,j,testx,testy,toomuch;
  unsigned long thiscolor;
  extern int global_ctype,global_cnum,global_instance;
  extern long int global_fileposn;
 

  


  if(type==1)
    {
      xrange = abs(x1-x2);
      yrange = abs(y1-y2);

      if((xrange>10)&&(yrange>10))
	{
	  xmid = (x1 + x2)/2;
	  ymid = (y1 + y2)/2;
	  RememberCondition(x1,y1,(short int)xmid,(short int)ymid,1);
	  RememberCondition((short int)xmid,(short int)ymid,x2,y2,1);
	  return;
	}
      
      
      if(x1<x2) {llx = x1;}  else {llx = x2;}
      
      if(y1>y2) {ury = y2;}  else {ury = y1;}
    }
  else
    {
      xrange = x2;
      yrange = x2;
      llx = x1;
      ury = y1;

      if(llx>0) {llx = llx - 1;}
      if(ury>0) {ury = ury - 1;}

      xrange = xrange + 2;
      yrange = yrange + 2;

      AddHighlightCondition(
		  (short int)(x1+x2/2),
		  (short int)(y1+x2/2),
		  global_ctype,global_instance,global_cnum,global_fileposn);

      return;
    }


  

  if((llx+xrange)<999) 
  {
	
    if(llx>0) {llx = llx - 1;}
    xrange = xrange + 2;
  }
  else if((llx+xrange)==999)
  {
	

	if(llx>1)
	{ 
	  llx = llx - 2;
	}
	xrange = xrange + 2;

    
  }
  else 
  {
    
  }

  if((ury+yrange)<849) 
  {
    if(ury>0) {ury = ury - 1;}
    yrange = yrange + 2;
  }
  else if((ury+yrange)==849)
  {
	

	if(ury>1)
	{ 
	  ury = ury - 2;
	}
	yrange = yrange + 2;

    
  }
  else
  {
    
  }



  

  if((llx+xrange)>999)
  {
    if((llx+xrange)>1000)
	{
	  
	  printf("extra xmod: llx %d xrange %d\n",llx,xrange);
	}

	toomuch = (llx+xrange) - 999;

	xrange = xrange - toomuch;
	if(xrange<0)
	{
	  xrange = 0;
	}
  }

  if((ury+yrange)>849)
  {
    if((ury+yrange)>850)
	{
	  
	  printf("extra ymod: ury %d yrange %d\n",ury,yrange);
	}

	toomuch = (ury+yrange) - 849;

	yrange = yrange - toomuch;
	if(yrange<0)
	{
	  yrange = 0;
	}
  }

  if((llx+xrange)>999)
  {
	
	printf("x-mod final %d %d\n",llx,xrange);
	return;
  }
  if((ury+yrange)>849)
  {
	
	printf("y-mod final %d %d\n",ury,yrange);
	return;
  }



  

  if(GetTesterValues(llx,ury,&testx,&testy)>0)
  {
    if(MasterStacker[testx][testy]>=MAX_STACK)
    {
	 return;
    }
  }


  


  


  

  XDrawLine(mydisplay,ERROR_BITMAP,mybitgc,x1,y1,x2,y2);


  

  myimage = XGetImage(mydisplay,ERROR_BITMAP,llx,ury,xrange,yrange,XAllPlanes(),ZPixmap);

  if(myimage!=NULL)
    {
      for(i=0;i<xrange;i++)
	{
	  for(j=0;j<yrange;j++)
	    {
		  

          if(GetTesterValues(llx+i,ury+j,&testx,&testy)>0)
		  {
            if(MasterStacker[testx][testy]>=MAX_STACK)
			{  
	          continue;
			}
		  }


	      thiscolor = XGetPixel(myimage,i,j);

	      
	      if(thiscolor==1)
		{
		  AddHighlightCondition(
			  (short int)(llx+i),
			  (short int)(ury+j),
			  global_ctype,global_instance,global_cnum,global_fileposn);
		}
	    }
	}

      XDestroyImage(myimage);
    }
  else
    {
	  

      
    }

 

  
  XSetForeground(mydisplay,mybitgc,BITBLACK);
  XFillRectangle (XtDisplay (drawing_a), ERROR_BITMAP,   mybitgc, llx, ury,xrange+1,yrange+1);
  XSetForeground(mydisplay,mybitgc,BITWHITE);
  

  

}



void MAPdrawcircle(double x,double y,double diameter,int color, int Lindex)
{
  double xoff,yoff;
  int realx,realy,tester;
  unsigned int myradius;
  double xorig=x,yorig=y;
  int negcolorflag=0,rendering_priority;
  double radius=diameter;

  
  

   if(Lindex!=DRAW_NOW)
    {
	  if(color==1)
	  {
		rendering_priority = MAX_RENDER_PRI;
	  }
	  else
	  {
        rendering_priority = LODindex_DYN[LODindex[CrsWlk[Lindex].LODband-1].other_index].draw_priority - 1;
	  }

      LODS_USED[rendering_priority] = 1;
    }

  if(batch_mode==1){return;}

  if((running==1)&&(API_DRAW==0))
  {
	  BadDraw("MAPdrawcircle");
	  return;
  }

  if(xunits==0)
    {
      printf("mapdrawcircle got xunits==0!\n"); 
      XBell(mydisplay,50); 
    }

  if(color<0)
    {
      negcolorflag=1;
      color = -1 * color;
      
    }

  if(color<11){periodic_redraw();}
  if(color==1)
    {
      
      radius = CIRCLESIZE;
    }
  if(color==3)
    {
      radius = CIRCLESIZE*2;  
      color = 1;
    }



      urx_zoom = llx_zoom+(1000.0/xunits)*IRegionSize;
      ury_zoom = lly_zoom+(850.0/yunits)*IRegionSize;
      
      

      if( 
	 (x+(double)(radius/2.0)<llx_zoom)||
	 (x-(double)(radius/2.0)>urx_zoom)||
	 (y+(double)(radius/2.0)<lly_zoom)||
	 (y-(double)(radius/2.0)>ury_zoom)
	 )     
	{
	  return;
	
    }


  x = x - llx_zoom;
  y = y - lly_zoom;
 
  xoff = 10.0+(int)((double)(x/IRegionSize)*xunits);    
  yoff = 10.0+(int)((double)(y/IRegionSize)*yunits);
  
  realx =  (int)(xoff);
  realy =  height-(int)(yoff);

  if((color==1)||(color==299)||(negcolorflag==1))
    {
      myradius = (unsigned int)radius;
    }  
  else
    {
      myradius = (int)((double)(radius/IRegionSize)*xunits); 
    }
  

      tester = realy+(int)myradius;
      if(
          ((realx+((int)myradius))<10) ||
	  (realx>990)                  ||
	  (tester < 60)                ||
	  (realy>(height-10))	  
	 )
	{
	  return;
	}
    

  if(myradius<=1)
    {
      
      if(color<3)
	  {
	   MAPdrawcircle(xorig,yorig,CIRCLESIZE,1,Lindex); 
	   return;
	  }
      else
	  {
         if((SPECIAL_COND_COLOR>0)&&(color==1))
		 { 
           XSetForeground(mydisplay,mygc,mycolors[SPECIAL_COND_COLOR]);
		 } 
		 else
		 {
	       XSetForeground(mydisplay,mygc,mycolors[color]);
		 }

	   if(Lindex==DRAW_NOW)
	    {

	      if(myradius==0) 
		  {	  
		   XDrawPoint(mydisplay,pixmap, mygc,realx,realy);
		   MAPdrawX(xorig,yorig,color,Lindex);
		   if(color<17)
		    {
		      XDrawPoint(mydisplay,mywindow, mygc,realx,realy);
		    }
		  }
	      
	      else  
		{
		  
		  XDrawPoint(mydisplay,pixmap,   mygc,realx-1,realy);
		  XDrawPoint(mydisplay,pixmap,   mygc,realx+1,realy);
		  XDrawPoint(mydisplay,pixmap,   mygc,realx,realy-1);
		  XDrawPoint(mydisplay,pixmap,   mygc,realx,realy+1);
		  if(color<17)
		    {
		      XDrawPoint(mydisplay,mywindow, mygc,realx-1,realy);
		      XDrawPoint(mydisplay,mywindow, mygc,realx+1,realy);
		      XDrawPoint(mydisplay,mywindow, mygc,realx,realy-1);
		      XDrawPoint(mydisplay,mywindow, mygc,realx,realy+1);
		    }
		}
	      XSetForeground(mydisplay,mygc,mycolors[DRAW_COLOR_BLACK]);
	      return;
	    }
	  else
	    {
	      XBell(mydisplay,50);
	      printf("GAIT should not be drawing circles here\n");
	    }
	}
    }

  if(color==1)
    {
      MySetLineThickness(2);
    }
  



  if((color==1)||(color==299)||(negcolorflag==1))
    {
      
      realx = realx - (int)(radius/2.0);
      realy = realy - (int)(radius/2.0);
    }  
  else 
    {
      
      realx=realx-(int)(((((double)radius)/IRegionSize)*xunits)/2.0);  
      realy=realy-(int)(((((double)radius)/IRegionSize)*yunits)/2.0);
    }
  
  
  

   if((SPECIAL_COND_COLOR>0)&&(color==1))
   { 
     XSetForeground(mydisplay,mygc,mycolors[SPECIAL_COND_COLOR]);
   } 
   else
   {
     XSetForeground(mydisplay,mygc,mycolors[color]);
   }

   if(Lindex==DRAW_NOW)
     {
       XDrawArc(mydisplay,mywindow,mygc,realx,realy,myradius,myradius,0,23040);
       XDrawArc(mydisplay,pixmap,  mygc,realx,realy,myradius,myradius,0,23040);
      
       if((color==1)&&(DRAWING_ERRORS==1))
	   {
	    RememberCondition((short int)realx,(short int)realy,(short int)myradius,-1,2);
	   }
 
       XSetForeground(mydisplay,mygc,mycolors[DRAW_COLOR_BLACK]);
     }
   else
     {
       XDrawArc(mydisplay,DRAWING_PIXMAPS[rendering_priority], mygc,   realx,realy,myradius,myradius,0,23040);
       XDrawArc(mydisplay,DRAWING_CLIPMAPS[rendering_priority],mybitgc,realx,realy,myradius,myradius,0,23040);
     }
   



  circlecount++;
  if((circlecount%CIRCLECHUNK)==0)
    {
      FlushMainScreen(CIRCLE_LIMIT);
    }  

  if(color==1)
    {
      MySetLineThickness(0);
    }
}


int InSide(double llx,double lly,double urx,double ury,double x1,double y1,double x2,double y2)
{
  if(  (x1<=urx)&&(x1>=llx)&&(y1<=ury)&&(y1>=lly)  ) {return 1;}  
  if(  (x2<=urx)&&(x2>=llx)&&(y2<=ury)&&(y2>=lly)  ) {return 1;}

  return 0;
}








int cliplines(double X[],double Y[],int num,
	      double llx,double lly,double urx,double ury)
{
  int good_point=0;
  int i;


  for(i=0;i<num;i++)
    {
      if( (X[i]<=urx)&&(X[i]>=llx)&&(Y[i]<=ury)&&(Y[i]>=lly) ) 
	{
	  good_point++;
	}
      else
	{
	  break;
	}
    }
  
  
  if(good_point==num)
    {
      for(i=0;i<num;i++)
	{
          XNEW4[i] = X[i] - llx;
          YNEW4[i] = Y[i] - lly;
	}
      return 1;
    }
    
  return 0;
}






int clipit(double X[],double Y[],int * num,
	      double llx,double lly,double urx,double ury)
{
  

  double *XSTART;
  double *YSTART;
  double  *XNEW1;
  double  *XNEW2;
  double  *XNEW3;
  double  *YNEW1;
  double  *YNEW2;
  double  *YNEW3;
  int i,previous=0,index=0;
  int verts;
  double xint,yint;
  double BIGNUM=100000000;
  int good_point=0;

  



  for(i=0;i<*num;i++)
    {
      if( (X[i]<=urx)&&(X[i]>=llx)&&(Y[i]<=ury)&&(Y[i]>=lly) ) 
	{
	  good_point++;
	}
      else
	{
	  break;
	}
    }


  if(good_point==*num)
    {
      for(i=0;i<*num;i++)
	{	  
          XNEW4[i] = X[i] - llx;
          YNEW4[i] = Y[i] - lly;
	}
      return 1;
    }




  
  
  verts  = (*num + 10) * SzD;  
  XSTART = (double *) (malloc(verts));
  YSTART = (double *) (malloc(verts));
  XNEW1  = (double *) (malloc(verts));
  XNEW2  = (double *) (malloc(verts));
  XNEW3  = (double *) (malloc(verts));
  YNEW1  = (double *) (malloc(verts));
  YNEW2  = (double *) (malloc(verts));
  YNEW3  = (double *) (malloc(verts));

  if(
     (XSTART==NULL)||(YSTART==NULL)||(XNEW1==NULL)||(YNEW1==NULL)||
     (XNEW2==NULL)||(YNEW2==NULL)||(XNEW3==NULL)||(YNEW3==NULL)
     )
    {printf("clip: out of allocation memory!\n"); ExitWrapper(-1);}

  for(i=0;i<*num;i++)
    {
      XSTART[i]=X[i];
      YSTART[i]=Y[i];
    }
  
  XSTART[*num]=X[0];
  YSTART[*num]=Y[0];
  
  
  
  for(i=0;i<*num+1;i++)
    {
      if(previous==0)
	{
	  if(XSTART[i]>=llx)
	    {
	      if(i==0)
		{
		  XNEW1[index]=XSTART[i];
		  YNEW1[index]=YSTART[i];
		  index++;
		  previous=1;
		}
	      else if(LineSegmentsIntersect
		      (llx,lly-BIGNUM,llx,ury+BIGNUM,
		       XSTART[i-1],YSTART[i-1],XSTART[i],YSTART[i],&xint,&yint)==1)
		{
		  
		  XNEW1[index]=xint;
		  YNEW1[index]=yint;
		  index++;
		  XNEW1[index]=XSTART[i];
		  YNEW1[index]=YSTART[i];
		  index++;
		  previous=1;
		}
	      else
		{
		  XNEW1[index]=XSTART[i];
		  YNEW1[index]=YSTART[i];
		  index++;
		  previous=1;
		}
	    }
	}      
      else
	{
	  if(XSTART[i]>=llx)
	    {
	      XNEW1[index]=XSTART[i];
	      YNEW1[index]=YSTART[i];
	      index++;
	      previous=1;
	    }
	  else if(LineSegmentsIntersect
		  (llx,lly-BIGNUM,llx,ury+BIGNUM,
		   XSTART[i-1],YSTART[i-1],XSTART[i],YSTART[i],&xint,&yint)==1)
	    {
	      
	      XNEW1[index]=xint;
	      YNEW1[index]=yint;
	      index++;
	      previous=0;
	    }
	  else{previous=0;}
	}
    }

  if(index>0)
    {
      if( (XNEW1[index-1]!=XNEW1[0])||(YNEW1[index-1]!=YNEW1[0]))
	{
	  if(CLIPDEBUG==1){printf("added in first one\n");}
	  XNEW1[index]=XNEW1[0];
	  YNEW1[index]=YNEW1[0];
	  index++;
	}
    }

  if(index==0)
    {
      if(CLIPDEBUG==1){printf("bag 1 %d %d\n",*num,index);}
      free(XSTART);
      free(YSTART);
      free(XNEW1);
      free(XNEW2);
      free(XNEW3);
      free(YNEW1);
      free(YNEW2);
      free(YNEW3);
      return 0;
    }
  
  if(CLIPDEBUG==1)
    {
      printf("Have bounding box %lf %lf %lf %lf\n",llx,lly,urx,ury);
      printf("Have points %lf %lf   %lf %lf   %lf %lf  %lf %lf %lf %lf index %d\n",
	     XNEW1[0],YNEW1[0],XNEW1[1],YNEW1[1],XNEW1[2],YNEW1[2],XNEW1[3],YNEW1[3],XNEW1[4],YNEW1[4],index);
    }
  
  
  
  *num=index-1;
  index=0;
  previous=0;
  
  for(i=0;i<*num+1;i++)
    {
      if(previous==0)
	{
	  if(YNEW1[i]>=lly)
	    {
	      if(i==0)
		{
		  XNEW2[index]=XNEW1[i];
		  YNEW2[index]=YNEW1[i];
		  index++;
		  previous=1;
		}
	      else if (LineSegmentsIntersect
		       (
			llx-BIGNUM,lly,urx+BIGNUM,lly,
			XNEW1[i-1],YNEW1[i-1],XNEW1[i],YNEW1[i],&xint,&yint)==1)
		{
		  
		  XNEW2[index]=xint;
		  YNEW2[index]=yint;
		  index++;
		  XNEW2[index]=XNEW1[i];
		  YNEW2[index]=YNEW1[i];
		  index++;
		  previous=1;
		}
	      else
		{
		  XNEW2[index]=XNEW1[i];
		  YNEW2[index]=YNEW1[i];
		  index++;
		  previous=1;
		}
	    }
	}
      else
	{
	  if(YNEW1[i]>=lly)
	    {
	      XNEW2[index]=XNEW1[i];
	      YNEW2[index]=YNEW1[i];
	      index++;
	      previous=1;
	    }
	  else if(LineSegmentsIntersect
		  (llx-BIGNUM,lly,urx+BIGNUM,lly,
		   XNEW1[i-1],YNEW1[i-1],XNEW1[i],YNEW1[i],&xint,&yint)==1)
	    {
	      
	      XNEW2[index]=xint;
	      YNEW2[index]=yint;
	      index++;
	      previous=0;
	    }
	  else{previous=0;}
	}
    }
  
  if(index>0)
    {
      if( (XNEW2[index-1]!=XNEW2[0])||(YNEW2[index-1]!=YNEW2[0]))
	{
	  if(CLIPDEBUG==1){printf("added in second one\n");}
	  XNEW2[index]=XNEW2[0];
	  YNEW2[index]=YNEW2[0];
	  index++;
	}
    }

  if(index==0)
    {
      if(CLIPDEBUG==1){printf("bag 2 %d %d\n",*num,index);}
      free(XSTART);
      free(YSTART);
      free(XNEW1);
      free(XNEW2);
      free(XNEW3);
      free(YNEW1);
      free(YNEW2);
      free(YNEW3);
      return 0;
    }
  
  
  
  *num=index-1;
  index=0;
  previous=0;
  
  for(i=0;i<*num+1;i++)
    {
      if(previous==0)
	{
	  if(YNEW2[i]<=ury)
	    {
	      if(i==0)
		{
		  XNEW3[index]=XNEW2[i];
		  YNEW3[index]=YNEW2[i];
		  index++;
		  previous=1;
		}
	      else if (LineSegmentsIntersect
		       (urx+BIGNUM,ury,llx-BIGNUM,ury,
			XNEW2[i-1],YNEW2[i-1],XNEW2[i],YNEW2[i],&xint,&yint)==1)
		{
		  
		  XNEW3[index]=xint;
		  YNEW3[index]=yint;
		  index++;
		  XNEW3[index]=XNEW2[i];
		  YNEW3[index]=YNEW2[i];
		  index++;
		  previous=1;
		}
	      else
		{
		  XNEW3[index]=XNEW2[i];
		  YNEW3[index]=YNEW2[i];
		  index++;
		  previous=1;
		}
	    }
	}
      else
	{
	  if(YNEW2[i]<=ury)
	    {
	      XNEW3[index]=XNEW2[i];
	      YNEW3[index]=YNEW2[i];
	      index++;
	      previous=1;
	    }
	  else if(LineSegmentsIntersect
		  (urx+BIGNUM,ury,llx-BIGNUM,ury,
		   XNEW2[i-1],YNEW2[i-1],XNEW2[i],YNEW2[i],&xint,&yint)==1)
	    {
	      if(CLIPDEBUG==1){printf("Fund intersection 7 at %lf %lf\n",xint,yint);}
	      XNEW3[index]=xint;
	      YNEW3[index]=yint;
	      index++;
	      previous=0;
	    }
	  else{previous=0;}
	}
    }
  
  if(index>0)
    {
      if( (XNEW3[index-1]!=XNEW3[0])||(YNEW3[index-1]!=YNEW3[0]))
	{
	  if(CLIPDEBUG==1){printf("added in third one\n");}
	  XNEW3[index]=XNEW3[0];
	  YNEW3[index]=YNEW3[0];
	  index++;
	}
    }

  if(index==0)
    {
      if(CLIPDEBUG==1){printf("bag 3 %d %d\n",*num,index);}
      free(XSTART);
      free(YSTART);
      free(XNEW1);
      free(XNEW2);
      free(XNEW3);
      free(YNEW1);
      free(YNEW2);
      free(YNEW3);
      return 0;
    }
  
  
  
  *num=index-1;
  index=0;
  previous=0;
  
  for(i=0;i<*num+1;i++)
    {
      if(previous==0)
	{
	  if(XNEW3[i]<=urx)
	    {
	      if(i==0)
		{
		  XNEW4[index]=XNEW3[i];
		  YNEW4[index]=YNEW3[i];
		  index++;
		  previous=1;
		}
	      else if (LineSegmentsIntersect
		       (urx,ury+BIGNUM,urx,lly-BIGNUM,
			XNEW3[i-1],YNEW3[i-1],XNEW3[i],YNEW3[i],&xint,&yint)==1)
		{
		  
		  XNEW4[index]=xint;
		  YNEW4[index]=yint;
		  index++;
		  XNEW4[index]=XNEW3[i];
		  YNEW4[index]=YNEW3[i];
		  index++;
		  previous=1;
		}
	      else
		{
		  XNEW4[index]=XNEW3[i];
		  YNEW4[index]=YNEW3[i];
		  index++;
		  previous=1;
		}
	    }
	}
      else
	{
	  if(XNEW3[i]<=urx)
	    {
	      XNEW4[index]=XNEW3[i];
	      YNEW4[index]=YNEW3[i];
	      index++;
	      previous=1;
	    }
	  else if(LineSegmentsIntersect
		  (urx,ury+BIGNUM,urx,lly-BIGNUM,
		   XNEW3[i-1],YNEW3[i-1],XNEW3[i],YNEW3[i],&xint,&yint)==1)
	    {
	      
	      XNEW4[index]=xint;
	      YNEW4[index]=yint;
	      index++;
	      previous=0;
	    }
	  else{previous=0;}
	}
    }
  


  if(index==0)
    {
      if(CLIPDEBUG==1){printf("bag 4 %d %d\n",*num,index);}
      free(XSTART);
      free(YSTART);
      free(XNEW1);
      free(XNEW2);
      free(XNEW3);
      free(YNEW1);
      free(YNEW2);
      free(YNEW3);
      return 0;
    }
  
  *num = index;
  
  if(*num<3)
    {
      if(CLIPDEBUG==1){printf("returning with num=%d\n",*num);}
      free(XSTART);
      free(YSTART);
      free(XNEW1);
      free(XNEW2);
      free(XNEW3);
      free(YNEW1);
      free(YNEW2);
      free(YNEW3);
      return 0;
    }   
  
  if(CLIPDEBUG==1)
    {
      printf("num=%d\n",*num);
      printf("DIDNT bail on poly:\n");
      for(i=0;i<*num;i++)
	{
	  printf("%lf %lf\n",XNEW4[i],YNEW4[i]);
	}
      printf("in clip llx: %lf lly: %lf urx: %lf ury: %lf\n",
	     llx,lly,urx,ury); 
    }
  
  for(i=0;i<*num;i++)
    {
      XNEW4[i] = XNEW4[i] - llx;
      YNEW4[i] = YNEW4[i] - lly;
    }


  

  

  free(XSTART);
  free(YSTART);
  free(XNEW1);
  free(XNEW2);
  free(XNEW3);
  free(YNEW1);
  free(YNEW2);
  free(YNEW3);
  return 2; 
}








void ReSetVertexList(int num)
{
  if(XNEW4!=NULL)
    {
      free(XNEW4);
    }

  if(YNEW4!=NULL)
    {
      free(YNEW4);
    }

  if(Drawpoints!=NULL)
    {
      free(Drawpoints);
    }

  XNEW4 = (double *)malloc(SzD * (num + 1010));
  if(XNEW4==NULL)
    {
      printf("ReSetVertexList: out of memory for %d!\n",num);
    }

  YNEW4 = (double *)malloc(SzD * (num + 1010));
  if(YNEW4==NULL)
    {
      printf("ReSetVertexList2: out of memory for %d!\n",num);
    }

  Drawpoints = (XPoint *) (malloc(sizeof(XPoint) * (num+1010)));
  if(Drawpoints==NULL)
    {
      printf("ReSetVertexList3: out of memory for %d!\n",num);
    }
}







int DetermineCircles(double X[], double Y[], int numnodes)
{
  
  

  short int tempx,tempy;
  int i,good_edges=0;
  double thisminx,thisminy,thismaxx,thismaxy;

  if(batch_mode==1)
    {
      return 0;
    }
  

  
  for(i=0;i<numnodes;i++)
    {	  
      XNEW4[i] = X[i] - llx_zoom;
      YNEW4[i] = Y[i] - lly_zoom;
    }
  
   
  for(i=0;i<numnodes;i++)
    {
      tempx = (short int)((int)(10.0+(XNEW4[i]/IRegionSize)*xunits));
      tempy = (short int)(height-(10.0+(YNEW4[i]/IRegionSize)*xunits));     
      
      Drawpoints[i].x = tempx;
      Drawpoints[i].y = tempy;
    }
  

 
  
  thisminx = Drawpoints[0].x;
  thisminy = Drawpoints[0].y;
  thismaxx = Drawpoints[0].x;
  thismaxy = Drawpoints[0].y;
  
  for(i=0;i<numnodes-1;i++)
    {	 
      if(Drawpoints[i].x<thisminx)
	{
	  thisminx = Drawpoints[i].x;
	}
      if(Drawpoints[i].y<thisminy)
	{
	  thisminy = Drawpoints[i].y;
	}
      if(Drawpoints[i].x>thismaxx)
	{
	  thismaxx = Drawpoints[i].x;
	}
      if(Drawpoints[i].x>thismaxx)
	{
	  thismaxx = Drawpoints[i].x;
	}
      if(EuclideanDistance((double)Drawpoints[i].x,(double)Drawpoints[i].y,
			   (double)Drawpoints[i+1].x,(double)Drawpoints[i+1].y)>SMALL)
	{
	  good_edges++;
	  break;
	}
    }
  if(EuclideanDistance((double)Drawpoints[0].x,(double)Drawpoints[0].y,
		       (double)Drawpoints[numnodes-1].x,(double)Drawpoints[numnodes-1].y)>SMALL)
    {
      good_edges++;
    }
  
  
  
  
  if(EuclideanDistance((double)thisminx,(double)thisminy,
		       (double)thismaxx,(double)thismaxy)>SMALL)
    {good_edges++;}

  if(good_edges==0)
    {
      return 1;
    }

  return 0;
}




short int GetPixelX(double x)
{
  return (short int)((int)  (10.0+((x - llx_zoom)/IRegionSize)*xunits));
}

short int GetPixelY(double y)
{
  return (short int)(height-(10.0+((y - lly_zoom)/IRegionSize)*xunits));
}


void ComputeOverAdjust(double x1,double y1,int *overadjustx,int *overadjusty)
{
   short int thisx,thisy;
   int i;
   
   thisx = GetPixelX(x1);
   thisy = GetPixelY(y1);

   for(i=0;i<NUM_LABEL_REMEMBER;i++)
   {
     if((thisx==RememberLabelX[i]) && (thisy==RememberLabelY[i]))
	 {
        
		*overadjustx = 0;
		*overadjusty = 11 * RememberLabelDepth[i]; 
	 }
   }
}


void RememberLabelPixel(unsigned short int addx,unsigned short addy)
{
  int i; 

  if(addx>=10000)
  {
    if(NUM_LABEL_REMEMBER>0)
	{
      for(i=0;i<NUM_LABEL_REMEMBER_MAX;i++)
	  {
        RememberLabelDepth[i] = 0;
	  }
      NUM_LABEL_REMEMBER = 0;
	}
	return;
  }


  for(i=0;i<NUM_LABEL_REMEMBER;i++)
  {
    if((RememberLabelX[i]==addx)&&(RememberLabelY[i]==addy))
	{
      if(RememberLabelDepth[i]<20)
	  {
        RememberLabelDepth[i] = RememberLabelDepth[i] + 1;
	  }
	  return;
	}
  }

  

  RememberLabelX    [NUM_LABEL_REMEMBER] = addx;
  RememberLabelY    [NUM_LABEL_REMEMBER] = addy;
  RememberLabelDepth[NUM_LABEL_REMEMBER] = 1;
  NUM_LABEL_REMEMBER = NUM_LABEL_REMEMBER + 1;

}



void ChooseLabel(double x, double y, char *thestr, int color,
				double *lastx,double *lasty,int Lindex, int PLAG)
{
  int doit=0,totalmodules=((MaxXindex+1)*(MaxYindex+1));
  short int newxpix,newypix;
  double thisdist;
  extern int POINT_LABELS_DRAWN,LINE_LABELS_DRAWN,AREA_LABELS_DRAWN,GRID_LABELS_DRAWN,GRID_LABEL_DRAW_OVERRIDE;


  


  if((ATTRTYPE_TREX())&&(xunits<1000000))
  {
	
	return;
  }

  if((xunits<10000)&&(totalmodules>100))
  {
    return;
  }

  if(DRAW_LABELS==0)
  {
    
    return;
  }


  if(Lindex!=DRAW_NOW)
  {
    if(LODindex_DYN[LODindex[CrsWlk[Lindex].LODband-1].other_index].geom==C_GRID)
	{
	  if(PLAG!=4)
	  {
		
        return;
	  }

	  
      
	}

	if(ATTRTYPE_TREX())
	{
      y = y + (IRegionSize/xunits)*10;
	}
  }



  if(PLAG==1)
  {
    if(POINT_LABELS_DRAWN> (50*LABEL_VOLUME)  )  
	{
      
	  return;
	}
  }
  if(PLAG==2)
  {
    if(LINE_LABELS_DRAWN>  (50*LABEL_VOLUME)  )  
	{
      
	  return;
	}
  }
  if(PLAG==3)
  {
    if(AREA_LABELS_DRAWN>  (50*LABEL_VOLUME)  )  
	{
      
	  return;
	}
  }
  if(PLAG==4)
  {
    if((GRID_LABELS_DRAWN>250)&&(GRID_LABEL_DRAW_OVERRIDE==0))
	{
      
	  return;
	}
  }


  newxpix = GetPixelX(x);
  newypix = GetPixelY(y);


  if((newxpix>=10)&&(newypix>=60)&&(newxpix<=990)&&(newypix<=840))  
  {

    if(
        (PLAG==1) || (PLAG==4) ||             
		((*lastx<0)&&(*lasty<0)) 
	  )
	{
      doit = 1;
	}
    else
	{
      

      thisdist = EuclideanDistance(*lastx,*lasty,newxpix,newypix);
	
      if(thisdist> (LABEL_PROXIMITY*100) )  
	  { 
	    
        doit = 1;
	  } 
	  else
	  { 
        
	  } 
	} 
  }

  if(doit==1)
  {

    *lastx = newxpix;
    *lasty = newypix;

    MAPdrawstring(x,y,thestr,color,0,Lindex,1);

	if(LABEL_OK==1)
	{
	  RememberLabelPixel(newxpix,newypix);

      if(PLAG==1)
	  {  
        POINT_LABELS_DRAWN = POINT_LABELS_DRAWN + 1;
	  } 
      else if((PLAG==2)||(LINE_TYPE_ONLY==1))  
	  {  
        LINE_LABELS_DRAWN = LINE_LABELS_DRAWN + 1;
	  }  
      else if(PLAG==3)
	  {  
        AREA_LABELS_DRAWN = AREA_LABELS_DRAWN + 1;
	  }  
      else if(PLAG==4)
	  {  
        GRID_LABELS_DRAWN = GRID_LABELS_DRAWN + 1;
	  }  
      
	  
	}
  }


}


void MAPdrawfullline(double X[],double Y[],int numnodes,int color, int Lindex)
{
  int i,sendcolor;
  int drawc=0;
  int saveval=NO_CIRCLES;
  double x1,y1,x2,y2,x3,y3,x4,y4,lineangle,endangle1,endangle2,mypi=3.1415926535,mylen,lastx,lasty;
  char thestr[200];

  if((running==1)&&(API_DRAW==0))
  {
	  BadDraw("MAPdrawfullline");
	  return;
  }

  if(batch_mode==1)
    {
      return;
    }

  if(numnodes<1)
    {
      return;
    }

  
  if((color==1)||(color==2)||(color==2000))
    {
      if(numnodes>MAXVERTSFOUND)
	{
	  ReSetVertexList(numnodes);
	  MAXVERTSFOUND = numnodes + 1000;
	}     
      drawc = DetermineCircles(X,Y,numnodes);
    }
  
  
  if(drawc==0)
    {
      NO_CIRCLES = 1;
    }


  if((SHOW_LINE_VERTICES==1)&&(LINE_SHAPE==4))
  {
	mylen = (double)((double)(IRegionSize*10.0/xunits));
 

    if(LINE_COLOR==999)
	{
      sendcolor = color;
	}
	else
	{
      sendcolor = LINE_COLOR;
	}
	

    for(i=1;i<numnodes; i++)
	{
      x1 = X[i-1];
      y1 = Y[i-1];
      x2 = X[i];
      y2 = Y[i];

	  if(
		  (fabs(y2-y1)<0.000000001) &&
		  (fabs(x2-x1)<0.000000001)
		  )
	  {
        continue;
	  }

	  if(fabs(y2-y1)<0.000000001)
	  {
        lineangle = 0.0;
	  }
	  else if(fabs(x2-x1)<0.000000001)
	  {
        lineangle = mypi/2.0;
	  }
	  else
	  {
        lineangle = atan((y2-y1)/(x2-x1));
	  }

	  endangle1 = lineangle + 45.0 * mypi/180.0;
	  endangle2 = lineangle - 45.0 * mypi/180.0;

	  if(x1>x2)
	  {
        x3 = x2 + mylen * cos(endangle1);
        x4 = x2 + mylen * cos(endangle2);
        y3 = y2 + mylen * sin(endangle1);
        y4 = y2 + mylen * sin(endangle2);
	  }
	  else if(x1<x2)
	  {
        x3 = x2 - mylen * cos(endangle1);
        x4 = x2 - mylen * cos(endangle2);
        y3 = y2 - mylen * sin(endangle1);
        y4 = y2 - mylen * sin(endangle2);
	  }
	  else if(x1==x2)
	  {
        if(y1>y2)
		{
          x3 = x2 + mylen*.7;
		  x4 = x2 - mylen*.7;
		  y3 = y2 + mylen*.7;
		  y4 = y2 + mylen*.7;
		}
		else
		{
          x3 = x2 + mylen*.7;
		  x4 = x2 - mylen*.7;
		  y3 = y2 - mylen*.7;
		  y4 = y2 - mylen*.7;
		}
	  }
	  else
	  {
        printf("boink!\n");
		continue;
	  }


  	  MAPdrawline(0,x2,y2,x3,y3,sendcolor,Lindex);
  	  MAPdrawline(0,x2,y2,x4,y4,sendcolor,Lindex);
  	  MAPdrawline(0,x3,y3,x4,y4,sendcolor,Lindex);

	}
  }



  if((DRAW_LINE_LABELS==1)&&(Lindex!=DRAW_NOW))
  {
	lastx = -1;
	lasty = -1;

    for(i=1;i<=numnodes;i++)
	{
      if(i==numnodes)
	  {
		 if((X[i-1]==X[0])&&(Y[i-1]==Y[0]))
		 {
          
          break;
		 } 
	
		 
		 
	  }

      sprintf(thestr,"%s",GetECCLabel(SCCtable[CrsWlk[Lindex].LtoSmapping].ECC));
      ChooseLabel(X[i-1],Y[i-1],thestr,color,&lastx,&lasty,Lindex,2);
	}
  }


  if(SHOW_LINE_VERTICES==1)
  {   
    for(i=1; i<numnodes; i++)
	{
	  MAPdrawline(4,X[i-1],Y[i-1],X[i],Y[i],color,Lindex);
	}
    if(SHOW_END_VERTICES==1)
	{
	  MAPdrawline(1,X[0],Y[0],X[1],Y[1],color,Lindex);
	  MAPdrawline(2,X[numnodes-2],Y[numnodes-2],X[numnodes-1],Y[numnodes-1],color,Lindex);	
	}

    if((DRAWING_INFO_ITEM==1)&&(DRAW_VERTICES==1))
	{
	  for(i=1;i<=numnodes;i++)
	    {
	      sprintf(thestr,"%d",i);
	      MAPdrawstring(X[i-1],Y[i-1],thestr,color,0,DRAW_NOW,0);
	    }
	}
  }
  else
  {
    LINE_TYPE_ONLY = 1;
    MAPdrawpoly(numnodes,X,Y,color,1,1,1,Lindex);
    LINE_TYPE_ONLY = 0;

    if(SHOW_END_VERTICES==1)
	{
	  
	  MAPdrawline(1,X[0],Y[0],X[1],Y[1],color,Lindex);
	  MAPdrawline(2,X[numnodes-2],Y[numnodes-2],X[numnodes-1],Y[numnodes-1],color,Lindex);
	}
  }

  NO_CIRCLES = saveval;
}



int DrawAreaFilled(int Lindex)
{

  if(LODindex_DYN[LODindex[CrsWlk[Lindex].LODband-1].other_index].draw_style==1)
    {
      return 0; 
    }
  
  return 1;
}



int DrawGridShaded(int Lindex)
{

  


  if(LODindex_DYN[LODindex[CrsWlk[Lindex].LODband-1].other_index].draw_style==0)
    {
      return 1; 
    }
  else if(LODindex_DYN[LODindex[CrsWlk[Lindex].LODband-1].other_index].draw_style==1)
    {
      return 1; 
    }

  return 2; 
}



void SetShadedColor(int color)
{
  if((color>=100)&&(color<=165))
    {
      if(USE_GREY==1)
	  {
        XSetForeground(mydisplay,mygc,col[(color-100)*4]);
	  }
      else if(USE_GREY==2)
	  {
        XSetForeground(mydisplay,mygc,col2[(color-100)*4]);
	  }
      else if(USE_GREY==3)
	  {
        XSetForeground(mydisplay,mygc,col3[(color-100)*4]);
	  }
      if(USE_GREY==4)
	  {
        XSetForeground(mydisplay,mygc,col4[(color-100)*4]);
	  }
    }
  else
  {
    printf("bad C %d to SSC\n",color);
  }

}



void PrepareForGridMasking(int gridnum,long int fileposn, int LODband, int reset, int setmask)
{

  char filename[1000];


  

  


  if(gridnum==1)
  {
    sprintf(filename,"%sgrid.bin",indirectory);
  } 
  else
  {
    sprintf(filename,"%sgrid%d.bin",indirectory,gridnum);
  } 


  

  if(global_mask_allocced==0)
  {
    global_mask_bitmap =
	    XCreatePixmap (XtDisplay (drawing_a),
					 RootWindowOfScreen (XtScreen (drawing_a)), width, height,
					 1);  
    global_mask_allocced = 1;
  } 


  

  if(reset==1)
  {
    
    XSetForeground(mydisplay,mybitgc,BITBLACK);
    XFillRectangle (XtDisplay (drawing_a), global_mask_bitmap, mybitgc, 0, 0, width, height);
  }

  

  XSetForeground(mydisplay,mybitgc,BITWHITE);

  
  


  


  
  DrawShadedGrid(filename,fileposn);



  if(setmask==1)
  {
    XSetClipMask(mydisplay,   mygc,global_mask_bitmap);
    XSetClipMask(mydisplay,   mybitgc,global_mask_bitmap);
  }

  

}


void EndGridMasking()
{
  XSetClipMask  (mydisplay,mygc,None);
  XSetClipMask  (mydisplay,mybitgc,None);

  XSetClipOrigin(mydisplay,mygc, 0,  0);
  XSetClipOrigin(mydisplay,mybitgc, 0,  0);
}




void MAPdrawpoly(int num,
		 double X[],double Y[],
		 int color,int convex,int clip,int thickness, int Lindex)
{
  int i,old[3],gridtype=0;
  int good_edges=0;
  double thisminx,thisminy,thismaxx,thismaxy,lastx,lasty;
  int oldnum=num;
  int addindex;
  short int tempx,tempy;
  int cleanit = 0;
  int cliptest;
  char thestr[200];
  int rendering_priority=-1;
  int draw_style;
  extern int OVERRIDE_GRID_STYLE;

  draw_style = 1; 



  if(Lindex!=DRAW_NOW)
    {

	  if(color==1)
	  {
		
		rendering_priority = MAX_RENDER_PRI;
	  }
	  else
	  {
        rendering_priority = LODindex_DYN[LODindex[CrsWlk[Lindex].LODband-1].other_index].draw_priority - 1;
	  }
      draw_style         = LODindex_DYN[LODindex[CrsWlk[Lindex].LODband-1].other_index].draw_style;
      
      if(draw_style==0)
	  {
	   	  draw_style = 5;
	  }

      LODS_USED[rendering_priority] = 1;
      
    }





  if(Lindex!=DRAW_NOW)
    {
      
      
      if(LODindex_DYN[LODindex[CrsWlk[Lindex].LODband-1].other_index].geom!=C_GRID)
	{
	  if(DO_OVERRIDE==1)
	    {
	      if(OVERRIDING_STYLE>0)
		{
		  draw_style = OVERRIDING_STYLE;
		}
	    }
	}
    }
  else if(DO_OVERRIDE==1)
    {
      
      if(OVERRIDING_STYLE>0)
	{
	  draw_style = OVERRIDING_STYLE;
	}
    }


  if(OVERRIDE_GRID_STYLE>=0)
  {
    
    draw_style = OVERRIDE_GRID_STYLE; 
  }


  if((batch_mode==1)&&(SpecialMapdrawPoly==0))
    {
      return;
    }

  if((running==1)&&(API_DRAW==0))
  {
	  BadDraw("MAPdrawpoly");
	  return;
  }

  
  if(num<1)
    {
      return;
    }

  if((color==2)||(color==2000))
    {
      periodic_redraw();
    }

  if((color==1)||(color==2))
    {
      thickness = 2;
    }


  if(num>MAXVERTSFOUND)
    {
      ReSetVertexList(num);
      MAXVERTSFOUND = num + 1000;
    }
  
 
  if(color==2000)
    {
      color = 1;
    }




  

  if(LINE_TYPE_ONLY==1)
    {
      if(cliplines(
		   X,Y,                                 
		   num,
		   llx_zoom,lly_zoom,                   
		   llx_zoom+(980.0/xunits)*IRegionSize, 
		   lly_zoom+(780.0/yunits)*IRegionSize  
		   )!=1)
	{
	  
	  
	  
	  for(i=1; i<num; i++)
	    {
	      MAPdrawline(0,X[i-1],Y[i-1],X[i],Y[i],color,Lindex);
	    }
	  MAPdrawline(1,X[0],Y[0],X[1],Y[1],color,Lindex);
	  MAPdrawline(2,X[i-2],Y[i-2],X[i-1],Y[i-1],color,Lindex);		
	  
	  if((DRAWING_INFO_ITEM==1)&&(DRAW_VERTICES==1))
	    {
	      for(i=1;i<=num;i++)
		{
		  sprintf(thestr,"%d",i);
		  MAPdrawstring(X[i-1],Y[i-1],thestr,color,0,DRAW_NOW,0);
		}
	    }  
	  return;
	}
    }
  else
    {
      cliptest = 
	clipit(
	       X,Y,                                 
	       &num,                                
	       llx_zoom,lly_zoom,                   
	       llx_zoom+(980.0/xunits)*IRegionSize, 
	       lly_zoom+(780.0/yunits)*IRegionSize  
	       );

      if(cliptest==0)
	{
	  return;
	}

      if(cliptest==2)
	{
	  cleanit = 1;
	}
    }
  


  
  
  
  
  Drawpoints[0].x = (short int)((int)(10.0+(XNEW4[0]/IRegionSize)*xunits));
  Drawpoints[0].y = (short int)(height-(10.0+(YNEW4[0]/IRegionSize)*xunits));     
  
  addindex = 1;
  
  for(i=1;i<num;i++)
    {
      tempx = (short int)((int)(10.0+(XNEW4[i]/IRegionSize)*xunits));
      tempy = (short int)(height-(10.0+(YNEW4[i]/IRegionSize)*xunits));     
      
      if(
	 (Drawpoints[addindex-1].x!=tempx) ||
	 (Drawpoints[addindex-1].y!=tempy) ||
	 (DRAWING_MARKERS==1)
	 )
	{
	  Drawpoints[addindex].x = tempx;
	  Drawpoints[addindex].y = tempy;
	  addindex = addindex + 1;
	}
    }

  num = addindex;



  if(SpecialMapdrawPoly==1)
  {      

    AllocateExtraColors();

    SetShadedColor(color);

    if(GLOBAL_activelayer==1)
	{
      if(GLOBAL_draw==1)
	  { 
	    

        XFillPolygon(mydisplay,pixmap,mygc,Drawpoints,num,Convex,CoordModeOrigin);
	  } 
      else
	  { 
        

        XFillPolygon(mydisplay,pixmap2,mygc,Drawpoints,num,Convex,CoordModeOrigin);
	  } 
	}

    if(GLOBAL_needextrapixmap==1)
	{ 
      

      XFillPolygon(mydisplay,over_pixmap,mygc,Drawpoints,num,Convex,CoordModeOrigin);
	} 
      
    if((GLOBAL_showlayers==1)&&(GLOBAL_activelayer==1))
	{ 
      

      XFillPolygon(mydisplay,mywindow,mygc,Drawpoints,num,Convex,CoordModeOrigin);
	} 
    return;
  }  
  


  if(RETURN_VERTS==1)  
    {
      

      num_hole_points = num;
      hole_points = (XPoint *)malloc(sizeof(XPoint)*num);
      for(i=0;i<num;i++)
	{
	  hole_points[i].x = Drawpoints[i].x;
	  hole_points[i].y = Drawpoints[i].y;
	}
      
      return;
    }



  if(DRAWING_MARKERS==1)
    {
	  

      if(
		  ((Drawpoints[2].x - Drawpoints[0].x)<7) &&
		  ((Drawpoints[3].y - Drawpoints[1].y)<7)
		)
	  {
	   Drawpoints[0].x = Drawpoints[0].x - 3;
	   Drawpoints[2].x = Drawpoints[2].x + 3;
	   Drawpoints[1].y = Drawpoints[1].y - 3;
	   Drawpoints[3].y = Drawpoints[3].y + 3;
	  }
    }
  

  


  
  
  if((color==1)||(color==2))
    {
      thisminx = Drawpoints[0].x;
      thisminy = Drawpoints[0].y;
      thismaxx = Drawpoints[0].x;
      thismaxy = Drawpoints[0].y;

      for(i=0;i<num-1;i++)
	{	 
	  if(Drawpoints[i].x<thisminx)
	    {
	      thisminx = Drawpoints[i].x;
	    }
	  if(Drawpoints[i].y<thisminy)
	    {
	      thisminy = Drawpoints[i].y;
	    }
	  if(Drawpoints[i].x>thismaxx)
	    {
	      thismaxx = Drawpoints[i].x;
	    }
	  if(Drawpoints[i].x>thismaxx)
	    {
	      thismaxx = Drawpoints[i].x;
	    }
	  if(EuclideanDistance((double)Drawpoints[i].x,(double)Drawpoints[i].y,
		      (double)Drawpoints[i+1].x,(double)Drawpoints[i+1].y)>SMALL)
	    {
	      good_edges++;
	      break;
	    }
	}
      if(EuclideanDistance((double)Drawpoints[0].x,(double)Drawpoints[0].y,
		  (double)Drawpoints[num-1].x,(double)Drawpoints[num-1].y)>SMALL)
	{good_edges++;}


      

      if(EuclideanDistance((double)thisminx,(double)thisminy,
		  (double)thismaxx,(double)thismaxy)>SMALL)
	{good_edges++;}
    }


  
  if(NO_CIRCLES==0)
    {
      if(((color==1)||(color==2))&&(good_edges==0))
	{
	  for(i=0;i<num;i++)
	    {
	      if(i>2)continue;  
	      
	      MAPdrawcircle(X[i],Y[i],CIRCLESIZE,1,Lindex); 
	    }
	}
    }


  
  if(COLOR_ALREADY_SET==0) 
  {
    if((color>=100)&&(color<=165))
    {
      

	  SetShadedColor(color);
	  
    }
  else if((SPECIAL_COND_COLOR>0)&&(color==1))
  {
    XSetForeground(mydisplay,mygc,mycolors[SPECIAL_COND_COLOR]);
  }
  else
	{ 
      XSetForeground(mydisplay,mygc,mycolors[color]);
	} 
  }


  if(thickness>1)
    {
      MySetLineThickness(thickness);
    }



  if (LINE_TYPE_ONLY==1)
    {
      

      if(Lindex==DRAW_NOW)
	{

	  XDrawLines(mydisplay,mywindow,mygc,Drawpoints,num,CoordModeOrigin);   
	  XDrawLines(mydisplay,pixmap,mygc,Drawpoints,num,CoordModeOrigin);

	  if((DRAWING_ERRORS==1)&&(color==1))
	    {
	      for(i=1;i<num;i++)
		{
		  RememberCondition(Drawpoints[i-1].x,Drawpoints[i-1].y,Drawpoints[i].x,Drawpoints[i].y,1);
		}
	    }
	}
      else
	{
	  XDrawLines(mydisplay,DRAWING_PIXMAPS[rendering_priority],mygc,Drawpoints,num,CoordModeOrigin);
	  XDrawLines(mydisplay,DRAWING_CLIPMAPS[rendering_priority],mybitgc,Drawpoints,num,CoordModeOrigin);
	}
    }
  else if (LINE_TYPE_ONLY==2)
    {
      

      Drawpoints[num].x = Drawpoints[0].x;
      Drawpoints[num].y = Drawpoints[0].y;
      
      if((Lindex==DRAW_NOW)||(color<17))
	{
	  XDrawLines(mydisplay,mywindow,mygc,Drawpoints,num+1,CoordModeOrigin);   
	  XDrawLines(mydisplay,pixmap,mygc,Drawpoints,num+1,CoordModeOrigin);
	  
	  if((DRAWING_ERRORS==1)&&(color==1))
	    {
	      for(i=1;i<num+1;i++)
		{
		  RememberCondition(Drawpoints[i-1].x,Drawpoints[i-1].y,Drawpoints[i].x,Drawpoints[i].y,1);
		}
	    }
	}
      else
	{
	  Drawpoints[num].x = Drawpoints[0].x;
	  Drawpoints[num].y = Drawpoints[0].y;
	  
	  XDrawLines(mydisplay,DRAWING_PIXMAPS[rendering_priority],mygc,Drawpoints,num+1,CoordModeOrigin);
	  XDrawLines(mydisplay,DRAWING_CLIPMAPS[rendering_priority],mybitgc,Drawpoints,num+1,CoordModeOrigin);
	}
    }
  else
    {

      switch(draw_style)
	{
	case 1: 
	  break;
	case 2: 
	  XSetStipple   (mydisplay,mygc,stipmap_lgt);
	  XSetFillStyle (mydisplay,mygc,FillStippled);
	  XSetStipple   (mydisplay,mybitgc,stipmap_lgt);
	  XSetFillStyle (mydisplay,mybitgc,FillStippled);
	  break;
	case 3: 
	  XSetStipple   (mydisplay,mygc,stipmap_avg);
	  XSetFillStyle (mydisplay,mygc,FillStippled);
	  XSetStipple   (mydisplay,mybitgc,stipmap_avg);
	  XSetFillStyle (mydisplay,mybitgc,FillStippled);
	  break;
	case 4: 
	  XSetStipple   (mydisplay,mygc,stipmap_hvy);
	  XSetFillStyle (mydisplay,mygc,FillStippled);
	  XSetStipple   (mydisplay,mybitgc,stipmap_hvy);
	  XSetFillStyle (mydisplay,mybitgc,FillStippled);
	  break;
	case 5: 
	  break;
	case 6: 
	  XSetStipple   (mydisplay,mygc,stipmapstypes[0]);
	  XSetFillStyle (mydisplay,mygc,FillStippled);
	  XSetStipple   (mydisplay,mybitgc,stipmapstypes[0]);
	  XSetFillStyle (mydisplay,mybitgc,FillStippled);
	  break;
	case 7: 
	  XSetStipple   (mydisplay,mygc,stipmapstypes[1]);
	  XSetFillStyle (mydisplay,mygc,FillStippled);
	  XSetStipple   (mydisplay,mybitgc,stipmapstypes[1]);
	  XSetFillStyle (mydisplay,mybitgc,FillStippled);
	  break;
	case 8: 
	  XSetStipple   (mydisplay,mygc,stipmapstypes[2]);
	  XSetFillStyle (mydisplay,mygc,FillStippled);
	  XSetStipple   (mydisplay,mybitgc,stipmapstypes[2]);
	  XSetFillStyle (mydisplay,mybitgc,FillStippled);
	  break;
	case 9: 
	  XSetStipple   (mydisplay,mygc,stipmapstypes[3]);
	  XSetFillStyle (mydisplay,mygc,FillStippled);
	  XSetStipple   (mydisplay,mybitgc,stipmapstypes[3]);
	  XSetFillStyle (mydisplay,mybitgc,FillStippled);
	  break;
	case 10: 
	  XSetStipple   (mydisplay,mygc,stipmapstypes[5]);
	  XSetFillStyle (mydisplay,mygc,FillStippled);
	  XSetStipple   (mydisplay,mybitgc,stipmapstypes[5]);
	  XSetFillStyle (mydisplay,mybitgc,FillStippled);
	  break;
	case 11: 
	  XSetStipple   (mydisplay,mygc,stipmapstypes[4]);
	  XSetFillStyle (mydisplay,mygc,FillStippled);
	  XSetStipple   (mydisplay,mybitgc,stipmapstypes[4]);
	  XSetFillStyle (mydisplay,mybitgc,FillStippled);
	  break;
	case 12: 
	  XSetStipple   (mydisplay,mygc,stipmapstypes[6]);
	  XSetFillStyle (mydisplay,mygc,FillStippled);
	  XSetStipple   (mydisplay,mybitgc,stipmapstypes[6]);
	  XSetFillStyle (mydisplay,mybitgc,FillStippled);
	  break;
	case 13: 
	  XSetStipple   (mydisplay,mygc,stipmapstypes[7]);
	  XSetFillStyle (mydisplay,mygc,FillStippled);
	  XSetStipple   (mydisplay,mybitgc,stipmapstypes[7]);
	  XSetFillStyle (mydisplay,mybitgc,FillStippled);
	  break;
	default:
	  printf("(2) should not be in default fill style.  draw_style: %d lindex %d color %d\n",
		  draw_style,Lindex,color);
	}
      
      
      
      
      if(((color>=100)&&(color<=165)) || ((color<17)&&(Lindex==DRAW_NOW)))
	{
	  

	  if(DRAWING_INFO_ITEM==0)
	    {
	      XSetFillStyle(mydisplay,mygc,FillSolid);
	      XSetFillStyle(mydisplay,mybitgc,FillSolid);
	    }

	}
      
      
      
      if( ((color>17)             &&(draw_style!=1))  || 
		  ((rendering_priority==5)&&(draw_style!=1))
		  )
	{
	  
	  
	  
	  

	  if(PROCESS_GRID_VALUES==1)
	  {
        


        


	    XFillPolygon(mydisplay,global_mask_bitmap,mybitgc,
		     Drawpoints,num,Nonconvex,CoordModeOrigin);


	  }
	  else
	  {
	    XFillPolygon(mydisplay,DRAWING_PIXMAPS[rendering_priority],mygc,
		     Drawpoints,num,Nonconvex,CoordModeOrigin);
	    
	    XFillPolygon(mydisplay,DRAWING_CLIPMAPS[rendering_priority],mybitgc,
		     Drawpoints,num,Nonconvex,CoordModeOrigin);
	  }

	}
      else if(DRAWING_INFO_ITEM==1)
	{
	  if(draw_style!=1)
	    {
	      
	      XFillPolygon(mydisplay,mywindow,mygc,Drawpoints,num,Nonconvex,CoordModeOrigin);
	      XFillPolygon(mydisplay,pixmap,mygc,Drawpoints,num,Nonconvex,CoordModeOrigin);
	    }
	}

      
   
      XSetFillStyle (mydisplay,mygc,   FillSolid);
      XSetFillStyle (mydisplay,mybitgc,FillSolid);
      
      
      
      if( 
	 (gridtype==0)  &&  ((color<100)||(color>165))
	 )
	{
	  Drawpoints[num].x = Drawpoints[0].x;
	  Drawpoints[num].y = Drawpoints[0].y;
	  
	  if(Lindex==DRAW_NOW)
	    {
	      
	      XDrawLines(mydisplay,pixmap,  mygc,Drawpoints,num+1,CoordModeOrigin);
	      XDrawLines(mydisplay,mywindow,mygc,Drawpoints,num+1,CoordModeOrigin);
	      
	      if((DRAWING_ERRORS==1)&&(color==1))
		  {
		   for(i=1;i<(num+1);i++)
		    {
		      RememberCondition(Drawpoints[i-1].x,Drawpoints[i-1].y,Drawpoints[i].x,Drawpoints[i].y,1);
		    }
		  }
	    }
	  else
	    {
	      XDrawLines(mydisplay,DRAWING_PIXMAPS[rendering_priority],mygc,Drawpoints,num+1,CoordModeOrigin);
	      XDrawLines(mydisplay,DRAWING_CLIPMAPS[rendering_priority],mybitgc,Drawpoints,num+1,CoordModeOrigin);
	    }
	}
    }
  
  
  
  if(cleanit==1)
    {
      
      CleanScreen();
    }
  

  

  if((LINE_TYPE_ONLY!=1)&&(DRAW_AREA_LABELS==1)&&(Lindex!=DRAW_NOW)) 
  {
    
	lastx = -1;
	lasty = -1;

    for(i=1;i<=oldnum;i++)
	{
      sprintf(thestr,"%s",GetECCLabel(SCCtable[CrsWlk[Lindex].LtoSmapping].ECC));
      ChooseLabel(X[i-1],Y[i-1],thestr,color,&lastx,&lasty,Lindex,3);
	}
  }



  if((LINE_TYPE_ONLY==0)||(LINE_TYPE_ONLY==2))
    {
      
      if(SHOW_POLY_VERTICES==1)
	{

	  old[0] = SHOW_POLY_VERTICES;
	  old[1] = SHOW_LINE_VERTICES;
	  old[2] = SHOW_END_VERTICES;
	  SHOW_POLY_VERTICES = 0;
	  SHOW_LINE_VERTICES = 0;
	  SHOW_END_VERTICES  = 0;
	  
	  for(i=0;i<oldnum;i++)
	    {
          DRAW_LABELS = 0;

          if(Lindex!=DRAW_NOW)
		  { 
            
      
            if(LODindex_DYN[LODindex[CrsWlk[Lindex].LODband-1].other_index].geom==C_GRID)
			{
              break;
			}
		  }

	      if(POLY_SHAPE==0)
		{
		  if(POLY_COLOR!=999)
		    {
		      MAPdrawTri(X[i],Y[i],POLY_COLOR,Lindex);
		    }
		  else
		    {
		      MAPdrawTri(X[i],Y[i],color,Lindex);
		    }
		}
	      else if(POLY_SHAPE==1)
		{
		  if(POLY_COLOR!=999)
		    {
		      MAPdrawStar(X[i],Y[i],MY2DSENTINEL,POLY_COLOR,Lindex,1);

		    }
		  else
		    {
		      MAPdrawStar(X[i],Y[i],MY2DSENTINEL,color,Lindex,1);
		    }
		}
	      else if(POLY_SHAPE==2)
		{
		  if(POLY_COLOR!=999)
		    {
		      MAPdrawX(X[i],Y[i],POLY_COLOR,Lindex);
		    }
		  else
		    {
		      MAPdrawX(X[i],Y[i],color,Lindex);
		    }
		}
	      else if(POLY_SHAPE==3)
		{
		  if(POLY_COLOR!=999)
		    {
		      MAPdrawcircle(X[i],Y[i],CIRCLESIZE,-1*POLY_COLOR,Lindex);
		    }
		  else
		    {
		      MAPdrawcircle(X[i],Y[i],CIRCLESIZE,-1*color,Lindex);
		    }
		}
	    }
	  SHOW_POLY_VERTICES = old[0];
	  SHOW_LINE_VERTICES = old[1];
	  SHOW_END_VERTICES  = old[2];
	}
      
      polycount++;
      
      if((polycount%POLYCHUNK)==0)
	{
	  FlushMainScreen(POLY_LIMIT);
	}
    }
  else
    {
      linecount++;
      if((linecount%LINECHUNK)==0)
	{
	  FlushMainScreen(LINE_LIMIT);
	}
    }
  
  XSetForeground(mydisplay,mygc,mycolors[DRAW_COLOR_BLACK]);
  
  if(thickness>1)
    {
      MySetLineThickness(0);
    }


  DRAW_LABELS = 1;


  if((DRAWING_INFO_ITEM==1)&&(DRAW_VERTICES==1))
    {
      for(i=1;i<=oldnum;i++)
	{
	  sprintf(thestr,"%d",i);
	  MAPdrawstring(X[i-1],Y[i-1],thestr,color,0,DRAW_NOW,0);
	}
    }
}











void MAPdrawX(double x1,double y1,int color, int Lindex)
{
  char thestr[200];
  double halfxlen,junk;
 
  


  
      
  if(batch_mode==1){return;}

  if((running==1)&&(API_DRAW==0))
  {
	  BadDraw("MAPdrawX");
	  return;
  }

  if(xunits==0){printf("mapdrawX got xunits==0!\n"); XBell(mydisplay,50); }

  halfxlen = (IRegionSize*5.0)/xunits;

  NO_CIRCLES = 1;

  if((DRAW_POINT_LABELS==1)&&(Lindex!=DRAW_NOW))
  {
    sprintf(thestr,"%s",GetECCLabel(SCCtable[CrsWlk[Lindex].LtoSmapping].ECC));
    ChooseLabel(x1,y1,thestr,color,&junk,&junk,Lindex,1);
  }


  MySetLineThickness(2);

  MAPdrawline(-1,x1-halfxlen,y1-halfxlen,x1+halfxlen,y1+halfxlen,color,Lindex);

  MAPdrawline(-1,x1-halfxlen,y1+halfxlen,x1+halfxlen,y1-halfxlen,color,Lindex);

  MySetLineThickness(0);
  
  NO_CIRCLES = 0;
}



void MAPdrawTri(double x1,double y1,int color, int Lindex)
{
  double X[3],Y[3];
  int temp,temp2,temp3,temp4;

  


  

  if(batch_mode==1){return;}

  if((running==1)&&(API_DRAW==0))
  {
	  BadDraw("MAPdrawtri");
	  return;
  }

  if(xunits==0){printf("mapdrawTri got xunits==0!\n"); XBell(mydisplay,50); }
	     
  X[0] = (double)(x1-(double)(IRegionSize*10.0/xunits));
  Y[0] = (double)(y1-(double)(IRegionSize*9.0/yunits));
  X[1] = (double)(x1+(double)(IRegionSize*10.0/xunits));
  Y[1] = (double)(y1-(double)(IRegionSize*9.0/yunits));
  X[2] = (double)(x1);
  Y[2] = (double)(y1+(double)(IRegionSize*9.0/yunits));
  
  temp  = OVERRIDING_STYLE;
  temp2 = DO_OVERRIDE;
  temp3 = DRAW_VERTICES;
  temp4 = SHOW_POLY_VERTICES;

  DO_OVERRIDE        = 1;
  OVERRIDING_STYLE   = 1; 
  DRAW_VERTICES      = 0;
  SHOW_POLY_VERTICES = 0;

  MAPdrawpoly(3,X,Y,color,1,1,1,Lindex);

  OVERRIDING_STYLE   = temp;
  DO_OVERRIDE        = temp2;
  DRAW_VERTICES      = temp3;
  SHOW_POLY_VERTICES = temp4;
}



void MAPdrawStar(double x1,double y1,double z1,int color,int Lindex,int type)
{
  char thestr[500];
  int temp,old[3];
  double halfxlen,length,junk;

  


  

  if(batch_mode==1){return;}

  if((running==1)&&(API_DRAW==0))
  {
	  BadDraw("MAPdrawstar");
	  return;
  }

  if(xunits==0){printf("mapdrawStar got xunits==0!\n"); XBell(mydisplay,50); }

  NO_CIRCLES = 1;

  old[0] = SHOW_POLY_VERTICES;
  old[1] = SHOW_LINE_VERTICES;
  old[2] = SHOW_END_VERTICES;
  SHOW_POLY_VERTICES = 0;
  SHOW_LINE_VERTICES = 0;
  SHOW_END_VERTICES  = 0;



  temp = DRAW_LABELS;

  if((DRAW_GRID_LABELS==1)&&(Lindex!=DRAW_NOW))
  {
    if((CrsWlk[Lindex].geomtype==C_GRID)&&(type>1))
	{
      


	  if(type==2)
	  {
	    sprintf(thestr,"%.2lf",z1);
	  }
	  else if(type==3)
	  {

	    if(
			(strstr(LODindex[CrsWlk[Lindex].LODband-1].filename,"TDF / ")) &&
			(strstr(LODindex[CrsWlk[Lindex].LODband-1].filename," Difference"))
		  )
		{ 
	      sprintf(thestr,"TDF/Ref Diff: %.2lf",z1);
		}
	    else if(!strcmp(LODindex[CrsWlk[Lindex].LODband-1].filename,"TREx DEM Finished"))
		{ 
	      sprintf(thestr,"Finished DEM: %.2lf",z1);
		} 
	    else if(!strcmp(LODindex[CrsWlk[Lindex].LODband-1].filename,"TREx Edge Match WBM"))
		{ 
	      sprintf(thestr,"Edge WBM: %.2lf",z1);
		} 
	    else if(!strcmp(LODindex[CrsWlk[Lindex].LODband-1].filename,"TREx Edge Match DEM"))
		{ 
	      sprintf(thestr,"Edge DEM: %.2lf",z1);
		} 
	    else if(!strcmp(LODindex[CrsWlk[Lindex].LODband-1].filename,"Height Error Map"))
		{ 
	      sprintf(thestr,"HEM: %.2lf",z1);
		} 
	    else if(!strcmp(LODindex[CrsWlk[Lindex].LODband-1].filename,"Reliability Mask"))
		{ 
	      sprintf(thestr,"RLM: %.2lf",z1);
		} 
	    else if(!strcmp(LODindex[CrsWlk[Lindex].LODband-1].filename,"Source Data Mask"))
		{ 
	      sprintf(thestr,"SDM: %.2lf",z1);
		} 
	    else if(!strcmp(LODindex[CrsWlk[Lindex].LODband-1].filename,"Water Body Mask"))
		{ 
	      sprintf(thestr,"WBM: %.2lf",z1);
		} 
	    else if(!strcmp(LODindex[CrsWlk[Lindex].LODband-1].filename,"Edit Data Mask"))
		{ 
	      sprintf(thestr,"EDM: %.2lf",z1);
		} 
	    else if(!strcmp(LODindex[CrsWlk[Lindex].LODband-1].filename,"DTED Level 1"))
		{ 
	      sprintf(thestr,"DTED1: %.2lf",z1);
		} 
	    else if(!strcmp(LODindex[CrsWlk[Lindex].LODband-1].filename,"ASTER GDEM v2"))
		{ 
	      sprintf(thestr,"ASTER: %.2lf",z1);
		} 
	    else if(!strcmp(LODindex[CrsWlk[Lindex].LODband-1].filename,"Active Earthscape"))
		{ 
	      sprintf(thestr,"AE: %.2lf",z1);
		} 
	    else if(!strcmp(LODindex[CrsWlk[Lindex].LODband-1].filename,"HRTE3 Bare Earth"))
		{ 
	      sprintf(thestr,"HRTE3 BE: %.2lf",z1);
		} 
	    else if(!strcmp(LODindex[CrsWlk[Lindex].LODband-1].filename,"HRTE3 Reflective Surface"))
		{ 
	      sprintf(thestr,"HRTE3 RS: %.2lf",z1);
		}
	    else if(!strcmp(LODindex[CrsWlk[Lindex].LODband-1].filename,"SRTM Level 2"))
		{ 
	      sprintf(thestr,"SRTM2: %.2lf",z1);
		} 
	    else if(!strcmp(LODindex[CrsWlk[Lindex].LODband-1].filename,"TREx DEM Raw"))
		{ 
	      sprintf(thestr,"Raw DEM: %.2lf",z1);
		} 
	    else if(!strcmp(LODindex[CrsWlk[Lindex].LODband-1].filename,"CDEM"))
		{ 
	      sprintf(thestr,"CDEM: %.2lf",z1);
		} 
	    else if(!strcmp(LODindex[CrsWlk[Lindex].LODband-1].filename,"GMTED"))
		{ 
	      sprintf(thestr,"GMTED: %.2lf",z1);
		} 
	    else
		{ 
	      sprintf(thestr,"%s: %.2lf",LODindex[CrsWlk[Lindex].LODband-1].filename,z1);
		} 
	  }

      ChooseLabel(x1,y1,thestr,color,&junk,&junk,Lindex,4);

	} 
  }





  DRAW_LABELS = 0; 


  MAPdrawX(x1,y1,color,Lindex);


  halfxlen = (IRegionSize*5.0)/xunits;
  length=EuclideanDistance(0,0,halfxlen,halfxlen);


  MAPdrawline(-1,x1-length,y1,x1+length,y1,color,Lindex);
  MAPdrawline(-1,x1,y1+length,x1,y1-length,color,Lindex);


  SHOW_POLY_VERTICES = old[0];
  SHOW_LINE_VERTICES = old[1];
  SHOW_END_VERTICES  = old[2];
  NO_CIRCLES = 0;

  DRAW_LABELS = temp;

}









void MAPdrawline(int flag, double x1,double y1,double x2,double y2, int color, int Lindex)
{
  

  int old[3];
  double llx_clip,lly_clip,urx_clip,ury_clip;
  double xint,yint;
  double xorig,yorig;
  double x1orig=x1,y1orig=y1,x2orig=x2,y2orig=y2;
  int thickness=1;
  int rendering_priority;


  if(Lindex!=DRAW_NOW)
    {
	  if(color==1)
	  {
		rendering_priority = MAX_RENDER_PRI;
	  }
	  else
	  {
        rendering_priority = LODindex_DYN[LODindex[CrsWlk[Lindex].LODband-1].other_index].draw_priority - 1;
	  }

      LODS_USED[rendering_priority] = 1;
    }



  if((color==1)||(color==2)||(SPECIAL_COLOR>0))
    {
      thickness = 2;
    }

  if(batch_mode==1){return;}

  if((running==1)&&(API_DRAW==0))
  {
	  BadDraw("MAPdrawline");
	  return;
  }

  if((color==2000)){periodic_redraw();}
  if(xunits==0){printf("mapdrawline got xunits==0!\n"); XBell(mydisplay,50); }
  
  xorig=(x1+x2)/2.0; 
  yorig=(y1+y2)/2.0; 


  MakeClip(&llx_clip,&lly_clip,&urx_clip,&ury_clip);


  


  if(
     (x1<llx_clip)||(x2<llx_clip)||(y1<lly_clip)||(y2<lly_clip)||
     (x1>urx_clip)||(x2>urx_clip)||(y1>ury_clip)||(y2>ury_clip)
     )
    {
      if(LineSegmentsIntersect(llx_clip,lly_clip,llx_clip,ury_clip,x1,y1,x2,y2,&xint,&yint)==1)
	{
	  
	  if(x1<=llx_clip){x1=xint;y1=yint;}
	  else if(x2<=llx_clip){x2=xint;y2=yint;}
	  else if(INTDEBUG==1)
	    {
	      printf("detected a problem with line intersections\n");
	      printf("in place 1, got clip line %lf %lf %lf %lf\n",llx_clip,lly_clip,llx_clip,ury_clip);
	      printf(" and got line %lf %lf %lf %lf\n",x1,y1,x2,y2);
	      printf("xunits,yunits: %lf %lf\n",xunits,yunits);
	      printf("intersection at point %lf %lf\n",xint,yint);
	    }
	}
      if(LineSegmentsIntersect(llx_clip,lly_clip,urx_clip,lly_clip,x1,y1,x2,y2,&xint,&yint)==1)
	{
	  
	  if(y1<=lly_clip){x1=xint;y1=yint;}
	  else if(y2<=lly_clip){x2=xint;y2=yint;}
	  else if(INTDEBUG==1)
	    {
	      printf("detected a problem with line intersections\n");
	      printf("in place 2, got clip line %lf %lf %lf %lf\n",llx_clip,lly_clip,urx_clip,lly_clip);
	      printf(" and got line %lf %lf %lf %lf\n",x1,y1,x2,y2);
	      printf("xunits,yunits: %lf %lf\n",xunits,yunits);
	      printf("intersection at point %lf %lf\n",xint,yint);
	    }
	}
      if(LineSegmentsIntersect(urx_clip,ury_clip,llx_clip,ury_clip,x1,y1,x2,y2,&xint,&yint)==1)
	{
	  
	  if(y1>=ury_clip){x1=xint;y1=yint;}
	  else if(y2>=ury_clip){x2=xint;y2=yint;}
	  else if(INTDEBUG==1)
	    {
	      printf("detected a problem with line intersections\n");
	      printf("in place 3, got clip line %lf %lf %lf %lf\n",urx_clip,ury_clip,llx_clip,ury_clip);
	      printf(" and got line %lf %lf %lf %lf\n",x1,y1,x2,y2);
	      printf("xunits,yunits: %lf %lf\n",xunits,yunits);
	      printf("intersection at point %lf %lf\n",xint,yint);
	    }
	}
      if(LineSegmentsIntersect(urx_clip,ury_clip,urx_clip,lly_clip,x1,y1,x2,y2,&xint,&yint)==1)
	{
	  
	  if(x1>=urx_clip){x1=xint;y1=yint;}
	  else if(x2>=urx_clip){x2=xint;y2=yint;}
	  else if(INTDEBUG==1)
	    {
	      printf("detected a problem with line intersections\n");
	      printf("in place 4, got clip line %lf %lf %lf %lf\n",urx_clip,ury_clip,urx_clip,lly_clip);
	      printf(" and got line %lf %lf %lf %lf\n",x1,y1,x2,y2);
	      printf("xunits,yunits: %lf %lf\n",xunits,yunits);
	      printf("intersection at point %lf %lf\n",xint,yint);
	    }
	}
    }

  if(!InSide(llx_clip,lly_clip,urx_clip,ury_clip,x1,y1,x2,y2)==1)
    {
      return; 
    }


  x1 = x1 - llx_clip;
  x2 = x2 - llx_clip;
  y1 = y1 - lly_clip;
  y2 = y2 - lly_clip;


  if(color==2000)
    {
      color = 1;
    }


  if(SPECIAL_COLOR>0)
  {
    XSetForeground(mydisplay,mygc,mycolors[SPECIAL_COLOR]);
  }
  else if((SPECIAL_COND_COLOR>0)&&(color==1))
  {
    XSetForeground(mydisplay,mygc,mycolors[SPECIAL_COND_COLOR]);
  }
  else if(SPECIAL_OUTLINE_COLOR>0)
  {
    XSetForeground(mydisplay,mygc,color);
  }
  else
  {
    XSetForeground(mydisplay,mygc,mycolors[color]);
  }

  if(NO_CIRCLES == 0)
  {

    

    if((color==1)&&(EuclideanDistance(
					(double)((short int)((int)  (10.0+(x1/IRegionSize)*xunits))),
					(double)((short int)(height-(10.0+(y1/IRegionSize)*xunits))),
					(double)((short int)((int)  (10.0+(x2/IRegionSize)*yunits))),
					(double)((short int)(height-(10.0+(y2/IRegionSize)*xunits)))
					)<SMALL))
	{ 
      MAPdrawcircle(xorig,yorig,CIRCLESIZE,1,Lindex);
      if(SPECIAL_COLOR>0)
	  {
        XSetForeground(mydisplay,mygc,mycolors[SPECIAL_COLOR]);
	  }
     else if((SPECIAL_COND_COLOR>0)&&(color==1))
	 { 
        XSetForeground(mydisplay,mygc,mycolors[SPECIAL_COND_COLOR]);
	 } 
     else
	 { 
       XSetForeground(mydisplay,mygc,mycolors[color]);
	 } 
	} 
  }
  
  if(OVERRIDE_THICKNESS>0)
  {
    MySetLineThickness(OVERRIDE_THICKNESS);
  }
  else
  {
    if((thickness>1)&&(KEEP_THICKNESS==0))  
    {
      MySetLineThickness(thickness);
    }
  }


  if(  ((color>=5)||(Lindex!=DRAW_NOW))  && (SPECIAL_COLOR<0)  )
    {
      if((Lindex==DRAW_NOW))
	  {
	   XDrawLine(mydisplay,pixmap,     mygc,
		    (short int)((int)  (10.0+(double)(x1/IRegionSize)*xunits)),
		    (short int)(height-(10.0+(double)(y1/IRegionSize)*xunits)),
		    (short int)((int)  (10.0+(double)(x2/IRegionSize)*yunits)),
		    (short int)(height-(10.0+(double)(y2/IRegionSize)*xunits)));
	  
	   XDrawLine(mydisplay,mywindow,     mygc,
		    (short int)((int)  (10.0+(double)(x1/IRegionSize)*xunits)),
		    (short int)(height-(10.0+(double)(y1/IRegionSize)*xunits)),
		    (short int)((int)  (10.0+(double)(x2/IRegionSize)*yunits)),
		    (short int)(height-(10.0+(double)(y2/IRegionSize)*xunits)));
	  
	  }
      else
	  {
	  XDrawLine(mydisplay,DRAWING_PIXMAPS[rendering_priority],     mygc,
		    (short int)((int)  (10.0+(double)(x1/IRegionSize)*xunits)),
		    (short int)(height-(10.0+(double)(y1/IRegionSize)*xunits)),
		    (short int)((int)  (10.0+(double)(x2/IRegionSize)*yunits)),
		    (short int)(height-(10.0+(double)(y2/IRegionSize)*xunits)));
	  
	  
	  
	  XDrawLine(mydisplay,DRAWING_CLIPMAPS[rendering_priority],     mybitgc,
		    (short int)((int)  (10.0+(double)(x1/IRegionSize)*xunits)),
		    (short int)(height-(10.0+(double)(y1/IRegionSize)*xunits)),
		    (short int)((int)  (10.0+(double)(x2/IRegionSize)*yunits)),
		    (short int)(height-(10.0+(double)(y2/IRegionSize)*xunits)));
	  }
    }



  if( ((thickness>1)&&(KEEP_THICKNESS==0)) && (OVERRIDE_THICKNESS<0)  )
    {
      MySetLineThickness(0);
    }







  if(  ((color<5)||(SPECIAL_COLOR>0))  &&  (Lindex==DRAW_NOW)  )
    {
	  if(OVERRIDE_THICKNESS>0)
	  {
        MySetLineThickness(OVERRIDE_THICKNESS);
	  }
	  else
	  {
        if((thickness>1)&&(KEEP_THICKNESS==0))
		{
	      MySetLineThickness(thickness);
		}
	  }

      

	  if(SPECIAL_COLOR>0)
	  {

        XDrawLine(mydisplay,DRAWING_PIXMAPS[MAX_RENDER_PRI],     mygc,
		    (short int)((int)  (10.0+(double)(x1/IRegionSize)*xunits)),
		    (short int)(height-(10.0+(double)(y1/IRegionSize)*xunits)),
		    (short int)((int)  (10.0+(double)(x2/IRegionSize)*yunits)),
		    (short int)(height-(10.0+(double)(y2/IRegionSize)*xunits)));
	  
	  
	   
	   XDrawLine(mydisplay,DRAWING_CLIPMAPS[MAX_RENDER_PRI],     mybitgc,
		    (short int)((int)  (10.0+(double)(x1/IRegionSize)*xunits)),
		    (short int)(height-(10.0+(double)(y1/IRegionSize)*xunits)),
		    (short int)((int)  (10.0+(double)(x2/IRegionSize)*yunits)),
		    (short int)(height-(10.0+(double)(y2/IRegionSize)*xunits)));

	   LODS_USED[MAX_RENDER_PRI] = 1;

	  }
	  else
	  {
        XDrawLine(mydisplay,mywindow,     mygc,
		  (short int)((int)  (10.0+(double)(x1/IRegionSize)*xunits)),
		  (short int)(height-(10.0+(double)(y1/IRegionSize)*xunits)),
		  (short int)((int)  (10.0+(double)(x2/IRegionSize)*yunits)),
		  (short int)(height-(10.0+(double)(y2/IRegionSize)*xunits)));      
	  }

      XDrawLine(mydisplay,pixmap,     mygc,
		(short int)((int)  (10.0+(double)(x1/IRegionSize)*xunits)),
		(short int)(height-(10.0+(double)(y1/IRegionSize)*xunits)),
		(short int)((int)  (10.0+(double)(x2/IRegionSize)*yunits)),
		(short int)(height-(10.0+(double)(y2/IRegionSize)*xunits)));      
      
      if((color==1)&&(DRAWING_ERRORS==1))
	{
	  RememberCondition(
			    (short int)((int)  (10.0+(double)(x1/IRegionSize)*xunits)),
			    (short int)(height-(10.0+(double)(y1/IRegionSize)*xunits)),
			    (short int)((int)  (10.0+(double)(x2/IRegionSize)*yunits)),
			    (short int)(height-(10.0+(double)(y2/IRegionSize)*xunits)),1);
	}
      
      if((thickness>1)&&(KEEP_THICKNESS==0))
	{
	  MySetLineThickness(0);
	}
    }
  
  XSetForeground(mydisplay,mygc,mycolors[DRAW_COLOR_BLACK]);  


  DRAW_LABELS = 0;


  if((SHOW_LINE_VERTICES==1)&&(flag==4))
    {
      old[0] = SHOW_POLY_VERTICES;
      old[1] = SHOW_LINE_VERTICES;
      old[2] = SHOW_END_VERTICES;
      SHOW_POLY_VERTICES = 0;
      SHOW_LINE_VERTICES = 0;
      SHOW_END_VERTICES  = 0;


      if(LINE_SHAPE==0)
	{
	  if(LINE_COLOR==999)
	    {
	      MAPdrawTri(x1orig,y1orig,color,Lindex);
	      MAPdrawTri(x2orig,y2orig,color,Lindex);
	  }
	  else
	    {
	      MAPdrawTri(x1orig,y1orig,LINE_COLOR,Lindex);
	      MAPdrawTri(x2orig,y2orig,LINE_COLOR,Lindex);
	    }
	}
      else if(LINE_SHAPE==1)
	{
	  if(LINE_COLOR==999)
	    {
	      MAPdrawStar(x1orig,y1orig,MY2DSENTINEL,color,Lindex,1);
	      MAPdrawStar(x2orig,y2orig,MY2DSENTINEL,color,Lindex,1);
	    }
	  else
	    {
	      MAPdrawStar(x1orig,y1orig,MY2DSENTINEL,LINE_COLOR,Lindex,1);
	      MAPdrawStar(x2orig,y2orig,MY2DSENTINEL,LINE_COLOR,Lindex,1);
	    }
	}
      else if(LINE_SHAPE==2)
	{
	  if(LINE_COLOR==999)
	    {
	      MAPdrawX(x1orig,y1orig,color,Lindex);
	      MAPdrawX(x2orig,y2orig,color,Lindex);
	    }
	  else
	    {
	      MAPdrawX(x1orig,y1orig,LINE_COLOR,Lindex);
	      MAPdrawX(x2orig,y2orig,LINE_COLOR,Lindex);
	    }
	}
      else if(LINE_SHAPE==3)
	{
	  if(LINE_COLOR==999)
	    {
	      MAPdrawcircle(x1orig,y1orig,CIRCLESIZE,-1*color,Lindex);
	      MAPdrawcircle(x2orig,y2orig,CIRCLESIZE,-1*color,Lindex);
	    }
	  else
	    {
	      MAPdrawcircle(x1orig,y1orig,CIRCLESIZE,-1*LINE_COLOR,Lindex);
	      MAPdrawcircle(x2orig,y2orig,CIRCLESIZE,-1*LINE_COLOR,Lindex);
	    }
	}
    else if(LINE_SHAPE==4)
	{
	  
	}  
      SHOW_POLY_VERTICES = old[0];
      SHOW_LINE_VERTICES = old[1];
      SHOW_END_VERTICES  = old[2];
    }



  if(SHOW_END_VERTICES==1)
    {
      old[0] = SHOW_POLY_VERTICES;
      old[1] = SHOW_LINE_VERTICES;
      old[2] = SHOW_END_VERTICES;
      SHOW_POLY_VERTICES = 0;
      SHOW_LINE_VERTICES = 0;
      SHOW_END_VERTICES  = 0;

      if(END_LINE_SHAPE==0)
	{
	  if((flag==1)||(flag==3))
	    {
	      if(END_LINE_COLOR==999)
		{
		  MAPdrawTri(x1orig,y1orig,color,Lindex);
		}
	      else
		{
		  MAPdrawTri(x1orig,y1orig,END_LINE_COLOR,Lindex);
		}
	    }
	  
	  if((flag==2)||(flag==3))
	    {
	      if(END_LINE_COLOR==999)
		{
		  MAPdrawTri(x2orig,y2orig,color,Lindex);
		}
	      else
		{
		  MAPdrawTri(x2orig,y2orig,END_LINE_COLOR,Lindex);
		}
	    }
	}
      else if(END_LINE_SHAPE==1)
	{
	  if((flag==1)||(flag==3))
	    {
	      if(END_LINE_COLOR==999)
		{
		  MAPdrawStar(x1orig,y1orig,MY2DSENTINEL,color,Lindex,1);
		}
	      else
		{
		  MAPdrawStar(x1orig,y1orig,MY2DSENTINEL,END_LINE_COLOR,Lindex,1);
		}
	    }
	  
	  if((flag==2)||(flag==3))
	    {
	      if(END_LINE_COLOR==999)
		{
		  MAPdrawStar(x2orig,y2orig,MY2DSENTINEL,color,Lindex,1);
		}
	      else
		{
		  MAPdrawStar(x2orig,y2orig,MY2DSENTINEL,END_LINE_COLOR,Lindex,1);
		}
	    }
	}
      else if(END_LINE_SHAPE==3)
	{
	  if((flag==1)||(flag==3))
	    {
	      if(END_LINE_COLOR==999)
		{
		  MAPdrawcircle(x1orig,y1orig,CIRCLESIZE,-1*color,Lindex);
		}
	      else
		{
		  MAPdrawcircle(x1orig,y1orig,CIRCLESIZE,-1*END_LINE_COLOR,Lindex);
		}
	    }
	  
	  if((flag==2)||(flag==3))
	    {
	      if(END_LINE_COLOR==999)
		{
		  MAPdrawcircle(x2orig,y2orig,CIRCLESIZE,-1*color,Lindex);
		}
	      else
		{
		  MAPdrawcircle(x2orig,y2orig,CIRCLESIZE,-1*END_LINE_COLOR,Lindex);
		}
	    }
	}
      else if(END_LINE_SHAPE==2)
	{
	  if((flag==1)||(flag==3))
	    {
	      if(END_LINE_COLOR==999)
		{
		  MAPdrawX(x1orig,y1orig,color,Lindex);
		}
	      else
		{
		  MAPdrawX(x1orig,y1orig,END_LINE_COLOR,Lindex);
		}
	    }
	  
	  if((flag==2)||(flag==3))
	    {
	      if(END_LINE_COLOR==999)
		{
		  MAPdrawX(x2orig,y2orig,color,Lindex);
		}
	      else
		{
		  MAPdrawX(x2orig,y2orig,END_LINE_COLOR,Lindex);
		}
	    }
	}
      SHOW_POLY_VERTICES = old[0];
      SHOW_LINE_VERTICES = old[1];
      SHOW_END_VERTICES  = old[2];
    }


  DRAW_LABELS = 1;

  linecount++;
  if((linecount%LINECHUNK)==0)
    {
      FlushMainScreen(LINE_LIMIT);
    }
}






Widget BuildPulldownMenu2(Widget parent, char *menu_title, char menu_mnemonic, 
		   Boolean tear_off, MenuItem *items)
{
  Widget PullDown, cascade;
  int i;
  XmString str;
  
  PullDown = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);

  if(!strcmp(menu_title,"Mode"))
    {
      top_menu[1] = PullDown;
    }



  if (tear_off)
    {
      XtVaSetValues (PullDown, XmNtearOffModel, XmTEAR_OFF_ENABLED, NULL);
    }

  str = XmStringCreateLocalized (menu_title);
  cascade = XtVaCreateManagedWidget (menu_title,
				     xmCascadeButtonWidgetClass, parent,
				     XmNsubMenuId,   PullDown,
				     XmNlabelString, str,
				     XmNmnemonic,    menu_mnemonic,
  				     XmNtranslations, XtParseTranslationTable (toptrans),
				     NULL);
  XmStringFree (str);
  for (i = 0; items[i].label != NULL; i++) 
    {
      if (items[i].subitems)
	{
	  modes[i] = BuildPulldownMenu2 (PullDown, items[i].label, 
					 items[i].mnemonic, tear_off, items[i].subitems);
	}
      else
	{
	  modes[i] = XtVaCreateManagedWidget (items[i].label,
					      *items[i].cclass, PullDown,
					      NULL);
	}
      if (items[i].mnemonic)
	{
	  XtVaSetValues (modes[i], XmNmnemonic, items[i].mnemonic, NULL);
	}
      if (items[i].accelerator) 
	{
	  str = XmStringCreateLocalized (items[i].accel_text);
	  XtVaSetValues (modes[i],
			 XmNaccelerator, items[i].accelerator,
			 XmNacceleratorText, str,
			 NULL);
	  XmStringFree (str);
	}
      if (items[i].callback)
	{
	  XtAddCallback(modes[i],
			(items[i].cclass == &xmToggleButtonWidgetClass ||
			 items[i].cclass == &xmToggleButtonWidgetClass) ?
			XmNvalueChangedCallback : 
			XmNactivateCallback,      
			(XtCallbackProc)items[i].callback, items[i].callback_data);
	}
    }
  return cascade;
}


Widget BuildPulldownMenu3(Widget parent, char *menu_title, char menu_mnemonic, 
		  Boolean tear_off, MenuItem *items)
{
  
  

  printf("should not be in BuildPulldownMenu3\n");
  return NULL;


  
}






Widget BuildStratumMenu(Widget parent, char *menu_title, char menu_mnemonic, 
		  Boolean tear_off, MenuItem *items)
{
  Widget PullDown, cascade;
  int i;
  XmString str;
  
  PullDown = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);
  if (tear_off)
    {
      XtVaSetValues (PullDown, XmNtearOffModel, XmTEAR_OFF_ENABLED, NULL);
    }
  str = XmStringCreateLocalized (menu_title);
  cascade = XtVaCreateManagedWidget (menu_title,
				     xmCascadeButtonWidgetClass, parent,
				     XmNsubMenuId,   PullDown,
				     XmNlabelString, str,
				     XmNmnemonic,    menu_mnemonic,
				     NULL);

  XmStringFree (str);
  for (i = 0; items[i].label != NULL; i++) 
    {
      if (items[i].subitems)
	{
	  Tstrat[i] = BuildStratumMenu (PullDown, items[i].label, 
				       items[i].mnemonic, tear_off, items[i].subitems);
	}
      else
	{
	  Tstrat[i] = XtVaCreateManagedWidget (items[i].label,
					       *items[i].cclass, PullDown,
					       NULL);
	}

      if (items[i].mnemonic)
	{
	  XtVaSetValues (Tstrat[i], XmNmnemonic, items[i].mnemonic, NULL);
	}
      
      if (items[i].accelerator) 
	{
	  str = XmStringCreateLocalized (items[i].accel_text);
	  XtVaSetValues (Tstrat[i],
			 XmNaccelerator, items[i].accelerator,
			 XmNacceleratorText, str,
			 NULL);
	  XmStringFree (str);
	}

      if (items[i].callback)
	{
	  XtAddCallback(Tstrat[i],
			(items[i].cclass == &xmToggleButtonWidgetClass ||
			 items[i].cclass == &xmToggleButtonWidgetClass) ?
			XmNvalueChangedCallback : 
			XmNactivateCallback,      
			(XtCallbackProc)items[i].callback, items[i].callback_data);
	}
    }
  return cascade;
}


void TearCallback(Widget w, XtPointer userData, XtPointer callData)
{
   int type = (int)userData;

   

   if(type==1)
   {
     XtVaSetValues(XtParent(w),XmNtitle,"Attribution Errors/Input Data Anomalies",NULL);
   }
   else if(type==2)
   {
     XtVaSetValues(XtParent(w),XmNtitle,"Input Data Anomalies",NULL);
   }
   else if(type==3)
   {
     XtVaSetValues(XtParent(w),XmNtitle,"GAIT Documentation",NULL);
   }
   else if(type==4)
   {
     XtVaSetValues(XtParent(w),XmNtitle,"Schema Documentation",NULL);
   }
   else if(type==5)
   {
     XtVaSetValues(XtParent(w),XmNtitle,"NGA Documentation",NULL);
   }
   else if(type==7)
   {
     XtVaSetValues(XtParent(w),XmNtitle,"MGCP Documentation",NULL);
   }
   else if(type==8)
   {
     XtVaSetValues(XtParent(w),XmNtitle,"Master Profile Documentation",NULL);
   }
   else if(type==9)
   {
     XtVaSetValues(XtParent(w),XmNtitle,"TDS Documentation",NULL);
   }
}


Widget BuildPulldownMenu(Widget parent,char *menu_title,char menu_mnemonic, 
		  Boolean tear_off, MenuItem *items)
{
  Widget PullDown, cascade, widget;
  int i,flag=0;
  XmString str;

  PullDown = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);


  if (!strcmp(menu_title,"Attribution Errors/Input Data Anomalies"))
  {
    XtAddCallback (PullDown, XmNtearOffMenuActivateCallback,TearCallback,(XtPointer)1);
  }
  else if (!strcmp(menu_title,"Input Data Anomalies"))
  {
    XtAddCallback (PullDown, XmNtearOffMenuActivateCallback,TearCallback,(XtPointer)2);
  }
  else if (!strcmp(menu_title,"GAIT Documentation"))
  {
    XtAddCallback (PullDown, XmNtearOffMenuActivateCallback,TearCallback,(XtPointer)3);
  }
  else if (!strcmp(menu_title,"Schema Documentation"))
  {
    XtAddCallback (PullDown, XmNtearOffMenuActivateCallback,TearCallback,(XtPointer)4);
  }
  else if (!strcmp(menu_title,"NGA Documentation"))
  {
    XtAddCallback (PullDown, XmNtearOffMenuActivateCallback,TearCallback,(XtPointer)5);
  }
  else if (!strcmp(menu_title,"Coordinate Grid"))
  {
	tear_off = 0;
  }
  else if (!strcmp(menu_title,"MGCP Documentation"))
  {
    XtAddCallback (PullDown, XmNtearOffMenuActivateCallback,TearCallback,(XtPointer)7);
  }
  else if (!strcmp(menu_title,"Master Profile Documentation"))
  {
    XtAddCallback (PullDown, XmNtearOffMenuActivateCallback,TearCallback,(XtPointer)8);
  }
  else if (!strcmp(menu_title,"TDS Documentation"))
  {
    XtAddCallback (PullDown, XmNtearOffMenuActivateCallback,TearCallback,(XtPointer)9);
  }


  if(!strcmp(menu_title,"File"))
    {
      top_menu[0] = PullDown;
    }
  else if(!strcmp(menu_title,"View"))
    {
      top_menu[2] = PullDown;
    }
  else if(!strcmp(menu_title,"Inspection"))
    {
      top_menu[3] = PullDown;
    }
  else if(!strcmp(menu_title,"Parameters"))
    {
      top_menu[4] = PullDown;
    }
  else if(!strcmp(menu_title,"Help"))
    {
      top_menu[5] = PullDown;
    }




  if (tear_off)
    {
      XtVaSetValues (PullDown, XmNtearOffModel, XmTEAR_OFF_ENABLED, NULL);
    }


  
    cascade = XtVaCreateManagedWidget (menu_title,
				     xmCascadeButtonWidgetClass, parent,
				     XmNsubMenuId,   PullDown,
				     XmNlabelString, STRING(menu_title),
				     XmNtitle,       menu_title,
				     XmNmnemonic,    menu_mnemonic,
				     XmNtranslations, XtParseTranslationTable (toptrans),
				     NULL);




  
  for (i = 0; items[i].label != NULL; i++) {
    
    
    
    


    flag = 0;
    
    if ((items[i].subitems)&&(!strcmp( items[i].label,"Fill Style")))
      {
	widget = BuildPulldownMenu3 (PullDown, items[i].label, 
				     items[i].mnemonic, True, items[i].subitems);
      }
    
    else if ((items[i].subitems)&&(!strcmp(items[i].label,"Stratum")))
      {
	widget = BuildStratumMenu (PullDown, items[i].label, 
				  items[i].mnemonic, True, items[i].subitems);
      }
    

    else if ((items[i].subitems)&&(!strcmp(items[i].label,"Attribution Errors/Input Data Anomalies")))
      {
	     widget = BuildPulldownMenu (PullDown, items[i].label, 
					     items[i].mnemonic, True, items[i].subitems);
      }
    else if ((items[i].subitems)&&(!strcmp(items[i].label,"Background")))
      {
       widget = BuildPulldownMenu (PullDown, items[i].label, 
					     items[i].mnemonic, False, items[i].subitems);
      }
    else if ((items[i].subitems)&&(!strcmp(items[i].label,"Open report file for current project")))
      {
       widget = BuildPulldownMenu (PullDown, items[i].label, 
					     items[i].mnemonic, False, items[i].subitems);
       QACR_button = widget;
      }
    else if (items[i].subitems)
      {
	widget = BuildPulldownMenu (PullDown, items[i].label, 
				    items[i].mnemonic, True, items[i].subitems);
      }
    else
      {
	if(!strcmp( items[i].label,"Import Terrain..."))
          {
	    import = XtVaCreateManagedWidget (items[i].label,
					      *items[i].cclass, PullDown,
					      NULL);
	    flag = 1;
	  }
	else if(!strcmp( items[i].label,"LOS Fan"))
          {
		    if(DO_FAN()==1)
			{ 
	           losbutton = XtVaCreateManagedWidget (items[i].label,
						 *items[i].cclass, PullDown,
						 NULL);
			}
	    flag = 2;
	  }
	else if(!strcmp( items[i].label,"Terrain Profile..."))
          {
	    profile = XtVaCreateManagedWidget (items[i].label,
					       *items[i].cclass, PullDown,
					       NULL);
	    flag = 3;
	  }
	else
	  {
	    widget = XtVaCreateManagedWidget (items[i].label,
					      *items[i].cclass, PullDown,
					      NULL);


	    if(!strcmp( items[i].label,"Restore current/latest zoom"))
	      {
		stackwids[0] = widget;
	      }
	    else  if(!strcmp( items[i].label,"Restore view from 1 zoom ago"))
	      {
		stackwids[1] = widget;
	      }
	    else if(!strcmp( items[i].label,"Restore view from 2 zooms ago"))
	      {
		stackwids[2] = widget;
	      }
	    else if(!strcmp( items[i].label,"Restore view from 3 zooms ago"))
	      {
		stackwids[3] = widget;
	      }
	    else if(!strcmp( items[i].label,"Restore view from 4 zooms ago"))
	      {
		stackwids[4] = widget;
	      }
	    else if(!strcmp( items[i].label,"Restore view from 5 zooms ago"))
	      {
		stackwids[5] = widget;
	      }
	    else if(!strcmp( items[i].label,"Restore view from 6 zooms ago"))
	      {
		stackwids[6] = widget;
	      }
	    else if(!strcmp( items[i].label,"Restore view from 7 zooms ago"))
	      {
		stackwids[7] = widget;
	      }
	    else if(!strcmp( items[i].label,"Restore view from 8 zooms ago"))
	      {
		stackwids[8] = widget;
	      }
	    else if(!strcmp( items[i].label,"Restore view from 9 zooms ago"))
	      {
		stackwids[9] = widget;
	      }
	    else if(!strcmp( items[i].label,"Save Condition Report..."))
	      {
		condwid = widget;
	      }
	    else if(!strcmp( items[i].label,"Load Condition Report..."))
	      {
		condwid3 = widget;
	      }
	    else if(!strcmp( items[i].label,"Re-generate inspection specification files for current project"))
	      {
		genwid = widget;
	      }
	    else if(!strcmp( items[i].label,"Grid Options..."))
	      {
		demwid = widget;
	      }
	    else if(!strcmp( items[i].label,"Conditions..."))
	      {
		condwid1 = widget;
	      }
	    else if(!strcmp( items[i].label,"Conditions by Feature..."))
	      {
		condwid2 = widget;
	      }
	    else if(!strcmp( items[i].label,"Conditions by Object..."))
	      {
		condwid2 = widget;
	      }

	    else if(!strcmp( items[i].label,"0.25 Degree Grid Without Labels"))
	      {
		    gridwid1 = widget;

            if(DrawQuarterDegreeGrid>0)
			{
              XtVaSetValues(gridwid1,XmNset,True,NULL);
			}
	      }
	    else if(!strcmp( items[i].label,"0.25 Degree Grid With Labels"))
	      {
		    gridwid2 = widget;

            if(DrawQuarterDegreeGridL>0)
			{
              XtVaSetValues(gridwid2,XmNset,True,NULL);
			}
	      }
	    else if(!strcmp( items[i].label,"0.50 Degree Grid Without Labels"))
	      {
		    gridwid3 = widget;

            if(DrawHalfDegreeGrid>0)
			{
              XtVaSetValues(gridwid3,XmNset,True,NULL);
			}
	      }
	    else if(!strcmp( items[i].label,"0.50 Degree Grid With Labels"))
	      {
		    gridwid4 = widget;

            if(DrawHalfDegreeGridL>0)
			{
              XtVaSetValues(gridwid4,XmNset,True,NULL);
			}
	      }
	    else if(!strcmp( items[i].label,"1.0 Degree Grid Without Labels"))
	      {
		    gridwid5 = widget;

            if(DrawOneDegreeGrid>0)
			{
              XtVaSetValues(gridwid5,XmNset,True,NULL);
			}
	      }
	    else if(!strcmp( items[i].label,"1.0 Degree Grid With Labels"))
	      {
		    gridwid6 = widget;

            if(DrawOneDegreeGridL>0)
			{
              XtVaSetValues(gridwid6,XmNset,True,NULL);
			}
	      }
	    else if(!strcmp( items[i].label,"User-Defined Grid Without Labels"))
	      {
		    gridwid7 = widget;

            if(DrawUserGrid>0)
			{
              XtVaSetValues(gridwid7,XmNset,True,NULL);
			}
	      }
	    else if(!strcmp( items[i].label,"User-Defined Grid With Labels"))
	      {
		    gridwid8 = widget;

            if(DrawUserGridL>0)
			{
              XtVaSetValues(gridwid8,XmNset,True,NULL);
			}
	      }

		
	    else if(!strcmp( items[i].label,"Networks..."))
		{
		  netwid = widget;
		}
	    else if(!strcmp( items[i].label,"Attribute Dependency errors"))
		{
 		  mgcpattrwid2 = widget;
		}
		else if(!strcmp( items[i].label,"MGCP \"No FCODE Column\" errors"))
		{
 		  mgcpattrwid3 = widget;
		}
		else if(!strcmp( items[i].label,"MGCP Shapefile Naming errors"))
		{
 		  mgcpattrwid4 = widget;
		}
		else if(!strcmp( items[i].label,"MGCP \"Shape Type\" errors"))
		{
 	      mgcpattrwid5 = widget;
		}
		else if(!strcmp( items[i].label,"Blank Attribute errors"))
		{
 	      mgcpattrwid6 = widget;
		}
		else if(!strcmp( items[i].label,"MGCP \"Mixed Null/Non-Null Optional Attribute\" errors"))
		{
 		  mgcpattrwid7 = widget;
		}
		else if(!strcmp( items[i].label,"MGCP \"Invalid Field Length\" errors"))
		{
 	      mgcpattrwid8 = widget;
		}
		else if(!strcmp( items[i].label,"MGCP \"Required Attribute Assigned Null Value\" errors"))
		{
 		  mgcpattrwid9 = widget;
		}
		else if(!strcmp( items[i].label,"MGCP \"UTF-8 Encoding\" anomalies"))
		{
 		  mgcpattrwid10 = widget;
		}
	    else if(!strcmp( items[i].label,"Export Shapefiles from current conditions"))
		{
		  shapewid = widget;
		}
	    else if(!strcmp( items[i].label,"Open NGA_QACR.doc file"))
		{
		  NGAQACR_button = widget;
		}
	    else if(!strcmp( items[i].label,"Open MGCP_QACR.doc file"))
		{
		  MGCPQACR_button = widget;
		}
	    else if(!strcmp( items[i].label,"Open projectsummary.txt file"))
		{
		  PROJSUMM_button = widget;
		}
	    else if(!strcmp( items[i].label,"Open checksummary.txt file"))
		{
		  CHECKSUMM_button = widget;
		}
        else if(!strcmp( items[i].label,"FCODE errors"))
		{
		  otherattrwid1 = widget;
		}
        else if(!strcmp( items[i].label,"Invalid Case errors"))
		{
		  otherattrwid2 = widget;
		}
        else if(!strcmp( items[i].label,"Non Domain Specific Pick-list errors"))
		{
		  otherattrwid3 = widget;
		}
        else if(!strcmp( items[i].label,"Domain Specific Pick-list errors"))
		{
		  otherattrwid4 = widget;
		}
        else if(!strcmp( items[i].label,"Unexpected FCODE-Geometry Pair errors"))
		{
		  otherattrwid5 = widget;
		}
        else if(!strcmp( items[i].label,"Value Range errors"))
		{
		  otherattrwid6 = widget;
		}
        else if(!strcmp( items[i].label,"Unexpected Attribute errors"))
		{
		  otherattrwid7 = widget;
		}
        else if(!strcmp( items[i].label,"Missing Attribute Field Or Value errors"))
		{
		  otherattrwid8 = widget;
		}
        else if(!strcmp( items[i].label,"Metadata errors"))
		{
		  otherattrwid9 = widget;
		}
        else if(!strcmp( items[i].label,"Zero-Part Area/Line errors"))
		{
		  otherattrwid10 = widget;
		}
        else if(!strcmp( items[i].label,"Null Feature errors"))
		{
		  otherattrwid11 = widget;
		}
        else if(!strcmp( items[i].label,"Invalid Coordinate errors"))
		{
		  otherattrwid12 = widget;
		}
       else if(!strcmp( items[i].label,"Invalid Cut-Out errors"))
		{
		  otherattrwid13 = widget;
		}
       else if(!strcmp( items[i].label,"Unrecognized Column Names"))
		{
		  otherattrwid14 = widget;
		}
       else if(!strcmp( items[i].label,"Invalid Data Type"))
		{
		  otherattrwid15 = widget;
		}
       else if(!strcmp( items[i].label,"Empty or Invalid Shapefiles or Tables"))
		{
		  otherattrwid16 = widget;
		}
       else if(!strcmp( items[i].label,"Geodatabase Bezier/Circle/Ellipse features"))
		{
		  otherattrwid17 = widget;
		}
       else if(!strcmp( items[i].label,"Open GAIT Basics"))
		{
	      
		}
       else if(!strcmp( items[i].label,"Open GAIT Inspections"))
		{
		  
		}
	  }
      }



    
    
    
    if(flag==1)
      {
	if (items[i].mnemonic)
	  XtVaSetValues (import, XmNmnemonic, items[i].mnemonic, NULL);


	



	if (items[i].accelerator) 
	  {
	    str = XmStringCreateLocalized (items[i].accel_text);
	    XtVaSetValues (import,
			   XmNaccelerator, items[i].accelerator,
			   XmNacceleratorText, str,
			   NULL);
	    XmStringFree (str);
	  }
	if (items[i].callback)
	  {
	    XtAddCallback(import,
			  (items[i].cclass == &xmToggleButtonWidgetClass ||
			   items[i].cclass == &xmToggleButtonWidgetClass) ?
			  XmNvalueChangedCallback : 
			  XmNactivateCallback,      
			  (XtCallbackProc)items[i].callback, items[i].callback_data);
	  }
      }
    else if(flag==2)
      {
	
	if (items[i].mnemonic)
	  {
		if(DO_FAN()==1)
		{
	      XtVaSetValues (losbutton, XmNmnemonic, items[i].mnemonic, NULL);
		}
	  }
	
	if (items[i].accelerator) 
	  {
	    str = XmStringCreateLocalized (items[i].accel_text);

		if(DO_FAN()==1)
		{
	      XtVaSetValues (losbutton,
			   XmNaccelerator, items[i].accelerator,
			   XmNacceleratorText, str,
			   NULL);
		}
	    XmStringFree (str);
	  }
	if (items[i].callback)
	  {
		if(DO_FAN()==1)
		{
	      XtAddCallback(losbutton,
			  (items[i].cclass == &xmToggleButtonWidgetClass ||
			   items[i].cclass == &xmToggleButtonWidgetClass) ?
			  XmNvalueChangedCallback : 
			  XmNactivateCallback,      
			  (XtCallbackProc)items[i].callback, items[i].callback_data);
		}
	  }
      } 
    else if(flag==3)
      {
	    if (items[i].mnemonic)
		{ 
	      XtVaSetValues (profile, XmNmnemonic, items[i].mnemonic, NULL);
		} 
	    
	    if (items[i].accelerator) 
		{ 
	      str = XmStringCreateLocalized (items[i].accel_text);
	      XtVaSetValues (profile,
			   XmNaccelerator, items[i].accelerator,
			   XmNacceleratorText, str,
			   NULL);
	      XmStringFree (str);
		} 
	    if (items[i].callback)
		{ 
	      XtAddCallback(profile,
			  (items[i].cclass == &xmToggleButtonWidgetClass ||
			   items[i].cclass == &xmToggleButtonWidgetClass) ?
			  XmNvalueChangedCallback : 
			  XmNactivateCallback,      
			  (XtCallbackProc)items[i].callback, items[i].callback_data);
		} 
	}
    else
      {
	if (items[i].mnemonic)
	  {
	    XtVaSetValues (widget, XmNmnemonic, items[i].mnemonic, NULL);
	  }
	
	if (items[i].accelerator) 
	  {
	    str = XmStringCreateLocalized (items[i].accel_text);
	    XtVaSetValues (widget,
			   XmNaccelerator, items[i].accelerator,
			   XmNacceleratorText, str,
			   NULL);
	    XmStringFree (str);
	  }
	if (items[i].callback)
	  {
	    XtAddCallback(widget,
			  (items[i].cclass == &xmToggleButtonWidgetClass ||
			   items[i].cclass == &xmToggleButtonWidgetClass) ?
			  XmNvalueChangedCallback : 
			  XmNactivateCallback,      
			  (XtCallbackProc)items[i].callback, items[i].callback_data);
	  }
      }
  }
  return cascade;
}





void all_toggle(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int i = (int) client_data;
  int j;



  if(i==1000)
    {
      
      for(j=0;j<NUM_C;j++)
	{
	  DrawByConfig[j] = 1;

	  if((NGA_TYPE==1)&&(j>=5))
	    {
	      continue;
	    }
	}
    }
  else if(i==2000)
    {
      
      for(j=0;j<NUM_C;j++)
	{
	  DrawByConfig[j] = 0;
	  
	  if((NGA_TYPE==1)&&(j>=5))
	    {
	      continue;
	    }
	}
    }
  else if(i==3000)
    {
      
      for(j=0;j<NUM_S;j++)
	{
	  DrawByStratum[j] = 1;
	  XtVaSetValues(Tstrat[j],XmNset,True,NULL);
	}
    }
  else if(i==4000)
    {
      
      for(j=0;j<NUM_S;j++)
	{
	  DrawByStratum[j] = 0;
	  XtVaSetValues(Tstrat[j],XmNset,False,NULL);
	}
    }
  else if(i==5000)
    {
      
     for(j=0;j<NUM_D;j++)
	{
	  DrawByDomain[j] = 1;
	}
    }
  else if(i==6000)
    {
      
      for(j=0;j<NUM_D;j++)
	{
	  DrawByDomain[j] = 0;
	}
    }
}


void open_doc(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int i = (int) client_data;
  char filename[1000],filename2[1000],OPENCOMMAND[50];

 
  if(USE_MAC==1)
  {
    sprintf(OPENCOMMAND,"open ");
  }
  else
  {
    OPENCOMMAND[0] = '\0';
  }

  if(i==DOC_TRM)
  { 
	sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),TRMNAME);
  }
  else if(i==DOC_BASICS)
  { 
	sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),BASICSNAME);
  }
  else if(i==DOC_UFD1)
  {
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),UFD1NAME);
  }
  else if(i==DOC_UFD2)
  {
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),UFD2NAME);
  }
  else if(i==DOC_UFD3)
  {
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),UFD3NAME);
  }
  else if(i==DOC_MGCPISF3)
  {  
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),MGCPISF3NAME);
  } 
  else if(i==DOC_MGCPISF4)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),MGCPISF4NAME);
  } 
  else if(i==DOC_MGCPISL3)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),MGCPISL3NAME);
  } 
  else if(i==DOC_MGCPISL4)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),MGCPISL4NAME);
  } 
  else if(i==DOC_MGCPXML)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),MGCPXMLNAME);
  } 
  else if(i==DOC_MGCPRANGE3)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),MGCPRANGE3NAME);
  } 
  else if(i==DOC_MGCPRANGE4)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),MGCPRANGE4NAME);
  } 
  else if(i==DOC_MGCPPPP3)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),MGCPPPP3NAME);
  } 
  else if(i==DOC_MGCPFTA)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),MGCPFTANAME);
  } 
  else if(i==DOC_MGCPIAE)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),MGCPIAENAME);
  } 
  else if(i==DOC_TDSIAE)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),TDSIAENAME);
  } 
  else if(i==DOC_MGCPPPP4)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),MGCPPPP4NAME);
  } 
  else if(i==DOC_WHATSNEW)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),WHATSNEWNAME);
  } 
  else if(i==DOC_INSPECTIONS)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),INSPECTIONSNAME);
  } 
  else if(i==DOC_COOKBOOK)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),COOKBOOKNAME);
  } 
  else if(i==DOC_METADATA)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),METADATANAME);
  } 
  else if(i==DOC_NUNANPO)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),NUNANPONAME);
  } 
  else if(i==DOC_D4)
  { 
     sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),DOCD4NAME);
  } 
  else if(i==DOC_FACC)
  {
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),DOCFACCNAME);
  } 
  else if(i==DOC_VMAP)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),DOCVMAPNAME);
  } 
  else if(i==DOC_MGCP3)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),DOCMGCP3NAME);
  } 
  else if(i==DOC_MGCP4)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),DOCMGCP4NAME);
  } 
  else if(i==DOC_TDS4)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),DOCTDS4NAME);
  } 
  else if(i==DOC_TDS6)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),DOCTDS6NAME);
  } 
  else if(i==DOC_XWALK)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),DOCXWALKNAME);
  } 
  else if(i==DOC_SAC)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),DOCSACNAME);
  } 
  else if(i==DOC_SCHEMA)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),DOCSCHEMANAME);
  } 
  else if(i==DOC_TDSISF4)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),TDSISF4NAME);
  } 
  else if(i==DOC_TDSISF6)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),TDSISF6NAME);
  } 
  else if(i==DOC_TDSISL4)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),TDSISL4NAME);
  } 
  else if(i==DOC_TDSISL6)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),TDSISL6NAME);
  } 
  else if(i==DOC_NGAQACR)
  { 
    sprintf(filename,"%s\"%sQACR_files/NGA_QACR.doc\"",OPENCOMMAND,indirectory);
  } 
  else if(i==DOC_MGCPQACR)
  { 
    sprintf(filename,"%s\"%sQACR_files/MGCP_QACR.doc\"",OPENCOMMAND,indirectory);
  } 
  else if(i==DOC_PROJSUMM)
  { 
    sprintf(filename,"\"%ssummary_files/projectsummary.txt\"",indirectory);
  } 
  else if(i==DOC_CHECKSUMM)
  { 
    sprintf(filename,"\"%ssummary_files/checksummary.txt\"",indirectory);
  } 
  else if(i==DOC_GGDM21)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),DOCGGDM21NAME);
  }	  
  else if(i==DOC_GGDM22)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),DOCGGDM22NAME);
  } 
  else if(i==DOC_GGDM3)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),DOCGGDM3NAME);
  } 
  else if(i==DOC_UNIQUENAMES)
  { 
    sprintf(filename,"%s\"%ssummary_files/names.html\"",OPENCOMMAND,indirectory);
  }
  else if(i==DOC_MGCPIPA)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),MGCPIPANAME);
  }	  
  else if(i==DOC_MGCPILA)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),MGCPILANAME);
  }	  
  else if(i==DOC_MGCPIPL)
  { 
    sprintf(filename,"%s\"%sdocs%s%s\"",OPENCOMMAND,GAIT_HOME_DIR,GetSlash(),MGCPIPLNAME);
  }	  
  else
  { 
	printf("bad value %d to open_doc\n",i);
	return;
  } 



  if(USE_LINUX==1)
  {
    sprintf(filename2,"To open the file:\n\n %s,\n\n\
locate it with your file browser and open it with the appropriate application",filename);

    not_while_running(widget,filename2,1614,"Linux File Open Help",5);

    return;
  }



  if(USE_DOS==1)
  {
    printf("open file %s\n",filename);

    
    sprintf(filename2,"start \"tt\" %s",filename);

    system(filename2);
  }
  else
  {
    printf("Launch Mac command %s\n",filename);
    system(filename);
  }

}



void draw_poly(Widget widget,XtPointer client_data,XtPointer call_data)
{
  int i = (int) client_data;
  
  
  if(i<50)
    {
      
      DrawByConfig[i] = !DrawByConfig[i];
    }
  else if(i<120)
    {
      
      DrawByStratum[i-100] = !DrawByStratum[i-100];
    }
  else if(i<300)
    {
      
      DrawByDomain[i-200] = !DrawByDomain[i-200];
    }
  else
    {
      XBell(mydisplay,50);
      printf("bad value in draw_poly %d\n",i);
    }
  
  
}




void realfixCallback(Widget w,XtPointer data,XtPointer callData)
{ 
  #if(NGA_TYPE==0)

  int result;

  if(stf_overwrite_source==0)
    {
      not_while_running(w,"You must specify an STF before you can apply a patch file to it.\n\
Use the \"Specify STF to OVEWRWRITE...\" button to specify an STF.",1278,"No STF Specified",1);	
      return;
    }
  
  if(patch_source==0)
    {
      not_while_running(w,"You must specify a patch file before you can apply a patch file to an STF.\n\
Use the \"Specify patch file...\" button to specify a patch file.",1279,"No patch file specified",1);	
      return;
    }
  
  
  
  
  set_cursor(mydisplay,mywindow,WATCH);
  set_cursor(XtDisplay(patchshell),XtWindow(patchshell),WATCH);
  BUSY = 1;
  
  
  
  FIX_RUNNING = 0;
  STOP_FIX_FLAG = 0;
  StartTime = time(NULL); 
  result = DoTheFixing(stffix,patchfile);

  if(STOP_FIX_FLAG==0)
    {
      periodic_fixing_redraw(1);
      XtVaSetValues(fix_running, XmNcancelLabelString, STRING("Done"),NULL);
    }
  set_cursor(mydisplay,mywindow,GOOD);
  set_cursor(XtDisplay(patchshell),XtWindow(patchshell),GOOD);
  BUSY = 0;

  #endif

}



void PatchHelpCallback(Widget w,XtPointer data,XtPointer callData)
{
  not_while_running(w,"This window is used to specify parameters for repairing an STF file,\n\
and beginning the repair operation.\n\n\
Two parameters are required:\n\
1) The STF file to repair.  NOTE that this STF file will be overwritten,\n\
so if you wish to maintain the original STF file, YOU must make a copy\n\
of it.\n\n\
2) The patch file that will be used to repair the STF.  This file\n\
must have been created using the \"repair...\" buttons that appear\n\
on the \"Conditions Found\" window.\n\n\
After specifying these 2 arguments, the repair operation may be\n\
initiated using the button labeled:\n\
\"APPLY patch file, OVERWRITING selected STF...\".",1187,"Apply Patch Help",5);
}



void fixCallback(Widget w,XtPointer data,XtPointer callData)
{ 
  Widget rowcol,form,text_w,button;
  Arg args[20];
  int n=0;
  Dimension Pheight;
  
  if(PATCH_WIN==0)
    {
      patchshell = XtCreatePopupShell("Apply patch file",topLevelShellWidgetClass,drawing_a,args,n);
      
      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass, patchshell, NULL);
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
      text_w = XtVaCreateManagedWidget ("Apply (previously created) patch file...",
					xmLabelWidgetClass, form,
					XmNtraversalOn,     True,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,   99,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    1,
					LABELWTRANSLATE,
					NULL);      
      XtManageChild(form);
      
    
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
      text_w = XtVaCreateManagedWidget ("Patch file:",
					xmLabelWidgetClass, form,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    1,
					LABELWTRANSLATE,
					NULL);
      
      if(patch_source==0)
	{
	  patch_t = XtVaCreateManagedWidget ("<none selected>                                        ",
					     xmLabelWidgetClass, form,
					     XmNleftAttachment,  XmATTACH_WIDGET,
					     XmNleftWidget,      text_w,
					     LABELWTRANSLATE,
					     NULL);
	}
      else if(patch_source==1)
	{
	  patch_t = XtVaCreateManagedWidget (patchfile,
					     xmLabelWidgetClass, form,
					     XmNleftAttachment,  XmATTACH_WIDGET,
					     XmNleftWidget,      text_w,
					     LABELWTRANSLATE,
					     NULL); 
	}
      else
	{
	  printf("bad value %d for input_source!\n",input_source);
	  ExitWrapper(-1);
	}
      XtManageChild(form);


      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      text_w = XtVaCreateManagedWidget ("STF root file to be OVERWRITTEN:",
					xmLabelWidgetClass, form,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    1,
					LABELWTRANSLATE,
					NULL);
      
      if(stf_overwrite_source==0)
	{
	  stf_t = XtVaCreateManagedWidget ("<none selected>                                        ",
					   xmLabelWidgetClass, form,
					   XmNleftAttachment,  XmATTACH_WIDGET,
					   XmNleftWidget,      text_w,
					   LABELWTRANSLATE,
					   NULL);
	}

      else if(stf_overwrite_source==1)
	{
	  stf_t  = XtVaCreateManagedWidget (stffix,
					    xmLabelWidgetClass, form,
					    XmNleftAttachment,  XmATTACH_WIDGET,
					    XmNleftWidget,      text_w,
					    LABELWTRANSLATE,
					    NULL); 
	}
      else
	{
	  printf("bad value %d for import_output_source!\n",input_source);
	  ExitWrapper(-1);
	}
      XtManageChild(form);


      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      
      button = XtVaCreateManagedWidget ("Specify STF to OVERWRITE...",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Specify STF to OVERWRITE..."),
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,                    1,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,                   49,
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL); 
      XtAddCallback(button, XmNactivateCallback, STFFileCallback, (XtPointer) NULL);
      XtManageChild(button);

      button = XtVaCreateManagedWidget ("Specify patch file...",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Specify patch file..."),
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,                    51,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,                   99,
					XmNtraversalOn,                  False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, PatchFileCallback, (XtPointer) NULL);
      XtManageChild(button);
      XtManageChild (form);




      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      button = XtVaCreateManagedWidget ("Specify patch file...",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("APPLY patch file, OVERWRITING selected STF..."),
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,                    1,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,                  99,
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL); 
      XtAddCallback(button, XmNactivateCallback, realfixCallback, (XtPointer) NULL);
      XtManageChild(button);
      XtManageChild (form);


      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);

      button = XtVaCreateManagedWidget ("Help",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Help"),
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,                    1,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,                  49,
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, PatchHelpCallback, (XtPointer)NULL);
      XtManageChild(button);

      button = XtVaCreateManagedWidget ("Done",xmPushButtonWidgetClass,form,
					XmNlabelString,        STRING("Done"),
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,                   51,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,                  99,
					XmNtraversalOn,                 False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, die_callback, (XtPointer)1010);
      XtManageChild(button);
      XtManageChild (form);
      XtManageChild (rowcol);
      
      PATCH_WIN = 1;
      MyPopup(patchshell);
      XtAddCallback(patchshell,XmNdestroyCallback,ShellDeath,(XtPointer)255);       

      XtVaGetValues(patchshell,  XmNheight,     &Pheight, NULL);
      XtVaSetValues(patchshell,  XmNminHeight,   Pheight, NULL);
      XtVaSetValues(patchshell,  XmNmaxHeight,   Pheight, NULL);

      XtAddEventHandler(patchshell,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)Pheight));

    }
  else
    {
      ResetWidget(patchshell);
    }
}





void modeCallback(Widget w,XtPointer data,XtPointer callData)
{
  char help[200],help1[500];
  XmString t1,message2;

  
  SetColorRight();
  
  if(DIST_MODE==1)
    {
      if((int)data!=8)
	{
	  
	  StopDistanceGathering();
	}
    }
  
  if((int)data==1)
    { 
      if(DEBUG==1){printf("NOW IN ZOOM MODE...\n");}
      
      
      
      XtVaSetValues(modes[0],XmNset,True, NULL);
      XtVaSetValues(modes[1],XmNset,False,NULL);
      XtVaSetValues(modes[2],XmNset,False,NULL);
      XtVaSetValues(modes[3],XmNset,False,NULL);
      XtVaSetValues(modes[4],XmNset,False,NULL);
      XtVaSetValues(modes[5],XmNset,False,NULL);
      XtVaSetValues(modes[6],XmNset,False,NULL);
      XtVaSetValues(modes[7],XmNset,False,NULL);
	  if(DO_FAN()==1)
	  { 
        XtVaSetValues(modes[8],XmNset,False,NULL);
	  }
      
      ZOOM_MODE    = 1;
      INFO_MODE    = 0;
      PROFILE_MODE = 0;
      LOS          = 0;
      FAN_MODE     = 0;
      DIST_MODE    = 0;
      CHECK_MODE   = 0;
      PAN_MODE     = 0;
      
      
      if(NOT_ZOOMED==1)
	{
	  sprintf(help1,"%s Current extents: %s",
		  help3,
		  MakeUString2());
	}
      else
	{
	  sprintf(help1,"%s Current extents: %s",
		  help3,
		  MakeUString((980.0*IRegionSize)/xunits,(780.0*IRegionSize)/yunits));
	}
      
      message2 = XmStringCreate (help1, "TAG5");
      XtVaSetValues(TEXT_HELP,XmNfontList, fontlist,NULL);
      XtVaSetValues(TEXT_HELP,XmNlabelString,message2,NULL);
      XmStringFree(message2);
      
      
    }
  
  else if((int)data==2)
    { 
      if(DEBUG==1){printf("NOW IN INFO MODE...\n");}
      
      XtVaSetValues(modes[0],XmNset,False,NULL);
      XtVaSetValues(modes[1],XmNset,False,NULL);
      XtVaSetValues(modes[2],XmNset,True,NULL);
      XtVaSetValues(modes[3],XmNset,False,NULL);
      XtVaSetValues(modes[4],XmNset,False,NULL);
      XtVaSetValues(modes[5],XmNset,False,NULL);
      XtVaSetValues(modes[6],XmNset,False,NULL);
      XtVaSetValues(modes[7],XmNset,False,NULL);
	  if(DO_FAN()==1)
	  { 
        XtVaSetValues(modes[8],XmNset,False,NULL);
      }
      
      ZOOM_MODE    = 0;
      INFO_MODE    = 1;
      PROFILE_MODE = 0;
      LOS          = 0;
      FAN_MODE     = 0;
      DIST_MODE    = 0;
      CHECK_MODE   = 0;
      PAN_MODE     = 0;
      
      if((input_source==1)&&(DOALLCELLS==0))
	{
	  message2 = XmStringCreate (help4, "TAG5");
	  XtVaSetValues(TEXT_HELP,XmNfontList, fontlist,NULL);
	  XtVaSetValues(TEXT_HELP,XmNlabelString,message2,NULL);
	  XmStringFree(message2);
 	}
      else if((input_source==1)&&(DOALLCELLS==1))
	{
	  message2 = XmStringCreate (help4, "TAG5");
	  XtVaSetValues(TEXT_HELP,XmNlabelString,message2,NULL);
	  XmStringFree(message2);
	}
    }
  
  else if((int)data==3)
    { 
      if(DEBUG==1){printf("NOW IN PAN MODE...\n");}
      
      XtVaSetValues(modes[0],XmNset,False,NULL);
      XtVaSetValues(modes[1],XmNset,True,NULL);
      XtVaSetValues(modes[2],XmNset,False,NULL);
      XtVaSetValues(modes[3],XmNset,False,NULL);
      XtVaSetValues(modes[4],XmNset,False,NULL);
      XtVaSetValues(modes[5],XmNset,False,NULL);
      XtVaSetValues(modes[6],XmNset,False,NULL);
      XtVaSetValues(modes[7],XmNset,False,NULL);
	  if(DO_FAN()==1)
	  { 
        XtVaSetValues(modes[8],XmNset,False,NULL);
	  }
      
      
      INFO_MODE    = 0;
      ZOOM_MODE    = 0;
      PROFILE_MODE = 0;
      LOS          = 0;
      FAN_MODE     = 0;
      DIST_MODE    = 0;
      CHECK_MODE   = 0;
      PAN_MODE     = 1;
      
      if(input_source==1)
	{
	  message2 = XmStringCreate (help9, "TAG5");
	  XtVaSetValues(TEXT_HELP,XmNfontList, fontlist,NULL);
	  XtVaSetValues(TEXT_HELP,XmNlabelString,message2,NULL);
	  XmStringFree(message2);
	}
    }
  
  
  
  
  else if(((int)data==4)||((int)data==5)||(int)data==6)
    { 
      if(DEBUG==1){printf("NOW IN PROFILE MODE...\n");}
      
      XtVaSetValues(modes[0],XmNset,False,NULL);
      XtVaSetValues(modes[1],XmNset,False,NULL);
      XtVaSetValues(modes[2],XmNset,False,NULL);
      XtVaSetValues(modes[3],XmNset,False,NULL);
      XtVaSetValues(modes[4],XmNset,False,NULL);
      XtVaSetValues(modes[5],XmNset,False,NULL);
      XtVaSetValues(modes[6],XmNset,False,NULL);
      XtVaSetValues(modes[7],XmNset,False,NULL);
	  if(DO_FAN()==1)
	  { 
        XtVaSetValues(modes[8],XmNset,False,NULL);
	  }
      
      if((int)data==4)
	{
	  XtVaSetValues(modes[5],XmNset,True,NULL);
          LOS = 0;
	}
      else if((int)data==5)
	{
	  XtVaSetValues(modes[6],XmNset,True,NULL);
          LOS = 0;
	}
      else if((int)data==6)
	{
	  XtVaSetValues(modes[7],XmNset,True,NULL);
          LOS = 1;
	}
      
      ZOOM_MODE    = 0;
      INFO_MODE    = 0;
      PROFILE_MODE = 1;
      LOS          = 0;
      FAN_MODE     = 0;
      DIST_MODE    = 0;
      CHECK_MODE   = 0;
      PAN_MODE     = 0;


      if((int)data==5){NON_ACTUAL=1;ACTUAL=0;LOS=0;}
      else if((int)data==4){NON_ACTUAL=0;ACTUAL=1;LOS=0;}
      else if((int)data==6){NON_ACTUAL=1;ACTUAL=0;LOS=1;}
      
      if(input_source==1)
	{
	  message2 = XmStringCreate (help7, "TAG5");
	  XtVaSetValues(TEXT_HELP,XmNfontList,fontlist,NULL);
	  XtVaSetValues(TEXT_HELP,XmNlabelString,message2,NULL);
	  XmStringFree(message2);
   	}
    }
  else if((int)data==7)
    {
      if(DEBUG==1){printf("NOW IN FAN MODE...\n");}
      XtVaSetValues(modes[0],XmNset,False,NULL);
      XtVaSetValues(modes[1],XmNset,False,NULL);
      XtVaSetValues(modes[2],XmNset,False,NULL);
      XtVaSetValues(modes[3],XmNset,False,NULL);
      XtVaSetValues(modes[4],XmNset,False,NULL);
      XtVaSetValues(modes[5],XmNset,False,NULL);
      XtVaSetValues(modes[6],XmNset,False,NULL);
      XtVaSetValues(modes[7],XmNset,False,NULL);
	  if(DO_FAN()==1)
	  { 
        XtVaSetValues(modes[8],XmNset,True,NULL);
	  }

      INFO_MODE    = 0;
      ZOOM_MODE    = 0;
      PROFILE_MODE = 0;
      LOS          = 0;
      FAN_MODE     = 1;
      DIST_MODE    = 0;
      CHECK_MODE   = 0;
      PAN_MODE     = 0;

      if(input_source==1)
	{
	  message2 = XmStringCreate (help8, "TAG5");
	  XtVaSetValues(TEXT_HELP,XmNfontList,fontlist,NULL);
	  XtVaSetValues(TEXT_HELP,XmNlabelString,message2,NULL);
	  XmStringFree(message2);
	}
    }
  else if((int)data==8)
    {
      if(DEBUG==1){printf("NOW IN DISTANCE MODE...\n");}
      XtVaSetValues(modes[0],XmNset,False,NULL);
      XtVaSetValues(modes[1],XmNset,False,NULL);
      XtVaSetValues(modes[2],XmNset,False,NULL);
      XtVaSetValues(modes[3],XmNset,True,NULL);
      XtVaSetValues(modes[4],XmNset,False,NULL);
      XtVaSetValues(modes[5],XmNset,False,NULL);
      XtVaSetValues(modes[6],XmNset,False,NULL);
      XtVaSetValues(modes[7],XmNset,False,NULL);
	  if(DO_FAN()==1)
	  { 
        XtVaSetValues(modes[8],XmNset,False,NULL);
	  }


      ZOOM_MODE    = 0;
      INFO_MODE    = 0;
      PROFILE_MODE = 0;
      LOS          = 0;
      FAN_MODE     = 0;
      DIST_MODE    = 1;
      CHECK_MODE   = 0;
      PAN_MODE     = 0;


      if(input_source==1)
	{
	  sprintf(help,"Left: Click points to add distance: Right: Stop");
	  t1 = XmStringCreateLtoR (help,"TAG5");
	  XtVaSetValues(TEXT_HELP,XmNlabelString,t1,NULL); 
	  XmStringFree(t1);    
	}
    }
  else if((int)data==9)
    {
      if(DEBUG==1){printf("NOW IN CHECKING MODE...\n");}
      XtVaSetValues(modes[0],XmNset,False,NULL);
      XtVaSetValues(modes[1],XmNset,False,NULL);
      XtVaSetValues(modes[2],XmNset,False,NULL);
      XtVaSetValues(modes[3],XmNset,False,NULL);
      XtVaSetValues(modes[4],XmNset,True,NULL);
      XtVaSetValues(modes[5],XmNset,False,NULL);
      XtVaSetValues(modes[6],XmNset,False,NULL);
      XtVaSetValues(modes[7],XmNset,False,NULL);
	  if(DO_FAN()==1)
	  { 
        XtVaSetValues(modes[8],XmNset,False,NULL);
	  }

      ZOOM_MODE    = 0;
      INFO_MODE    = 0;
      PROFILE_MODE = 0;
      LOS          = 0;
      FAN_MODE     = 0;
      DIST_MODE    = 0;
      CHECK_MODE   = 1;
      PAN_MODE     = 0;


      if(input_source==1)
	{
	  sprintf(help,"Left: Select area to inspect");
	  t1 = XmStringCreateLtoR (help,"TAG5");
	  XtVaSetValues(TEXT_HELP,XmNlabelString,t1,NULL); 
	  XmStringFree(t1);    
	}
      
      if(DOALLCELLS==1)
	{
	  DOALLCELLS = 0;
	}
    }

  set_cursor(mydisplay,mywindow,GOOD);
}





void OmitCallback(Widget w,XtPointer data,XtPointer callData)
{
  extern int OmitGridSentinels;

  if(OmitGridSentinels==1)
  {
    OmitGridSentinels = 0;
  }
  else
  { 
    OmitGridSentinels = 1;
  } 
}



void Forecallback(Widget w,XtPointer data,XtPointer callData)
{
  int test= (int)data;

  DrawLabels = 0;

  if(test==999)
    {
      if(DrawContourLines==1)
	  {
	    DrawContourLines = 0;
	  }
      else
	  { 
	    DrawContourLines = 1;
	  } 

	  
	  return;
    }

  else if(test==1)
    {
	  XtVaSetValues(gridwid2,XmNset,False,NULL);
	  XtVaSetValues(gridwid3,XmNset,False,NULL);
	  XtVaSetValues(gridwid4,XmNset,False,NULL);
	  XtVaSetValues(gridwid5,XmNset,False,NULL);
	  XtVaSetValues(gridwid6,XmNset,False,NULL);
	  XtVaSetValues(gridwid7,XmNset,False,NULL);
	  XtVaSetValues(gridwid8,XmNset,False,NULL);

      DrawQuarterDegreeGridL = 0;
      DrawHalfDegreeGrid     = 0;
      DrawHalfDegreeGridL    = 0;
      DrawOneDegreeGrid      = 0;
      DrawOneDegreeGridL     = 0;
      DrawUserGrid           = 0;
      DrawUserGridL          = 0;

      if(DrawQuarterDegreeGrid==1)
	  { 
	    DrawQuarterDegreeGrid = 0;
	  } 
      else
	  { 
	    DrawQuarterDegreeGrid = 1;
	  } 
    }
  else if(test==2)
    {
	  XtVaSetValues(gridwid1,XmNset,False,NULL);
	  XtVaSetValues(gridwid3,XmNset,False,NULL);
	  XtVaSetValues(gridwid4,XmNset,False,NULL);
	  XtVaSetValues(gridwid5,XmNset,False,NULL);
	  XtVaSetValues(gridwid6,XmNset,False,NULL);
	  XtVaSetValues(gridwid7,XmNset,False,NULL);
	  XtVaSetValues(gridwid8,XmNset,False,NULL);

      DrawQuarterDegreeGrid  = 0;
      DrawHalfDegreeGrid     = 0;
      DrawHalfDegreeGridL    = 0;
      DrawOneDegreeGrid      = 0;
      DrawOneDegreeGridL     = 0;
      DrawUserGrid           = 0;
      DrawUserGridL          = 0;

      if(DrawQuarterDegreeGridL==1)
	  { 
	    DrawQuarterDegreeGridL = 0;
	  } 
      else
	  { 
	    DrawQuarterDegreeGridL = 1;
	  } 
    }
  else if(test==3)
    {
	  XtVaSetValues(gridwid1,XmNset,False,NULL);
	  XtVaSetValues(gridwid2,XmNset,False,NULL);
	  XtVaSetValues(gridwid4,XmNset,False,NULL);
	  XtVaSetValues(gridwid5,XmNset,False,NULL);
	  XtVaSetValues(gridwid6,XmNset,False,NULL);
	  XtVaSetValues(gridwid7,XmNset,False,NULL);
	  XtVaSetValues(gridwid8,XmNset,False,NULL);

      DrawQuarterDegreeGrid  = 0;
      DrawQuarterDegreeGridL = 0;
      DrawHalfDegreeGridL    = 0;
      DrawOneDegreeGrid      = 0;
      DrawOneDegreeGridL     = 0;
      DrawUserGrid           = 0;
      DrawUserGridL          = 0;

      if(DrawHalfDegreeGrid==1)
	  { 
	    DrawHalfDegreeGrid = 0;
	  } 
      else
	  { 
	    DrawHalfDegreeGrid = 1;
	  } 
    }
  else if(test==4)
    {
	  XtVaSetValues(gridwid1,XmNset,False,NULL);
	  XtVaSetValues(gridwid2,XmNset,False,NULL);
	  XtVaSetValues(gridwid3,XmNset,False,NULL);
	  XtVaSetValues(gridwid5,XmNset,False,NULL);
	  XtVaSetValues(gridwid6,XmNset,False,NULL);
	  XtVaSetValues(gridwid7,XmNset,False,NULL);
	  XtVaSetValues(gridwid8,XmNset,False,NULL);

      DrawQuarterDegreeGrid  = 0;
      DrawQuarterDegreeGridL = 0;
      DrawHalfDegreeGrid     = 0;
      DrawOneDegreeGrid      = 0;
      DrawOneDegreeGridL     = 0;
      DrawUserGrid           = 0;
      DrawUserGridL          = 0;

      if(DrawHalfDegreeGridL==1)
	  { 
	    DrawHalfDegreeGridL = 0;
	  } 
      else
	  { 
	    DrawHalfDegreeGridL = 1;
	  } 
    }
  else if(test==5)
    {
	  XtVaSetValues(gridwid1,XmNset,False,NULL);
	  XtVaSetValues(gridwid2,XmNset,False,NULL);
	  XtVaSetValues(gridwid3,XmNset,False,NULL);
	  XtVaSetValues(gridwid4,XmNset,False,NULL);
	  XtVaSetValues(gridwid6,XmNset,False,NULL);
	  XtVaSetValues(gridwid7,XmNset,False,NULL);
	  XtVaSetValues(gridwid8,XmNset,False,NULL);

      DrawQuarterDegreeGrid  = 0;
      DrawQuarterDegreeGridL = 0;
      DrawHalfDegreeGrid     = 0;
      DrawHalfDegreeGridL    = 0;
      DrawOneDegreeGridL     = 0;
      DrawUserGrid           = 0;
      DrawUserGridL          = 0;

      if(DrawOneDegreeGrid==1)
	  { 
	    DrawOneDegreeGrid = 0;
	  } 
      else
	  { 
	    DrawOneDegreeGrid = 1;
	  } 
    }
  else if(test==6)
    {
	  XtVaSetValues(gridwid1,XmNset,False,NULL);
	  XtVaSetValues(gridwid2,XmNset,False,NULL);
	  XtVaSetValues(gridwid3,XmNset,False,NULL);
	  XtVaSetValues(gridwid4,XmNset,False,NULL);
	  XtVaSetValues(gridwid5,XmNset,False,NULL);
	  XtVaSetValues(gridwid7,XmNset,False,NULL);
	  XtVaSetValues(gridwid8,XmNset,False,NULL);

      DrawQuarterDegreeGrid  = 0;
      DrawQuarterDegreeGridL = 0;
      DrawHalfDegreeGrid     = 0;
      DrawHalfDegreeGridL    = 0;
      DrawOneDegreeGrid      = 0;
      DrawUserGrid           = 0;
      DrawUserGridL          = 0;

      if(DrawOneDegreeGridL==1)
	  { 
	    DrawOneDegreeGridL = 0;
	  } 
      else
	  { 
	    DrawOneDegreeGridL = 1;
	  } 
    }
  else if(test==7)
    {
	  XtVaSetValues(gridwid1,XmNset,False,NULL);
	  XtVaSetValues(gridwid2,XmNset,False,NULL);
	  XtVaSetValues(gridwid3,XmNset,False,NULL);
	  XtVaSetValues(gridwid4,XmNset,False,NULL);
	  XtVaSetValues(gridwid5,XmNset,False,NULL);
	  XtVaSetValues(gridwid6,XmNset,False,NULL);
	  XtVaSetValues(gridwid8,XmNset,False,NULL);

      DrawQuarterDegreeGrid  = 0;
      DrawQuarterDegreeGridL = 0;
      DrawHalfDegreeGrid     = 0;
      DrawHalfDegreeGridL    = 0;
      DrawOneDegreeGrid      = 0;
      DrawOneDegreeGridL     = 0;
      DrawUserGridL          = 0;

      if(DrawUserGrid==1)
	  { 
	    DrawUserGrid = 0;
	  } 
      else
	  { 
	    DrawUserGrid = 1;
	  } 
    }
  else if(test==8)
    {
	  XtVaSetValues(gridwid1,XmNset,False,NULL);
	  XtVaSetValues(gridwid2,XmNset,False,NULL);
	  XtVaSetValues(gridwid3,XmNset,False,NULL);
	  XtVaSetValues(gridwid4,XmNset,False,NULL);
	  XtVaSetValues(gridwid5,XmNset,False,NULL);
	  XtVaSetValues(gridwid6,XmNset,False,NULL);
	  XtVaSetValues(gridwid7,XmNset,False,NULL);

      DrawQuarterDegreeGrid  = 0;
      DrawQuarterDegreeGridL = 0;
      DrawHalfDegreeGrid     = 0;
      DrawHalfDegreeGridL    = 0;
      DrawOneDegreeGrid      = 0;
      DrawOneDegreeGridL     = 0;
      DrawUserGrid           = 0;

      if(DrawUserGridL==1)
	  { 
	    DrawUserGridL = 0;
	  } 
      else
	  { 
	    DrawUserGridL = 1;
	  } 
    }
  else
    {
      XBell(mydisplay,50);
      printf("bad arg %d to forecallback\n",test);
    }

  DrawLabels = DrawQuarterDegreeGridL + DrawHalfDegreeGridL + DrawOneDegreeGridL + DrawUserGridL;

  if((DrawLabels!=0)&&(DrawLabels!=1))
  {
    XBell(mydisplay,50);
    printf("bad DL %d %d %d %dto FCB:\n",DrawQuarterDegreeGridL,DrawHalfDegreeGridL,DrawOneDegreeGridL,DrawUserGridL);
	DrawLabels = 0;
  }
  

  


  TransferCleanPixmap();
  DrawTopGrid(); 
  MyDrawErrors();
  DrawTopGrid(); 

}



void TestCoordExtents(int zeroout, double x, double y)
{
  static int firstone = 1;

  if(zeroout==1)
    {
      firstone = 1;
      return;
    }

  if(firstone==1)
    {
      ErrLLX = x;
      ErrLLY = y;
      ErrURX = x;
      ErrURY = y;
      firstone = 0;
    }
  else
    {  
      if(x<ErrLLX)
	{
	  ErrLLX = x;
	}
      if(y<ErrLLY)
	{
	  ErrLLY = y;
	}
      
      if(x>ErrURX)
	{
	  ErrURX = x;
	}
      if(y>ErrURY)
	{
	  ErrURY = y;
	}
    }
}


void GetExtents(struct ConditionList * cond)
{
  int i;
  int j;

  


  TestCoordExtents(1,0,0);

  while(cond!=NULL)
  {
   if(cond->AdditionalPointUsed==1)
    {
      TestCoordExtents(0,cond->pointx,cond->pointy);
    }


   if(cond->CONDITION_TYPE==TVERT)
    {
      
      return;
    }

   for(i=1; i <= cond->num_areals; i++)
    {
      if(i==1)
	{
	  for(j=0; j<cond->areal1.numverts; j++)
            {
	      TestCoordExtents(0, cond->areal1.x[j], cond->areal1.y[j]);
            }
	}
      else
	{
	  for(j=0; j<cond->areal2.numverts; j++)
            {
	      TestCoordExtents(0,cond->areal2.x[j],cond->areal2.y[j]);
            }
	}
    }
  
  for(i=1; i <= cond->num_polys; i++)
    {
      if(i==1)
	{
	  for(j=0; j<cond->poly1.numverts; j++)
            {
	      TestCoordExtents(0,cond->poly1.x[j],cond->poly1.y[j]);
            }
	}
      else
	{
	  for(j=0; j<cond->poly2.numverts; j++)
            {
	      TestCoordExtents(0,cond->poly2.x[j],cond->poly2.y[j]);
            }
	}
    }
  
  for(i=1; i <= cond->num_lines; i++)
    {
      if(i==1)
	{
	  for(j=0; j<cond->linear1.numverts; j++)
            {
	      TestCoordExtents(0,cond->linear1.x[j],cond->linear1.y[j]);
            }
	}
      else
	{
	  for(j=0; j<cond->linear2.numverts; j++)
            {
	      TestCoordExtents(0,cond->linear2.x[j],cond->linear2.y[j]);
            }
	}
    }
  
  for(i=1; i <= cond->num_points; i++)
    {
      if(i==1)
	{
	  TestCoordExtents(0,cond->point1.x,cond->point1.y);
	}
      else
	{
	  TestCoordExtents(0,cond->point2.x,cond->point2.y);
	}
    }
  
  
  for(i=1; i <= cond->num_circles; i++)
    {
      if(i==1)
	{
	  TestCoordExtents(0,cond->circle1.x,cond->circle1.y);
	}
      else
	{
	  TestCoordExtents(0,cond->circle2.x,cond->circle2.y);
	}
    }

  for(i=1; i <= cond->num_sphere; i++)
    {
      if(i==1)
	{
	  TestCoordExtents(0,cond->sphere1.x,cond->sphere1.y);
	}
      else
	{
	  TestCoordExtents(0,cond->sphere2.x,cond->sphere2.y);
	}
    }
  
  for(i=1; i <= cond->num_gridpt; i++)
    {
      if(i==1)
	{
	  for(j=0; j < cond->gridobj1.numverts; j++)
            {
	      TestCoordExtents(0,cond->gridobj1.x[j],cond->gridobj1.y[j]);
            }
	}
      else
	{
	  for(j=0; j < cond->gridobj2.numverts; j++)
            {
	      TestCoordExtents(0,cond->gridobj2.x[j],cond->gridobj2.y[j]);
            }
	}
    }
  cond = cond->next;
  }
}


double GetXFractionVisible()
{
  Dimension x;
  extern Widget WW;

  XtVaGetValues (WW, XmNwidth, &x, NULL);

  if((x-30)<20)
  {
    return 20.0/(double)xlimit;
  }

  return (double)(x-30)/(double)xlimit;
}

double GetYFractionVisible()
{
  Dimension y;
  extern Widget WW;

  XtVaGetValues (WW, XmNheight, &y, NULL);

  if((y-80)<20)
  {
    return 20.0/(double)xlimit;
  }

  return (double)(y-80)/(double)ylimit;
}


void SetScrollbars()
{
  int min,max,slidesize,increment,Pincrement;
  extern Widget draw_h_scroll;

  XtVaGetValues(draw_h_scroll,
		XmNminimum,      &min,
		XmNmaximum,      &max,
		XmNsliderSize,   &slidesize,
		XmNincrement,    &increment,
		XmNpageIncrement,&Pincrement,
		NULL);
  
  XmScrollBarSetValues(draw_h_scroll,
		       min,
		       slidesize,
		       30,
		       Pincrement,
		       1);

  XtVaGetValues(vert_scroll[DRAWING_A_SCROLL],
		XmNminimum,      &min,
		XmNmaximum,      &max,
		XmNsliderSize,   &slidesize,
		XmNincrement,    &increment,
		XmNpageIncrement,&Pincrement,
		NULL);
  
  XmScrollBarSetValues(vert_scroll[DRAWING_A_SCROLL],
		       max-slidesize,
		       slidesize,
		       30,
		       Pincrement,
		       1);


}


double AddVoidSpace(int xy)
{
 

 Dimension x,y;
 int dist;
 extern Widget WW;

 XtVaGetValues (WW, XmNwidth, &x, XmNheight, &y, NULL);


 if((xy==1)||(xy==-1))
 {
   

   dist = 35 + (grx - x);  
   if(dist<=0)
   {
	   return 0;
   }
   if(xy==-1)
   {
	 return dist;
   }
   return (double)((double)dist/xunits)*IRegionSize; 
 }
 else if((xy==2)||(xy==-2))
 {
   

   dist = 45 + (gry - y);  
   if(dist<=0)
   {
	 return 0;
   }
   if(xy==-2)
   {
	 return dist+40;
   }
   return (double)((double)dist/yunits)*IRegionSize; 

 }
 else if(xy==3)
 {
   

   dist = (grx - x);  
   if(dist<=0)
   {
	   return 0;
   }


   return (double)((double)dist/xunits)*IRegionSize; 
 }

 return 0;
}




void SetZoomValues(double centerLLX,double centerLLY,double centerURX,double centerURY)
{

  

  double xfraction,yfraction,multiplier,multiplier2,spanx,spany,
	  temp_xrange,temp_yrange,temp_llx_zoom,temp_lly_zoom,
	  temp_urx_zoom,temp_ury_zoom;
  double units1,units2;

  xfraction = GetXFractionVisible();
  yfraction = GetYFractionVisible();

  

  

  multiplier  = (1.0/xfraction) - 1.0;
  multiplier2 = (1.0/yfraction) - 1.0;

  temp_llx_zoom = centerLLX;
  temp_lly_zoom = centerLLY;
  temp_urx_zoom = centerURX + multiplier *(centerURX-centerLLX);
  temp_ury_zoom = centerURY + multiplier2*(centerURY-centerLLY);


  units1 = (IRegionSize*(xlimit-20.0))/(temp_urx_zoom-temp_llx_zoom);
  units2 = (IRegionSize*(ylimit-20.0))/(temp_ury_zoom-temp_lly_zoom);

  

  temp_xrange = fabs(temp_urx_zoom - temp_llx_zoom);
  temp_yrange = fabs(temp_ury_zoom - temp_lly_zoom);
  
  temp_xrange = temp_xrange/IRegionSize;
  temp_yrange = temp_yrange/IRegionSize;


  if(
	  ((temp_xrange*DBWidth) <(X_ZOOM_MAX))  ||
	  ((temp_yrange*DBHeight)<(Y_ZOOM_MAX))  ||
	  (units1<0)                               ||
	  (units2<0)
	  )

  {
	  
      global_zoomed_too_far = 1;
	  return;
  }


  llx_zoom = temp_llx_zoom;
  lly_zoom = temp_lly_zoom;
  urx_zoom = temp_urx_zoom;
  ury_zoom = temp_ury_zoom;


  if(units1<units2)
  {
    xunits = units1;
  }
  else
  {
    xunits = units2;
  }

  yunits = xunits;


  

  urx_zoom = llx_zoom+(xlimit/xunits)*IRegionSize;
  spanx = urx_zoom-llx_zoom-AddVoidSpace(1); 
  llx_zoom = centerLLX - (spanx - (centerURX-centerLLX)) / 2.0;      

  

  ury_zoom = lly_zoom+(ylimit/yunits)*IRegionSize;
  spany = ury_zoom-lly_zoom-AddVoidSpace(2);
  lly_zoom = centerLLY - (spany - (centerURY-centerLLY)) / 2.0;      

  
  urx_zoom = llx_zoom+(xlimit/xunits)*IRegionSize;
  ury_zoom = lly_zoom+(ylimit/yunits)*IRegionSize;

  SetScrollbars();
}



int GetNetExtents2(int errnum,int clonenum,int startindex)
{
  FILE *netfile;
  FILE *lfilein=NULL, *afilein=NULL, *pfilein=NULL;
  char geom;
  char fname[1000];
  int Afiledecimal=-1, Lfiledecimal=-1,Afileopen=-1,Lfileopen=-1;
  int ttlnets,NetTypeCount,i,j,LIindex,net_errnum,net_clonenum,ijunk,net_num,numfeatures;
  long int seekposn;
  double djunk;
  double FeatureFileInfo,dbltemp;
  struct LookupInfo
  {
    int cnumber;
    int index;
    long seekposn;
  } *LI;
  extern struct LinearAsRead LinearFromFile;
  extern struct ArealAsRead ArealFromFile;
  extern struct PointAsRead PointFromFile;
  extern int ReadArealFromFile(FILE * arealfile, double decimalplaces);
  extern int ReadLinearFromFile(FILE * linearfile, double decimalplaces);
  extern int ReadPointFromFile(FILE * pointfile, double decimalplaces);


  sprintf(fname,"%scondreport.nt",outdirectory);
  
  netfile = fopen(fname,"rb");
  if(netfile==NULL)
    {
      printf("Error: could not open %s\n",fname);
      return 0;
    }
  
  
  SEEIT_fread_int(&NetTypeCount,netfile);
  if(NetTypeCount<=0)
    {
      printf("internal error: GNE2: %d\n",NetTypeCount);
      return 0;
    }
  
  
  
  for(i=0; i<NetTypeCount; i++)
    {
      SEEIT_fread_int(&net_errnum,netfile);
      SEEIT_fread_int(&net_clonenum,netfile);
      SEEIT_fread_int(&ijunk,netfile);
      fread(&fname[0],1000,1,netfile);
    }
  
  SEEIT_fread_int(&ttlnets,netfile);

  

  LI = (struct LookupInfo *) (malloc(sizeof(struct LookupInfo) * (ttlnets + 2)));
  LIindex = 0;
  for(i=0; i<ttlnets; i++)
    {
      SEEIT_fread_int(&net_errnum,netfile);
      SEEIT_fread_int(&net_clonenum,netfile);
      SEEIT_fread_int(&net_num,netfile);
      SEEIT_fread_long(&seekposn,netfile);
      
      if((net_errnum==errnum)&&(net_clonenum==clonenum))
	{
	  LI[LIindex].cnumber = clonenum;
	  LI[LIindex].index = net_num;
	  LI[LIindex].seekposn = seekposn;
	  LIindex = LIindex + 1;
	}
    }
  
   
  for(i=0; i<LIindex; i++)
    {
      if((LI[i].cnumber==clonenum) && (LI[i].index==startindex)) 
	{
	  seekposn = LI[i].seekposn;
	  break;
	}
    }
  if(i>=LIindex)
    {
      printf("\n\ninternal error: i %d LIi %d\n",i,LIindex);
      return 0;
    }
  
  
  fseek(netfile,seekposn,SEEK_SET);
  SEEIT_fread_int(&net_errnum,netfile);
  SEEIT_fread_int(&net_clonenum,netfile);
  SEEIT_fread_int(&net_num,netfile);
  
  
  if((net_errnum==errnum)&&(net_clonenum==clonenum)&&(net_num==startindex))
    {
      SEEIT_fread_int(&ijunk,netfile);
      SEEIT_fread_int(&ijunk,netfile);
      SEEIT_fread_double(&djunk,netfile);  
      SEEIT_fread_double(&djunk,netfile);  
      SEEIT_fread_double(&djunk,netfile);  
      SEEIT_fread_double(&djunk,netfile);  
      SEEIT_fread_int(&numfeatures,netfile);



      for(j=0; j<numfeatures; j++)
	{
	  
	  fread(&geom,1,1,netfile);
	  SEEIT_fread_double(&FeatureFileInfo,netfile);
	  

	  if((int)geom == G_AREAL)
	    {	      
	      seekposn = (long int) FeatureFileInfo;
	      dbltemp = FeatureFileInfo - ((double)seekposn);
	      dbltemp = dbltemp * 10;
	      dbltemp = dbltemp + 0.1;
	      Afiledecimal = (int) dbltemp;
	      if(Afiledecimal != Afileopen)
		{
		  if(afilein != NULL)
		    {
		      fclose(afilein);
		    }
		  
		  if(Afiledecimal > 1)
		    {
		      sprintf(fname,"%sarealdata.bin%d",indirectory,Afiledecimal-1);
		    }
		  else
		    {
		      sprintf(fname,"%sarealdata.bin",indirectory);
		    }
		  
		  
		  afilein = fopen(fname,"rb");
		  if(afilein == NULL)
		    {
		      printf("ie9 area feature data input file %s could not be opened\n",fname);
		      return 0;
		    }
		  Afileopen = Afiledecimal;
		}
	      
	      fseek(afilein,seekposn,SEEK_SET);
	      ijunk = ReadArealFromFile(afilein,10);

	      for(i=0; i<ArealFromFile.numverts; i++)
		{
		  TestCoordExtents(0,ArealFromFile.x[i],ArealFromFile.y[i]);
		}
	    }
	  else if((int)geom == G_LINE)
	    {      
	      seekposn = (long int) FeatureFileInfo;
	      dbltemp = FeatureFileInfo - ((double) seekposn);
	      dbltemp = dbltemp * 10;
	      dbltemp = dbltemp + 0.1;
	      Lfiledecimal = (int) dbltemp;
	      if(Lfiledecimal != Lfileopen)
		{
		  if(lfilein != NULL)
		    {
		      fclose(lfilein);
		    }
		  
		  if(Lfiledecimal > 1)
		    {
		      sprintf(fname,"%slineardata.bin%d",indirectory,Lfiledecimal-1);
		    }
		  else
		    {
		      sprintf(fname,"%slineardata.bin",indirectory);
		    }
		  
		  lfilein = fopen(fname,"rb");
		  if(lfilein == NULL)
		    {
		      printf("ie7 line feature data input file %s could not be opened\n",fname);
		      return 0;
		    }
		  Lfileopen = Lfiledecimal;
		}
	      
	      fseek(lfilein,seekposn,SEEK_SET);
	      ijunk = ReadLinearFromFile(lfilein,10);


	      for(i=0; i<LinearFromFile.numnodes; i++)
		{
		  

		  TestCoordExtents(0,LinearFromFile.x[i], LinearFromFile.y[i]);
		}

	      
	    }
	  else if((int)geom == G_POINT)
	    {
	      if(pfilein==NULL)
		{
		  sprintf(fname,"%spointdata.bin",indirectory);
		  pfilein = fopen(fname,"rb");
		}
	      seekposn = (long int) FeatureFileInfo;
	      fseek(pfilein,seekposn,SEEK_SET);
	      ijunk = ReadPointFromFile(pfilein,10);
	      
	      TestCoordExtents(0,PointFromFile.x[0],PointFromFile.y[0]);
	    }
	  
	  
	}
      
    
      if(pfilein!=NULL)
	{
	  fclose(pfilein);
	}
      if(lfilein!=NULL)
	{
	  fclose(lfilein);
	}
      if(afilein!=NULL)
	{
	  fclose(afilein);
	}
      
      fclose(netfile);
      free(LI);
      return 1;
    }
    


   


  if(pfilein!=NULL)
    {
      fclose(pfilein);
    }
  if(lfilein!=NULL)
    {
      fclose(lfilein);
    }
  if(afilein!=NULL)
    {
      fclose(afilein);
    }
  
  free(LI);
  fclose(netfile);
  return 0;
}



int GetNetExtents()
{
  
  int errnum,clonenum,cloneindex,result;
  


  TestCoordExtents(1,0,0);
  
  ErrLLX = -100;
  ErrLLY = -100;
  ErrURX = -200;
  ErrURY = -200;


  for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
    {
      if(ErrorLookup[errnum].numberNets>0)
	{
	  if(ErrorLookup[errnum].viewallNET==1)
	    {
	      printf("Error in GNE:  VAN 1\n");
	      XBell(mydisplay,50);
	      return 0;
	    }
	  else if(ErrorLookup[errnum].viewsomeNET==1)
	    {
	      if(ErrorLookup[errnum].NETpos_list_made==1)
		{
		  clonenum = 0;

		  

		  result = GetNetExtents2(errnum,clonenum,ErrorLookup[errnum].NETpos_list[0]);
		  if(result==0)
		    {
		      return 0;
		    }
		}
	    }
	}
    }	



  for(cloneindex=0;cloneindex<CLONE_DEFINITIONS;cloneindex++)
    {	
      if(CloneErrorLookup[cloneindex].numberNets>0)
	{
	  if(CloneErrorLookup[cloneindex].viewallNET==1)
	    {
	      printf("Error in GNE:  VAN 1 for ci %d\n",cloneindex);
	      XBell(mydisplay,50);
	      return 0;
	    }
	  else if(CloneErrorLookup[cloneindex].viewsomeNET==1)
	    {
	      if(CloneErrorLookup[cloneindex].NETpos_list_made==1)
		{

		  clonenum = GetCloneNumber(cloneindex,CloneErrorLookup[cloneindex].CloneNumber);

		  

		  result = GetNetExtents2( 		     
				 CloneErrorLookup[cloneindex].CloneNumber,
				 clonenum,
				 CloneErrorLookup[cloneindex].NETpos_list[0]);

		  if(result==0)
		    {
		      return 0;
		    }
		}
	    }
	}
    }



  

  if(ErrLLX<=ErrURX)
    {
      
      
	  

      return 1;
    }

  return 0;


}



void refreshCallback(Widget w,XtPointer data,XtPointer callData)
{
  Dimension x1,y1;
  String temp="zoom_out";
  char scrubout[1000];
  int i,outlen,SpecificConditionBegin,SpecificConditionEnd,TotalSpecs,TotalSpecs2;
  int junk=1,temp_mode=-1,ErrorIndex,SingleBegin,SingleEnd,CloneIndex;
  int ConditionFlags[CONDITION_ARRAY_SIZE];
  double numregions,totalfraction;
  struct ConditionList * NEW_LIST=NULL;
  struct AdditionalConditions * AdditionalConditionFlags=NULL;
  extern int CenterZoomOnNets;


  if(input_source==0)
    {
      
      return;
    }
 
  if(output_source==0)
    {
      
      return;
    }


  XtVaGetValues (drawing_a, XmNwidth, &x1, XmNheight, &y1, NULL);
  x1=x1-10;
  y1=y1-10;


  TotalSpecs  = GetTotalIndiv(&ErrorIndex,&SingleBegin,&SingleEnd,&CloneIndex);
  TotalSpecs2 = GetTotalNonIndiv();
  
  




  if(
      (PossibleToCenterNetZoom==1) &&
      (CenterZoomOnNets==1)
      )
    {
	  


      if(GetNetExtents()>0)
	{
	  


	  
	  
	  ErrLLX = ErrLLX - NPAD_DIST;
	  ErrLLY = ErrLLY - NPAD_DIST;
	  ErrURX = ErrURX + NPAD_DIST;
	  ErrURY = ErrURY + NPAD_DIST;

	  numregions = ((ErrURX-ErrLLX+1)/RegionSize) * (ErrURY-ErrLLY+1)/RegionSize;
  
	  totalfraction = numregions/((MaxXindex+1)*(MaxYindex+1));

	  

	  if((numregions>1000)||(totalfraction>0.25))
	    {
		  
	      ZoomAllOut();
	      return;
	    }

      
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  SaveXScroll = ScrollPercent(1);
	  SaveYScroll = ScrollPercent(2);
	  SetZoomValues(ErrLLX,ErrLLY,ErrURX,ErrURY);
	  
	  
	  MakePixmap3();
	  set_color (drawing_a, "White",(XtPointer)NULL);
	  XFillRectangle (XtDisplay (drawing_a), pixmap,   mygc, 0, 0, width, height);
	  XFillRectangle (XtDisplay (drawing_a), mywindow, mygc, 0, 0, width, height);
	  SetColorRight();
	  
	  
	  NOT_ZOOMED = 0; 
	  
	  SAVE_ZOOM_STATE(SaveXScroll,SaveXScroll); 
	  DrawAll();
	}
      else
	{
	  printf("Not zooming due to previous error\n");
	}

      return;
    }











  if( 
     (PossibleToCenterZoom==1) &&
     (CenterZoomOnErrors==1)   &&
     (TotalSpecs==1)           &&
     (TotalSpecs2==0)
     )
    {  
      
      for(i=1;i<=CONDITION_DEFINITIONS;i++)
	{
	  ConditionFlags[i] = 0;
	}    


      if(CloneIndex<0)
	{
	  
	  ConditionFlags[ErrorIndex] = 1;
	}
    
      
      sprintf(scrubout,"%s",outdirectory);
      outlen = strlen(scrubout);
      scrubout[outlen-1] = '\0';
      
      SEEIT_LoadConditionReport(scrubout);
      
      
      if(CloneIndex >= 0)
	{
	  
	  
	  SEEIT_AddAdditionalFlag(&AdditionalConditionFlags,
				  CloneErrorLookup[CloneIndex].CloneNumber, 
				  GetCloneNumber(CloneIndex,CloneErrorLookup[CloneIndex].CloneNumber)
				  );
	  
	}
      SpecificConditionBegin  = SingleBegin;
      SpecificConditionEnd    = SingleEnd;
      
      ABORT_ZOOM = 0;
      
      NEW_LIST =
	SEEIT_GetConditions(scrubout,
			    ConditionFlags,
			    SpecificConditionBegin,
			    SpecificConditionEnd,
			    AdditionalConditionFlags, 
			    1,     
			    1,     
			    0,     
			    NULL,
			    -1
			    );
  
      if(NEW_LIST==NULL)
	{
	  if(NGA_TYPE==1)
	    {
	      not_while_running(drawing_a,"An error has occured in the GAIT condition report API:\nNULL error list returned",1284,"Error",5);
	    }
	  else
	    {
	      not_while_running(drawing_a,"An error has occured in the SEE-IT condition report API:\nNULL error list returned",1285,"Error",5);
	    }

	  printf("NULL list 3\n");
	  return;
	}

    
      GetExtents(NEW_LIST);

     
            
      UnTranslateCoords(&ErrLLX,&ErrLLY);
      UnTranslateCoords(&ErrURX,&ErrURY);


      
      ErrLLX = ErrLLX - PAD_DIST;
      ErrLLY = ErrLLY - PAD_DIST;
      ErrURX = ErrURX + PAD_DIST;
      ErrURY = ErrURY + PAD_DIST;


      numregions = ((ErrURX-ErrLLX+1)/RegionSize) * (ErrURY-ErrLLY+1)/RegionSize;
     
	  totalfraction = numregions/((MaxXindex+1)*(MaxYindex+1));

      

      if((numregions>1000)||(totalfraction>0.25))
	  {
		  
		  ZoomAllOut();
		  return;
	  }


	  
      
      
    
    



      

	  
	  SaveXScroll = ScrollPercent(1);
	  SaveYScroll = ScrollPercent(2);
	  SetZoomValues(ErrLLX,ErrLLY,ErrURX,ErrURY);

      
      MakePixmap3();
      set_color (drawing_a, "White",(XtPointer)NULL);
      XFillRectangle (XtDisplay (drawing_a), pixmap,   mygc, 0, 0, width, height);
      XFillRectangle (XtDisplay (drawing_a), mywindow, mygc, 0, 0, width, height);
      SetColorRight();
 

      NOT_ZOOMED = 0; 

      SAVE_ZOOM_STATE(SaveXScroll,SaveXScroll); 
      DrawAll();


      SEEIT_FreeConditions(NEW_LIST);
      SEEIT_FreeAdditionalFlags(AdditionalConditionFlags);
      AdditionalConditionFlags = NULL;
      SEEIT_FreeConditionReportMemory();
 

      return;
    }



  

  if ((xunits==mymax(PixDBWidth,PixDBHeight))||(NOT_ZOOMED==1))
    {
      
      
      junk = 1;
      
      if(ZOOM_MODE==0)
	{
	  if(PROFILE_MODE==1)   {PROFILE_MODE = 0; temp_mode = 1;}
	  else if(FAN_MODE==1)  {FAN_MODE     = 0; temp_mode = 2;}
	  else if(INFO_MODE==1) {INFO_MODE    = 0; temp_mode = 3;}
	  else if(DIST_MODE==1) {DIST_MODE    = 0; temp_mode = 4;}
	  else if(CHECK_MODE==1){CHECK_MODE   = 0; temp_mode = 5;}
	  else if(PAN_MODE==1)  {PAN_MODE     = 0; temp_mode = 6;}
	  else if(LOS==1)       {LOS          = 0; temp_mode = 7;}
 	  ZOOM_MODE=1;
	}
    
      set_cursor(mydisplay,mywindow,WATCH);

      
      


      draw(drawing_a,NULL,&temp,&junk);


      BUSY=1;
      if(temp_mode>0)
	{
	  if(temp_mode==1)     {PROFILE_MODE = 1;}
	  else if(temp_mode==2){FAN_MODE     = 1;}
	  else if(temp_mode==3){INFO_MODE    = 1;}
	  else if(temp_mode==4){DIST_MODE    = 1;}
	  else if(temp_mode==5){CHECK_MODE   = 1;}
	  else if(temp_mode==6){PAN_MODE     = 1;}
	  else if(temp_mode==7){LOS          = 1;}
	  ZOOM_MODE=0;
	}
      set_cursor(mydisplay,mywindow,GOOD);
      BUSY=0;
      return;
    }

  BUSY=1; 

  
  MakePixmap3();
  set_color (drawing_a, "White",(XtPointer)NULL);
  XFillRectangle (XtDisplay (drawing_a), pixmap, mygc, 0, 0, x1+10,y1+10);
  XFillRectangle (XtDisplay (drawing_a), mywindow, mygc, 0, 0, x1+10,y1+10);
  

  if(GRID==1)
    {
      if(xunits>=20)
	{
	  DrawGrid();
	  XFlush(mydisplay);
	}
    }
  
  if(DEBUG==1){printf("refresh drawall\n");}
  
 
      urx_zoom = llx_zoom+(1000.0/xunits)*IRegionSize;
      ury_zoom = lly_zoom+(850.0/yunits)*IRegionSize;
      
      DrawAll();
    
  
  XCopyArea (mydisplay, mywindow,pixmap, mygc,
	     0, 0, width, height, 0, 0);
    
  BUSY=0; 
}



void los_result(Widget w,XtPointer data,XtPointer callData)
{
  char *value = XmTextFieldGetString (w);
  int dots=0,i;
  double test;
  char temp[50];
  int num = (int)data;
  extern double NPAD_DIST;

  bad_los_result = 0;


   
  
  if(num==1){sprintf(temp,"%.2lf",      OBS_HEIGHT) ;}
  else if(num==2) {sprintf(temp,"%.2lf",TGT_HEIGHT) ;}
  else if(num==3) {sprintf(temp,"%.2lf",FAN_ANGLE)  ;}
  else if(num==4) {sprintf(temp,"%d",   FAN_QUALITY);}
  else if(num==5) {sprintf(temp,"%.3lf",CLIPLLX)    ;}
  else if(num==6) {sprintf(temp,"%.3lf",CLIPLLY)    ;}
  else if(num==7) {sprintf(temp,"%.3lf",CLIPURX)    ;}
  else if(num==8) {sprintf(temp,"%.3lf",CLIPURY)    ;}
  else if(num==9) {sprintf(temp,"%.2lf",PAD_DIST)   ;}
  else if(num==10){sprintf(temp,"%.2lf",VPAD_DIST)  ;}
  else if(num==11){sprintf(temp,"%.2lf",PPAD_DIST)  ;}
  else if(num==12){sprintf(temp,"%.2lf",NPAD_DIST)  ;}
  


  
  
  for(i=0;i<(int)(strlen(value));i++)
    {
      if((value[i]<'0')||(value[i]>'9'))
	{
	  if(value[i]=='.')
	    {
	      dots++;
	      if(dots<2){continue;}
	    }
	  if((value[i]=='-')&&(i==0)&&(num>=5)&&(num<=8))
	    {
	      continue;
	    }

          
	  
	  XmTextFieldSetString(w,temp);
	  XtFree(value);
	  bad_los_result = 1;
          return; 
	}
    }
  
  if(strlen(value)==0)
    {
      XmTextFieldSetString(w,temp);
      XtFree(value);
      bad_los_result = 1;
      return;
    }
  
    
  
  
  sscanf(value,"%lf",&test);

  if(DEBUG==1){printf("test is %lf\n",test);}
  
  if  ((num<3)&& ((test<2000.0)&&(test>0.000)))
    {
      if(num==1){OBS_HEIGHT = test;}
      else if(num==2){TGT_HEIGHT = test;}
    }
  else if(  (num==3)  && (test>.999) && (test<=360.0))
    {
      FAN_ANGLE = test;
    }
  else if(num==4)
    {
      if(test<1.0){test=1.0;}
      else if(test>10.0){test=10.0;}
      FAN_QUALITY = (int)test;
    }



  else if(num==5)
    {
      if( (test<CLIPURX) && (test>=-180.0001) && (test<=180.0001) )
	{
	  CLIPLLX = test;
	}
      else
	{
	  bad_los_result = 1;
	}
    } 
  else if(num==6)
    {
      if( (test<CLIPURY) && (test>=-90.0001) && (test<= 90.0001) )
	{
	  CLIPLLY = test;
	}
      else
	{
	  bad_los_result = 1;
	}
    }
  else if(num==7)
    {
      if( (test>CLIPLLX) && (test>=-180.0001) && (test<=180.0001) )
	{
	  CLIPURX = test;
	}
      else
	{
	  bad_los_result = 1;
	}
    }
  else if(num==8)
    {
      if( (test>CLIPLLY) && (test>=-90.0001) && (test<=90.0001) )
	{
	  CLIPURY = test;
	}
      else
	{
	  bad_los_result = 1;
	}
    }
  else if( num==9)
    {
      if((test>=MIN_PAD_DIST) && (test<=MAX_PAD_DIST))
	{
	  PAD_DIST = test;
	}
      else
	{
	  bad_los_result = 1;
	}
    }
  else if( num==10)
    {
      if((test>=MIN_PAD_DIST) && (test<=MAX_PAD_DIST))
	{
	  VPAD_DIST = test;
	}
      else
	{
	  bad_los_result = 1;
	}
    }
  else if( num==11)
    {
      if((test>=MIN_PAD_DIST) && (test<=MAX_PAD_DIST))
	{
	  PPAD_DIST = test;
	}
      else
	{
	  bad_los_result = 1;
	}
    }
  else if( num==12)
    {
      if((test>=MIN_PAD_DIST) && (test<=MAX_PAD_DIST))
	{
	  NPAD_DIST = test;
	}
      else
	{
	  bad_los_result = 1;
	}
    }
  

  if(num==1)      {sprintf(temp,"%.2lf",OBS_HEIGHT)  ;}
  else if(num==2) {sprintf(temp,"%.2lf",TGT_HEIGHT)  ;}
  else if(num==3) {sprintf(temp,"%.2lf",FAN_ANGLE)   ;}
  else if(num==4) {sprintf(temp,"%d",   FAN_QUALITY) ;}
  else if(num==5) {sprintf(temp,"%.3lf",CLIPLLX)     ;}
  else if(num==6) {sprintf(temp,"%.3lf",CLIPLLY)     ;}
  else if(num==7) {sprintf(temp,"%.3lf",CLIPURX)     ;}
  else if(num==8) {sprintf(temp,"%.3lf",CLIPURY)     ;}
  else if(num==9) {sprintf(temp,"%.2lf",PAD_DIST)    ;}
  else if(num==10){sprintf(temp,"%.2lf",VPAD_DIST)   ;}
  else if(num==11){sprintf(temp,"%.2lf",PPAD_DIST)   ;}
  else if(num==12){sprintf(temp,"%.2lf",NPAD_DIST)   ;}
  
  XmTextFieldSetString(w,temp);

  XtFree(value);
}







int discrete_result(Widget w,XtPointer data,XtPointer callData)
{
  char *value = XmTextFieldGetString (w);
  int dots=0,i,layer_num=(int)data;
  double test;
  char temp[500];
  int failed = 0;


  sprintf(temp,"%.2lf",LODindex_DYN[layer_num].discrete_ignore_value);


  for(i=0;i<(int)(strlen(value));i++)
  { 
	if((value[i]<'0')||(value[i]>'9'))
	{
	  if(value[i]=='.')
	  {
		dots++;
		if(dots<2){continue;}
	  } 
	      
	  if(value[i]=='-')
	  { 
		if(i==0){continue;}
	  } 
	          
	  
	      
	  XmTextFieldSetString(w,temp);
	  XtFree(value);
	  return 0; 
	} 
  }   



  if(strlen(value)==0)
  { 
    XtFree(value);
    return 0;
  }
  
    

  sscanf(value,"%lf",&test);




  if(DEBUG==1){printf("test is %lf\n",test);}


  

  LODindex_DYN[layer_num].discrete_ignore_value = test;



  

  sprintf(temp,"%.2lf",LODindex_DYN[layer_num].discrete_ignore_value);
   
  XmTextFieldSetString(w,temp);
  

  XtFree(value);
 
  if(failed==1)
  {
    return 0;
  }
  return 1;  

}












int fore_result(Widget w,XtPointer data,XtPointer callData)
{
  char *value = XmTextFieldGetString (w);
  int dots=0,i,type=(int)data,tempint,len;
  double test,divider;
  char temp[500],message[500];
  int nomessage = 0;
  int failed    = 0;


  

  if(type>1000)
    {
      nomessage = 1;
      type = type - 1000;
    }



  if(Ctype()==1)
    {
      if(type==1){sprintf(temp,"%.4lf",ContourInterval);}
      else if(type==2) {sprintf(temp,"%.7lf",GridX);}
      else if(type==3) {sprintf(temp,"%.7lf",GridY);}
      else if(type==4) {sprintf(temp,"%.7lf",GridSpace);}
      else if(type==20){sprintf(temp,"%d",ZoomSunAzimuth);}
      else if(type==21){sprintf(temp,"%d",ZoomSunAngle);}
      else if(type==22){sprintf(temp,"%.2lf",ZoomVertExag);}
      else if(type==23){sprintf(temp,"%d",VertexPrintLimit);}
      else if(type==24){sprintf(temp,"%s",GAITProjectName);}
      else if(type==25){sprintf(temp,"%s",shapeimportoutputdir);}
      else if(type==26){sprintf(temp,"%d",DIGITS_TO_PRINT);}
      else if(type==27){sprintf(temp,"%s",metamapfile);}
      else if(type==28){sprintf(temp,"%.4lf",ErrorLookup[LODELEVDIF].sensitivity);}
      else if(type==29){sprintf(temp,"%.4lf",ErrorLookup[GSPIKE].sensitivity); }
      else if(type==30){sprintf(temp,"%.4lf",ErrorLookup[GSPIKE].sensitivity2);}
      else if(type==31){sprintf(temp,"%.4lf",ErrorLookup[GSPIKE].sensitivity3);}
      else if(type==32){sprintf(temp,"%.4lf",ErrorLookup[LODELEVDIF].sensitivity2);}
      else if(type==33){sprintf(temp,"%.4lf",ErrorLookup[LODELEVDIF].sensitivity3);}
      else if(type==34){sprintf(temp,"%s",attrinsfolder);}
      else if(type==35){sprintf(temp,"%s",shape_out_name);}
      else if(type==36){}
      else
	{
	  printf("bad arg %d to fore_result\n",type);
	  ExitWrapper(-1);
	}
      divider = 100000.0;
    }
  else if(Ctype()==2)
    {
      if(type==1){sprintf(temp,"%.4lf",ContourInterval);}
      else if(type==2) {sprintf(temp,"%.1lf",GridX);}
      else if(type==3) {sprintf(temp,"%.1lf",GridY);}
      else if(type==4) {sprintf(temp,"%.1lf",GridSpace);}
      else if(type==20){sprintf(temp,"%d",ZoomSunAzimuth);}
      else if(type==21){sprintf(temp,"%d",ZoomSunAngle);}
      else if(type==22){sprintf(temp,"%.2lf",ZoomVertExag);}
      else if(type==23){sprintf(temp,"%d",VertexPrintLimit);}
      else if(type==24){sprintf(temp,"%s",GAITProjectName);}
      else if(type==25){sprintf(temp,"%s",shapeimportoutputdir);}
      else if(type==26){sprintf(temp,"%d",DIGITS_TO_PRINT);}
      else if(type==27){sprintf(temp,"%s",metamapfile);}
      else if(type==28){sprintf(temp,"%.4lf",ErrorLookup[LODELEVDIF].sensitivity);}
      else if(type==29){sprintf(temp,"%.4lf",ErrorLookup[GSPIKE].sensitivity); }
      else if(type==30){sprintf(temp,"%.4lf",ErrorLookup[GSPIKE].sensitivity2);}
      else if(type==31){sprintf(temp,"%.4lf",ErrorLookup[GSPIKE].sensitivity3);}
      else if(type==32){sprintf(temp,"%.4lf",ErrorLookup[LODELEVDIF].sensitivity2);}
      else if(type==33){sprintf(temp,"%.4lf",ErrorLookup[LODELEVDIF].sensitivity3);}
      else if(type==34){sprintf(temp,"%s",attrinsfolder);}
      else if(type==35){sprintf(temp,"%s",shape_out_name);}
      else if(type==36){}
      else
	{
	  printf("bad arg %d to fore_result\n",type);
	  ExitWrapper(-1);
	}
      divider = 1.0;
    }


  

  if((type!=24)&&(type!=25)&&(type!=27)&&(type!=34)&&(type!=35))
  { 
    for(i=0;i<(int)(strlen(value));i++)
	{ 
	  if((value[i]<'0')||(value[i]>'9'))
	  {
	    if((value[i]=='.') && ((type<15)||(type==22)||(type==28)||(type==29)||(type==30)||(type==31)||(type==32)||(type==33))   )
		{
		  dots++;
		  if(dots<2){continue;}
		} 
	      
	    if(value[i]=='-')
		{ 
		  if(i==0){continue;}
		} 
	      
	      
	     
	      
	     XmTextFieldSetString(w,temp);
	     XtFree(value);
	     return 0; 
	  } 
	}  
  }  


  if(strlen(value)==0)
    {
      if((type!=24)&&(type!=25))
	{
	  XmTextFieldSetString(w,temp);
	}
      else if(type==24)
	{
	  XtVaSetValues(terrain_to_import,    XmNlabelString,STRING("   <enter project name below to specify>"),NULL);
	  
	  import_source        = 0;
	  import_output_source = 0;
	}
      else if(type==25)
	{
	  
	  shape_source=0;
	}
      else if(type==27)
	{
	  metamap_source=0;
	}
      else if(type==34)
	{
	  attrins_source=0;
	}

      XtFree(value);
      return 0;
    }
  
    

  if((type!=24)&&(type!=25)&&(type!=27)&&(type!=34)&&(type!=35))
    {
      sscanf(value,"%lf",&test);
    }



  if(DEBUG==1){printf("test is %lf\n",test);}


  if((type==20)||(type==21)||(type==22)||(type==26))
    {
      tempint = (int)test;
      if(type==26)
	{
	  if((tempint<1)||(tempint>15))
	    {
	      if(nomessage==0)
		{
		  sprintf(message,"The decimal limit you have entered is out of range.\n\
You must enter a valid integer from 1 to 15\n");
		  not_while_running(w,message,1372,"Illegal Decimal Limit",1);
		  failed = 1;
		}
	    }
	  else
	    {
	      DIGITS_TO_PRINT = tempint;	  
	    }
	}
      else if(type==20)
	{
	  if((tempint<0)||(tempint>359))
	    {
	      if(nomessage==0)
		{
		  sprintf(message,"The Sun Azimuth you have entered is out of range.\n\
You must enter a valid integer from 0 to 359\n");
		  not_while_running(w,message,1287,"Illegal Sun Azimuth",1);
		  failed = 1;
		}
	    }
	  else
	    {
	      ZoomSunAzimuth = tempint;	  
	    }
	}
      
      else if(type==21)
	{
	  if((tempint<15)||(tempint>75))
	    {
	      if(nomessage==0)
		{
		  sprintf(message,"The Sun Angle you have entered is out of range.\n\
You must enter a valid integer from 15 to 75\n");
		  not_while_running(w,message,1289,"Illegal Sun Angle",1);
		  failed = 1;
		}
	    }
	  else
	    {
	      ZoomSunAngle = tempint;	  
	    }
	}
      else if(type==22)
	{
	  if((test<0.1)||(test>1000))
	    {
	      if(nomessage==0)
		  {
		  sprintf(message,"The Vertical Exagerration you have entered is out of range.\n\
You must enter a valid number from 0.1 to 1000\n");
		  not_while_running(w,message,1291,"Illegal Vertical Exagerration",1);
		  failed = 1;
		  } 
	    }
	  else
	    {
	      ZoomVertExag = test;	  
	    }
	}
    }
  else if(type==1)
    {
      if((test>0)&&(test<=2000))
	{
	  ContourInterval = test;
	}
    }
  else if(type==28)
    {
      if((test>ErrorLookup[LODELEVDIF].lowrange)&&(test<=ErrorLookup[LODELEVDIF].highrange))
	{
	  ErrorLookup[LODELEVDIF].sensitivity = test;
	}
    }
  else if(type==29)
    {
      if((test>ErrorLookup[GSPIKE].lowrange)&&(test<=ErrorLookup[GSPIKE].highrange))
	{
	  ErrorLookup[GSPIKE].sensitivity = test;
	}
    }
  else if(type==30)
    {
	  ErrorLookup[GSPIKE].sensitivity2 = test;
    }
  else if(type==31)
    {
	  ErrorLookup[GSPIKE].sensitivity3 = test;
    }
  else if(type==32)
    {
	  ErrorLookup[LODELEVDIF].sensitivity2 = test;
    }
  else if(type==33)
    {
	  ErrorLookup[LODELEVDIF].sensitivity3 = test;
    }
  else if(type==36)
    {



	  



      
    }
  else if(type==23)
    {
      VertexPrintLimit = (int)test;
    }
  

  
  else if((type==4)||(type==5)||(type==8))
    {
      if
	(Ctype()==1)
	{
	  if((test>=0.00001)&&(test<=10.0))
	    {
	      
	      if(type==4){GridSpace = test;}
	    }
	  else
	    {

	      sprintf(message,"The Spacing you have entered is out of range.\n\
You must enter a valid number from 0.00001 to 10.0\n");
	      not_while_running(w,message,1292,"Illegal Grid Spacing",1);
		  failed = 1;
	    }
	}
      else if(Ctype()==2)
	{
	  if((test>=1)&&(test<=100000.0))
	    {
	      
	      if(type==4){GridSpace = test;}
	    }
	  else
	    {
	      sprintf(message,"The Spacing you have entered is out of range.\n\
You must enter a valid number from 1 to 100000\n");
	      not_while_running(w,message,1293,"Illegal Grid Spacing",1);
		  failed = 1;
	    }
	}
    }
  else if((type==2)||(type==6))     
    {
 
	  if(
	 ((test+.0000001)>=Xtranslation)&&
	 ((test-.0000001)<=(Xtranslation+(MaxXindex+1)*(RegionSize/divider))) 
	 )
	{
	  if(type==2){GridX = test;}
	}
      else if((NGA_TYPE==1)&&(test>=-180.0)&&(test<=180.0))
	  {
	     if(type==2){GridX = test;}
	  }
	  else if(NGA_TYPE==1)
	  {
	    sprintf(message,"The Grid X Anchor Point you have entered is out of range.\n\
You must enter a valid number from -180.0 to 180.0\n");

	  not_while_running(w,message,1294,"Illegal X Point",1);
	  failed = 1;	  
	  }
	  else
	{
	  sprintf(message,"The X point you have entered is out of range.\n\
You must enter a valid number from %lf to %lf\n",Xtranslation,
Xtranslation+(MaxXindex+1)*(RegionSize/divider)); 

	  not_while_running(w,message,1294,"Illegal X Point",1);
	  failed = 1;
	}
    }
  else if(type==3)
    {
     
      if(
	 ((test+.0000001)>=Ytranslation)&&
	 ((test-.0000001)<=(((MaxYindex+1)*RegionSize)/100000.0 + Ytranslation)) 
	 )
	{
	  if(type==3){GridY = test;}
	}
      else if((NGA_TYPE==1)&&(test>=-90.0)&&(test<=90.0))
	  {
	     if(type==3){GridY = test;}
	  }
	  else if(NGA_TYPE==1)
	  {
	    sprintf(message,"The Grid Y Anchor Point you have entered is out of range.\n\
You must enter a valid number from -90.0 to 90.0\n");

	  not_while_running(w,message,1294,"Illegal X Point",1);
	  failed = 1;	  
	  }
      else
	{

	  sprintf(message,"The Y Point you have entered is out of range.\n\
You must enter a valid number from %lf to %lf\n",Ytranslation,
Ytranslation+(MaxYindex+1)*(RegionSize/divider));  

	  not_while_running(w,message,1295,"Illegal Y Point",1);
	  failed = 1;
	  	  
	  
	  }
    }
  else if(type==24)
    {
      sprintf(GAITProjectName,"%s",value);

      

      if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
	{
	  sprintf(importdirectory,"%s\\%s\\InputSpecFile.txt",PROJECTLOC,GAITProjectName);
	  sprintf(importoutputdir,"%s\\%s\\",PROJECTLOC,GAITProjectName);
	}
      else
	{
	  sprintf(importdirectory,"%s/%s/InputSpecFile.txt",PROJECTLOC,GAITProjectName);
	  sprintf(importoutputdir,"%s/%s/",PROJECTLOC,GAITProjectName);
	}
      XtVaSetValues(terrain_to_import,    XmNlabelString,STRING(importdirectory),NULL);

      import_source        = 1;
      import_output_source = 1;
    }
  else if(type==25)
    {
      sprintf(shapeimportoutputdir,"%s",value);
      shape_source=1;
    }
  else if(type==27)
    {
      sprintf(metamapfile,"%s",value);
      metamap_source=1;
    }
  else if(type==34)
    {
      sprintf(attrinsfolder,"%s",value);
      attrins_source=1;
    }
  else if(type==35)
    {
      len = strlen(value);

      for(i=0;i<len;i++)
	  {
        if(
            ((value[i]<65)   || (value[i]>90))  &&
            ((value[i]<48)   || (value[i]>57))  &&
            ((value[i]<97)   || (value[i]>122)) &&
             (value[i]!='-') && (value[i]!='_')
		     )
		{
		      sprintf(message,"The Export Shapefile Name you have entered is invalid because\n\
it contains the character \"%c\"\n\n\
Please enter a name consisting of letters, numbers, \"-\", and \"_\"\n",value[i]);

		      not_while_running(w,message,1539,"Bad Export Shapefile Name",1);   

			  return 0;
		}
	  }
    sprintf(shape_out_name,"%s",value);
  }


  if(Ctype()==1)
    {
      
      if(type==1){sprintf(temp,"%.4lf",ContourInterval);}
      else if(type==2) {sprintf(temp,"%.7lf",GridX);}
      else if(type==3) {sprintf(temp,"%.7lf",GridY);}
      else if(type==4) {sprintf(temp,"%.7lf",GridSpace);}
      else if(type==20){sprintf(temp,"%d",ZoomSunAzimuth);}
      else if(type==21){sprintf(temp,"%d",ZoomSunAngle);}
      else if(type==22){sprintf(temp,"%.2lf",ZoomVertExag);}
      else if(type==23){sprintf(temp,"%d",VertexPrintLimit);}
      else if(type==24){sprintf(temp,"%s",GAITProjectName);}
      else if(type==25){sprintf(temp,"%s",shapeimportoutputdir);}
      else if(type==26){sprintf(temp,"%d",DIGITS_TO_PRINT);}
      else if(type==27){sprintf(temp,"%s",metamapfile);}
      else if(type==28){sprintf(temp,"%.4lf",ErrorLookup[LODELEVDIF].sensitivity);}
      else if(type==29){sprintf(temp,"%.4lf",ErrorLookup[GSPIKE].sensitivity); }
      else if(type==30){sprintf(temp,"%.4lf",ErrorLookup[GSPIKE].sensitivity2);}
      else if(type==31){sprintf(temp,"%.4lf",ErrorLookup[GSPIKE].sensitivity3);}
      else if(type==32){sprintf(temp,"%.4lf",ErrorLookup[LODELEVDIF].sensitivity2);}
      else if(type==33){sprintf(temp,"%.4lf",ErrorLookup[LODELEVDIF].sensitivity3);}
      else if(type==34){sprintf(temp,"%s",attrinsfolder);}
      else if(type==35){sprintf(temp,"%s",shape_out_name);}
      
    }
  else if(Ctype()==2)
    {
      
      if(type==1){sprintf(temp,"%.4lf",ContourInterval);}
      else if(type==2) {sprintf(temp,"%.1lf",GridX);}
      else if(type==3) {sprintf(temp,"%.1lf",GridY);}
      else if(type==4) {sprintf(temp,"%.1lf",GridSpace);}
      else if(type==20){sprintf(temp,"%d",ZoomSunAzimuth);}
      else if(type==21){sprintf(temp,"%d",ZoomSunAngle);}
      else if(type==22){sprintf(temp,"%.2lf",ZoomVertExag);}
      else if(type==23){sprintf(temp,"%d",VertexPrintLimit);}
      else if(type==24){sprintf(temp,"%s",GAITProjectName);}
      else if(type==25){sprintf(temp,"%s",shapeimportoutputdir);}
      else if(type==26){sprintf(temp,"%d",DIGITS_TO_PRINT);}
      else if(type==27){sprintf(temp,"%s",metamapfile);}
      else if(type==28){sprintf(temp,"%.4lf",ErrorLookup[LODELEVDIF].sensitivity);}
      else if(type==29){sprintf(temp,"%.4lf",ErrorLookup[GSPIKE].sensitivity); }
      else if(type==30){sprintf(temp,"%.4lf",ErrorLookup[GSPIKE].sensitivity2);}
      else if(type==31){sprintf(temp,"%.4lf",ErrorLookup[GSPIKE].sensitivity3);}
      else if(type==32){sprintf(temp,"%.4lf",ErrorLookup[LODELEVDIF].sensitivity2);}
      else if(type==33){sprintf(temp,"%.4lf",ErrorLookup[LODELEVDIF].sensitivity3);}
      else if(type==34){sprintf(temp,"%s",attrinsfolder);}
      else if(type==35){sprintf(temp,"%s",shape_out_name);}
      
     }
  else
    {
      printf("bad value %d to fore_result\n",CoordinateSystem);
      ExitWrapper(-1);
    }

  if((type!=24)&&(type!=25)&&(type!=27)&&(type!=34)&&(type!=35))
    {
      XmTextFieldSetString(w,temp);
    }


  XtFree(value);
 
  if(failed==1)
  {
	  return 0;
  }
  return 1;  

}



void con_info(Widget w,XtPointer data,XtPointer callData)
{
  int type=(int)data;

  if(type==0)
    {
      not_while_running(w,"Contour Interval:  Used to set the interval used when\n\
drawing contour lines.\n\n\
Range: >0 - 2000.0",1299,"Contour Interval",5);
    }

  else if(type==2)
    {
      not_while_running(w,"This parameter defines a specific x-value in the data\n\
extents which will be used as a \"beginning point\" for\n\
drawing the vertical grid lines.\n\n\
This parameter is used to \"place\" the grid.",1300,"Grid X anchor point help",5);
    }
  else if(type==3)
    {
      not_while_running(w,"This parameter defines a specific y-value in the data\n\
extents which will be used as a \"beginning point\" for\n\
drawing the horizontal grid lines.\n\n\
This parameter is used to \"place\" the grid.",1301,"Grid Y anchor point help",5);
    }
  else if(type==4)
    {
      if(Ctype()==1)
	{
	  not_while_running(w,"This parameter defines the spacing of the User-Defined grid lines which\n\
are activated under the \"View\" menu (\"Coordinate Grid\" submenu).\n\n\
Units: Degrees\n\n\
Acceptable range: 0.00001 to 10.0",1302,"User-Defined Coordinate Grid spacing help",5);
	}
      else if(Ctype()==2)
	{
	  not_while_running(w,"This parameter defines the spacing of the User-Defined grid lines which\n\
are activated under the \"View\" menu (\"Coordinate Grid\" submenu).\n\n\
Units: Meters\n\n\
Acceptable range: 1 to 100000",1303,"User-Defined Coordinate Grid spacing help",5);
	}
      else
	{
	  printf("bad coord system %d in con_info\n",CoordinateSystem);
	  ExitWrapper(-1);
	}
    }
  else if (type==13)
    {
	  if(NGA_TYPE==1)
	  {
       not_while_running(w,"Maximum number vertices to print for any feature\n\
described in information mode.\n\n\
Units: Integer",1316,"Info Mode Vertex Max help",5);
	  }
	  else
	  {
       not_while_running(w,"Maximum number vertices to print for any single object\n\
described in information mode.\n\n\
Units: Integer",1316,"Info Mode Vertex Max help",5);
	  }
    }
  else if (type==14)
    {
      not_while_running(w,"This parameter represents the number of decimal digits after the decimal\n\
to print for all coordinates (x,y,z).\n\
Units: Integer\n\
Acceptable range: 1-15",1316,"Number of decimals to show",5);
    }
  else if (type==15)
    {
      not_while_running(w,"This parameter specifies the root name of output condition shapefiles.",
		  1538,"Export Shapefile Root Name",5);
    }

}


void con_info2(Widget w,XtPointer data,XtPointer callData)
{
  if(NGA_TYPE==1)
    {
      not_while_running(w,"\
This window is used to modify parameters related to miscellaneous options.\n\n\
For detailed information about parameters with data entry fields, click\n\
the button which is labeled with the parameter's name\n\
(to the left of the data entry field).\n\n\
To make changes in data entry fields take effect, hit return with the\n\
cursor inside the data entry field.\n\n\
Coordinate Grid line and label changes take effect immediately upon\n\
refresh of the screen, if a coordinate grid is active.\n\n\
The \"Include Geographic WGS84 Projection File with Exported Condition\n\
Shapefiles\" option may be used to include a GCS WGS 84 projection file\n\
to exported condition shapefiles for non-UTM projects.\n\n\
The \"Show area vertices\", \"Show line vertices\", and\n\
\"Show line end nodes\" buttons and associated menus are used to mark\n\
the vertices of the given objects in the specified colors with the\n\
specified symbols on the display when zooming.  The \"Inherent\" color\n\
is whatever color is currently being used to draw the object whose\n\
vertices are being marked.\n\n\
The \"Show Inspection Grid in Background\" option is used to display the\n\
inspection grid.\n\n\
Invalid values entered will revert to the last valid value.",1317,"Miscellaneous Parameters Help",5);
    }
  else
    {
      not_while_running(w,"This window is used to modify parameters related to\n\
miscellaneous drawing options.\n\n\
For detailed information about parameters with data entry\n\
fields, click the button which is labeled with the\n\
parameter's name (to the left of the data entry field).\n\n\
To make changes in data entry fields take effect, hit\n\
return with the cursor inside the data entry field.\n\n\
Grid line and label changes take effect immediately upon\n\
refresh of the screen.\n\n\
The \"Show polygonal vertices\", \"Show linear vertices\", and\n\
\"Show linear end nodes\" buttons and associated menus are used\n\
to mark the vertices of the given objects in the specified colors\n\
with the specified symbols on the display when zooming.  The\n\
\"Inherent\" color is whatever color is currently being used to\n\
draw the object whose vertices are being marked.\n\n\
Invalid values entered will revert to the last valid value.",1317,"Miscellaneous Drawing Parameters Help",5);
    }
}



void los_info(Widget w,XtPointer data,XtPointer callData)
{
  if((int)data==1)
    {
      not_while_running(w,"Observer Height:\n\n\
Units: Input data coordinates (usually meters)\n\n\
Usage: This parameter is used for all LOS calculations.\n\
Any LOS calculation will have a start point, called\n\
the observer location.  This parameter defines the\n\
elevation of the observer location above ground level.",1319,"Observer Height",5);
    }
  else if((int)data==2)
    {
      not_while_running(w,"Target Height:\n\n\
Units: Input data coordinates (usually meters)\n\n\
Usage: This parameter is used for all LOS calculations.\n\
Any LOS calculation will have an end point, called\n\
the target location.  This parameter defines the\n\
elevation of the target location above ground level.",1320,"Target Height",5);
    }
  else if((int)data==3)
    {
      not_while_running(w,"Los Fan Angle:\n\n\
Units: Degrees\n\n\
Usage: This parameter defines the field of view for a LOS fan.\n\
Range: 1-360.  The fan is shown as the user defines the area to compute.",1321,"LOS Fan Angle",5);
    }
  else if((int)data==4)
    {
      not_while_running(w,"Los Fan Granularity:\n\n\
Units: Integer\n\
Range: 1-10\n\
Usage: This parameter defines the granularity of LOS calculations\n\
when computing an LOS fan.  Higher granularity results in\n\
more detailed LOS results at the cost of higher\n\
computation time.\n",1322,"LOS Fan Angle",5);
    }
}


void LosParameterCallback(Widget w,XtPointer data,XtPointer callData)
{
  int n=0;
  Arg resources[15];
  Widget form,rowcol,button;
  static Widget los_head;
  char obs_str[50];
  Dimension Pheight;


  if(LOS_WIN==0)
    {
      n=0;
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++;

      los_head =  XtCreatePopupShell("LOS Parameters",topLevelShellWidgetClass,w,resources,n);

      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass, los_head, NULL);

      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);

      sprintf(obs_str,"%.2lf",OBS_HEIGHT);

      text_obs = XtVaCreateManagedWidget ("text_obs",
					  xmTextFieldWidgetClass, form,	  
					  XmNvalue,            obs_str,
					  XmNtraversalOn,      True,
					  XmNrightAttachment,  XmATTACH_POSITION,
					  XmNrightPosition,    99,
					  XmNleftAttachment,   XmATTACH_POSITION,
					  XmNleftPosition,     50,
					  XmNmaxLength,        6,
                      XmNtranslations,     XtParseTranslationTable ( translations_paste ) ,
					  NULL);

      button = XtVaCreateManagedWidget ("OH",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    50,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					XmNlabelString,      STRING("Observer Height"),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);

      XtAddCallback (text_obs, XmNactivateCallback,
		     los_result, (XtPointer)1);

      XtAddCallback (button, XmNactivateCallback,
		     los_info, (XtPointer)1);

      XtManageChild(form);

      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);

      sprintf(obs_str,"%.2lf",TGT_HEIGHT);

      text_tgt = XtVaCreateManagedWidget ("text_tgt",
					  xmTextFieldWidgetClass, form,	  
					  XmNvalue,            obs_str,
					  XmNtraversalOn,      True,
					  XmNrightAttachment,  XmATTACH_POSITION,
					  XmNrightPosition,    99,
					  XmNleftAttachment,   XmATTACH_POSITION,
					  XmNleftPosition,     50,
					  XmNmaxLength,        6,
                      XmNtranslations,     XtParseTranslationTable ( translations_paste ) ,
					  NULL);

      button = XtVaCreateManagedWidget ("TH",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    50,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					XmNlabelString,      STRING("Target Height"),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);

      XtAddCallback (text_tgt, XmNactivateCallback,
		     los_result, (XtPointer)2);

      XtAddCallback (button, XmNactivateCallback,
		     los_info, (XtPointer)2);

      XtManageChild(form);



	  if(DO_FAN()==1)
	  {
        form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);

        sprintf(obs_str,"%.2lf",FAN_ANGLE);      
        text_angle = XtVaCreateManagedWidget ("text_angle",
					    xmTextFieldWidgetClass, form,	  
					    XmNvalue,            obs_str,
					    XmNtraversalOn,      True,
					    XmNrightAttachment,  XmATTACH_POSITION,
					    XmNrightPosition,    99,
					    XmNleftAttachment,   XmATTACH_POSITION,
					    XmNleftPosition,     50,
					    XmNmaxLength,        6,
                        XmNtranslations,     XtParseTranslationTable ( translations_paste ) ,
					    NULL);

        button = XtVaCreateManagedWidget ("LOSFA",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    50,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					XmNlabelString,      STRING("LOS Fan Angle"),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
        XtAddCallback (text_angle, XmNactivateCallback,
		     los_result, (XtPointer)3);
        XtAddCallback (button, XmNactivateCallback,
		     los_info, (XtPointer)3);
        XtManageChild(form);


        form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);

        sprintf(obs_str,"%d",FAN_QUALITY);
        text_quality = XtVaCreateManagedWidget ("text_quality",
					      xmTextFieldWidgetClass, form,	  
					      XmNvalue,            obs_str,
					      XmNtraversalOn,      True,
					      XmNrightAttachment,  XmATTACH_POSITION,
					      XmNrightPosition,    99,
					      XmNleftAttachment,   XmATTACH_POSITION,
					      XmNleftPosition,     50,
					      XmNmaxLength,        3,
                          XmNtranslations,     XtParseTranslationTable ( translations_paste ) ,
					      NULL);

        button = XtVaCreateManagedWidget ("LOSFG",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    50,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					XmNlabelString,      STRING("LOS Fan Granularity"),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
        XtAddCallback (text_quality, XmNactivateCallback,
		     los_result, (XtPointer)4);
        XtAddCallback (button, XmNactivateCallback,
		     los_info, (XtPointer)4);
        XtManageChild(form);

	  }

      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);


      button = XtVaCreateManagedWidget ("Done",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    99,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);

      XtAddCallback(button, XmNactivateCallback, exitCallback, (XtPointer)3);
      XtManageChild(button);
      XtManageChild(form);
      XtManageChild (rowcol);
      MyPopup(los_head); 
      XtAddCallback(los_head,XmNdestroyCallback,ShellDeath,(XtPointer)214);

      
      XtVaGetValues(los_head,  XmNheight,     &Pheight, NULL);
      XtVaSetValues(los_head,  XmNminHeight,   Pheight, NULL);
      XtVaSetValues(los_head,  XmNmaxHeight,   Pheight, NULL);
      XtVaSetValues(los_head,  XmNmaxWidth,   1000, NULL);

      XtAddEventHandler(los_head,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)Pheight));

      LOS_WIN=1;
    }
  else
    {
      ResetWidget(los_head);
    }
}




int TotalGridLayers()
{
  int i,totalgridlayer = 0;

  for(i=0;i<NumLODbands;i++)
  {
    if( (LODindex[i].geomtype_single==C_GRID) || (LODindex[i].geomtype[C_GRID]>0)  )
	{
      totalgridlayer = totalgridlayer + 1;
	}
  }

  return totalgridlayer;
}


void TogCFCallback(Widget widget,XtPointer client_data,XtPointer call_data)
{  
  DrawColorFill = !DrawColorFill;
}


void TogOCFCallback(Widget widget,XtPointer client_data,XtPointer call_data)
{
  OVERRIDING_CONTOUR = !OVERRIDING_CONTOUR;
}

void TogFlattenCallback(Widget widget,XtPointer client_data,XtPointer call_data)
{
  NO_FLATTEN_CONTOUR = !NO_FLATTEN_CONTOUR;
}

void TogBCCallback(Widget widget,XtPointer client_data,XtPointer call_data)
{
  BOLD_CONTOUR = !BOLD_CONTOUR;
}









void ContourHelpCallback(Widget w,XtPointer data,XtPointer callData)
{

  not_while_running(XtParent(XtParent(XtParent(w))),"\
This window is used to instruct GAIT to draw contours\n\
and modify profiling behavior.\n\n\
Contours may be drawn as lines or as color fill.\n\
When drawing contours as lines, the contour interval is used.\n\n\
When drawing contours as color fill, the contour interval is also used,\n\
but instead of drawing contour lines, a filled representation is rendered.\n\
This filled representation may be shown with some transparency using the\n\
\"Use transparency when using color filled contours\" option.  It may\n\
also be displayed with and without intermediate shading using the \n\
\"Use shades of color between contour bands\" option.\n\n\
The \"Omit sentinel values from profiles and contour lines\" option\n\
may be used to instruct GAIT to not use values for profiles and \n\
contour lines that are outside of the range [-12000,9000].",1512,"Contour / Profile Parameters Help",5);

}


void ChooseProfileHelpCallback(Widget w,XtPointer data,XtPointer callData)
{

  not_while_running(XtParent(XtParent(XtParent(w))),"\
This window is used to instruct GAIT which layer(s)\n\
to use when drawing profiles in profiling modes.\n\n\
The layers active here are independent of the layers\n\
active in the \"Layer Options\" window. ",1633,"Profile Layer Selection Help",5);

}


void SetProfileLayers(Widget w,XtPointer data,XtPointer callData)
{
  int index=(int)data;
  extern int *profiling_layers;

  if((index<0)>(index>=NumLODbands))
  {
    printf("Error to SPL: %d %d\n",index,NumLODbands);
	return;
  }

  if(profiling_layers[index]==100)
  {
    profiling_layers[index] = 101; 
  }
  else if(profiling_layers[index]==101)
  {
    profiling_layers[index] = 100; 
  }
  else
  {
    printf("Error2 to SPL: %d %d\n",index,profiling_layers[index]);
  }
}


void ChooseProfileCallback(Widget w,XtPointer data,XtPointer callData)
{
  Widget form,rowcol,button;
  Arg resources[15];
  Dimension Pheight;
  int i,n=0;
  static Widget profile_head;
  extern int *profiling_layers;

  for(i=0;i<NumLODbands;i++)
  {
	if(profiling_layers[i]>99) 
	{
	  
	}
  }


  if(PROFILE_WIN==0)
  { 
    n=0;
    XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++;

    profile_head =  XtCreatePopupShell("Layers to Profile",topLevelShellWidgetClass,w,resources,n);

    rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass, profile_head, NULL);



   for(i=0;i<NumLODbands;i++)
   {

	 if(profiling_layers[i]>99) 
	 { 
       form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);

	   button = XtVaCreateManagedWidget ("the_test",
				       xmToggleButtonWidgetClass, form,
				       XmNtopAttachment,    XmATTACH_FORM,
				       XmNtraversalOn,      False,
				       XmNbottomAttachment, XmATTACH_FORM,
				       XmNalignment,        XmALIGNMENT_BEGINNING,
				       XmNlabelString,      STRING(LODindex[i].filename),
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    99,
				       XmNleftAttachment,   XmATTACH_POSITION,
				       XmNleftPosition,     0,
				       TOGGLETRANSLATE,     TOGGLEINCLUDE,
				       NULL);
      
        XtAddCallback (button, XmNvalueChangedCallback,SetProfileLayers, (XtPointer)i);
        XmToggleButtonSetState(button,(Boolean)(profiling_layers[i]-100),(Boolean)0);
        XtManageChild(form);
	 }
   }


   form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
                    XmNfractionBase,  100,  
                    NULL);

   button = XtVaCreateManagedWidget ("seperr",
                    xmSeparatorWidgetClass, form,
                    XmNrightAttachment,   XmATTACH_FORM,
                    XmNleftAttachment,    XmATTACH_FORM,
                    NULL);

   XtManageChild(form);




   form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);

   button = XtVaCreateManagedWidget ("Help",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    49,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					XmNtranslations, XtParseTranslationTable ( translations_global ),
					NULL);

   XtAddCallback(button, XmNactivateCallback, ChooseProfileHelpCallback, (XtPointer)NULL);
   XtManageChild(button);


   button = XtVaCreateManagedWidget ("Done",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    99,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     51,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);

   XtAddCallback(button, XmNactivateCallback, exitCallback, (XtPointer)57);
      XtManageChild(button);

   XtManageChild(form);



   XtManageChild (rowcol);
   MyPopup(profile_head); 
   XtAddCallback(profile_head,XmNdestroyCallback,ShellDeath,(XtPointer)4103);

   
   XtVaGetValues(profile_head,  XmNheight,     &Pheight, NULL);
   XtVaSetValues(profile_head,  XmNminHeight,   Pheight, NULL);
   XtVaSetValues(profile_head,  XmNmaxHeight,   Pheight, NULL);
   XtVaSetValues(profile_head,  XmNmaxWidth,   1000, NULL);

   XtAddEventHandler(profile_head,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)Pheight));

   PROFILE_WIN=1;
  }
  else
  {
    ResetWidget(profile_head);
  }
}






void ContourParameterCallback(Widget w,XtPointer data,XtPointer callData)
{
  Widget form,rowcol,button,contour_color_menu;
  Arg resources[15];
  Dimension Pheight;
  int n=0;
  static Widget contour_head;
  char obs_str[50];
  extern int OmitGridSentinels;


  MenuItem color_type[] = {
    {"Red",   &xmPushButtonWidgetClass, '!', NULL, NULL, (void (*)())contour_color_cb, (XtPointer)2,   (MenuItem *) NULL},
    {"Green", &xmPushButtonWidgetClass, '!', NULL, NULL, (void (*)())contour_color_cb, (XtPointer)27,  (MenuItem *) NULL},
    {"Blue",  &xmPushButtonWidgetClass, '!', NULL, NULL, (void (*)())contour_color_cb, (XtPointer)55,  (MenuItem *) NULL},
    {"Black", &xmPushButtonWidgetClass, '!', NULL, NULL, (void (*)())contour_color_cb, (XtPointer)51,  (MenuItem *) NULL},
    {"White", &xmPushButtonWidgetClass, '!', NULL, NULL, (void (*)())contour_color_cb, (XtPointer)255, (MenuItem *) NULL},
    {"Purple",&xmPushButtonWidgetClass, '!', NULL, NULL, (void (*)())contour_color_cb, (XtPointer)40,  (MenuItem *) NULL},
    {"Tan",   &xmPushButtonWidgetClass, '!', NULL, NULL, (void (*)())contour_color_cb, (XtPointer)54,  (MenuItem *) NULL},
    {"Grey",  &xmPushButtonWidgetClass, '!', NULL, NULL, (void (*)())contour_color_cb, (XtPointer)128, (MenuItem *) NULL},
    {"Brown", &xmPushButtonWidgetClass, '!', NULL, NULL, (void (*)())contour_color_cb, (XtPointer)53,  (MenuItem *) NULL},
    {"Yellow",&xmPushButtonWidgetClass, '!', NULL, NULL, (void (*)())contour_color_cb, (XtPointer)28,  (MenuItem *) NULL},
    {NULL},
  };


  if(CONTOUR_WIN==0)
    {
      n=0;
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++;

      contour_head =  XtCreatePopupShell("Contour and Profile Parameters",topLevelShellWidgetClass,w,resources,n);

      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass, contour_head, NULL);




     form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);

      sprintf(obs_str,"%.4lf",ContourInterval);
 
      
	  fore_con = XtVaCreateManagedWidget ("fore_con",
					  xmTextFieldWidgetClass, form,	  
					  XmNvalue,            obs_str,
					  XmNtraversalOn,      True,
					  XmNrightAttachment,  XmATTACH_POSITION,
					  XmNrightPosition,    99,
					  XmNleftAttachment,   XmATTACH_POSITION,
					  XmNleftPosition,     51,
					  XmNmaxLength,        10,
                      XmNtranslations,     XtParseTranslationTable ( translations_paste ) ,
					  NULL);
      XtManageChild(fore_con);
      XtAddCallback (fore_con, XmNactivateCallback,
		     (XtCallbackProc)fore_result, (XtPointer)1);


      button = XtVaCreateManagedWidget ("CI",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    49,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					XmNlabelString,      STRING("Contour Interval"),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtManageChild(button);
      XtAddCallback (button, XmNactivateCallback,
		     con_info, (XtPointer)NULL);      


      XtManageChild(form);




      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);

	  button = XtVaCreateManagedWidget ("the_test",
				       xmToggleButtonWidgetClass, form,
				       XmNtopAttachment,    XmATTACH_FORM,
				       XmNtraversalOn,      False,
				       XmNbottomAttachment, XmATTACH_FORM,
				       XmNalignment,        XmALIGNMENT_BEGINNING,
				       XmNlabelString,      STRING("Draw Contour Lines"),
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    99,
				       XmNleftAttachment,   XmATTACH_POSITION,
				       XmNleftPosition,     0,
				       TOGGLETRANSLATE,     TOGGLEINCLUDE,
				       NULL);
      
      XtAddCallback (button, XmNvalueChangedCallback, Forecallback, (XtPointer)999);
      XmToggleButtonSetState(button,(Boolean)DrawContourLines,(Boolean)0);
      XtManageChild(form);



      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);


	  button = XtVaCreateManagedWidget ("the_test",
				       xmToggleButtonWidgetClass, form,
				       XmNtopAttachment,    XmATTACH_FORM,
				       XmNtraversalOn,      False,
				       XmNbottomAttachment, XmATTACH_FORM,
				       XmNalignment,        XmALIGNMENT_BEGINNING,
				       XmNlabelString,      STRING("Draw every 5th contour line bold"),
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    99,
				       XmNleftAttachment,   XmATTACH_POSITION,
				       XmNleftPosition,     10,
				       TOGGLETRANSLATE,     TOGGLEINCLUDE,
				       NULL);
      
      XtAddCallback (button, XmNvalueChangedCallback, TogBCCallback, (XtPointer)NULL);
      XmToggleButtonSetState(button,(Boolean)BOLD_CONTOUR,(Boolean)0);

      XtManageChild(form);


      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);

      contour_color_menu = BuildContourColorMenu (form, XmMENU_OPTION, "Contour Line Color",color_type);
      
      XtVaSetValues(contour_color_menu,
		    XmNtopAttachment,          XmATTACH_FORM,
		    XmNbottomAttachment,       XmATTACH_FORM,
            XmNrightAttachment,  XmATTACH_POSITION,
            XmNrightPosition,    99,
            XmNleftAttachment,   XmATTACH_POSITION,
            XmNleftPosition,     10,
		    NULL);
      
      XtManageChild (contour_color_menu);

      XtManageChild(form);



      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);

	  button = XtVaCreateManagedWidget ("the_test",
				       xmToggleButtonWidgetClass, form,
				       XmNtopAttachment,    XmATTACH_FORM,
				       XmNtraversalOn,      False,
				       XmNbottomAttachment, XmATTACH_FORM,
				       XmNalignment,        XmALIGNMENT_BEGINNING,
				       XmNlabelString,      STRING("Draw Contours as Color Fill"),
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    99,
				       XmNleftAttachment,   XmATTACH_POSITION,
				       XmNleftPosition,     0,
				       TOGGLETRANSLATE,     TOGGLEINCLUDE,
				       NULL);
      
      XtAddCallback (button, XmNvalueChangedCallback, TogCFCallback, (XtPointer)NULL);
      XmToggleButtonSetState(button,(Boolean)DrawColorFill,(Boolean)0);

      XtManageChild(form);




      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);

	  button = XtVaCreateManagedWidget ("the_test",
				       xmToggleButtonWidgetClass, form,
				       XmNtopAttachment,    XmATTACH_FORM,
				       XmNtraversalOn,      False,
				       XmNbottomAttachment, XmATTACH_FORM,
				       XmNalignment,        XmALIGNMENT_BEGINNING,
				       XmNlabelString,      STRING("Use transparency when using color filled contours"),
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    99,
				       XmNleftAttachment,   XmATTACH_POSITION,
				       XmNleftPosition,     10,
				       TOGGLETRANSLATE,     TOGGLEINCLUDE,
				       NULL);
      
      XtAddCallback (button, XmNvalueChangedCallback, TogOCFCallback, (XtPointer)NULL);
      XmToggleButtonSetState(button,(Boolean)OVERRIDING_CONTOUR,(Boolean)0);

      XtManageChild(form);



      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);

	  button = XtVaCreateManagedWidget ("the_test",
				       xmToggleButtonWidgetClass, form,
				       XmNtopAttachment,    XmATTACH_FORM,
				       XmNtraversalOn,      False,
				       XmNbottomAttachment, XmATTACH_FORM,
				       XmNalignment,        XmALIGNMENT_BEGINNING,
				       XmNlabelString,      STRING("Use shades of color between contour bands"),
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    99,
				       XmNleftAttachment,   XmATTACH_POSITION,
				       XmNleftPosition,     10,
				       TOGGLETRANSLATE,     TOGGLEINCLUDE,
				       NULL);

      XtAddCallback (button, XmNvalueChangedCallback, TogFlattenCallback, (XtPointer)NULL);
      XmToggleButtonSetState(button,(Boolean)NO_FLATTEN_CONTOUR,(Boolean)0);

      XtManageChild(form);







      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);

	  button = XtVaCreateManagedWidget ("the_test",
				       xmToggleButtonWidgetClass, form,
				       XmNtopAttachment,    XmATTACH_FORM,
				       XmNtraversalOn,      False,
				       XmNbottomAttachment, XmATTACH_FORM,
				       XmNalignment,        XmALIGNMENT_BEGINNING,
				       XmNlabelString,      STRING("Omit sentinel values from profiles and contour lines"),
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    99,
				       XmNleftAttachment,   XmATTACH_POSITION,
				       XmNleftPosition,     0,
				       TOGGLETRANSLATE,     TOGGLEINCLUDE,
				       NULL);
      
      XtAddCallback (button, XmNvalueChangedCallback, OmitCallback, (XtPointer)NULL);
      XmToggleButtonSetState(button,(Boolean)OmitGridSentinels,(Boolean)0);
      XtManageChild(form);



      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
                    XmNfractionBase,  100,  
                    NULL);

      button = XtVaCreateManagedWidget ("Specify layers to use when profiling...",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    99,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					XmNtranslations, XtParseTranslationTable ( translations_global ),
					NULL);

      XtAddCallback(button, XmNactivateCallback, ChooseProfileCallback, (XtPointer)NULL);



      XtManageChild(form);



      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
                    XmNfractionBase,  100,  
                    NULL);

      button = XtVaCreateManagedWidget ("Applied settings take effect on next screen redraw",
                    xmLabelWidgetClass,  form,
                    XmNtraversalOn,      False,
                    XmNleftAttachment,   XmATTACH_FORM,
                    XmNtopAttachment,    XmATTACH_FORM,
                    XmNbottomAttachment, XmATTACH_FORM,
                    LABELWTRANSLATE,
                    NULL);

      XtManageChild(form);



      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
                    XmNfractionBase,  100,  
                    NULL);

      button = XtVaCreateManagedWidget ("seperr",
                    xmSeparatorWidgetClass, form,
                    XmNrightAttachment,   XmATTACH_FORM,
                    XmNleftAttachment,    XmATTACH_FORM,
                    NULL);

      XtManageChild(form);



      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);


      button = XtVaCreateManagedWidget ("Help",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    49,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					XmNtranslations, XtParseTranslationTable ( translations_global ),
					NULL);

      XtAddCallback(button, XmNactivateCallback, ContourHelpCallback, (XtPointer)NULL);
      XtManageChild(button);


      button = XtVaCreateManagedWidget ("Done/Apply Settings",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    99,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     51,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);

      XtAddCallback(button, XmNactivateCallback, exitCallback, (XtPointer)52);
      XtManageChild(button);

      XtManageChild(form);



      XtManageChild (rowcol);
      MyPopup(contour_head); 
      XtAddCallback(contour_head,XmNdestroyCallback,ShellDeath,(XtPointer)4087);

      
      XtVaGetValues(contour_head,  XmNheight,     &Pheight, NULL);
      XtVaSetValues(contour_head,  XmNminHeight,   Pheight, NULL);
      XtVaSetValues(contour_head,  XmNmaxHeight,   Pheight, NULL);
      XtVaSetValues(contour_head,  XmNmaxWidth,   1000, NULL);

      XtAddEventHandler(contour_head,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)Pheight));

      CONTOUR_WIN=1;
    }
  else
    {
      ResetWidget(contour_head);
    }
}




void InitGrid()
{
  char temp[500];


  GridTools[0].name = "Shaded Relief...";
  GridTools[1].name = "Line of Sight...";
  GridTools[2].name = "Contours/Profiles...";



  sprintf(temp,"The \"%s\" tool allows the user to change parameters\nand settings used when displaying grid data in shaded relief.",GridTools[0].name);
  GridTools[0].help = (char *)malloc(strlen(temp)+10);
  sprintf(GridTools[0].help,"%s",temp);

  sprintf(temp,"The \"%s\" tool allows the user to change parameters\nand settings used when computing line-of-sight (LOS) displays.",GridTools[1].name);
  GridTools[1].help = (char *)malloc(strlen(temp)+10);
  sprintf(GridTools[1].help,"%s",temp);

  sprintf(temp,"The \"%s\" tool allows the user to specify contour and\nprofile parameters.",GridTools[2].name);
  GridTools[2].help = (char *)malloc(strlen(temp)+10);
  sprintf(GridTools[2].help,"%s",temp);


  GridTools[0].helpid = 1502;
  GridTools[1].helpid = 1503;
  GridTools[2].helpid = 1511;


  GridTools[0].cb = ShadeCallback;
  GridTools[1].cb = LosParameterCallback;
  GridTools[2].cb = ContourParameterCallback;

}




void grid_info(Widget w,XtPointer data,XtPointer callData)
{
  int num,len,index = (int)data;
  char help_str[200],help_str2[700];

  sprintf(help_str,"%s",GridTools[index].name);
  len = strlen(help_str);
  help_str[len-3] = '\0';

  num = TotalGridLayers();

  if((index==4) && (num<2))
  {   
    
    sprintf(help_str2,"%s\n\nThis option is not available because the current GAIT project\nonly contains %d DEM layer.",GridTools[index].help,num);
  }
  else
  {
    sprintf(help_str2,"%s",GridTools[index].help);
  }

  not_while_running(w,help_str2,GridTools[index].helpid,help_str,5);
}



void gridmenuCallback(Widget w,XtPointer data,XtPointer callData)
{
  int i,n=0;
  Arg resources[15];
  Widget form,rowcol,button;
  Dimension Pheight;

  if(GRID_WIN==0)
    {
      n=0;
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++;

      grid_head =
	XtCreatePopupShell
	("Grid Options",topLevelShellWidgetClass,drawing_a,resources,n);
      
      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass, grid_head, NULL);
      

	  for(i=0;i<NUM_GRID_TOOLS;i++)
	  {

        form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
        button = XtVaCreateManagedWidget ("Help",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    20,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					XmNlabelString,      STRING("Help"),
					XmNtranslations, XtParseTranslationTable(translations_global),
					NULL);
            
        XtAddCallback (button, XmNactivateCallback, grid_info, (XtPointer)i);
        XtManageChild(button);


        GridTools[i].ActivateButton = XtVaCreateManagedWidget (GridTools[i].name,
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    99,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     21,
					XmNlabelString,      STRING(GridTools[i].name),
					XmNtranslations, XtParseTranslationTable(translations_global),
					NULL);

		if(  (!strcmp(GridTools[i].name,"Surface Comparison..."))  &&  (TotalGridLayers()<2)  )
		{
          XtSetSensitive(GridTools[i].ActivateButton,False);
		}
		else
		{
          XtAddCallback (GridTools[i].ActivateButton, XmNactivateCallback, GridTools[i].cb, (XtPointer)NULL);
		}

        XtManageChild(GridTools[i].ActivateButton);
  
        XtManageChild(form);
	  }
            

      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      

      button = XtVaCreateManagedWidget ("Done",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    99,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);

      XtAddCallback(button, XmNactivateCallback, exitCallback, (XtPointer)50);
      XtManageChild(button);
      XtManageChild(form);
      XtManageChild (rowcol);
      MyPopup(grid_head); 
      XtAddCallback(grid_head,XmNdestroyCallback,ShellDeath,(XtPointer)216);

      
      XtVaGetValues(grid_head,  XmNheight,     &Pheight, NULL);
      XtVaSetValues(grid_head,  XmNminHeight,   Pheight, NULL);
      XtVaSetValues(grid_head,  XmNmaxHeight,   Pheight, NULL);
      XtVaSetValues(grid_head,  XmNmaxWidth,   1000, NULL);

      XtAddEventHandler(grid_head,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)Pheight));

      GRID_WIN=1;
    }
  else
    {
      ResetWidget(grid_head);
    }
}



Widget BuildGridMenu(Widget parent,int menu_type,char *menu_title,MenuItem *items,int selection)
{
  Widget menu, cascade, widget;
  int i,n=0,thisone;
  XmString str;
  Arg args[5];
  
  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);
  
  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId, menu);                                  n++;
  XtSetArg (args[n], XmNlabelString, str);                                 n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;



  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);
  
  for (i = 0; items[i].label != NULL; i++) 
    {
      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);


      if(!strcmp( items[i].label,"Black")) 
	{
	  thisone=51;
	}
      else if(!strcmp( items[i].label,"Inherent"))
	{
	  thisone=999;
	}
      else if(!strcmp( items[i].label,"Red"))
	{
	  thisone=1;
	  XtVaSetValues(widget,				
			XmNarmColor,          mycolors[DRAW_COLOR_RED],
			XmNbackground,        mycolors[DRAW_COLOR_RED],
			NULL);
	}
      else if(!strcmp( items[i].label,"Blue"))
	{
	  thisone=55;
	  XtVaSetValues(widget,				
			XmNarmColor,          mycolors[DRAW_COLOR_BLUE],
			XmNbackground,        mycolors[DRAW_COLOR_BLUE],
			NULL);
	}
      else if(!strcmp( items[i].label,"Yellow"))
	{
	  thisone=28;
	  XtVaSetValues(widget,				
			XmNarmColor,          mycolors[DRAW_COLOR_YELLOW],
			XmNbackground,        mycolors[DRAW_COLOR_YELLOW],
			NULL);
	}

       else if(!strcmp( items[i].label,"Purple"))
	{
	  thisone=40;
	  XtVaSetValues(widget,				
			XmNarmColor,          mycolors[DRAW_COLOR_PURPLE],
			XmNbackground,        mycolors[DRAW_COLOR_PURPLE],
			NULL);
	}
      else if(!strcmp( items[i].label,"Green"))
	{
	  thisone=27;
	  XtVaSetValues(widget,				
			XmNarmColor,          mycolors[DRAW_COLOR_LTGREEN],
			XmNbackground,        mycolors[DRAW_COLOR_LTGREEN],
			NULL);
	}
       else if(!strcmp( items[i].label,"Dark Green"))
	{
	  thisone=50;
	  XtVaSetValues(widget,				
			XmNarmColor,          mycolors[DRAW_COLOR_MEDGREEN],
			XmNbackground,        mycolors[DRAW_COLOR_MEDGREEN],
			NULL);
	}
      else if(!strcmp( items[i].label,"Cyan"))
	{
	  thisone=30;
	  XtVaSetValues(widget,				
			XmNarmColor,          mycolors[DRAW_COLOR_LTCYAN],
			XmNbackground,        mycolors[DRAW_COLOR_LTCYAN],
			NULL);
	}
      else if(!strcmp( items[i].label,"Brown"))
	{
	  thisone=53;
	  XtVaSetValues(widget,				
			XmNarmColor,          mycolors[DRAW_COLOR_BROWN],
			XmNbackground,        mycolors[DRAW_COLOR_BROWN],
			NULL);
	}
     else if(!strcmp( items[i].label,"White"))
	{
	  thisone=255;
	  XtVaSetValues(widget,				
			XmNarmColor,          mycolors[DRAW_COLOR_WHITE],
			XmNbackground,        mycolors[DRAW_COLOR_WHITE],
			NULL);
	}
      else
	{
	  thisone=i;
	}

      XtAddCallback (widget,
		     (items[i].cclass == &xmToggleButtonWidgetClass ||
		      items[i].cclass == &xmToggleButtonWidgetClass) ?
		     XmNvalueChangedCallback : 
		     XmNactivateCallback,      
		     (XtCallbackProc)items[i].callback, items[i].callback_data);

      if(thisone==selection)
	{
	  XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);
	}
      
    }
  return menu_type == XmMENU_POPUP ? menu : cascade;
}









Widget BuildCondColorMenu(Widget parent,int menu_type,char *menu_title,MenuItem *items,int selection)
{
  Widget menu, cascade, widget;
  int i,n=0;
  XmString str;
  Arg args[5];

  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);

  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId, menu);                                               n++;
  XtSetArg (args[n], XmNlabelString, str);                                              n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;

  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);


  for (i=0;items[i].label!=NULL;i++)
    {
      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);

      if(!strcmp( items[i].label,"Red"))
	  {
	    XtVaSetValues(widget,
			XmNarmColor,          mycolors[DRAW_COLOR_RED],
			XmNbackground,        mycolors[DRAW_COLOR_RED],
			NULL);
	  }
      else if(!strcmp( items[i].label,"Blue"))
	  {
	    XtVaSetValues(widget,
			XmNarmColor,          mycolors[DRAW_COLOR_BLUE],
			XmNbackground,        mycolors[DRAW_COLOR_BLUE],
			NULL);
	  }
      else if(!strcmp( items[i].label,"Yellow"))
	  {
	    XtVaSetValues(widget,
			XmNarmColor,          mycolors[DRAW_COLOR_YELLOW],
			XmNbackground,        mycolors[DRAW_COLOR_YELLOW],
			NULL);
	  }
      else if(!strcmp( items[i].label,"Purple"))
	  {
	    XtVaSetValues(widget,
			XmNarmColor,          mycolors[DRAW_COLOR_PURPLE],
			XmNbackground,        mycolors[DRAW_COLOR_PURPLE],
			NULL);
	  }
      else if(!strcmp( items[i].label,"Green"))
	  {
	    XtVaSetValues(widget,
			XmNarmColor,          mycolors[DRAW_COLOR_LTGREEN],
			XmNbackground,        mycolors[DRAW_COLOR_LTGREEN],
			NULL);
	  }
      else if(!strcmp( items[i].label,"Dark Green"))
	  {
	    XtVaSetValues(widget,
			XmNarmColor,          mycolors[DRAW_COLOR_MEDGREEN],
			XmNbackground,        mycolors[DRAW_COLOR_MEDGREEN],
			NULL);
	  }
      else if(!strcmp( items[i].label,"Cyan"))
	  {
	    XtVaSetValues(widget,
			XmNarmColor,          mycolors[DRAW_COLOR_LTCYAN],
			XmNbackground,        mycolors[DRAW_COLOR_LTCYAN],
			NULL);
	  }
      else if(!strcmp( items[i].label,"Brown"))
	  {
	    XtVaSetValues(widget,
			XmNarmColor,          mycolors[DRAW_COLOR_BROWN],
			XmNbackground,        mycolors[DRAW_COLOR_BROWN],
			NULL);
	  }
      else if(!strcmp( items[i].label,"White"))
	  {
	    XtVaSetValues(widget,
			XmNarmColor,          mycolors[DRAW_COLOR_WHITE],
			XmNbackground,        mycolors[DRAW_COLOR_WHITE],
			NULL);
	  }

	  if((int)items[i].callback_data==SPECIAL_COND_COLOR)
	  {
	    XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);	  
	  }


      XtAddCallback (widget,
		     (items[i].cclass == &xmToggleButtonWidgetClass ||
		      items[i].cclass == &xmToggleButtonWidgetClass) ?
		     XmNvalueChangedCallback : 
		     XmNactivateCallback,      
		     (XtCallbackProc)items[i].callback, items[i].callback_data);
      
    }
  return menu_type == XmMENU_POPUP ? menu : cascade;
}




Widget BuildQACRMenu(Widget parent,int menu_type,char *menu_title,MenuItem *items)
{
  Widget menu, cascade, widget;
  int i,n=0;
  XmString str;
  Arg args[5];
  extern int QACR_COUNTRY;


  XtSetArg (args[n], XmNpacking,    XmPACK_COLUMN); n++;
  XtSetArg (args[n], XmNnumColumns,            11); n++;

  menu = XmCreatePulldownMenu (parent, "_pulldown", args, n);
  

  n = 0;

  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId, menu);                                               n++;
  XtSetArg (args[n], XmNlabelString, str);                                              n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;

  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);


  for (i=0;items[i].label!=NULL;i++)
    {

      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);


	  if((int)items[i].callback_data==QACR_COUNTRY)
	  {
	    XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);	  
	  }


      XtAddCallback (widget,
		     (items[i].cclass == &xmToggleButtonWidgetClass ||
		      items[i].cclass == &xmToggleButtonWidgetClass) ?
		     XmNvalueChangedCallback : 
		     XmNactivateCallback,      
		     (XtCallbackProc)items[i].callback, items[i].callback_data);
      
    }
  return menu_type == XmMENU_POPUP ? menu : cascade;
}


Widget BuildQACRMenu2(Widget parent,int menu_type,char *menu_title,MenuItem *items)
{
  Widget menu, cascade, widget;
  int i,n=0;
  XmString str;
  Arg args[5];
  extern int QACR_EXPORT_TRD_VERSION;


  menu = XmCreatePulldownMenu (parent, "_pulldown", args, n);
  

  n = 0;

  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId, menu);                                               n++;
  XtSetArg (args[n], XmNlabelString, str);                                              n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;

  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);


  for (i=0;items[i].label!=NULL;i++)
    {

      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);


	  if((int)items[i].callback_data==QACR_EXPORT_TRD_VERSION)
	  {
	    XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);	  
	  }


      XtAddCallback (widget,
		     (items[i].cclass == &xmToggleButtonWidgetClass ||
		      items[i].cclass == &xmToggleButtonWidgetClass) ?
		     XmNvalueChangedCallback : 
		     XmNactivateCallback,      
		     (XtCallbackProc)items[i].callback, items[i].callback_data);
      
    }
  return menu_type == XmMENU_POPUP ? menu : cascade;
}




Widget BuildDDMenu(Widget parent,int menu_type,char *menu_title,MenuItem *items)
{
  Widget menu, cascade, widget;
  int i,n=0;
  XmString str;
  Arg args[5];

  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);

  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId, menu);                                               n++;
  XtSetArg (args[n], XmNlabelString, str);                                              n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;

  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);


  for (i=0;items[i].label!=NULL;i++)
    {

      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);


	  if((int)items[i].callback_data==IUseDMScoordinates)
	  {
	    XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);	  
	  }


      XtAddCallback (widget,
		     (items[i].cclass == &xmToggleButtonWidgetClass ||
		      items[i].cclass == &xmToggleButtonWidgetClass) ?
		     XmNvalueChangedCallback : 
		     XmNactivateCallback,      
		     (XtCallbackProc)items[i].callback, items[i].callback_data);
      
    }
  return menu_type == XmMENU_POPUP ? menu : cascade;
}







Widget BuildLabel1Menu(Widget parent,int menu_type,char *menu_title,MenuItem *items)
{
  Widget menu, cascade, widget;
  int i,n=0;
  XmString str;
  Arg args[5];

  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);

  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId, menu);                                               n++;
  XtSetArg (args[n], XmNlabelString, str);                                              n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;

  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);


  for (i=0;items[i].label!=NULL;i++)
    {
      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);

	  if((int)items[i].callback_data==LABEL_PROXIMITY)
	  {
	    XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);	  
	  }


      XtAddCallback (widget,
		     (items[i].cclass == &xmToggleButtonWidgetClass ||
		      items[i].cclass == &xmToggleButtonWidgetClass) ?
		     XmNvalueChangedCallback : 
		     XmNactivateCallback,      
		     (XtCallbackProc)items[i].callback, items[i].callback_data);
      
    }
  return menu_type == XmMENU_POPUP ? menu : cascade;
}




Widget BuildLabel2Menu(Widget parent,int menu_type,char *menu_title,MenuItem *items)
{
  Widget menu, cascade, widget;
  int i,n=0;
  XmString str;
  Arg args[5];

  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);

  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId, menu);                                               n++;
  XtSetArg (args[n], XmNlabelString, str);                                              n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;

  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);


  for (i=0;items[i].label!=NULL;i++)
    {
      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);

	  if((int)items[i].callback_data==LABEL_VOLUME)
	  {
	    XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);	  
	  }


      XtAddCallback (widget,
		     (items[i].cclass == &xmToggleButtonWidgetClass ||
		      items[i].cclass == &xmToggleButtonWidgetClass) ?
		     XmNvalueChangedCallback : 
		     XmNactivateCallback,      
		     (XtCallbackProc)items[i].callback, items[i].callback_data);
      
    }
  return menu_type == XmMENU_POPUP ? menu : cascade;
}


void all_shape_cb(Widget w,XtPointer data,XtPointer callData)
{ 
  int color = (int) data;
  
  if(color<50)
    {
      
      POLY_SHAPE = color;
    }
  else if(color<150)
    {
      
      LINE_SHAPE = (color-100);
    }
  else if(color<250)
    {
      
      END_LINE_SHAPE = (color-200);
    }
}





void pv_color_cb(Widget w,XtPointer data,XtPointer callData)
{ 
  int color = (int) data;
  
  POLY_COLOR = color;

  
  if(POLY_COLOR!=999)
    {
      XtVaSetValues(poly_color_menu,
		    XmNforeground,       mycolors[POLY_COLOR],
		    XmNtopShadowColor,   mycolors[POLY_COLOR],
		    XmNbottomShadowColor,mycolors[POLY_COLOR],
		    NULL);
    }
  else
    {
      XtVaSetValues(poly_color_menu,
		    XmNforeground,       mycolors[DRAW_COLOR_BLACK],
		    XmNtopShadowColor,   mycolors[DRAW_COLOR_BLACK],
		    XmNbottomShadowColor,mycolors[DRAW_COLOR_BLACK],
		    NULL);
    }
}


void lv_color_cb(Widget w,XtPointer data,XtPointer callData)
{ 
  int color = (int) data;
  
  LINE_COLOR = color;

  
  if(LINE_COLOR!=999)
    {
      XtVaSetValues(line_color_menu,
		    XmNforeground,       mycolors[LINE_COLOR],
		    XmNtopShadowColor,   mycolors[LINE_COLOR],
		    XmNbottomShadowColor,mycolors[LINE_COLOR],
		    NULL);
    }
  else
    {
      XtVaSetValues(line_color_menu,
		    XmNforeground,       mycolors[DRAW_COLOR_BLACK],
		    XmNtopShadowColor,   mycolors[DRAW_COLOR_BLACK],
		    XmNbottomShadowColor,mycolors[DRAW_COLOR_BLACK],
		    NULL);
    }
}

void elv_color_cb(Widget w,XtPointer data,XtPointer callData)
{ 
  int color = (int) data;
  
  END_LINE_COLOR = color;

  
  if(END_LINE_COLOR!=999)
    {
      XtVaSetValues(end_line_color_menu,
		    XmNforeground,       mycolors[END_LINE_COLOR],
		    XmNtopShadowColor,   mycolors[END_LINE_COLOR],
		    XmNbottomShadowColor,mycolors[END_LINE_COLOR],
		    NULL);
    }
  else
    {
      XtVaSetValues(end_line_color_menu,
		    XmNforeground,       mycolors[DRAW_COLOR_BLACK],
		    XmNtopShadowColor,   mycolors[DRAW_COLOR_BLACK],
		    XmNbottomShadowColor,mycolors[DRAW_COLOR_BLACK],
		    NULL);
    }
}





void thick_cb(Widget w,XtPointer data,XtPointer callData)
{ 
  int thick = (int) data;
  
  GRID_THICKNESS=thick;  
}

void proximity_cb(Widget w,XtPointer data,XtPointer callData)
{ 
  int num = (int) data;
  
  LABEL_PROXIMITY = num;
}

void volume_cb(Widget w,XtPointer data,XtPointer callData)
{ 
  int num = (int) data;
  
  LABEL_VOLUME = num;
}

void qacr_cb(Widget w,XtPointer data,XtPointer callData)
{ 
  int num = (int) data;
  extern int QACR_COUNTRY;
  
  QACR_COUNTRY = num;
}

void qacr2_cb(Widget w,XtPointer data,XtPointer callData)
{ 
  int num = (int) data;
  extern int QACR_EXPORT_TRD_VERSION;
  
  QACR_EXPORT_TRD_VERSION = num;
}


void l_color_cb(Widget w,XtPointer data,XtPointer callData)
{ 
  int color = (int) data;
  
  GRID_COLOR = color;
  
  XtVaSetValues(color_menu2,				
		XmNforeground,       mycolors[GRID_COLOR],
		XmNtopShadowColor,   mycolors[GRID_COLOR],
		XmNbottomShadowColor,mycolors[GRID_COLOR],
		NULL);
}


void cond_color_cb(Widget w,XtPointer data,XtPointer callData)
{ 
  int color = (int) data;
  
  SPECIAL_COND_COLOR = color;
  
  if(SPECIAL_COND_COLOR==-1)
  {
    XtVaSetValues(color_menu4,
		XmNforeground,       mycolors[1],
		XmNtopShadowColor,   mycolors[1],
		XmNbottomShadowColor,mycolors[1],
		NULL);
  }
  else
  {
    XtVaSetValues(color_menu4,
		XmNforeground,       mycolors[SPECIAL_COND_COLOR],
		XmNtopShadowColor,   mycolors[SPECIAL_COND_COLOR],
		XmNbottomShadowColor,mycolors[SPECIAL_COND_COLOR],
		NULL);
  }
}




void lab_color_cb(Widget w,XtPointer data,XtPointer callData)
{ 
  int color = (int) data;
  
  GRID_LABEL_COLOR = color;
  
  XtVaSetValues(color_menu3,				
		XmNforeground,       mycolors[GRID_LABEL_COLOR],
		XmNtopShadowColor,   mycolors[GRID_LABEL_COLOR],
		XmNbottomShadowColor,mycolors[GRID_LABEL_COLOR],
		NULL);
}



void InspectionGridCallback(Widget w,XtPointer data,XtPointer callData)
{
  if(GRID==0)
    {
      GRID=1;
    }
  else
    {
      GRID=0;
    }
}


void do_large_labels(Widget widget,XtPointer client_data,XtPointer call_data)
{  
  DoLargeLabels = !DoLargeLabels;
}

void do_bold_labels(Widget widget,XtPointer client_data,XtPointer call_data)
{  
  DoBoldLabels = !DoBoldLabels;
}

void add_projection(Widget widget,XtPointer client_data,XtPointer call_data)
{  
  INCLUDE_PROJECTION=!INCLUDE_PROJECTION;
}


void do_dms(Widget widget,XtPointer client_data,XtPointer call_data)
{  
  int type=(int)client_data;

  IUseDMScoordinates = type;
}


void show_labels(Widget widget,XtPointer client_data,XtPointer call_data)
{  
  int type=(int)client_data;

  if(type==10001)
    {
      DRAW_POINT_LABELS=!DRAW_POINT_LABELS;
    }
  else if(type==10002)
    {
      DRAW_LINE_LABELS=!DRAW_LINE_LABELS;
    }
  else if(type==10003)
    {
      DRAW_AREA_LABELS=!DRAW_AREA_LABELS;
    }
  else
    {      
      printf("bad data to show_vert: %d\n",type);
    }
}




void ForeGridCallback(Widget w,XtPointer data,XtPointer callData)
{ 
  Arg resources[15];
  Widget form,rowcol,button,thick_menu,tog,poly_type_menu,line_type_menu,end_line_type_menu,
	  label1_menu,label2_menu,qacr_menu,qacr_menu2,dd_menu;
  char obs_str[50];
  Dimension y1;
  int n=0;
  extern const char *ParticipantNationCodes4[32*3];

  MenuItem line_thick[] = {
    { "1 point", &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())thick_cb,(XtPointer)1,(MenuItem *)NULL},
    { "2 point", &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())thick_cb,(XtPointer)2,(MenuItem *)NULL},
    { "3 point", &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())thick_cb,(XtPointer)3,(MenuItem *)NULL},
    { "4 point", &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())thick_cb,(XtPointer)4,(MenuItem *)NULL},
    { "5 point", &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())thick_cb,(XtPointer)5,(MenuItem *)NULL},
    {NULL},
  };

  MenuItem line_color[] = {
    { "Black",      &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())l_color_cb, (XtPointer)51,  (MenuItem *) NULL },
    { "Red",        &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())l_color_cb, (XtPointer)1,   (MenuItem *) NULL },
    { "Green",      &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())l_color_cb, (XtPointer)27,  (MenuItem *) NULL },
    { "Dark Green", &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())l_color_cb, (XtPointer)50,  (MenuItem *) NULL },
    { "Blue",       &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())l_color_cb, (XtPointer)55,  (MenuItem *) NULL },
    { "Yellow",     &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())l_color_cb, (XtPointer)28,  (MenuItem *) NULL },
    { "Purple",     &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())l_color_cb, (XtPointer)40,  (MenuItem *) NULL },
    { "Cyan",       &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())l_color_cb, (XtPointer)30,  (MenuItem *) NULL },
    { "Brown",      &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())l_color_cb, (XtPointer)53,  (MenuItem *) NULL },
    { "White",      &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())l_color_cb, (XtPointer)255, (MenuItem *) NULL },
   {NULL},
  };

  MenuItem cond_color[] = {
    { "Black",      &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())cond_color_cb, (XtPointer)51,  (MenuItem *) NULL },
    { "Red",        &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())cond_color_cb, (XtPointer)-1,   (MenuItem *) NULL },
    { "Green",      &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())cond_color_cb, (XtPointer)27,  (MenuItem *) NULL },
    { "Dark Green", &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())cond_color_cb, (XtPointer)50,  (MenuItem *) NULL },
    { "Blue",       &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())cond_color_cb, (XtPointer)55,  (MenuItem *) NULL },
    { "Yellow",     &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())cond_color_cb, (XtPointer)28,  (MenuItem *) NULL },
    { "Purple",     &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())cond_color_cb, (XtPointer)40,  (MenuItem *) NULL },
    { "Cyan",       &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())cond_color_cb, (XtPointer)30,  (MenuItem *) NULL },
    { "Brown",      &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())cond_color_cb, (XtPointer)53,  (MenuItem *) NULL },
    { "White",      &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())cond_color_cb, (XtPointer)255, (MenuItem *) NULL },
   {NULL},
  };

  MenuItem poly_color2[] = {
    { "Inherent",      &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())pv_color_cb, (XtPointer)999,  (MenuItem *) NULL },
    { "Black",      &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())pv_color_cb, (XtPointer)51,  (MenuItem *) NULL },
    { "Red",        &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())pv_color_cb, (XtPointer)1,   (MenuItem *) NULL },
    { "Green",      &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())pv_color_cb, (XtPointer)27,  (MenuItem *) NULL },
    { "Dark Green", &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())pv_color_cb, (XtPointer)50,  (MenuItem *) NULL },
    { "Blue",       &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())pv_color_cb, (XtPointer)55,  (MenuItem *) NULL },
    { "Yellow",     &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())pv_color_cb, (XtPointer)28,  (MenuItem *) NULL },
    { "Purple",     &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())pv_color_cb, (XtPointer)40,  (MenuItem *) NULL },
    { "Cyan",       &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())pv_color_cb, (XtPointer)30,  (MenuItem *) NULL },
    { "Brown",      &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())pv_color_cb, (XtPointer)53,  (MenuItem *) NULL },
    { "White",      &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())pv_color_cb, (XtPointer)255, (MenuItem *) NULL },
   {NULL},
  };


  MenuItem line_color2[] = {
    { "Inherent",      &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())lv_color_cb, (XtPointer)999,  (MenuItem *) NULL },
    { "Black",      &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())lv_color_cb, (XtPointer)51,  (MenuItem *) NULL },
    { "Red",        &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())lv_color_cb, (XtPointer)1,   (MenuItem *) NULL },
    { "Green",      &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())lv_color_cb, (XtPointer)27,  (MenuItem *) NULL },
    { "Dark Green", &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())lv_color_cb, (XtPointer)50,  (MenuItem *) NULL },
    { "Blue",       &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())lv_color_cb, (XtPointer)55,  (MenuItem *) NULL },
    { "Yellow",     &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())lv_color_cb, (XtPointer)28,  (MenuItem *) NULL },
    { "Purple",     &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())lv_color_cb, (XtPointer)40,  (MenuItem *) NULL },
    { "Cyan",       &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())lv_color_cb, (XtPointer)30,  (MenuItem *) NULL },
    { "Brown",      &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())lv_color_cb, (XtPointer)53,  (MenuItem *) NULL },
    { "White",      &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())lv_color_cb, (XtPointer)255, (MenuItem *) NULL },
   {NULL},
  };

  MenuItem line_color3[] = {
    { "Inherent",      &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())elv_color_cb, (XtPointer)999,  (MenuItem *) NULL },
    { "Black",      &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())elv_color_cb, (XtPointer)51,  (MenuItem *) NULL },
    { "Red",        &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())elv_color_cb, (XtPointer)1,   (MenuItem *) NULL },
    { "Green",      &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())elv_color_cb, (XtPointer)27,  (MenuItem *) NULL },
    { "Dark Green", &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())elv_color_cb, (XtPointer)50,  (MenuItem *) NULL },
    { "Blue",       &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())elv_color_cb, (XtPointer)55,  (MenuItem *) NULL },
    { "Yellow",     &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())elv_color_cb, (XtPointer)28,  (MenuItem *) NULL },
    { "Purple",     &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())elv_color_cb, (XtPointer)40,  (MenuItem *) NULL },
    { "Cyan",       &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())elv_color_cb, (XtPointer)30,  (MenuItem *) NULL },
    { "Brown",      &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())elv_color_cb, (XtPointer)53,  (MenuItem *) NULL },
    { "White",      &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())elv_color_cb, (XtPointer)255, (MenuItem *) NULL },
   {NULL},
  };



  MenuItem label_color[] = {
    { "Black",      &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())lab_color_cb, (XtPointer)51,  (MenuItem *) NULL },
    { "Red",        &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())lab_color_cb, (XtPointer)1,   (MenuItem *) NULL },
    { "Green",      &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())lab_color_cb, (XtPointer)27,  (MenuItem *) NULL },
    { "Dark Green", &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())lab_color_cb, (XtPointer)50,  (MenuItem *) NULL },
    { "Blue",       &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())lab_color_cb, (XtPointer)55,  (MenuItem *) NULL },
    { "Yellow",     &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())lab_color_cb, (XtPointer)28,  (MenuItem *) NULL },
    { "Purple",     &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())lab_color_cb, (XtPointer)40,  (MenuItem *) NULL },
    { "Cyan",       &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())lab_color_cb, (XtPointer)30,  (MenuItem *) NULL },
    { "Brown",      &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())lab_color_cb, (XtPointer)53,  (MenuItem *) NULL },
    { "White",      &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())lab_color_cb, (XtPointer)255, (MenuItem *) NULL },
   {NULL},
  };



  MenuItem mark_types[] = {
    { "Triangle", &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())all_shape_cb, (XtPointer)0, (MenuItem *) NULL },
    { "Star",     &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())all_shape_cb, (XtPointer)1, (MenuItem *) NULL },
    { "X-Mark",   &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())all_shape_cb, (XtPointer)2, (MenuItem *) NULL },
    { "Circle",   &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())all_shape_cb, (XtPointer)3, (MenuItem *) NULL },
    {NULL},
  };

  MenuItem mark_types2[] = {
    { "Triangle", &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())all_shape_cb, (XtPointer)200, (MenuItem *) NULL },
    { "Star",     &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())all_shape_cb, (XtPointer)201, (MenuItem *) NULL },
    { "X-Mark",   &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())all_shape_cb, (XtPointer)202, (MenuItem *) NULL },
    { "Circle",   &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())all_shape_cb, (XtPointer)203, (MenuItem *) NULL },
    {NULL},
  };

  MenuItem mark_types3[] = {
    { "Triangle", &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())all_shape_cb, (XtPointer)100, (MenuItem *) NULL },
    { "Star",     &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())all_shape_cb, (XtPointer)101, (MenuItem *) NULL },
    { "X-Mark",   &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())all_shape_cb, (XtPointer)102, (MenuItem *) NULL },
    { "Circle",   &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())all_shape_cb, (XtPointer)103, (MenuItem *) NULL },
    { "Arrow",    &xmPushButtonWidgetClass,'!' , NULL, NULL, (void (*)())all_shape_cb, (XtPointer)104, (MenuItem *) NULL },
    {NULL},
  };

  MenuItem label_proximity[] = {
    { "Close Together", &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())proximity_cb,(XtPointer)1,(MenuItem *)NULL},
    { "Medium", &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())proximity_cb,(XtPointer)2,(MenuItem *)NULL},
    { "Far Apart", &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())proximity_cb,(XtPointer)4,(MenuItem *)NULL},
    {NULL},
  };

  MenuItem label_volume[] = {
    { "Low", &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())volume_cb,(XtPointer)1,(MenuItem *)NULL},
    { "Medium", &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())volume_cb,(XtPointer)2,(MenuItem *)NULL},
    { "High", &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())volume_cb,(XtPointer)4,(MenuItem *)NULL},
    {NULL},
  };


  MenuItem qacr_choices[] = {
    {"None", &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)999,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[0], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)0,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[3], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)3,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[6], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)6,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[9], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)9,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[12], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)12,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[15], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)15,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[18], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)18,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[21], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)21,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[24], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)24,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[27], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)27,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[30], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)30,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[33], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)33,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[36], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)36,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[39], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)39,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[42], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)42,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[45], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)45,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[48], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)48,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[51], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)51,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[54], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)54,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[57], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)57,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[60], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)60,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[63], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)63,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[66], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)66,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[69], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)69,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[72], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)72,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[75], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)75,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[78], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)78,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[81], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)81,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[84], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)84,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[87], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)87,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[90], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)90,(MenuItem *)NULL},
    {(char *)ParticipantNationCodes4[93], &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr_cb,(XtPointer)93,(MenuItem *)NULL},
    {NULL},
  };


  MenuItem qacr_choices2[] = {
    {"None", &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr2_cb,(XtPointer)999,(MenuItem *)NULL},
    {"3.0",  &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr2_cb,(XtPointer)30, (MenuItem *)NULL},
    {"4.0",  &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr2_cb,(XtPointer)40, (MenuItem *)NULL},
    {"4.1",  &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr2_cb,(XtPointer)41, (MenuItem *)NULL},
    {"4.2",  &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr2_cb,(XtPointer)42, (MenuItem *)NULL},
    {"4.3",  &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr2_cb,(XtPointer)43, (MenuItem *)NULL},
    {"4.4",  &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())qacr2_cb,(XtPointer)44, (MenuItem *)NULL},
    {NULL},
  };

  MenuItem dd_choices[] = {
    { "Decimal Degrees",         &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())do_dms,(XtPointer)0,(MenuItem *)NULL},
    { "Degrees/Minutes/Seconds", &xmPushButtonWidgetClass,'!',NULL,NULL,(void(*)())do_dms,(XtPointer)1,(MenuItem *)NULL},
    {NULL},
  };











     

  if(input_source==0)
    { 
      if(NGA_TYPE==1)
	{
	  not_while_running(drawing_a,"You must open a GAIT project before\n\
you can set foreground parameters.",1323,"No input directory.",1);  
	}
      else
	{
	  not_while_running(drawing_a,"You must select an input data source directory before\n\
you can set foreground parameters.",1324,"No input directory.",1);  
	}

      return;
    }

  if(FORE_WIN==0)
    {	   
      n=0;
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++; 

      fore_head = 
	XtCreatePopupShell
	("Miscellaneous Parameters",topLevelShellWidgetClass,drawing_a,resources,n);
      
      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass, fore_head, NULL);



      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);


      if(Ctype()==1)
	{
	  sprintf(obs_str,"%.7lf",GridSpace);
	}
      
      else if(Ctype()==2)
	{
	  sprintf(obs_str,"%.2lf",GridSpace);
	}
      
      fore_grid_s = XtVaCreateManagedWidget ("fore_grid_s",
					  xmTextFieldWidgetClass, form,	  
					  XmNvalue,            obs_str,
					  XmNtraversalOn,      True,
					  XmNrightAttachment,  XmATTACH_POSITION,
					  XmNrightPosition,    100,
					  XmNleftAttachment,   XmATTACH_POSITION,
					  XmNleftPosition,     75,
					  
                      XmNtranslations,     XtParseTranslationTable ( translations_paste ) ,
					  NULL);
      XtManageChild(fore_grid_s);
      XtAddCallback (fore_grid_s, XmNactivateCallback,
		     (XtCallbackProc)fore_result, (XtPointer)4);
      
      button = XtVaCreateManagedWidget ("GS",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    75,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     0,
					XmNlabelString,      STRING("User-Defined Coordinate Grid Spacing"),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtManageChild(button);
      XtAddCallback (button, XmNactivateCallback,
		     con_info, (XtPointer)4);
      XtManageChild(form);
      



      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
    
      if(Ctype()==1)
	{sprintf(obs_str,"%.7lf",GridX);}
      else if(Ctype()==2)
	{sprintf(obs_str,"%.2lf",GridX);}
      
      fore_grid_xa = XtVaCreateManagedWidget ("fore_grid_xa",
					  xmTextFieldWidgetClass, form,	  
					  XmNvalue,            obs_str,
					  XmNtraversalOn,      True,
					  XmNrightAttachment,  XmATTACH_POSITION,
					  XmNrightPosition,    100,
					  XmNleftAttachment,   XmATTACH_POSITION,
					  XmNleftPosition,     75,
					  
                      XmNtranslations,     XtParseTranslationTable ( translations_paste ) ,
					  NULL);
      XtManageChild(fore_grid_xa);
      XtAddCallback (fore_grid_xa, XmNactivateCallback,
		     (XtCallbackProc)fore_result, (XtPointer)2);


      button = XtVaCreateManagedWidget ("GX",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    75,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     0,
					XmNlabelString,      STRING("User-Defined Coordinate Grid X Anchor Point"),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtManageChild(button);
      XtAddCallback (button, XmNactivateCallback,
		     con_info, (XtPointer)2);      
      XtManageChild(form);
      




      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
    
      if(Ctype()==1)
	{sprintf(obs_str,"%.7lf",GridY);}
      else if(Ctype()==2)
	{sprintf(obs_str,"%.2lf",GridY);}
 
      fore_grid_ya = XtVaCreateManagedWidget ("fore_grid_ya",
					  xmTextFieldWidgetClass, form,	  
					  XmNvalue,            obs_str,
					  XmNtraversalOn,      True,
					  XmNrightAttachment,  XmATTACH_POSITION,
					  XmNrightPosition,    100,
					  XmNleftAttachment,   XmATTACH_POSITION,
					  XmNleftPosition,     75,
					  
                      XmNtranslations,     XtParseTranslationTable ( translations_paste ) ,
					  NULL);
      XtManageChild(fore_grid_ya);
      XtAddCallback (fore_grid_ya, XmNactivateCallback,
		     (XtCallbackProc)fore_result, (XtPointer)3);


      button = XtVaCreateManagedWidget ("GX",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    75,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     0,
					XmNlabelString,      STRING("User-Defined Coordinate Grid Y Anchor Point"),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtManageChild(button);
      XtAddCallback (button, XmNactivateCallback,
		     con_info, (XtPointer)3);      
      XtManageChild(form);
      




      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);


      shapename_w = XtVaCreateManagedWidget ("fore_grid_s",
					  xmTextFieldWidgetClass, form,	  
					  XmNvalue,            shape_out_name,
					  XmNtraversalOn,      True,
					  XmNrightAttachment,  XmATTACH_POSITION,
					  XmNrightPosition,    100,
					  XmNleftAttachment,   XmATTACH_POSITION,
					  XmNleftPosition,     75,
					  XmNmaxLength,        150,
                      XmNtranslations,     XtParseTranslationTable ( translations_paste ) ,
					  NULL);
      XtManageChild(shapename_w);
      XtAddCallback (shapename_w, XmNactivateCallback,
		     (XtCallbackProc)fore_result, (XtPointer)35);
      
      button = XtVaCreateManagedWidget ("Export Shapefile Root Name",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    75,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     0,
					XmNlabelString,      STRING("Export Shapefile Root Name"),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtManageChild(button);
      XtAddCallback (button, XmNactivateCallback,
		     con_info, (XtPointer)15);
      XtManageChild(form);




      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);

	  tog = XtVaCreateManagedWidget ("the_test",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNalignment,        XmALIGNMENT_BEGINNING,
					 XmNlabelString,      STRING("Include Geographic WGS84 Projection File with Exported Condition Shapefiles"),
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    100,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     0,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);

	    if(Ctype()==1)
		{ 
          XtAddCallback (tog, XmNvalueChangedCallback, add_projection, (XtPointer)0);
          XmToggleButtonSetState(tog,(Boolean)INCLUDE_PROJECTION,(Boolean)0);
		} 
	    else
		{ 
          INCLUDE_PROJECTION = 0;
          XtAddCallback (tog, XmNvalueChangedCallback, add_projection, (XtPointer)0);
          XmToggleButtonSetState(tog,(Boolean)INCLUDE_PROJECTION,(Boolean)0);
		  XtSetSensitive(tog,False);
		} 

      XtManageChild(form);




      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
	  tog = XtVaCreateManagedWidget ("the_test",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNalignment,        XmALIGNMENT_BEGINNING,
					 XmNlabelString,      STRING("Show point labels"),
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    33,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     0,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
    
      XtAddCallback (tog, XmNvalueChangedCallback, show_labels, (XtPointer)10001);
      XmToggleButtonSetState(tog,(Boolean)DRAW_POINT_LABELS,(Boolean)0);


	  tog = XtVaCreateManagedWidget ("the_test",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNalignment,        XmALIGNMENT_BEGINNING,
					 XmNlabelString,      STRING("Show line labels"),
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    66,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     34,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
    
      XtAddCallback (tog, XmNvalueChangedCallback, show_labels, (XtPointer)10002);
      XmToggleButtonSetState(tog,(Boolean)DRAW_LINE_LABELS,(Boolean)0);


	  tog = XtVaCreateManagedWidget ("the_test",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNalignment,        XmALIGNMENT_BEGINNING,
					 XmNlabelString,      STRING("Show area labels"),
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    99,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     67,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
    
      XtAddCallback (tog, XmNvalueChangedCallback, show_labels, (XtPointer)10003);
      XmToggleButtonSetState(tog,(Boolean)DRAW_AREA_LABELS,(Boolean)0);

      XtManageChild(form);









      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      


	  label1_menu = BuildLabel1Menu (form, XmMENU_OPTION, "Label proximity on single features:  ", label_proximity);

      XtManageChild (label1_menu);
      
      
      XtVaSetValues(label1_menu,
		    XmNleftAttachment,   XmATTACH_FORM,
		    XmNtraversalOn,      False,
		    NULL);



      label2_menu = BuildLabel2Menu (form, XmMENU_OPTION, "Total label volume:  ",label_volume);

      XtManageChild (label2_menu);

      XtVaSetValues(label2_menu,				
		    XmNleftAttachment,   XmATTACH_WIDGET,
		    XmNleftWidget,       label1_menu,
		    XmNtraversalOn,      False,
		    NULL);      

      XtManageChild(form);







      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      if(NGA_TYPE==1)
	{
	  tog = XtVaCreateManagedWidget ("the_test",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNalignment,        XmALIGNMENT_BEGINNING,
					 XmNlabelString,      STRING("Show area vertices"),
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    25,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     0,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
	}
      else
	{
	  tog = XtVaCreateManagedWidget ("the_test",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNalignment,        XmALIGNMENT_BEGINNING,
					 XmNlabelString,      STRING("Show polygonal vertices"),
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    25,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     0,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
	}
      XtAddCallback (tog, XmNvalueChangedCallback, show_vertices, (XtPointer)10001);
      XmToggleButtonSetState(tog,(Boolean)SHOW_POLY_VERTICES,(Boolean)0);

      if(NGA_TYPE==1)
	{
	  poly_color_menu = BuildGridMenu (form, XmMENU_OPTION, "Area vertex color:  ", poly_color2,POLY_COLOR);
	}
      else
	{
	  poly_color_menu = BuildGridMenu (form, XmMENU_OPTION, "Polygon vertex color:  ", poly_color2,POLY_COLOR);
	}

      XtManageChild (poly_color_menu);
      
      
      XtVaSetValues(poly_color_menu,
		    XmNrightAttachment,  XmATTACH_POSITION,
		    XmNrightPosition,    62,
		    XmNleftAttachment,   XmATTACH_POSITION,
		    XmNleftPosition,     25,
		    XmNtraversalOn,      False,
		    NULL);

      
      if(NGA_TYPE==1)
	{
	  poly_type_menu = BuildGridMenu (form, XmMENU_OPTION, "Area vertex marker:  ", mark_types, POLY_SHAPE);
	}
      else
	{
	  poly_type_menu = BuildGridMenu (form, XmMENU_OPTION, "Polygon vertex marker:  ", mark_types, POLY_SHAPE);
	}
      XtManageChild (poly_type_menu);
      
      
      XtVaSetValues(poly_type_menu,				
		    XmNrightAttachment,  XmATTACH_POSITION,
		    XmNrightPosition,    100,
		    XmNleftAttachment,   XmATTACH_POSITION,
		    XmNleftPosition,     62,
		    XmNtraversalOn,      False,
		    NULL);      

      XtManageChild(form);









      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      

      if(NGA_TYPE==1)
	{
	  tog = XtVaCreateManagedWidget ("the_test",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNalignment,        XmALIGNMENT_BEGINNING,
					 XmNlabelString,      STRING("Show line vertices"),
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    25,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     0,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
	}
      else
	{
	  tog = XtVaCreateManagedWidget ("the_test",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNalignment,        XmALIGNMENT_BEGINNING,
					 XmNlabelString,      STRING("Show linear vertices"),
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    25,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     0,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
	}

      XtAddCallback (tog, XmNvalueChangedCallback, show_vertices, (XtPointer)10002);
      XmToggleButtonSetState(tog,(Boolean)SHOW_LINE_VERTICES,(Boolean)0);


      if(NGA_TYPE==1)
	{
	  line_color_menu = BuildGridMenu (form, XmMENU_OPTION, "Line vertex color:  ", line_color2,LINE_COLOR);
	}
      else
	{
	  line_color_menu = BuildGridMenu (form, XmMENU_OPTION, "Linear vertex color:  ", line_color2,LINE_COLOR);
	}

      XtManageChild (line_color_menu);

      
      XtVaSetValues(line_color_menu,				
		    XmNrightAttachment,  XmATTACH_POSITION,
		    XmNrightPosition,  62,
		    XmNleftAttachment,   XmATTACH_POSITION,
		    XmNleftPosition,     25,
		    XmNtraversalOn,      False,
		    NULL);      
      

      if(NGA_TYPE==1)
	{
	  line_type_menu = BuildGridMenu (form, XmMENU_OPTION, "Line vertex marker:  ", mark_types3, LINE_SHAPE);
	}
      else
	{
	  line_type_menu = BuildGridMenu (form, XmMENU_OPTION, "Linear vertex marker:  ", mark_types3, LINE_SHAPE);
	}
     XtManageChild (line_type_menu);
      
      
      XtVaSetValues(line_type_menu,
		    XmNrightAttachment,  XmATTACH_POSITION,
		    XmNrightPosition,    100,
		    XmNleftAttachment,   XmATTACH_POSITION,
		    XmNleftPosition,     62,
		    XmNtraversalOn,      False,
		    NULL);      

      XtManageChild(form);










      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);

      if(NGA_TYPE==1)
	{
	  tog = XtVaCreateManagedWidget ("the_test",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNalignment,        XmALIGNMENT_BEGINNING,
					 XmNlabelString,      STRING("Show line end nodes"),
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    25,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     0,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
	}
      else
	{
	  tog = XtVaCreateManagedWidget ("the_test",
					 xmToggleButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNalignment,        XmALIGNMENT_BEGINNING,
					 XmNlabelString,      STRING("Show linear end nodes"),
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    25,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     0,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
	}


      XtAddCallback (tog, XmNvalueChangedCallback, show_vertices, (XtPointer)10003);
      XmToggleButtonSetState(tog,(Boolean)SHOW_END_VERTICES,(Boolean)0);

      if(NGA_TYPE==1)
	{
	  end_line_color_menu = BuildGridMenu (form, XmMENU_OPTION, "Line end node color:", 
					       line_color3,END_LINE_COLOR);
	}
      else
	{
	  end_line_color_menu = BuildGridMenu (form, XmMENU_OPTION, "Linear end node color:", 
					       line_color3,END_LINE_COLOR);
	}
      XtManageChild (end_line_color_menu);
      
      XtVaSetValues(end_line_color_menu,				
		    XmNrightAttachment,  XmATTACH_POSITION,
		    XmNrightPosition,  62,
		    XmNleftAttachment,   XmATTACH_POSITION,
		    XmNleftPosition,     25,
		    XmNtraversalOn,      False,
		    NULL);      

      if(NGA_TYPE==1)
	{
	  end_line_type_menu = BuildGridMenu (form, XmMENU_OPTION, "Line end node marker:", mark_types2, END_LINE_SHAPE);
	}
      else
	{
	  end_line_type_menu = BuildGridMenu (form, XmMENU_OPTION, "Linear end node marker:", mark_types2, END_LINE_SHAPE);
	}

      XtManageChild (end_line_type_menu);
      
      
      XtVaSetValues(end_line_type_menu,
		    XmNrightAttachment,  XmATTACH_POSITION,
		    XmNrightPosition,    100,
		    XmNleftAttachment,   XmATTACH_POSITION,
		    XmNleftPosition,     62,
		    XmNtraversalOn,      False,
		    NULL);      


      XtManageChild(form);






      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      
      thick_menu = BuildGridMenu (form, XmMENU_OPTION, "Grid line thickness: ", line_thick,GRID_THICKNESS-1);
      XtManageChild (thick_menu);

      XtVaSetValues(thick_menu,
		    XmNrightAttachment,  XmATTACH_POSITION,
		    XmNrightPosition,    34,
		    XmNleftAttachment,   XmATTACH_POSITION,
		    XmNleftPosition,     0,
		    XmNtraversalOn,      False,
		    NULL);
      
      color_menu2 = BuildGridMenu (form, XmMENU_OPTION, "Grid line color:", line_color,GRID_COLOR);
      XtManageChild (color_menu2);
      
      XtVaSetValues(color_menu2,				
		    XmNrightAttachment,  XmATTACH_POSITION,
		    XmNrightPosition,    67,
		    XmNleftAttachment,   XmATTACH_POSITION,
		    XmNleftPosition,     34,
		    XmNtraversalOn,      False,
		    NULL);      

	  color_menu3 = BuildGridMenu (form, XmMENU_OPTION, "Grid label color:", label_color,GRID_LABEL_COLOR);
      XtManageChild (color_menu3);
      
      XtVaSetValues(color_menu3,				
		    XmNrightAttachment,  XmATTACH_POSITION,
		    XmNrightPosition,    100,
		    XmNleftAttachment,   XmATTACH_POSITION,
		    XmNleftPosition,     67,
		    XmNtraversalOn,      False,
		    NULL);      

      XtManageChild(form);



      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
     

	  button = XtVaCreateManagedWidget ("the_test",
				       xmToggleButtonWidgetClass, form,
				       XmNtopAttachment,    XmATTACH_FORM,
				       XmNtraversalOn,      False,
				       XmNbottomAttachment, XmATTACH_FORM,
				       XmNalignment,        XmALIGNMENT_BEGINNING,
				       XmNlabelString,      STRING("Use large text size for grid labels"),
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    50,
				       XmNleftAttachment,   XmATTACH_POSITION,
				       XmNleftPosition,     0,
				       TOGGLETRANSLATE,     TOGGLEINCLUDE,
				       NULL);
      
      XtAddCallback (button, XmNvalueChangedCallback, do_large_labels, (XtPointer)0);
      XmToggleButtonSetState(button,(Boolean)DoLargeLabels,(Boolean)0);


	  button = XtVaCreateManagedWidget ("the_test",
				       xmToggleButtonWidgetClass, form,
				       XmNtopAttachment,    XmATTACH_FORM,
				       XmNtraversalOn,      False,
				       XmNbottomAttachment, XmATTACH_FORM,
				       XmNalignment,        XmALIGNMENT_BEGINNING,
				       XmNlabelString,      STRING("Use bold font for grid labels"),
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    100,
				       XmNleftAttachment,   XmATTACH_POSITION,
				       XmNleftPosition,     50,
				       TOGGLETRANSLATE,     TOGGLEINCLUDE,
				       NULL);
      
      XtAddCallback (button, XmNvalueChangedCallback, do_bold_labels, (XtPointer)0);
      XmToggleButtonSetState(button,(Boolean)DoBoldLabels,(Boolean)0);


      XtManageChild(form);






      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);      

	  qacr_menu = BuildQACRMenu (form, XmMENU_OPTION, "Participant Country for MGCP QACR:", qacr_choices);
      XtManageChild (qacr_menu);
      
      XtVaSetValues(qacr_menu,				
		    XmNrightAttachment,  XmATTACH_POSITION,
		    XmNrightPosition,    50,
		    XmNleftAttachment,   XmATTACH_POSITION,
		    XmNleftPosition,     0,
		    XmNtraversalOn,      False,
		    NULL);

	  qacr_menu2 = BuildQACRMenu2 (form, XmMENU_OPTION, "TRD Version for MGCP QACR:", qacr_choices2);
      XtManageChild (qacr_menu2);
      
      XtVaSetValues(qacr_menu2,				
		    XmNrightAttachment,  XmATTACH_POSITION,
		    XmNrightPosition,    100,
		    XmNleftAttachment,   XmATTACH_POSITION,
		    XmNleftPosition,     50,
		    XmNtraversalOn,      False,
		    NULL);

      XtManageChild(form);




      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);      
      
      dd_menu = BuildDDMenu (form, XmMENU_OPTION, "Show Coordinates in:", dd_choices);
      XtManageChild (dd_menu);
      
      XtVaSetValues(dd_menu,				
		    XmNrightAttachment,  XmATTACH_POSITION,
		    XmNrightPosition,    50,
		    XmNleftAttachment,   XmATTACH_POSITION,
		    XmNleftPosition,     0,
		    XmNtraversalOn,      False,
		    NULL);

      XtManageChild(form);




      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);      
      

      color_menu4 = BuildCondColorMenu (form, XmMENU_OPTION, "Highlighting Color:", cond_color,SPECIAL_COND_COLOR);
      XtManageChild (color_menu4);
      
      XtVaSetValues(color_menu4,				
		    XmNrightAttachment,  XmATTACH_POSITION,
		    XmNrightPosition,    50,
		    XmNleftAttachment,   XmATTACH_POSITION,
		    XmNleftPosition,     0,
		    XmNtraversalOn,      False,
		    NULL);


      button = XtVaCreateManagedWidget ("the_test",
				       xmToggleButtonWidgetClass, form,
				       XmNtopAttachment,    XmATTACH_FORM,
				       XmNtraversalOn,      False,
				       XmNbottomAttachment, XmATTACH_FORM,
				       XmNalignment,        XmALIGNMENT_BEGINNING,
				       XmNlabelString,      STRING("Show Inspection Grid in Background"),
				       XmNrightAttachment,  XmATTACH_POSITION,
				       XmNrightPosition,    100,
				       XmNleftAttachment,   XmATTACH_POSITION,
				       XmNleftPosition,     50,
				       TOGGLETRANSLATE,     TOGGLEINCLUDE,
				       NULL);
      
      XtAddCallback (button, XmNvalueChangedCallback, InspectionGridCallback, (XtPointer)0);
      XmToggleButtonSetState(button,(Boolean)GRID,(Boolean)0);


      XtManageChild(form);




       



      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      button = XtVaCreateManagedWidget ("Help",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    50,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     0,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback (button, XmNactivateCallback,
		     con_info2, (XtPointer)NULL);      
      XtManageChild(button);
      
      button = XtVaCreateManagedWidget ("Done",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    100,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     50,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      
      XtAddCallback(button, XmNactivateCallback, exitCallback, (XtPointer)4);
      XtManageChild(button);
      
      XtManageChild(form);
      XtManageChild (rowcol);
      MyPopup(fore_head); 
      XtAddCallback(fore_head,XmNdestroyCallback,ShellDeath,(XtPointer)232);

      XtVaGetValues (fore_head,  XmNheight, &y1, NULL);
      XtVaSetValues (fore_head,  XmNminHeight, y1, NULL);
      XtVaSetValues (fore_head,  XmNmaxHeight, y1, NULL);

      XtVaSetValues (fore_head,  XmNmaxWidth, 1000, NULL);

      XtAddEventHandler(fore_head,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)y1));


      XtVaSetValues(color_menu2,				
		    XmNforeground,       mycolors[GRID_COLOR],
		    XmNtopShadowColor,   mycolors[GRID_COLOR],
		    XmNbottomShadowColor,mycolors[GRID_COLOR],
		    NULL);
      XtVaSetValues(color_menu3,
		    XmNforeground,       mycolors[GRID_LABEL_COLOR],
		    XmNtopShadowColor,   mycolors[GRID_LABEL_COLOR],
		    XmNbottomShadowColor,mycolors[GRID_LABEL_COLOR],
		    NULL);

	  if(SPECIAL_COND_COLOR==-1)
	  {
        XtVaSetValues(color_menu4,
		    XmNforeground,       mycolors[1],
		    XmNtopShadowColor,   mycolors[1],
		    XmNbottomShadowColor,mycolors[1],
		    NULL);
	  }
	  else
	  {
        XtVaSetValues(color_menu4,
		    XmNforeground,       mycolors[SPECIAL_COND_COLOR],
		    XmNtopShadowColor,   mycolors[SPECIAL_COND_COLOR],
		    XmNbottomShadowColor,mycolors[SPECIAL_COND_COLOR],
		    NULL);
	  }

      if(LINE_COLOR!=999)
	{
	  XtVaSetValues(line_color_menu,
			XmNforeground,       mycolors[LINE_COLOR],
			XmNtopShadowColor,   mycolors[LINE_COLOR],
			XmNbottomShadowColor,mycolors[LINE_COLOR],
			NULL);
	}

      if(END_LINE_COLOR!=999)
	{
	  XtVaSetValues(end_line_color_menu,
			XmNforeground,       mycolors[END_LINE_COLOR],
			XmNtopShadowColor,   mycolors[END_LINE_COLOR],
			XmNbottomShadowColor,mycolors[END_LINE_COLOR],
			NULL);
	}
      if(POLY_COLOR!=999)
	{
	  XtVaSetValues(poly_color_menu,
			XmNforeground,       mycolors[POLY_COLOR],
			XmNtopShadowColor,   mycolors[POLY_COLOR],
			XmNbottomShadowColor,mycolors[POLY_COLOR],
			NULL);
	}
       FORE_WIN=1;
    }
  else
    {
      ResetWidget(fore_head);
    }
}




int AddLongUniqAttrFile(char *fname)
{
  FILE *thefile;
  short int type,foundit;
  long int seekposn;


  foundit = 0;

  thefile = fopen(fname,"rb");
  if(thefile!=NULL)
  {
    SEEIT_fread_short (&type,thefile);

	while((!feof(thefile))&&(foundit==0))
	{
	  if(type!=0)
	  {
		foundit = 1;
		break;
	  }
      SEEIT_fread_long  (&seekposn,thefile);
      SEEIT_fread_short (&type,thefile);
	}
	fclose(thefile);
  }

 return foundit;

}






void AddLongUniqAttrs()
{
  char fname[1000];

  sprintf(fname,"%sarealookup1.bin",indirectory);
  if(AddLongUniqAttrFile(fname)==1)
  {
    UNIQSAC[SilentGetAttrIndex(GetLongCode(LONG_ATTR_AREA))] = 1;
  }

  sprintf(fname,"%shgtlookup1.bin",indirectory);
  if(AddLongUniqAttrFile(fname)==1)
  {	  
    UNIQSAC[SilentGetAttrIndex(GetLongCode(LONG_ATTR_HGT))] = 1;
  }

  sprintf(fname,"%slenlookup1.bin",indirectory);
  if(AddLongUniqAttrFile(fname)==1)
  {	  
    UNIQSAC[SilentGetAttrIndex(GetLongCode(LONG_ATTR_LEN))] = 1;
  }

  sprintf(fname,"%snamlookup1.bin",indirectory);
  if(AddLongUniqAttrFile(fname)==1)
  {	  
    UNIQSAC[SilentGetAttrIndex(GetLongCode(LONG_ATTR_NAM))] = 1;
  }

  sprintf(fname,"%szvlookup1.bin",indirectory);
  if(AddLongUniqAttrFile(fname)==1)
  {
    UNIQSAC[SilentGetAttrIndex(GetLongCode(LONG_ATTR_ZV2))] = 1;
  }
}





void BuildUNIQArray()
{
  int i;
  
  for(i=0;i<INscc_loop;i++)
    {
      UNIQSCC[i] = 0;
    }
  for(i=0;i<INsac_loop;i++)
    {
      UNIQSAC[i] = 0;
    }

  

  UNIQSCCNUM = 0;
  UNIQSACNUM = 0;

  for(i=0;i<NumberOfModels;i++)
    {
      if((MdlNames[i].code>=0) && (MdlNames[i].code<INscc_loop))
	{
	  if(UNIQSCC[MdlNames[i].code]==0){UNIQSCCNUM++;}
	  UNIQSCC[MdlNames[i].code] = 1; 
	}
    }

  for(i=0;i<NumberOfAttributesEntries;i++)
    {    
      if((MdlNames2[i].code>=0) && (MdlNames2[i].code<INsac_loop))
	{
	  if(UNIQSAC[MdlNames2[i].code]==0){UNIQSACNUM++;}
	  UNIQSAC[MdlNames2[i].code] = 1; 
	}
    }


  

  AddLongUniqAttrs();



  UNIQARRAYBUILT = 1;
}

      






void shiftCallback(Widget w,XtPointer data,XtPointer callData)
{
  int type=(int)data;
  double Cwidth, Cheight;

  if(input_source==0)
    { 
      if(NGA_TYPE==1)
	{
	  not_while_running(XtParent(w),"You must open a GAIT project before\n\
you can shift the view.",1327,"No input directory.",1);  
	}
      else
	{
	  not_while_running(XtParent(w),"You must select an input data source directory before\n\
you can shift the view.",1328,"No input directory.",1);  
	}

      return;
    }
  if(output_source==0)
    {
      not_while_running(XtParent(w),"You must select an output directory before\n\
you can shift the view.",1329,"No outputput directory.",1);  
      return;
    }


  if(type==2)
    {
      if(ZOOMDEBUG==1)
	{
	  printf("zoom-shift left\n");
	}

      CURRENT_ZOOM++;
      if(CURRENT_ZOOM>SAVED_VIEWS-1)
	{
	  printf("you are at the end of the history.\n");
	  printf("you cant go back.\n");
	  CURRENT_ZOOM--;
	  return;
	}
      ZoomStackCallback((Widget)NULL, (XtPointer)CURRENT_ZOOM, (XtPointer)NULL);
    }
  else if(type==4)
    {
      if(ZOOMDEBUG==1)
	{
	  printf("zoom-shift right\n");
	}

      CURRENT_ZOOM--;
      if(CURRENT_ZOOM<0)
	{
	  printf("you are at the end of the history.\n");
	  printf("you cant go back.\n");
	  CURRENT_ZOOM++;
	  return;
	}
      ZoomStackCallback((Widget)NULL, (XtPointer)CURRENT_ZOOM, (XtPointer)NULL);
    }
  else if((type>=5)&&(type<=8))
    {
      

      Cwidth  = urx_zoom - llx_zoom;
      Cheight = ury_zoom - lly_zoom;

      if(type==5)
	{
	  llx_zoom = llx_zoom - Cwidth;
	  urx_zoom = urx_zoom - Cwidth;

	  
	}
      else if(type==6)
	{
	  llx_zoom = llx_zoom + Cwidth;
	  urx_zoom = urx_zoom + Cwidth;

	  
	}
      else if(type==8)
	{
	  lly_zoom = lly_zoom - Cheight;
	  ury_zoom = ury_zoom - Cheight;
	  
	  
	}
      else if(type==7) 
	{
	  lly_zoom = lly_zoom + Cheight;
	  ury_zoom = ury_zoom + Cheight;

	  
	}

	  SaveXScroll = ScrollPercent(1);
	  SaveYScroll = ScrollPercent(2);

      MakePixmap3();
      SAVE_ZOOM_STATE(SaveXScroll,SaveYScroll);  

      set_color (drawing_a, "White",(XtPointer)NULL);
      XFillRectangle (XtDisplay (drawing_a), pixmap,   mygc, 0, 0, width, height);
      XFillRectangle (XtDisplay (drawing_a), mywindow, mygc, 0, 0, width, height);
      SetColorRight();
      
      if(GRID==1)
	  {
	    DrawGrid();
	  }
	  
      DrawAll();
    }

  StopDistanceGathering();

}







void toolbarCallback(Widget w,XtPointer data,XtPointer callData)
{
  int type=(int)data;

  if(BUSY==1)
    {
      printf("toolbar selection dismissed due to being busy\n");
      return;
    }



  switch(type)
    {
    case 0:
      
      shiftCallback(w,(XtPointer)2,(XtPointer)2);
      break;
    case 1:
      
      shiftCallback(w,(XtPointer)4,(XtPointer)4);
      break;
    case 2:
      
      modeCallback(w,(XtPointer)1,(XtPointer)1);
      break;
    case 3:
      
      ZoomIt(-1,-1,2);
      break;
    case 4:
      
      ZoomIt(-1,-1,.5);
      break;
    case 5:
      
      ZoomAllOut();
      break;
    case 6:
      
      modeCallback(w,(XtPointer)3,(XtPointer)3);
      break;
    case 7:
      
      modeCallback(w,(XtPointer)8,(XtPointer)8);
      break;
    case 8:
      
      modeCallback(w,(XtPointer)2,(XtPointer)2);
      break;
    case 9:
      refreshCallback((Widget)NULL,(XtPointer)NULL,(XtPointer)NULL);
      break;
    case TOOLBAR_CLASS:
      break;
    default:
      printf("Toolbar got unexpected value! %d\n",type);
      XBell(mydisplay,50);
      break;
    }

  set_cursor(mydisplay,mywindow,GOOD);
}



void grabCallback(Widget w,XtPointer data,XtPointer callData)
{
  char message[2000];
  FILE *tempfile;
  XImage *myimage;
  int i,j,k;
  unsigned long temp;
  XmString t;
  Widget dialog;
  Arg args[15];
  int n=0;
  unsigned char junk1,junk2,junk3;
  char command[1000];
  XColor thiscolor;
  unsigned long color_ind_found[500];
  unsigned char red_found[500],green_found[500],blue_found[500];
  int num_colors_found = 0,foundcolor;
  

  if(input_source==0)
    {
      sprintf(message,"You must open a GAIT project before you can\n\
create screen grabs\n");
      not_while_running(drawing_a,message,1330,"No Input Directory",5);
      return;
    }



  #if(USE_DOS==0)
  sprintf(message,"%scellgraphic.xpm",outsumdirectory);
  
  tempfile = fopen(message,"wb");
  
  if(tempfile == NULL)
    {
      sprintf(message,"could not open file %s for writing\n",message);
      not_while_running(drawing_a,message,1331,"Can't open file",1);
      return;
    }
  
  fclose(tempfile);


  XpmWriteFileFromPixmap(mydisplay,message,pixmap,(Pixmap)NULL,(XpmAttributes *)NULL);
  #endif






  sprintf(message,"%scellgraphic.ppm",outsumdirectory);
  
  tempfile = fopen(message,"wb");



  fprintf(tempfile,"P6 1000 850 255\n");
 
  myimage = XGetImage(mydisplay,pixmap,0,0,width,height,XAllPlanes(),ZPixmap);
  
  sprintf(message,"Creating Screen Dump...0%% done");
  t = XmStringCreateLtoR (message,XmSTRING_DEFAULT_CHARSET);
  
  XtSetArg(args[n], XmNautoUnmanage, False); n++;
  
  dialog = XmCreateInformationDialog (drawing_a, "Wait while writing", args, n);
  
  XtUnmanageChild (XmMessageBoxGetChild (dialog, XmDIALOG_OK_BUTTON));
  XtUnmanageChild (XmMessageBoxGetChild (dialog, XmDIALOG_HELP_BUTTON));
  XtUnmanageChild (XmMessageBoxGetChild (dialog, XmDIALOG_CANCEL_BUTTON));
  
  XtVaSetValues (dialog,
		 XmNmessageString,    t,
		 XmNdialogStyle,      XmDIALOG_PRIMARY_APPLICATION_MODAL,
		 XmNdialogTitle,  STRING("Wait while Writing"),
		 NULL);
  
  XtManageChild (dialog);
  XtPopup  (XtParent(dialog), XtGrabNone);
  
  set_cursor(mydisplay,mywindow,WATCH);



  
  for(i=0;i<500;i++)
    {
      color_ind_found[i] = 0;
    }
  
  
  for(i=0;i<height;i++)
    {      
      if(i%8==0)
	{
	  sprintf(message,"Creating Screen Dump...%d%% done",
		  (int)((double)((double)i/(double)height)*100.0));
	  t = XmStringCreateLtoR (message,XmSTRING_DEFAULT_CHARSET);
	  XtVaSetValues (dialog,XmNmessageString,t,XmNdialogStyle,NULL,NULL);

	  XmUpdateDisplay(drawing_a);
	}
      
      for(j=0;j<width;j++)
	{
	  temp = XGetPixel(myimage,j,i);

	  thiscolor.red   = 0; 
	  thiscolor.green = 0; 
	  thiscolor.blue  = 0; 
	  thiscolor.pixel = temp;

	  foundcolor = 0;
	  
	  for(k=0;k<num_colors_found;k++)
	    {
	      if(color_ind_found[k]==temp)
		{
		  junk1 = red_found  [k];
		  junk2 = green_found[k];
		  junk3 = blue_found [k];
		  foundcolor = 1;
		}
	    }
	  
	  if(foundcolor==0)
	    {
	      if(!XQueryColor(mydisplay,cmap,&thiscolor))
		{
		  printf("bad color!\n");
		  
		  junk1 = 0;
		  fwrite(&junk1,1,1,tempfile);
		  fwrite(&junk1,1,1,tempfile);
		  fwrite(&junk1,1,1,tempfile);
		}
	      else
		{
		  red_found  [num_colors_found]  =  (unsigned char)(thiscolor.red  /256);
		  green_found[num_colors_found]  =  (unsigned char)(thiscolor.green/256);
		  blue_found [num_colors_found]  =  (unsigned char)(thiscolor.blue /256);
		  junk1 = red_found  [num_colors_found];
		  junk2 = green_found[num_colors_found];
		  junk3 = blue_found [num_colors_found];
		  		  
		  if(num_colors_found<490)
		    {
		      color_ind_found[num_colors_found] = temp;
		      num_colors_found = num_colors_found + 1;
		    }
		  else
		    {
		      printf("large number of colors\n");
		    }
		}
	    }

	  fwrite(&junk1,1,1,tempfile);
	  fwrite(&junk2,1,1,tempfile);
	  fwrite(&junk3,1,1,tempfile); 
	}
    }
  
  XtDestroyWidget(dialog);
  XmStringFree (t);
  fclose(tempfile);
  XDestroyImage(myimage);
  set_cursor(mydisplay,mywindow,GOOD);




  if(USE_DOS==1)
    {

      

      sprintf(command,".\\pnmtojpeg.exe -quality=95 \"%scellgraphic.ppm\" > \"%scellgraphic.jpg\"",outsumdirectory,outsumdirectory);
      printf("trying %s\n",command);
      system(command);


      


    }
  else
    {
      sprintf(command,"ppmtogif %scellgraphic.ppm > %scellgraphic.gif",outsumdirectory,outsumdirectory);
      printf("trying %s\n",command);
      system(command);
    }

  if(USE_DOS==1)
    {
      sprintf(message,"Screen saved to:\n\
       cellgraphic.ppm,\n\
       cellgraphic.jpg,\n\
(In folder %s)",outsumdirectory);
    }
  else
    {
      sprintf(message,"Screen saved to:\n\
       cellgraphic.ppm, (Mac/Linux)\n\
       cellgraphic.xpm, (only for Linux)\n\
       cellgraphic.gif  (only for Linux)\n\
(In directory %s)",outsumdirectory);
    }

  not_while_running(drawing_a,message,1332,"Done Writing",5); 

}







void SetToggles()
{
  int i;

  for(i=0;i<NUM_C;i++)
    {
      if((NGA_TYPE==1)&&(i>=5))
	{
	  continue;
	}
    }


  if(NGA_TYPE==0)
    {
      for(i=0;i<NUM_S;i++)
	{
	  XtVaSetValues(Tstrat[i],XmNset,True,NULL);
	}
    }


  if(NGA_TYPE==0)
    {
      
      XtVaSetValues(Tstrat[3],				
		    XmNset,                      False,
		    
		    NULL);
    }
  
  






  if(NGA_TYPE==0)
    {
      XtVaSetValues(Tstrat[0],				
		    
		    XmNarmColor,          mycolors[DRAW_COLOR_GRAY4],
		    XmNbackground,        mycolors[DRAW_COLOR_GRAY4],
		    NULL);
    }

}




void InitOtherStuff()
{
  int i;

  for(i=0;i<5000;i++)
    {
      shortmsg_up[i] = 0;
    }
}


void FixErrorDescription(int errnum)
{
  int chunk_len = 96;
  int end,totallen,lastend,i,len,insertindex;
  char *teststr,*teststr2;
  


  if(ErrorLookup[errnum].tol_desc1!=NULL)
  {
    if(strlen(ErrorLookup[errnum].tol_desc1)>40)
	{
      printf("Skipping too-long tolerance description #1 for inspection %s\n",ErrorLookup[errnum].name);
	  ErrorLookup[errnum].tol_desc1 = NULL;
	} 
  }

  if(ErrorLookup[errnum].tol_desc2!=NULL)
  {
    if(strlen(ErrorLookup[errnum].tol_desc2)>40)
	{ 
      printf("Skipping too-long tolerance description #2 for inspection %s\n",ErrorLookup[errnum].name);
	  ErrorLookup[errnum].tol_desc2 = NULL;
	} 
  }

  if(ErrorLookup[errnum].tol_desc3!=NULL)
  {
    if(strlen(ErrorLookup[errnum].tol_desc3)>40)
	{ 
      printf("Skipping too-long tolerance description #3 for inspection %s\n",ErrorLookup[errnum].name);
	  ErrorLookup[errnum].tol_desc3 = NULL;
	} 
  }

  if(ErrorLookup[errnum].tol_desc4!=NULL)
  {
    if(strlen(ErrorLookup[errnum].tol_desc4)>40)
	{ 
      printf("Skipping too-long tolerance description #4 for inspection %s\n",ErrorLookup[errnum].name);
	  ErrorLookup[errnum].tol_desc4 = NULL;
	} 
  }

  if(ErrorLookup[errnum].tol_desc5!=NULL)
  {
    if(strlen(ErrorLookup[errnum].tol_desc5)>40)
	{ 
      printf("Skipping too-long tolerance description #5 for inspection %s\n",ErrorLookup[errnum].name);
	  ErrorLookup[errnum].tol_desc5 = NULL;
	} 
  }

  if(ErrorLookup[errnum].tol_desc6!=NULL)
  {
    if(strlen(ErrorLookup[errnum].tol_desc6)>40)
	{ 
      printf("Skipping too-long tolerance description #6 for inspection %s\n",ErrorLookup[errnum].name);
	  ErrorLookup[errnum].tol_desc6 = NULL;
	} 
  }


  end = chunk_len;  
  
  
  
  totallen = strlen(ErrorLookup[errnum].description);
  
  
  if(totallen<=chunk_len)
    {
      return;
    }
  

  teststr  = (char *)malloc(totallen + 5);
  teststr2 = (char *)malloc(totallen + 5);
  sprintf(teststr,"%s",ErrorLookup[errnum].description);


  
  
  for(i=0;i<totallen;i++)
    {
      if(teststr[i]=='\n')
	{
	  teststr[i] = ' ';
	}
    }


  

  teststr2[0] = teststr[0];
  teststr2[1] = teststr[1];

  if(strstr(teststr,"  "))
  {
    len = strlen(teststr);
    insertindex = 2;
      
    for(i=2;i<len;i++)
	{
	  if(  ((teststr[i-1]!=' ') || (teststr[i]!=' '))  || (teststr[i-2]=='.') )
	  {
	    teststr2[insertindex] = teststr[i];
	    insertindex = insertindex + 1;
	  }
	} 
    teststr2[insertindex] = '\0';
    sprintf(teststr,"%s",teststr2);
  }  


  lastend = end;
  while(lastend<totallen)
    {
      if(teststr[end]==' ')
	{
	  teststr[end] = '\n';
	  end     = end + chunk_len;
	  lastend = end;
	}
      else
	{
	  end = end - 1;
	}
    }

  ErrorLookup[errnum].description = teststr;

  free(teststr2);
}





void InitErrorStuff()
{
  int i,j,k,l;

 

  for(i=0;i<5;i++)
    {
      dead_obhead[i] = 1;
    }

  
  HELP_UP[0]              = 0;
  for(i=0; i<=CONDITION_DEFINITIONS; i++)
    {
      


      deadfix[i]                           = 1;
      HELP_UP[i]                           = 0;
      ErrorLookup[i].active                = 1;
      ErrorLookup[i].number                = 0;
      ErrorLookup[i].scrollwidmade         = 0;
      ErrorLookup[i].scrollwidmadeNET      = 0;
      ErrorLookup[i].filterout             = 0;
      ErrorLookup[i].VConoff               = cond_start_onoff;
      ErrorLookup[i].onoff                 = cond_start_onoff;
      ErrorLookup[i].masteronoff           = -1;
      ErrorLookup[i].viewallNET            = 0;
      ErrorLookup[i].viewsomeNET           = 0;
      ErrorLookup[i].viewall               = 0;
      ErrorLookup[i].viewsome              = 0;
      ErrorLookup[i].pos_list_made         = 0;
      ErrorLookup[i].NETpos_list_made      = 0;
      ErrorLookup[i].sensitivity           = 0;
      ErrorLookup[i].sensitivity2          = 0;
      ErrorLookup[i].sensitivity3          = 0;
      ErrorLookup[i].sensitivity4          = 0;
      ErrorLookup[i].sensitivity5          = 0;
      ErrorLookup[i].sensitivity6          = 0;
      ErrorLookup[i].lowrange              = 0;
      ErrorLookup[i].highrange             = 0;
      ErrorLookup[i].lowrange2             = 0;
      ErrorLookup[i].highrange2            = 0;
      ErrorLookup[i].lowrange3             = 0;
      ErrorLookup[i].highrange3            = 0;
      ErrorLookup[i].lowrange4             = 0;
      ErrorLookup[i].highrange4            = 0;
      ErrorLookup[i].lowrange5             = 0;
      ErrorLookup[i].highrange5            = 0;
      ErrorLookup[i].lowrange6             = 0;
      ErrorLookup[i].highrange6            = 0;

      ErrorLookup[i].primaryEDCSstuff      = NULL;
      ErrorLookup[i].secondaryEDCSstuff    = NULL;
      ErrorLookup[i].tertiaryEDCSstuff     = NULL;

      ErrorLookup[i].primaryFIDstuff       = NULL;
      ErrorLookup[i].secondaryFIDstuff     = NULL;
      ErrorLookup[i].tertiaryFIDstuff      = NULL;

	  ErrorLookup[i].tol_desc1             = NULL;
	  ErrorLookup[i].tol_desc2             = NULL;
	  ErrorLookup[i].tol_desc3             = NULL;
	  ErrorLookup[i].tol_desc4             = NULL;
	  ErrorLookup[i].tol_desc5             = NULL;
	  ErrorLookup[i].tol_desc6             = NULL;
      ErrorLookup[i].units                 = NULL;
      ErrorLookup[i].Annotation            = NULL;
      ErrorLookup[i].groupnums             = NULL;
	  ErrorLookup[i].use_sen1              = 1;
	  ErrorLookup[i].use_sen2              = 1;
	  ErrorLookup[i].use_sen3              = 1;
	  ErrorLookup[i].use_sen4              = 1;
	  ErrorLookup[i].use_sen5              = 1;
	  ErrorLookup[i].use_sen6              = 1;

	  ErrorLookup[i].UseBorderCondsDefault = 2;

      for(j=0;j<NUM_C;j++)
	  {
	   for(k=0;k<(3+1);k++)
	    {
	      ErrorLookup[i].AllConfigOn[k][j]       = 0;
	      ErrorLookup[i].SpecifiedConfigOn[k][j] = 1;
	    }
	  }

      
      for(j=0;j<(3+1);j++)
	  {
	    for(k=0;k<2;k++)
		 { 
	       for(l=0;l<NUM_C;l++)
		   {
		    if((j+k+l)>0)  
			{
			  ErrorLookup[i].DO_EDCS_COMBO[j][k][l] = 0;
			}
		    ErrorLookup[i].IMarkRoot    [j][k][l] = NULL;
		    ErrorLookup[i].IMarkSACRoot [j][k][l] = NULL;
		    ErrorLookup[i].model_index  [j][k][l] = 0;
		    ErrorLookup[i].sac_index    [j][k][l] = 0;	      
		   }  
		}     
	  }    
  } 

  ResetKeepDismiss(1);


  for(i=0;i<NUM_S;i++)
    {
      DrawByStratum[i] = 1;
    }



  DoErrorSpecificInitialization();

  for(i=1; i<=CONDITION_DEFINITIONS; i++)
  {
	
    FixErrorDescription(i);
    ErrorLookup[i].UseBorderConds = ErrorLookup[i].UseBorderCondsDefault;
  }

  for(i=0;i<NUM_OBS;i++)
    {
      DO_OBS[i] = 1;
    }

  for(i=0;i<NUMCHECKGROUPS;i++)
    {
      OnOff2[i] = 0;
    }

  for(i=0;i<NUMCHECKGROUPS;i++)
    {
      VCOnOff2[i] = 0;
    }

  for(i=0;i<=CONDITION_DEFINITIONS;i++)
    {
      VCOnOff3[i] = 0;
    }

 for(i=0;i<NUMCHECKGROUPS;i++)
    {
      FCOnOff2[i] = 0;
    }

  for(i=0;i<=CONDITION_DEFINITIONS;i++)
    {
      FCOnOff3[i] = 0;
    }

  

  IgnoredPointFile[0] = '\0';
  IgnoredLineFile [0] = '\0';
 
  OnOff1          = 1;
  NetConfigOnOff1 = 1;
  VCOnOff1        = 1;
  FCOnOff1        = 1;

  
}





void WritePOIDBHeader(FILE *outfile, int num_records,int maxlen)
{
  char tempchar[10];
  short int headbytes = 0;
  short int recbytes = 0;
  int i;
  
  char fieldname[100];
  char fieldtype[10];
  unsigned char fieldlen;
  unsigned char fieldDcount;
  
  
  
  
  

  
  

  headbytes = 161;
  recbytes  =  1 + maxlen + 20 + 20 + 20;
  
  
  file_endianness = LITTLE;
  tempchar[0] = 3;
  tempchar[1] = 72;
  tempchar[2] = 7;
  tempchar[3] = 17;
  SEEIT_fwrite_char (&tempchar[0], outfile);  
  SEEIT_fwrite_char (&tempchar[1], outfile);  
  SEEIT_fwrite_char (&tempchar[2], outfile);  
  SEEIT_fwrite_char (&tempchar[3], outfile);  
  SEEIT_fwrite_int  (&num_records, outfile);
  SEEIT_fwrite_short(&headbytes  , outfile); 
  SEEIT_fwrite_short(&recbytes   , outfile); 

  tempchar[4] = 0;
  tempchar[5] = 87;
  tempchar[6] = 13;

  for(i=12;i<29;i++)
    {
      SEEIT_fwrite_char (&tempchar[4], outfile);  
    }
  SEEIT_fwrite_char (&tempchar[5], outfile);  
  SEEIT_fwrite_char (&tempchar[4], outfile);  
  SEEIT_fwrite_char (&tempchar[4], outfile);  
  
  
  
  
  
  
  sprintf(fieldname,"ANNOTATION");
  sprintf(fieldtype,"C");
  fieldlen = maxlen;
  fieldDcount = 0;
  fwrite(&fieldname  [0], 1,11,outfile);
  fwrite(&fieldtype  [0], 1, 1,outfile);
  fwrite(&tempchar   [4], 1, 1,outfile);
  fwrite(&tempchar   [4], 1, 1,outfile);
  fwrite(&tempchar   [4], 1, 1,outfile);
  fwrite(&tempchar   [4], 1, 1,outfile);
  fwrite(&fieldlen      , 1, 1,outfile);
  fwrite(&fieldDcount   , 1, 1,outfile);
  fwrite(&tempchar   [4], 1, 1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);


  sprintf(fieldname,"SYMBOL");
  sprintf(fieldtype,"C");
  fieldlen = 20;
  fieldDcount = 0;
  fwrite(&fieldname  [0], 1,11,outfile);
  fwrite(&fieldtype  [0], 1, 1,outfile);
  fwrite(&tempchar   [4], 1, 1,outfile);
  fwrite(&tempchar   [4], 1, 1,outfile);
  fwrite(&tempchar   [4], 1, 1,outfile);
  fwrite(&tempchar   [4], 1, 1,outfile);
  fwrite(&fieldlen      , 1, 1,outfile);
  fwrite(&fieldDcount   , 1, 1,outfile);
  fwrite(&tempchar   [4], 1, 1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);



  sprintf(fieldname,"XCOORD");
  sprintf(fieldtype,"N");
  fieldlen = 20;
  fieldDcount = 8;
  fwrite(&fieldname  [0], 1,11,outfile);
  fwrite(&fieldtype  [0], 1, 1,outfile);
  fwrite(&tempchar   [4], 1, 1,outfile);
  fwrite(&tempchar   [4], 1, 1,outfile);
  fwrite(&tempchar   [4], 1, 1,outfile);
  fwrite(&tempchar   [4], 1, 1,outfile);
  fwrite(&fieldlen      , 1, 1,outfile);
  fwrite(&fieldDcount   , 1, 1,outfile);
  fwrite(&tempchar   [4], 1, 1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);


  sprintf(fieldname,"YCOORD");
  sprintf(fieldtype,"N");
  fieldlen = 20;
  fieldDcount = 8;
  fwrite(&fieldname  [0], 1,11,outfile);
  fwrite(&fieldtype  [0], 1, 1,outfile);
  fwrite(&tempchar   [4], 1, 1,outfile);
  fwrite(&tempchar   [4], 1, 1,outfile);
  fwrite(&tempchar   [4], 1, 1,outfile);
  fwrite(&tempchar   [4], 1, 1,outfile);
  fwrite(&fieldlen      , 1, 1,outfile);
  fwrite(&fieldDcount   , 1, 1,outfile);
  fwrite(&tempchar   [4], 1, 1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);
  fwrite(&tempchar   [4], 1,1,outfile);


  
  fwrite(&tempchar   [6], 1,1,outfile);

}







char *GetPOIType(int type)
{

  if(type==13)
    {
      return "Red Triangle";
    }
  
  else if(type==9)
    {
      return "Red Star";
    }
  
  else if(type==1)
    {
      return "Red X-Mark";
    }
  else if(type==5)
    {
      return "Red Circle";
    }
  
  else if(type==15)
    {
      return "Green Triangle";
    }
  
  else if(type==11)
   {
      return "Green Star";
    }
  
   else if(type==3)
    {
      return "Green X-Mark";
    }
  else if(type==7)
    {
      return "Green Circle";
    }
  
  else if(type==14)
   {
      return "Blue Triangle";
    }
  
  else if(type==10)
    {
      return "Blue Star";
    }
  
  else if(type==2)
    {
      return "Blue X-Mark";
    }
  else if(type==6)
    {
      return "Blue Circle";
    }
  
  else if(type==16)
    {
      return "Yellow Triangle";
    }
  
  else if(type==12)
    {
      return "Yellow Star";
    }
  
  else if(type==4)
    {
      return "Yellow X-Mark";
    }
  else if(type==8)
    {
      return "Yellow Circle";
    }
  else
  {
	  XBell(mydisplay,50);
	  printf("bad type %d to GetPOIType\n",type);
	  return "unknown";
  }

  
  return "unknown2";

}


void HandleSuccessDos(Widget w)
{

  XtPopdown(w);
  
  if(w==choose_dialog)
    {
      browse12_up = 2;
    }
  else if(w==choose_es1_dialog)
    {
      browse13_up = 2;
    }
  else if(w==choose_es2_dialog)
    {
      browse14_up = 2;
    }
  else if(w==choose_txt_dialog)
    {
      browse15_up = 2;
    }
  else if(w==chooseshape_dialog)
    {
      SHAPE_IMPORT_OUTPUT = 2;
    }
  else if(w==choosedata_dialog)
    {
      browse26_up = 2;
    }
  else if(w==choose_xml1_dialog)
    {
      browse27_up = 2;
    }
  else if(w==choose_xml2_dialog)
    {
      browse28_up = 2;
    }
  else if(w==choose_xml3_dialog)
    {
      browse29_up = 2;
    }
  else if(w==chooseattr_dialog)
    {
      browse30_up = 2;
    }
  else if(w==choosedp_dialog)
    {
      browse31_up = 2;
    }
  else if(w==choosebr_dialog)
    {
      browse32_up = 2;
    }
  else
    {
      printf("Got unexpected wid %s to HSD\n",XtName(w));
    }
}



void WritePOIDBEntry(FILE *outfile,char *annotation, int maxlen, int type,
					 double x, double y)
{
  int j;
  char recvalue9[500];
  char tempchar[10];

  
  tempchar[4] = 32;
  fwrite(&tempchar   [4], 1, 1             ,outfile);
  
  
  
  
  for(j=0;j<maxlen;j++)
    {
      recvalue9[j] = ' ';
    }
  
  sprintf(recvalue9,"%s",annotation);
  
  recvalue9[maxlen-1]='\0';
  j = strlen(recvalue9);
  recvalue9[j]=' ';
  
  fwrite(&recvalue9  [0], 1,maxlen  ,outfile);
  



  
  for(j=0;j<20;j++)
    {
      recvalue9[j] = ' ';
    }
  
  sprintf(recvalue9,"%s",GetPOIType(type));
  
  j = strlen(recvalue9);
  recvalue9[j]=' ';
  
  fwrite(&recvalue9  [0], 1,20  ,outfile);



  
  
  for(j=0;j<20;j++)
    {
      recvalue9[j] = ' ';
    }
  sprintf(recvalue9,"%.8lf",x);
  
  recvalue9[19]='\0';
  j = strlen(recvalue9);
  recvalue9[j]=' ';

  fwrite(&recvalue9  [0], 1,20             ,outfile);

  


  
  
  for(j=0;j<20;j++)
    {
      recvalue9[j] = ' ';
    }
  sprintf(recvalue9,"%.8lf",y);
  
  recvalue9[19]='\0';
  j = strlen(recvalue9);
  recvalue9[j]=' ';

  fwrite(&recvalue9  [0], 1,20             ,outfile);

}




void toggled7(Widget widget,XtPointer client_data,XtPointer call_data)
{
  if(DetailedInfo==0){DetailedInfo=1;}
  else {DetailedInfo=0;}
}



void FCODEFilterCallback(Widget w, XtPointer userData, XtPointer callData)
{
  

  Widget rc,Done,form,label1,button;
  static Widget modelhead;
  XmString *model_names,*model_names2;
  XmString bignames[1];
  Arg resources[20];
  Dimension y1;
  int n=0,i,max=0,NumberOfRealModels = 0, insertindex;
  char temp[500], headtxt[1000],message[1000];
  extern int numobs,fcodefilter_up;
  
  
  
  if(numobs==0)
    {
      sprintf(message,"All the conditions have already been filtered out.\n\
Use \"Revert\" to un-filter them.");

      not_while_running(drawing_a,message,1390,"All Conditions Already Filtered",1);
      return;
    }


  
  
  for (i = 0; i < NumberOfModels ; i++)
    {
      if(MdlNames[i].inout>0)
	{
	  NumberOfRealModels = NumberOfRealModels + 1; 
	}
    }
  



  model_names =  (XmString *) (malloc(sizeof(XmString *) * NumberOfRealModels));
  if(model_names==NULL){printf("mn1: out of allocation memory!\n"); ExitWrapper(-1);}

  model_names2 = (XmString *) (malloc(sizeof(XmString *) * NumberOfRealModels));
  if(model_names2==NULL){printf("mn2: out of allocation memory!\n"); ExitWrapper(-1);}





  if(fcodefilter_up==0)
    {
      
      n=0;
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++;
      
      if(NGA_TYPE==1)
	  {
        sprintf(headtxt,"Filter Conditions by Feature Type");
	  }
	  else
	  {
        sprintf(headtxt,"Filter Conditions by Classification");
	  }
      
      
      modelhead = 
	XtCreatePopupShell(headtxt,topLevelShellWidgetClass,w,resources,n);
      
      
      
      rc = XtVaCreateManagedWidget
	(
	 "XformWidget", xmPanedWindowWidgetClass, modelhead,
	 XmNrubberPositioning, False,
	 XmNresizable,         True,
	 XmNseparatorOn,       False,
	 XmNsashHeight,        1,
	 NULL
	 );
      


      
      form = XtVaCreateWidget ("formola", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   18,
			       XmNpaneMaximum,   18,
			       XmNfractionBase,  100,  
			       NULL);
      
      if(NGA_TYPE==1)
	  {
        label1 = XtVaCreateManagedWidget (temp,
					xmLabelWidgetClass, form,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,   50,
					XmNleftAttachment,  XmATTACH_FORM,
					XmNalignment,       XmALIGNMENT_CENTER,
					XmNlabelString,     STRING("Feature Types"),
					XmNtraversalOn,     False,
					LABELWTRANSLATE,
					NULL);
      
        label1 = XtVaCreateManagedWidget ("Feature Types",
					xmLabelWidgetClass, form,
					XmNrightAttachment, XmATTACH_FORM,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    50,
					XmNalignment,       XmALIGNMENT_CENTER,
					XmNlabelString,     STRING("Feature Types"),
					XmNtraversalOn,     False,
					LABELWTRANSLATE,
					NULL);
	  }
	  else
	  {
        label1 = XtVaCreateManagedWidget (temp,
					xmLabelWidgetClass, form,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,   50,
					XmNleftAttachment,  XmATTACH_FORM,
					XmNalignment,       XmALIGNMENT_CENTER,
					XmNlabelString,     STRING("Classification identifiers"),
					XmNtraversalOn,     False,
					LABELWTRANSLATE,
					NULL);
      
        label1 = XtVaCreateManagedWidget ("Classification Identifiers",
					xmLabelWidgetClass, form,
					XmNrightAttachment, XmATTACH_FORM,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    50,
					XmNalignment,       XmALIGNMENT_CENTER,
					XmNlabelString,     STRING("Classification Identifiers"),
					XmNtraversalOn,     False,
					LABELWTRANSLATE,
					NULL);
	  }

      XtManageChild(form);
      
      
      
      
      
      form = XtVaCreateWidget ("formola", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   18,
			       XmNpaneMaximum,   18,
			       XmNfractionBase,  100,  
			       NULL);
      
      sprintf(temp,"(%d Definitions)",NumberOfRealModels);

      
      label1 = XtVaCreateManagedWidget (temp,
					xmLabelWidgetClass, form,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,   50,
					XmNleftAttachment,  XmATTACH_FORM,
					XmNalignment,       XmALIGNMENT_CENTER,
					XmNlabelString,     STRING(temp),
					XmNtraversalOn,     False,
					LABELWTRANSLATE,
					NULL);
      
      label1 = XtVaCreateManagedWidget ("Selected For Filtering:",
					xmLabelWidgetClass, form,
					XmNrightAttachment, XmATTACH_FORM,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    50,
					XmNalignment,       XmALIGNMENT_CENTER,
					XmNlabelString,     STRING("Selected For Filtering:"),
					XmNtraversalOn,     False,
					LABELWTRANSLATE,
					NULL);
      
      XtManageChild(form);
      




      insertindex = 0;

      for (i = 0; i < NumberOfModels ; i++)
	{
	  if(MdlNames[i].inout>0)
	    {
	      if(NGA_TYPE==1)
		{
		  sprintf(temp,"%s: %s %s (%d/%.0lf)",
			  GetECCCode(MdlNames[i].code),
			  GetECCLabel(MdlNames[i].code),
			  MdlNames[i].name,
			  MdlNames[i].inout,
			  MdlNames[i].occurrences);		  
		}
	      else
		{
		  sprintf(temp,"%s %s (%d/%.0lf)",
			  GetECCLabel(MdlNames[i].code),
			  MdlNames[i].name,
			  MdlNames[i].inout,
			  MdlNames[i].occurrences);	
		}
	      model_names[insertindex] = XmStringCreate(temp,"mytag1");
	      if((int)(strlen(temp))>max){max=strlen(temp);}

	      MdlNames[insertindex].origindex = i;

	      
	      insertindex = insertindex + 1;
	    }
	}
      
      
      for(i=0;i<max;i++)
	{		 
	  temp[i]=' ';
	}
      temp[i]='\0';
      
      form = XtVaCreateWidget ("formola", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);
      n=0;
      XtSetArg(resources[n],  XmNlistSizePolicy,   XmCONSTANT);         n++;
      XtSetArg(resources[n],  XmNvisibleItemCount, 10);                 n++;
      XtSetArg(resources[n],  XmNselectionPolicy,  XmEXTENDED_SELECT);  n++;
      XtSetArg(resources[n],  XmNleftAttachment,    XmATTACH_FORM);     n++;
      XtSetArg(resources[n],  XmNrightAttachment,   XmATTACH_POSITION); n++;
      XtSetArg(resources[n],  XmNrightPosition,     47);                n++;
      XtSetArg(resources[n],  XmNtopAttachment,     XmATTACH_FORM);     n++;
      XtSetArg(resources[n],  XmNbottomAttachment,  XmATTACH_FORM);     n++;
      XtSetArg(resources[n],  XmNtraversalOn,       False);             n++;
      XtSetArg(resources[n],  XmNtranslations,      XtParseTranslationTable (list_translations16)); n++;
      
      
      BOlist_w  = XmCreateScrolledList (form, "list",resources,n);
      
      
      XtAddCallback (BOlist_w, XmNsingleSelectionCallback,choose_specific_fcode,NULL);

      XtManageChild (BOlist_w);
      
      
      for(i=0;i<NumberOfRealModels;i++)
	{
	  model_names2[i] = XmStringCreate(temp,"mytag1");
	}     
      


      insertindex   = 0;

      for(i=0;i<NumberOfModels;i++)
	{
	  if(MdlNames[i].inout2>0)
	    {
	      if(NGA_TYPE==1)
		{
		  sprintf(temp,"%s: %s %s (%d/%.0lf)",
			  GetECCCode(MdlNames[i].code),
			  GetECCLabel(MdlNames[i].code),
			  MdlNames[i].name,
			  MdlNames[i].inout,
			  MdlNames[i].occurrences);
		}
	      else
		{
		  sprintf(temp,"%s %s (%d/%.0lf)",
			  GetECCLabel(MdlNames[i].code),
			  MdlNames[i].name,
			  MdlNames[i].inout,
			  MdlNames[i].occurrences);
		}

	      model_names2[insertindex] = XmStringCreate(temp,"mytag1");
	      
	      insertindex = insertindex + 1;
	    }
	}
      
      
    
      
      
      button = XtVaCreateManagedWidget ("arrow1",
					xmArrowButtonWidgetClass, form,
					XmNarrowDirection,    XmARROW_RIGHT,
					XmNleftAttachment,    XmATTACH_POSITION,
					XmNleftPosition,      47,
					XmNrightAttachment,   XmATTACH_POSITION,
					XmNrightPosition,     53,
					XmNtopAttachment,     XmATTACH_FORM,
					XmNbottomAttachment,  XmATTACH_FORM,
					XmNtraversalOn,       False,
					NULL);
      
      XtAddCallback (button, XmNactivateCallback, set_fcode,NULL);

      
      if(XCG==1)
	{
	  XcgLiteClueAddWidget(ToolTipMaster, button, 
			       "Add selected feature types to selected list", 0, 0);
	}
      
      n=0;
      XtSetArg(resources[n],  XmNlistSizePolicy,   XmCONSTANT);        n++;
      XtSetArg(resources[n],  XmNvisibleItemCount, 10);                n++;
      XtSetArg(resources[n],  XmNselectionPolicy,  XmEXTENDED_SELECT); n++;
      XtSetArg(resources[n],  XmNleftAttachment,   XmATTACH_POSITION); n++;
      XtSetArg(resources[n],  XmNleftPosition,     53);                n++;
      XtSetArg(resources[n],  XmNrightAttachment,  XmATTACH_FORM);     n++;
      XtSetArg(resources[n],  XmNtopAttachment,    XmATTACH_FORM);     n++;
      XtSetArg(resources[n],  XmNbottomAttachment, XmATTACH_FORM);     n++;
      XtSetArg(resources[n],  XmNtraversalOn,      False);             n++;
      XtSetArg(resources[n],  XmNtranslations,     XtParseTranslationTable (list_translations16)); n++;
	  


      BOlist2_w = XmCreateScrolledList (form, "list", resources,n);	  
      XtManageChild (BOlist2_w);
      
      XtManageChild (form);
      




      

      
       
      form = XtVaCreateWidget ("form3", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
      Done  = XtVaCreateManagedWidget("De-SelModels",xmPushButtonWidgetClass,form,
				      XmNleftAttachment,  XmATTACH_FORM,
				      XmNrightAttachment, XmATTACH_POSITION,
				      XmNrightPosition,   50,
				      XmNlabelString,     STRING("De-Select highlighted filter items"),
				      XmNtraversalOn,     False,
				      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 

      XtAddCallback(Done, XmNactivateCallback, (XtCallbackProc)kill_fcode,NULL);
      XtManageChild(Done);






      Done  = XtVaCreateManagedWidget("DeSelectALLModels",xmPushButtonWidgetClass,form,
				      XmNleftAttachment,  XmATTACH_POSITION,
				      XmNleftPosition,    50,
				      XmNrightAttachment, XmATTACH_FORM,
				      XmNlabelString,     STRING("De-Select ALL filter items"),
				      XmNtraversalOn,     False,
				      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 

      XtAddCallback(Done, XmNactivateCallback, kill_all_fcode,NULL);
      XtManageChild(Done);
      XtManageChild(form);







      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
      Done  = XtVaCreateManagedWidget("Help",xmPushButtonWidgetClass,form,
				      XmNleftAttachment,  XmATTACH_FORM,
				      XmNrightAttachment, XmATTACH_POSITION,
				      XmNrightPosition,   50,
				      XmNlabelString,     STRING("Help"),
				      XmNtraversalOn,     False,
				      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 
      XtAddCallback(Done, XmNactivateCallback,
		    Help_fcodeCallback, (XtPointer) NULL);
      XtManageChild(Done);





      Done  = XtVaCreateManagedWidget("Done7",xmPushButtonWidgetClass,form,
				      XmNleftAttachment,  XmATTACH_POSITION,
				      XmNleftPosition,    50,
				      XmNrightAttachment, XmATTACH_FORM,
				      XmNlabelString,     STRING("Done"),
				      XmNtraversalOn,     False,
				      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      );


      XtAddCallback(Done, XmNactivateCallback,kill_fcode_callback, NULL);


      XtManageChild(Done);
      XtManageChild(form);


      bignames[0] =  XmStringCreate("                                                                                                                                            ","mytag1");
      



      XtManageChild(rc);
      MyPopup(modelhead); 


      XtAddCallback(modelhead,XmNdestroyCallback,ShellDeath,(XtPointer)4057);


      XmListAddItems(BOlist2_w, model_names2,NumberOfRealModels,1);
      XmListAddItems(BOlist_w,  model_names ,NumberOfRealModels,1);
      

      
      
      XtAddCallback (BOlist_w,  XmNdefaultActionCallback, set_fcode, NULL);
      
      
      
      for (i = 0; i <  NumberOfRealModels; i++)
	{
	  XmStringFree (model_names[i]);
	  XmStringFree (model_names2[i]);
	}

     free(model_names);
     free(model_names2);


     
     
     XtVaGetValues (modelhead, XmNheight, &y1, NULL);
     XtVaSetValues (modelhead, XmNminHeight, y1+30, NULL);

     fcodefilter_up = 1;     
    }
  else
    {
      ResetWidget(modelhead);
    }  
}








void boapplyfilterCallback(Widget w, XtPointer userData, XtPointer callData)
{
  FILE *infile,*outfile;
  char filename[1000],filename2[1000],command2[1000],message[1000];
  int i;
  extern void ReadWriteObjConditions(FILE *fin, FILE *fout, 
				     int dimension, int *CheckArray, int *InstanceArray);
  
  if(BODEBUG==1)
    {
      printf("apply filters...\n");
    }


  
  

  sprintf(filename, "%scondreport.bo3",outdirectory);
  sprintf(filename2,"%scondreport.bo2",outdirectory);
  
  if((USE_DOS==0)||(SLASHTYPE==NONDOS_TYPE))
    {
      sprintf(command2,"cp \"%s\" \"%s\"",filename2,filename);
    }
  else
    {
      sprintf(command2,"copy \"%s\" \"%s\"",filename2,filename);
    }  
  
  system(command2);



  
  infile = fopen(filename,"rb");
  if(infile==NULL)
    {
      sprintf(message,"Error: Unable to open for reading:\n %s\nCan not continue.",
	      filename);	 
      not_while_running(drawing_a,message,1389,"Can not open BO3 file",1);
      return;
    }


  outfile = fopen(filename2,"wb");
  if(outfile==NULL)
    {
      sprintf(message,"Error: Unable to open for reading:\n %s\nCan not continue.",
	      filename2);	 
      not_while_running(drawing_a,message,1389,"Can not open new BO2 file for write",1);
      return;
    }
  


  if(BODEBUG==1)
    {
      printf("Indices to filter out:\n");
      
      
      for(i=0;i<NumberOfModels;i++)
	{
	  if(MdlNames[i].inout2==1)
	    {
	      printf("%d (%s %s)\n",i,
		     GetECCLabel(MdlNames[i].code),
		     MdlNames[i].name);
	    }
	}
    }



  XtPopdown(ob_head[current_ob_head]);  
  
  


  set_cursor(mydisplay,mywindow,WATCH);
  

  ReadWriteObjConditions(infile,outfile,0,NULL,NULL);

  fclose(infile);
  fclose(outfile);

  ResetBOoptions();

  view_object_page = 1;
  SetNewPage();

  set_cursor(mydisplay,mywindow,GOOD);

}



void bohelpCallback(Widget w, XtPointer userData, XtPointer callData)
{

  if(NGA_TYPE==1)
    {
      not_while_running(w,"This window is used to view conditions on a by-feature basis.\n\
Each item in the list represents a feature with associated conditions.\n\
The list is sorted according to the number of conditions associated\n\
with the features, so the feature with the largest number of conditions\n\
is at the top of the list.\n\n\
The conditions associated with features may be viewed by selecting\n\
the appropriate \"Highlight All\" and \"Highlight Selected\" buttons associated\n\
with the conditions for the feature(s) that you wish to view.\n\
The window shows only 25 features at a time.  The current features\n\
viewable at any time is called a page.  The current page can be changed\n\
using either the on-screen arrow buttons or a type-in window at the bottom\n\
of the screen.  The number of pages available is also shown at the bottom\n\
of the screen.\n\n\
The list of features and associated conditions may be shortened (filtered)\n\
using the \"Filter By Feature Type...\" and \"Filter By Inspection...\"\n\
buttons at the bottom of the screen.  After making selections in these\n\
menus, select the \"Apply Filters\" button to apply these selections.\n\
To Revert to an un-filtered list, select the \"Revert\" button.",
			1393,"View Conditions By Feature Help",5);
    }
  else
    {
      not_while_running(w,"This window is used to view conditions on a by-object basis.\n\
Each item in the list represents anobject with associated conditions.\n\
The list is sorted according to the number of conditions associated\n\
with the objects, so the object with the largest number of conditions\n\
is at the top of the list.\n\n\
The conditions associated with objects may be viewed by selecting\n\
the appropriate \"Highlight All\" and \"Highlight Selected\" buttons associated\n\
with the conditions for the object(s) that you wish to view.\n\
The window shows only 25 objects at a time.  The current objects\n\
viewable at any time is called a page.  The current page can be changed\n\
using either the on-screen arrow buttons or a type-in window at the bottom\n\
of the screen.  The number of pages available is also shown at the bottom\n\
of the screen.\n\n\
The list of objects and associated conditions may be shortened (filtered)\n\
using the \"Filter By Classification...\" and \"Filter By Inspection...\"\n\
buttons at the bottom of the screen.  After making selections in these\n\
menus, select the \"Apply Filters\" button to apply these selections.\n\
To Revert to an un-filtered list, select the \"Revert\" button.",
			1393,"View Conditions By Object Help",5);
    }

}




void toggled6(Widget widget,XtPointer client_data,XtPointer call_data)
{
  if(CenterZoomOnErrors==0)
    {
      CenterZoomOnErrors = 1;
    }
  else 
    {
      CenterZoomOnErrors = 0;
    }
}



void shift_page(Widget text_w,XtPointer client_data,XtPointer call_data)
{
  
  int leftright = (int)client_data;

  if(leftright==1)
    {
      
      view_object_page = view_object_page - 1;
    }
  else
    {
      
      view_object_page = view_object_page + 1;
    }

  if(BODEBUG==1)
    {
      printf("\n\nNow setting page to %d\n",view_object_page);
    }

  SetNewPage();
}


void page_result(Widget text_w,XtPointer client_data,XtPointer call_data)
{
  char *value = XmTextFieldGetString (text_w);
  char OLD[30];
  int i,bad=0,type,pagenumtest;
  double dtest;


  type = (int)client_data;

  sprintf(OLD,"%d",view_object_page);

  

  
  for(i=0;i<(int)(strlen(value));i++)
    {
      if((value[i]<'0')||(value[i]>'9'))
	{
	  XmTextFieldSetString(text_w,OLD);
	  bad = 1;
	}
    }
  
  if(bad==1)
    {
      
      return;
    }

  if(type==6)
    {
      
      return;
    }

  sscanf(value,"%lf",&dtest);
  pagenumtest = (int)dtest;

  if((pagenumtest>=1)&&(pagenumtest<=maxpages))
    {
      view_object_page = pagenumtest;
      SetNewPage();
    }
  else
    {
      XmTextFieldSetString(text_w,OLD);
    }
  XtFree(value);
}



void ConditionObjectCallback(Widget w, XtPointer userData, XtPointer callData)
{
  Widget formmaster,sb2,form,button,button1,button2,tempwid,toggleb,setB,
    button3, button4;
  Arg resources[20];
  FILE *bofile;
  char filename[1000],message[1000],temp[1000];
  int totalconds,i,n,total = 0;
  int numdec,numgroups,page_num,cloneindex;



  int totalnum,check,instance;


  page_num = view_object_page;



  if(BODEBUG==1)
    {
      printf("got page num %d\n",page_num);
    }

  
  MakeSen((Widget)NULL,(XEvent *)NULL,(String *)NULL,(int *)NULL);


  
  for(i=1;i<=CONDITION_DEFINITIONS;i++)
    {      
      total = total + ErrorLookup[i].number;
    }
  
  for(i=1;i<=CLONE_DEFINITIONS;i++)
    {
      total = total + CloneErrorLookup[i-1].number;
    }

  if(total==0)
    {
      printf("abnormal return\n");
      return;
    }
  


  if(dead_error==0)
    {
      if(NGA_TYPE==1)
	{
	  sprintf(message,"The \"Conditions Found\" window is currently active.\n\
It is not possible to \"View Conditions by Feature\" when this window is active.\n\
To \"View Conditions by Feature\", dismiss the \"Conditions Found\" window, and then\n\
select \"View Conditions by Feature\" again.");
      not_while_running(drawing_a,message,1405,"Can not view By Feature",1);
	}
      else
	{
	  sprintf(message,"The \"Conditions Found\" window is currently active.\n\
It is not possible to \"View Conditions by Object\" when this window is active.\n\
To \"View Conditions by Object\", dismiss the \"Conditions Found\" window, and then\n\
select \"View Conditions by Object\" again.");
      not_while_running(drawing_a,message,1405,"Can not view By Object",1);
	}
      return;
    }




  if(dead_obhead[current_ob_head]==1)
    {
      
      sprintf(filename,"%scondreport.bo2",outdirectory);
      bofile = fopen(filename,"rb");
      if(bofile==NULL)
	{
	  sprintf(message,"Error: Unable to open for reading:\n %s\nCan not continue.",
		  filename);	 
	  not_while_running(drawing_a,message,1389,"Can not open BO2 file",1);
	  return;
	}
      
      SEEIT_fread_int(&numobs,     bofile);
      SEEIT_fread_int(&totalconds, bofile);      
      SEEIT_fread_int(&numgroups, bofile);


      if(numobs>0)
	{
	  
	  maxpages = numobs/num_per_page + 1;
	  
	  if(numobs%num_per_page==0)
	    {
	      maxpages = maxpages - 1;
	    }
	  if(maxpages<1)
	    {
	      maxpages = 1;
	    }
	  
	  if(maxpages!=numgroups)
	    {
	      printf("error, %d fileposns but %d groups (%d/%d=%d)\n",
		     numgroups,maxpages,numobs,num_per_page,maxpages);
	    }
	  
	  
	  if(pageptrsalloced==1)
	    {
	      free(pageptrs);
	    }
	  pageptrs = (long int *)malloc(SzL*(numgroups+5));
	  if(pageptrs==NULL)
	    {
	      printf("memory exhausted when trying to alloc %d groups\n",numgroups);
	      ExitWrapper(-1);
	    }
	  pageptrsalloced = 1;
	  
	  for(i=1;i<=numgroups;i++)
	    {
	      SEEIT_fread_long(&pageptrs[i], bofile);
	    }

	  
	  for(i=0;i<NumberOfModels;i++)
	    {
	      SEEIT_fread_int(&MdlNames[i].inout,bofile);
	      
	      MdlNames[i].inout2 = 0;
	    }


	  SEEIT_fread_int(&totalnum,bofile);


	  for(i=1;i<=CONDITION_DEFINITIONS;i++)
	    {
	      ErrorLookup[i].totalBO         = 0;
	    }
	  for(i=0;i<CLONE_DEFINITIONS;i++)
	    {
	      CloneErrorLookup[i].totalBO    = 0;
	    }

	  for(i=0;i<totalnum;i++)
	    {
	      SEEIT_fread_int(&check,   bofile);
	      SEEIT_fread_int(&instance,bofile);
	      SEEIT_fread_int(&total,   bofile);

	      instance = instance + 1;

	      if(instance==1)
		{
		  ErrorLookup[check].totalBO = total;
		}
	      else
		{
		  cloneindex = GetCloneIndex(instance-1,check);
		  CloneErrorLookup[cloneindex].totalBO = total;
		}
	    }
	  
	  
	  fclose(bofile);
	  
	  if(BODEBUG==1)
	    {
	      printf("Read %d objects, %d total conds\n",numobs,totalconds);
	    }
	  
	  if(alloced_boonoff2==0)
	    {
	      BOOnOff2 = (int *)malloc(sizeof(int)*(numobs+5));
	      if(BOOnOff2==NULL)
		{
		  printf("failed to alloc BO for %d obs\n",numobs);
		  ExitWrapper(-1);
		}
	      for(i=0;i<numobs+5;i++)
		{
		  BOOnOff2[i] = 0;
		}
	      alloced_boonoff2 = numobs;
	    }
	}
      else
	{
	  maxpages = 1;

	  for(i=0;i<NumberOfModels;i++)
	    {
	      MdlNames[i].inout  = 0;
	      MdlNames[i].inout2 = 0;
	    }
	}
      

      n=0;
      
      XtSetArg(resources[n],  XmNdeleteResponse,    XmDESTROY); n++;
      XtSetArg(resources[n],  XmNrubberPositioning, True);      n++;
      
      if(override_location==1)
	{
	  XtSetArg(resources[n],  XmNx,          over_px1);     n++;
	  XtSetArg(resources[n],  XmNy,          over_py1);     n++;
	  XtSetArg(resources[n],  XmNheight,     over_height);  n++;
	  XtSetArg(resources[n],  XmNwidth,      over_width);   n++;
	}
      else
	{
	  XtSetArg(resources[n],  XmNheight,            600);   n++;
	  XtSetArg(resources[n],  XmNwidth,             700);   n++;
	}



      if(NGA_TYPE==1)
	{
	  ob_head[current_ob_head] = XtCreatePopupShell
	    ("View Conditions By Feature",topLevelShellWidgetClass,drawing_a,resources,n);
	}
      else
	{
	  ob_head[current_ob_head] = XtCreatePopupShell
	    ("View Conditions By Object",topLevelShellWidgetClass,drawing_a,resources,n);
	}

      formmaster = XtVaCreateManagedWidget
	(
	 "formWidget", xmPanedWindowWidgetClass, ob_head[current_ob_head],
	 XmNrubberPositioning, False,
	 XmNresizable,         True,
	 XmNseparatorOn,       False,
	 XmNsashHeight,        1,
	 NULL
	 );
      
      
      master_sw2 = XtVaCreateManagedWidget ("scrolled_win",
				     xmScrolledWindowWidgetClass, formmaster,
				     XmNvisualPolicy,           XmVARIABLE,
				     XmNwidth,                  500,
				     XmNscrollingPolicy,        XmAUTOMATIC,
				     XmNscrollBarDisplayPolicy, XmSTATIC,
				     XmNtopAttachment,          XmATTACH_FORM,
				     XmNbottomAttachment,       XmATTACH_FORM,
				     XmNleftAttachment,         XmATTACH_FORM,
				     XmNrightAttachment,        XmATTACH_FORM,
				     XmNtranslations, XtParseTranslationTable (list_translations23),
				     NULL);
      
      
      XtVaGetValues(master_sw2,XmNverticalScrollBar,&sb2,NULL);
      XtVaGetValues(master_sw2,XmNverticalScrollBar,&vert_scroll[BO_SCROLL],NULL);
      
      
      if(numobs>0)
	{
	  FillPage(page_num);
	}
      else
	{
	  FillPage(-1);
	}

      
      XtManageChild(master_sw2);
      





    


      form = XtVaCreateWidget ("form2", xmFormWidgetClass, formmaster,
			       XmNpaneMinimum,   23,
			       XmNpaneMaximum,   23,
			       XmNfractionBase,  100,  
			       NULL);
      
      toggleb = XtVaCreateManagedWidget ("Give Detailed Info",
					 xmToggleButtonWidgetClass, form,
					 XmNtraversalOn,      False,
					 XmNleftAttachment,   XmATTACH_FORM,
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    100,
					 XmNlabelString, 
					 STRING("Give detailed information about individual conditions"),
					 XmNtraversalOn,      False,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
      
      XtAddCallback (toggleb, XmNvalueChangedCallback, toggled7, NULL);
      XtManageChild(toggleb);
      
      XmToggleButtonSetState(toggleb,(Boolean)DetailedInfo,(Boolean)0);
      XtManageChild(form);
      


      
      form = XtVaCreateWidget ("form2", xmFormWidgetClass, formmaster,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
      zoom_b = XtVaCreateManagedWidget ("Center Zoom on Individual Conditions",
					 xmToggleButtonWidgetClass, form,
					 XmNtraversalOn,      False,
					 XmNleftAttachment,   XmATTACH_FORM,
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    50,
					 XmNlabelString,      STRING("Zoom to individual conditions"),
					 XmNtraversalOn,      False,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
      
      XtAddCallback (zoom_b, XmNvalueChangedCallback, toggled6, NULL);
      XtManageChild(zoom_b);
      
      XmToggleButtonSetState(zoom_b,(Boolean)CenterZoomOnErrors,(Boolean)0);


      setB  = XtVaCreateManagedWidget("Set Zoom Pad Distance",xmPushButtonWidgetClass,form,
				      XmNleftAttachment,  XmATTACH_POSITION,
				      XmNleftPosition,    50,
				      XmNrightAttachment, XmATTACH_POSITION,
				      XmNrightPosition,   100,
				      XmNlabelString,     STRING("Set Zoom Pad Distance..."),
				      XmNtraversalOn,     False,
				      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 
      
      XtAddCallback (setB, XmNactivateCallback,
		     set_pad_distance, (XtPointer)NULL);

      XtManageChild(setB);
      XtManageChild(form);















      
      form = XtVaCreateWidget ("form.sw.errors", xmFormWidgetClass, formmaster,
			       XmNpaneMinimum,   30,
			       XmNpaneMaximum,   30,
			       XmNfractionBase,  100,  
			       NULL);
      
      tempwid = XtVaCreateManagedWidget("Current page: ",
					xmLabelWidgetClass,form,
					XmNleftAttachment,    XmATTACH_FORM,
					XmNtopAttachment,     XmATTACH_FORM,
					XmNbottomAttachment,  XmATTACH_FORM,
					LABELWTRANSLATE,
					NULL);  	

      lbutton = XtVaCreateManagedWidget ("arrow1",
					 xmArrowButtonWidgetClass, form,
					 XmNarrowDirection,    XmARROW_LEFT,
					 XmNleftAttachment,    XmATTACH_WIDGET,
					 XmNleftWidget,        tempwid,
					 XmNtopAttachment,     XmATTACH_FORM,
					 XmNbottomAttachment,  XmATTACH_FORM,
					 XmNtraversalOn,       False,
					 NULL);
      
      XtAddCallback (lbutton, XmNactivateCallback, shift_page,(XtPointer)1);
      
            
      sprintf(temp,"%d",maxpages);
      numdec = strlen(temp) + 1;


      sprintf(temp,"%d",view_object_page);

      page_wid = XtVaCreateManagedWidget ("text_w",
					  xmTextFieldWidgetClass, form,
					  XmNvalue,            temp,
					  XmNtraversalOn,      True,
					  XmNleftAttachment,   XmATTACH_WIDGET,
					  XmNleftWidget,       lbutton,
					  XmNtopAttachment,    XmATTACH_FORM,
					  XmNbottomAttachment, XmATTACH_FORM,
					  XmNwidth,            numdec*15,
					  XmNmaxLength,        numdec,
                      XmNtranslations,     XtParseTranslationTable ( translations_paste ) ,
					  NULL);
      
      XtAddCallback (page_wid, XmNvalueChangedCallback, page_result, (XtPointer)6);
      XtAddCallback (page_wid, XmNactivateCallback,     page_result, (XtPointer)5);
      
            
      rbutton = XtVaCreateManagedWidget ("arrow1",
					 xmArrowButtonWidgetClass, form,
					 XmNarrowDirection,    XmARROW_RIGHT,
					 XmNleftAttachment,    XmATTACH_WIDGET,
					 XmNleftWidget,        page_wid,
					 XmNtopAttachment,     XmATTACH_FORM,
					 XmNbottomAttachment,  XmATTACH_FORM,
					 XmNtraversalOn,       False,
					 NULL);
      
      XtAddCallback (rbutton, XmNactivateCallback, shift_page,(XtPointer)2);


      sprintf(temp," of %d",maxpages);

      tempwid = XtVaCreateManagedWidget(temp,
					xmLabelWidgetClass,form,
					XmNleftAttachment,    XmATTACH_WIDGET,
					XmNleftWidget,        rbutton,
					XmNtopAttachment,     XmATTACH_FORM,
					XmNbottomAttachment,  XmATTACH_FORM,
					LABELWTRANSLATE,
					NULL);  
      
      XtManageChild(form);
 



      form = XtVaCreateWidget ("form.sw.errors", xmFormWidgetClass, formmaster,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      
	  if(NGA_TYPE==1)
	  {
        button = XtVaCreateManagedWidget ("Help4",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     0,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    40,
					XmNlabelString,      STRING("Filter By Feature type..."),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
	  }
	  else
      {
        button = XtVaCreateManagedWidget ("Help4",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     0,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    40,
					XmNlabelString,      STRING("Filter By Classification..."),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
	  }

      XtAddCallback(button, XmNactivateCallback, FCODEFilterCallback, (XtPointer)NULL);
      XtManageChild(button);
      
      
      button1 = XtVaCreateManagedWidget ("Help4",
					 xmPushButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     40,
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    80,
					 XmNlabelString,      STRING("Filter By Inspection..."),
					 XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					 NULL);
      XtAddCallback(button1, XmNactivateCallback, CheckFilterCallback, (XtPointer)NULL);
      XtManageChild(button1);
      

      button3 = XtVaCreateManagedWidget ("Help4",
					 xmPushButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     80,
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    100,
					 XmNlabelString,      STRING("Apply Filters"),
					 XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					 NULL);

      XtAddCallback(button3, XmNactivateCallback, boapplyfilterCallback, (XtPointer)NULL);
      XtManageChild(button3);
      
      XtManageChild(form);
      
      
      
      

      form = XtVaCreateWidget ("form.sw.errors", xmFormWidgetClass, formmaster,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);
      

      button4 = XtVaCreateManagedWidget ("Help4",
					 xmPushButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     0,
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    25,
					 XmNlabelString,      STRING("Revert"),
					 XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					 NULL);

      XtAddCallback(button4, XmNactivateCallback, borevertCallback, (XtPointer)NULL);
      XtManageChild(button4);



      button4 = XtVaCreateManagedWidget ("Help4",
					 xmPushButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     25,
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    50,
					 XmNlabelString,      STRING("De-Select All"),
					 XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					 NULL);

      XtAddCallback(button4, XmNactivateCallback, bodeselectCallback, (XtPointer)NULL);
      XtManageChild(button4);
   

      button4 = XtVaCreateManagedWidget ("Help4",
					 xmPushButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     50,
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    75,
					 XmNlabelString,      STRING("Help"),
					 XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					 NULL);

      XtAddCallback(button4, XmNactivateCallback, bohelpCallback, (XtPointer)NULL);
      XtManageChild(button4);

         
      
      button2 = XtVaCreateManagedWidget ("Help4",
					 xmPushButtonWidgetClass, form,
					 XmNtopAttachment,    XmATTACH_FORM,
					 XmNtraversalOn,      False,
					 XmNbottomAttachment, XmATTACH_FORM,
					 XmNleftAttachment,   XmATTACH_POSITION,
					 XmNleftPosition,     75,
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    100,
					 XmNlabelString,      STRING("Done"),
					 XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					 NULL);

      XtAddCallback(button2, XmNactivateCallback, exitCallback, (XtPointer)42);
      XtManageChild(button2);
      
      XtManageChild(form);
      


      
      if(page_num==1)
	{
	  XtSetSensitive(lbutton,False);
	}
      else
	{
	  XtSetSensitive(lbutton,True);
	}


      if(page_num==maxpages)
	{
	  XtSetSensitive(rbutton,False);
	}
      else
	{
	  XtSetSensitive(rbutton,True);
	}

      
      
      
      dead_obhead[current_ob_head] = 0;
      
      XtRealizeWidget(ob_head[current_ob_head]);
      MyPopup(ob_head[current_ob_head]); 
      

      
      XtAddCallback(ob_head[current_ob_head],XmNdestroyCallback,ShellDeath,(XtPointer)(4052+current_ob_head));
      
      XtVaSetValues(sb2,XmNincrement,30,NULL);

    }
  else
    {
      ResetWidget(ob_head[current_ob_head]);
    }
}



void ModifyPrevList(int num)
{


}


void ChoosePrevCallback(Widget w,XtPointer data,XtPointer callData)
{ 
  static Widget dialog;
  int num,i;
  char message[1000];
  

  
  if(prev_up==1)
    {
      
      ResetWidget(dialog);
      return;
    }
  
  
  if(NGA_TYPE==1)
    {
      
      num = GetFolders(PROJECTLOC,4,1);


      
      if(num==0)
	{
	  sprintf(message,"\
No valid, current GAIT projects with exported shapefile conditions\n\
were found in the current GAIT project folder:\n\n  %s\n\n\
The \"Specify GAIT Project Folder...\" option under the \"File\"\n\
menu can be used to specify a folder containing GAIT projects,\n\n\
      or\n\n\
The \"Create GAIT Project...\" option under the \"File\" menu can\n\
be used to create GAIT projects in the currently selected GAIT\n\
project folder.\n",PROJECTLOC);
	  
	  not_while_running(w,message,1414,"No Projects Found",1);   
	  return;

	}
      else
	{
	  

	  SortPrevList(0,num-1,1);
	  
	  

	}



      ModifyPrevList(num);


           

      prev_dialog = MakePicker(NULL,4,num,-1,-1); 
      dialog      = prev_dialog;

      prev_up = 1;
       
      for(i=0;i<num;i++)
	{
	  free(GAITPrevList[i]);
	}
      free(GAITPrevList);
      GAITPrevList = NULL;

    }

}


void set_ignore(Widget widget,XtPointer client_data,XtPointer call_data)
{  
  ConsultPreviouslyIgnored = !ConsultPreviouslyIgnored;
}


void modifyCallback(Widget w, XtPointer userData, XtPointer callData)
{
  Widget form,rowcol,button,sw2,sb2,handle,left,right,button1,
    outline,subhandle,suboutline,formmaster,checkhandle,checkoutline;
  int i,j,checknum,n=0,fixheight=0,totalactive,totalchecks,useit;
  Arg resources[20];
  Dimension Pwidth, Pheight;
  char *message;
  char thislabel[1000],temp[1000];
  extern struct CheckGroupNames CGN[NUMCHECKGROUPS];
  MyData *mydata3,*mydata4;
  extern int NO_EXE_REBUILD;


  if(NO_EXE_REBUILD==1)
  {
    
	printf("NOT rebuilding window\n");
    return;
  }


  if(running==1)
    {
      not_while_running(w,"You may not modify parameters while running.",1085,"Illegal Manuever",1);
      return;
    }

  if(input_source==0)
    {
      message ="You must open a GAIT project before\n\
you can modify inspection options.";

      not_while_running(w,message,1086,"No input source",1);
      return;
    }
    
  if(output_source==0)
    {
      message ="You must select an output data directory before\n\
you can modify inspection options.";
      
      not_while_running(w,message,1087,"No output directory",1);
      return;
    }



  set_cursor(mydisplay,mywindow,WATCH);

  
  if(((head_in_use==0)&&(deader_head==1))||
     ((head_in_use==1)&&(deader_phead==1)))
    {
      n=0;

      XtSetArg(resources[n],  XmNdeleteResponse,    XmDESTROY);                               n++;
      XtSetArg(resources[n],  XmNrubberPositioning, True);                                    n++;
      XtSetArg(resources[n],  XmNheight,            600);                                     n++;
      XtSetArg(resources[n],  XmNtranslations, XtParseTranslationTable (list_translations7)); n++;



      if(head_in_use==0)
	{
	  param_head = XtCreatePopupShell
	    ("Inspection Options",topLevelShellWidgetClass,w,resources,n);
	
	  formmaster = XtVaCreateManagedWidget
	    (
	     "formWidget", xmPanedWindowWidgetClass, param_head,
	     XmNrubberPositioning, False,
	     XmNresizable,         True,
	     XmNseparatorOn,       False,
	     XmNsashHeight,        1,
	     XmNtranslations,      XtParseTranslationTable (list_translations7),
	     NULL
	     );
	}
      else if(head_in_use==1)
	{
	  param2_head = XtCreatePopupShell
	    ("Inspection Options",topLevelShellWidgetClass,w,resources,n);
	  
	  formmaster = XtVaCreateManagedWidget
	    (
	     "formWidget", xmPanedWindowWidgetClass, param2_head,
	     XmNrubberPositioning, False,
	     XmNresizable,         True,
	     XmNseparatorOn,       False,
	     XmNsashHeight,        1,
	     XmNtranslations,      XtParseTranslationTable (list_translations7),
	     NULL
	     );
	}





      sw2 = XtVaCreateManagedWidget ("scrolled_win",
				     xmScrolledWindowWidgetClass, formmaster,
				     XmNvisualPolicy,           XmVARIABLE,
				     XmNwidth,                  450,
				     XmNscrollingPolicy,        XmAUTOMATIC,
				     XmNscrollBarDisplayPolicy, XmSTATIC,
				     XmNtopAttachment,          XmATTACH_FORM,
				     XmNbottomAttachment,       XmATTACH_FORM,
				     XmNleftAttachment,         XmATTACH_FORM,
				     XmNrightAttachment,        XmATTACH_FORM,
				     XmNtranslations, XtParseTranslationTable (list_translations7),
				     NULL);


     XtVaGetValues(sw2,XmNverticalScrollBar,&sb2,NULL);
     XtVaGetValues(sw2,XmNverticalScrollBar,&vert_scroll[EXE_SCROLL],NULL);
      









     

     rowcol = XtVaCreateWidget ("rowcol",
				xmRowColumnWidgetClass, formmaster, 
				XmNpaneMinimum,  135,
				XmNpaneMaximum,  135,
				XmNseparatorOn,  False,
				XmNtranslations, XtParseTranslationTable (list_translations7),
				NULL);

     

     handle = XtVaCreateManagedWidget("roothandle", xmHandleWidgetClass,
				      sw2,
				      XmNtranslations, XtParseTranslationTable (list_translations7),
				      NULL);
     
     left = XtVaCreateManagedWidget("left", xmPushButtonWidgetClass,
				    handle,
				    XmNlabelType,       XmPIXMAP,
				    XmNlabelPixmap,     minus_pix,
				    XmNshadowThickness, 0,
				    XmNtranslations,    XtParseTranslationTable (list_translations7),
				    NULL);



     right = XtVaCreateManagedWidget("All", xmLabelWidgetClass,
				     handle,
				     XmNtranslations,     XtParseTranslationTable (list_translations7),
				     NULL);
     
     right = XtVaCreateManagedWidget("Inspection", xmLabelWidgetClass,
				     handle,
				     XmNtranslations,     XtParseTranslationTable (list_translations7),
				     NULL);
     
     right = XtVaCreateManagedWidget("Categories", xmLabelWidgetClass,
				     handle,
				     XmNtranslations,     XtParseTranslationTable (list_translations7),
				     NULL);


     GetGlobalTotals(&totalactive,&totalchecks);
     
     sprintf(temp," (%d/%d active)",totalactive,totalchecks);

     GlobalTotals = XtVaCreateManagedWidget(temp, xmLabelWidgetClass,
					    handle,
					    XmNtranslations,     XtParseTranslationTable (list_translations7),
					    NULL);
     



     outline = XtVaCreateManagedWidget("outline", xmOutlineWidgetClass,
				       handle,
				       XmNindentation, 20,
				       XmNoutline, TRUE,
				       XmNtranslations,     XtParseTranslationTable (list_translations7),
				       NULL);

     
     mydata3  = (MyData *) (malloc(sizeof(MyData)));
     if(mydata3==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
     mydata3->outlinewid = (XmOutlineWidget)outline;
     mydata3->level = 1;

     XtAddCallback(left, 
		   XmNactivateCallback, (XtCallbackProc)ToggleButtonHandleCB, 
		   (XtPointer) mydata3);
               
     XtVaSetValues(handle, 
		   XmNsubWidget, outline,
		   NULL);


     if(OnOff1==0)
       {
	 
	 XtUnmanageChild(outline);
	 XtVaSetValues(left, XmNlabelPixmap, plus_pix, NULL);
       }




    

      for(i=0;i<NUMCHECKGROUPS;i++)
	{
	  totalactive = 0;
	  totalchecks = 0;


	  if((NGA_TYPE==0)&&(i==MATCH_GROUP))
	    {
	      continue;
	    }

	  if(i==DEM_GROUP)
	  {
        continue;
	  }


	  
	  GetTotals(i,&totalactive,&totalchecks);

	  subhandle = XtVaCreateManagedWidget("subhandle",
					      xmHandleWidgetClass,
					      outline,
					      XmNtranslations,     XtParseTranslationTable (list_translations7),
					      NULL);
	  left = XtVaCreateManagedWidget("left", xmPushButtonWidgetClass,
					 subhandle,
					 XmNlabelType, XmPIXMAP,
					 XmNlabelPixmap, minus_pix,
					 XmNarrowDirection, XmARROW_DOWN,
					 XmNshadowThickness, 0,
					 XmNtranslations,     XtParseTranslationTable (list_translations7),
					 NULL);
	  
	  sprintf(thislabel,"%s (%d/%d active)",
		  CGN[i].name,
		  totalactive,
		  totalchecks);

	  CGN[i].topwid = XtVaCreateManagedWidget(thislabel, xmLabelWidgetClass,
						  subhandle,
						  XmNtranslations,XtParseTranslationTable (list_translations7),
						  NULL);
	  
	  suboutline = XtVaCreateManagedWidget("suboutline",
					       xmOutlineWidgetClass,
					       subhandle, 
					       XmNindentation, 20, 
					       XmNoutline, TRUE,
					       XmNtranslations,     XtParseTranslationTable (list_translations7),
					       NULL);

	  

	  mydata4  = (MyData *) (malloc(sizeof(MyData)));
	  if(mydata4==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
	  mydata4->outlinewid = (XmOutlineWidget)suboutline;
	  mydata4->level     = 2;
	  mydata4->group_num = i;


	  XtAddCallback(left, 
			XmNactivateCallback, (XtCallbackProc)ToggleButtonHandleCB, 
			(XtPointer) mydata4);


	  if(OnOff2[i]==0)
	    {
	      
	      XtUnmanageChild(suboutline);
	      XtVaSetValues(left, XmNlabelPixmap, plus_pix, NULL);
	    }




	  XtVaSetValues(subhandle, 
			XmNsubWidget, suboutline, 
			NULL);
	  

	



	  


	  for(checknum=1;checknum<=CONDITION_DEFINITIONS;checknum++)
	    {


	      


	      useit = 0;
	      
	      if(ErrorLookup[checknum].checkapplies==GAITandSEEITcheck)
		{
		  useit = 1;
		}
	      else if ( (NGA_TYPE==1)  && (ErrorLookup[checknum].checkapplies==GAITcheck) )
		{
		  useit = 1;
		}
	      else if ( (NGA_TYPE==0)  && (ErrorLookup[checknum].checkapplies==SEEITcheck) )
		{
		  useit = 1;
		}

	      if(useit==0)
		{
		  continue;
		}




	      if(ErrorLookup[checknum].mygroup==i)
		  {
		  
		    checkhandle = XtVaCreateManagedWidget("subhandle",
							xmHandleWidgetClass,
							suboutline,
							XmNtranslations,XtParseTranslationTable (list_translations7),
							NULL);
		  
		    left = XtVaCreateManagedWidget("left", xmPushButtonWidgetClass,
						 checkhandle,
						 XmNlabelType,       XmPIXMAP,
						 XmNlabelPixmap,     minus_pix,
						 XmNarrowDirection,  XmARROW_DOWN,
						 XmNshadowThickness, 0,
						 XmNtranslations,    XtParseTranslationTable (list_translations7),
						 NULL);
		  

		    sprintf(thislabel,"%s (%d/%d active)",
			  ParseErrType(checknum),
			  GetActiveNum(checknum),
			  ErrorLookup [checknum].num_clones + 1);
		  

		    ErrorLookup[checknum].topwid = 
		      XtVaCreateManagedWidget(thislabel, xmLabelWidgetClass,
					    checkhandle,
					    XmNtranslations, XtParseTranslationTable (list_translations7),
					    NULL);
		  
		    checkoutline = XtVaCreateManagedWidget("suboutline",
							 xmOutlineWidgetClass,
							 checkhandle, 
							 XmNindentation,  20, 
							 XmNoutline,      TRUE,
							 XmNtranslations, XtParseTranslationTable (list_translations7),
							 NULL);

	      	XtVaSetValues(checkhandle, 
				XmNsubWidget, checkoutline, 
				NULL);


		    mydata3  = (MyData *) (malloc(sizeof(MyData)));
		    if(mydata3==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		    mydata3->outlinewid = (XmOutlineWidget)checkoutline;
		    mydata3->level = 4;
		    mydata3->check_num = checknum;

		    XtAddCallback(left, 
				XmNactivateCallback, (XtCallbackProc)ToggleButtonHandleCB, 
				(XtPointer) mydata3);
   

		    if(ErrorLookup[checknum].masteronoff<=0)
		    {
		      
		      XtUnmanageChild(checkoutline);
		      XtVaSetValues(left, XmNlabelPixmap, plus_pix, NULL);
		    }


		    if(ErrorLookup[checknum].masteronoff==1)
			{ 
			 
		     BuildEntries(checkoutline,checknum,0,0);
		  
		     for(j=0;j<ErrorLookup[checknum].num_clones;j++)
			 {
		       BuildEntries(checkoutline,checknum,j+1,0);
			 }
			}
		  } 
		} 
	} 

    XtManageChild(sw2);





      
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       XmNtranslations,     XtParseTranslationTable (translations_global),
			       NULL);
      
	  
	  toggle_all_cells = XtVaCreateManagedWidget ("All Regions",
						   xmToggleButtonWidgetClass, form,
						   XmNtopAttachment,    XmATTACH_FORM,
						   XmNbottomAttachment, XmATTACH_FORM,
						   XmNtraversalOn,      False,
						   XmNbottomAttachment, XmATTACH_FORM,
						   XmNleftAttachment,   XmATTACH_FORM,
						   XmNlabelString,      STRING("All Regions"),
						   XmNtranslations,     XtParseTranslationTable (translations_global),
						   TOGGLEINCLUDE,
						   NULL);

	  XtAddCallback (toggle_all_cells, XmNvalueChangedCallback, toggled,(XtPointer)1);
	  XmToggleButtonSetState(toggle_all_cells,(Boolean)DOALLCELLS,(Boolean)0);

	


      XtManageChild(toggle_all_cells);
      XtManageChild(form);
      


      if(NGA_TYPE==1)
	{
	  form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
				   XmNtranslations,     XtParseTranslationTable (translations_global),
				   NULL);
	  
	  
	  button = XtVaCreateManagedWidget ("test",
					    xmToggleButtonWidgetClass, form,
					    XmNtraversalOn,      False,
					    XmNleftAttachment,   XmATTACH_FORM,
					    XmNtopAttachment,    XmATTACH_FORM,
					    XmNbottomAttachment, XmATTACH_FORM,
					    XmNlabelString,
					    STRING("Mark results using exported shapefiles in project:"),
					    XmNtranslations,     XtParseTranslationTable (translations_global),
					    TOGGLEINCLUDE,
					    NULL);
	  
	  XtAddCallback (button, XmNvalueChangedCallback, set_ignore, (XtPointer)NULL);
	  XmToggleButtonSetState(button,(Boolean)ConsultPreviouslyIgnored,(Boolean)0);
	  
	  XtManageChild(button);
	  
	  
	  

	  previousresults = XtVaCreateManagedWidget ("Red",
						     xmTextFieldWidgetClass, form,
						     XmNvalue,            project_to_open,
						     XmNcolumns,          10,
						     XmNleftAttachment,   XmATTACH_WIDGET,
						     XmNleftWidget,       button,
						     XmNtopAttachment,    XmATTACH_FORM,
						     XmNbottomAttachment, XmATTACH_FORM,
						     XmNtranslations,     XtParseTranslationTable ( translations_paste ),
						     NULL);
	  
	  XtAddCallback (previousresults, XmNactivateCallback,
			 EnterFileCallback, (XtPointer)20);
	  
	  XtManageChild(previousresults);
	  
	  



	  button1 = XtVaCreateManagedWidget ("Help4",
					     xmPushButtonWidgetClass, form,
					     XmNtraversalOn,      False,
					     XmNtopAttachment,    XmATTACH_FORM,
					     XmNbottomAttachment, XmATTACH_FORM,
					     XmNleftAttachment,   XmATTACH_WIDGET,
					     XmNleftWidget,       previousresults,
					     XmNlabelString,      STRING("Choose..."),
					     XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					     NULL);
	  XtAddCallback (button1, XmNactivateCallback,
			 ChoosePrevCallback, (XtPointer)NULL);
	  
	  XtManageChild(button1);
	  XtManageChild(form);
	}



    form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      

    button = XtVaCreateManagedWidget ("Help4",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    33,
					XmNlabelString,      STRING("Save settings..."),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback (button, XmNactivateCallback,
		     SaveSettingsCallback, (XtPointer)0);
      XtManageChild(button);

      
      button = XtVaCreateManagedWidget ("Help4",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     33,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    66,
					XmNlabelString,      STRING("Load settings..."),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback (button, XmNactivateCallback,
		     LoadSettingsCallback,(XtPointer)0);
      XtManageChild(button);

      button = XtVaCreateManagedWidget("Selectall", xmPushButtonWidgetClass, form,
					     XmNtraversalOn,      False,
					     XmNtopAttachment,    XmATTACH_FORM,
					     XmNbottomAttachment, XmATTACH_FORM,
					     XmNleftAttachment,   XmATTACH_POSITION,
					     XmNleftPosition,     66,
					     XmNrightAttachment,  XmATTACH_POSITION,
					     XmNrightPosition,    99,
					     XmNlabelString,      STRING("Revert to Defaults"),
				         XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					     NULL);
      XtAddCallback(button, XmNactivateCallback,
		    revertCallback, (XtPointer)2);
      XtManageChild(button);

      XtManageChild(form);








      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);


      button = XtVaCreateManagedWidget("DSelectall", xmPushButtonWidgetClass, form,
					     XmNtraversalOn,      False,
					     XmNtopAttachment,    XmATTACH_FORM,
					     XmNbottomAttachment, XmATTACH_FORM,
					     XmNleftAttachment,   XmATTACH_POSITION,
					     XmNleftPosition,     1,
					     XmNrightAttachment,  XmATTACH_POSITION,
					     XmNrightPosition,    33,
					     XmNlabelString,      STRING("De-Select ALL"),
				             XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					     NULL);
      XtAddCallback(button, XmNactivateCallback,
		    revertCallback, (XtPointer)3);
      XtManageChild(button);


      button = XtVaCreateManagedWidget ("Help4",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     33,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    66,
					XmNlabelString,      STRING("Help"),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback (button, XmNactivateCallback,
		     InfoCallback, (XtPointer)NULL);
      XtManageChild(button);


	  button = XtVaCreateManagedWidget ("Help4",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     66,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    99,
					XmNlabelString,      STRING("Done"),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, exitCallback, (XtPointer)2);
      XtManageChild(button);


      XtManageChild(form);
      XtManageChild (rowcol);

      
      if(head_in_use==0)
	{
	  deader_head=0;

	  XtRealizeWidget(param_head);
	  MyPopup(param_head); 

	  XtAddCallback(param_head,XmNdestroyCallback,ShellDeath,(XtPointer)200);


	  XtVaGetValues(param_head, XmNwidth,     &Pwidth, XmNheight, &Pheight, NULL);	  
	  XtVaSetValues(param_head, XmNminWidth,  Pwidth+50,  NULL);
	  XtVaSetValues(param_head, XmNmaxWidth,  1000,  NULL);
	  if(fixheight==1)
	    {
	      XtVaSetValues(param_head, XmNminHeight, Pheight, NULL);
	      XtVaSetValues(param_head, XmNmaxHeight, Pheight, NULL);
	      XtAddEventHandler(param_head,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)Pheight));
	    }
	}
      else if(head_in_use==1)
	{
	  deader_phead=0;
	  XtRealizeWidget(param2_head);
	  MyPopup(param2_head); 

	  XtAddCallback(param2_head,XmNdestroyCallback,ShellDeath,(XtPointer)201);

	  
	  XtVaGetValues(param2_head, XmNwidth,     &Pwidth, XmNheight, &Pheight, NULL);	  
	  XtVaSetValues(param2_head, XmNminWidth,  Pwidth+50,  NULL);
	  XtVaSetValues(param2_head, XmNmaxWidth,  1000,  NULL);
	  if(fixheight==1)
	    {
	      XtVaSetValues(param2_head, XmNminHeight, Pheight,  NULL);
	      XtVaSetValues(param2_head, XmNmaxHeight, Pheight,  NULL);
	      XtAddEventHandler(param2_head,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)Pheight));
	    }
	}
      XtVaSetValues(sb2,XmNincrement,30,NULL);

    }
  else
    {
      if(head_in_use==1)
	{
	  ResetWidget(param2_head);
	}
      else if(head_in_use==0)
	{
	  ResetWidget(param_head);
	}      
    }
  set_cursor(mydisplay,mywindow,GOOD);

}




void NetInfoCallback(Widget w, XtPointer userData, XtPointer callData)
{
  not_while_running(w,"\
This window is used to specify and create networks for viewing.\n\n\
Each network specification has Applicability (features involved) and\n\
Tolerance(s).  To create multiple specifications, create new instantiations\n\
using the \"Create new Instantiation\" button and fill in the appropriate\n\
specifications for the new instantiation(s).\n\n\
Specifications may be loaded and saved using the \"Save settings...\" and\n\
\"Load settings...\" buttons.\n\n\
Computed networks are saved and loaded as condition reports using the\n\
\"Load Condition Report...\" and \"Save Condition Report...\" buttons (\"File\" menu).\n\n\
The \"Revert to Defaults\" button reverts the specifications to a default state\n\n\
The \"Generate networks for viewing\" button uses the existing settings to generate\n\
the specified network(s) for viewing.  The \"Networks...\" item under the \"View\"\n\
menu may be used to raise the network viewer after they are computed.",
1607,"Network viewing information",5);
}



void buildNetworksCallback(Widget w, XtPointer userData, XtPointer callData)
{
  

  int OldChecks[CONDITION_DEFINITIONS+10];
  int *OldClones;
  int i;
  extern int NETS_ONLY;

  if(ADDNETS==1)
  {
    printf("Build networks with inspections\n");

	NETS_ONLY = 2;  
    ExecuteCallback(drawing_a,(XtPointer)0,(XtPointer)0);
    NETS_ONLY = 0;
  }
  else
  {
	for(i=0;i<=CONDITION_DEFINITIONS;i++)
	{
      OldChecks[i] = 0;

	  if(ErrorLookup[i].active==1)
	  {
        if(IsNetCheck(i)==0)
		{
          ErrorLookup[i].active = 0;
		  OldChecks[i] = 1;
		}
	  }
	}

	OldClones = (int *)malloc(SzI*(CLONE_DEFINITIONS+5));

	for(i=0;i<CLONE_DEFINITIONS;i++)
	{
      OldClones[i] = 0;

	  if(CloneErrorLookup[i].active==1)
	  {
        if(IsNetCheck(CloneErrorLookup[i].CloneNumber)==0)
		{
          CloneErrorLookup[i].active = 0;
		  OldClones[i] = 1;
		}
	  }
	}


	

	

	NETS_ONLY = 1;  
    ExecuteCallback(drawing_a,(XtPointer)0,(XtPointer)0);
    NETS_ONLY = 0;


	



	for(i=0;i<=CONDITION_DEFINITIONS;i++)
	{
	  if(OldChecks[i]==1)
	  {
	    ErrorLookup[i].active = 1;
	  }
	}

	for(i=0;i<CLONE_DEFINITIONS;i++)
	{
	  if(OldClones[i]==1)
	  {
	    CloneErrorLookup[i].active = 1;
	  }
	}

	free(OldClones);
  }


}



void toggle_int(Widget w, XtPointer userData, XtPointer callData)
{
  INTERSECTION_BASED = !INTERSECTION_BASED;
}

void toggle_add_nets(Widget w, XtPointer userData, XtPointer callData)
{
  ADDNETS = !ADDNETS;
}


void net_edge_cb(Widget menu_item,XtPointer client_data,XtPointer call_data)
{
  extern int NetFeatureMin;

  int item_no = (int) client_data;

  NetFeatureMin = item_no;
}





Widget BuildNetEdgeMenu(Widget parent,int menu_type,char *menu_title,MenuItem *items)
{
  Widget menu, cascade, widget;
  int i,n=0;
  XmString str;
  Arg args[5];
  extern int NetFeatureMin;
  
  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);
  
  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId, menu);  n++;
  XtSetArg (args[n], XmNlabelString, str); n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;

  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);
  
  for (i = 0; items[i].label != NULL; i++) 
    {
      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);
      
	  if(
		  ((i==0)&&(NetFeatureMin==0))   ||
		  ((i==1)&&(NetFeatureMin==1))   ||
		  ((i==2)&&(NetFeatureMin==2))   ||
		  ((i==3)&&(NetFeatureMin==3))   ||
		  ((i==4)&&(NetFeatureMin==4))   ||
		  ((i==5)&&(NetFeatureMin==5))   ||
		  ((i==6)&&(NetFeatureMin==10))  ||
		  ((i==7)&&(NetFeatureMin==100))
		)
	{
	  XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);
	}

      if (items[i].callback)
	XtAddCallback (widget,
		       (items[i].cclass == &xmToggleButtonWidgetClass ||
			items[i].cclass == &xmToggleButtonWidgetClass) ?
		       XmNvalueChangedCallback : 
		       XmNactivateCallback,      
		       (XtCallbackProc)items[i].callback, items[i].callback_data);
    }
  return menu_type == XmMENU_POPUP ? menu : cascade;
}






void NETmodifyCallback(Widget w, XtPointer userData, XtPointer callData)
{
  Widget form,rowcol,button,sw2,sb2,handle,left,right,outline,formmaster,
	  network_edge_menu;
  int j,checknum,n=0,fixheight=0,totalactive,totalchecks;
  Arg resources[20];
  Dimension Pwidth, Pheight;
  char temp[1000];
  MyData *mydata3;

  MenuItem network_edge_type[] = {
    {"Compute all",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())net_edge_cb, (XtPointer)0, (MenuItem *) NULL},
    {"Ignore when 1 feature",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())net_edge_cb, (XtPointer)1, (MenuItem *) NULL},
    {"Ignore when <= 2 features",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())net_edge_cb, (XtPointer)2, (MenuItem *) NULL},
    {"Ignore when <= 3 features",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())net_edge_cb, (XtPointer)3, (MenuItem *) NULL},
    {"Ignore when <= 4 features",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())net_edge_cb, (XtPointer)4, (MenuItem *) NULL},
    {"Ignore when <= 5 features",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())net_edge_cb, (XtPointer)5, (MenuItem *) NULL},
    {"Ignore when <= 10 features",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())net_edge_cb, (XtPointer)10, (MenuItem *) NULL},
    {"Ignore when <= 100 features",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())net_edge_cb, (XtPointer)100, (MenuItem *) NULL},
    {"Ignore all",
     &xmPushButtonWidgetClass,'!', NULL, NULL, (void (*)())net_edge_cb, (XtPointer)101, (MenuItem *) NULL},
    {NULL},
  };




  


  set_cursor(mydisplay,mywindow,WATCH);


  
  
  if(((net_head_in_use==0)&&(net_deader_head==1))||
     ((net_head_in_use==1)&&(net_deader_phead==1)))
    {
      n=0;

      XtSetArg(resources[n],  XmNdeleteResponse,    XmDESTROY);                               n++;
      XtSetArg(resources[n],  XmNrubberPositioning, True);                                    n++;
      XtSetArg(resources[n],  XmNheight,            450);                                     n++;
      XtSetArg(resources[n],  XmNtranslations, XtParseTranslationTable (list_translations64)); n++;



      if(net_head_in_use==0)
	{
	  param_net_head = XtCreatePopupShell
	    ("Network Options",topLevelShellWidgetClass,w,resources,n);
	
	  formmaster = XtVaCreateManagedWidget
	    (
	     "formWidget", xmPanedWindowWidgetClass, param_net_head,
	     XmNrubberPositioning, False,
	     XmNresizable,         True,
	     XmNseparatorOn,       False,
	     XmNsashHeight,        1,
	     XmNtranslations,      XtParseTranslationTable (list_translations64),
	     NULL
	     );
	}
      else if(net_head_in_use==1)
	{
	  param2_net_head = XtCreatePopupShell
	    ("Network Options",topLevelShellWidgetClass,w,resources,n);
	  
	  formmaster = XtVaCreateManagedWidget
	    (
	     "formWidget", xmPanedWindowWidgetClass, param2_net_head,
	     XmNrubberPositioning, False,
	     XmNresizable,         True,
	     XmNseparatorOn,       False,
	     XmNsashHeight,        1,
	     XmNtranslations,      XtParseTranslationTable (list_translations64),
	     NULL
	     );
	}





      sw2 = XtVaCreateManagedWidget ("scrolled_win",
				     xmScrolledWindowWidgetClass, formmaster,
				     XmNvisualPolicy,           XmVARIABLE,
				     XmNwidth,                  450,
				     XmNscrollingPolicy,        XmAUTOMATIC,
				     XmNscrollBarDisplayPolicy, XmSTATIC,
				     XmNtopAttachment,          XmATTACH_FORM,
				     XmNbottomAttachment,       XmATTACH_FORM,
				     XmNleftAttachment,         XmATTACH_FORM,
				     XmNrightAttachment,        XmATTACH_FORM,
				     XmNtranslations, XtParseTranslationTable (list_translations64),
				     NULL);



     XtVaGetValues(sw2,XmNverticalScrollBar,&sb2,NULL);
     XtVaGetValues(sw2,XmNverticalScrollBar,&vert_scroll[NET_SCROLL],NULL);
      









     

     rowcol = XtVaCreateWidget ("rowcol",
				xmRowColumnWidgetClass, formmaster, 
				XmNpaneMinimum,  200,
				XmNpaneMaximum,  200,
				XmNseparatorOn,  False,
				XmNtranslations, XtParseTranslationTable (list_translations64),
				NULL);

     

     handle = XtVaCreateManagedWidget("roothandle", xmHandleWidgetClass,
				      sw2,
				      XmNtranslations, XtParseTranslationTable (list_translations64),
				      NULL);
     
     left = XtVaCreateManagedWidget("left", xmPushButtonWidgetClass,
				    handle,
				    XmNlabelType,       XmPIXMAP,
				    XmNlabelPixmap,     minus_pix,
				    XmNshadowThickness, 0,
				    XmNtranslations,    XtParseTranslationTable (list_translations64),
				    NULL);



     right = XtVaCreateManagedWidget("All", xmLabelWidgetClass,
				     handle,
				     XmNtranslations,     XtParseTranslationTable (list_translations64),
				     NULL);
     
     right = XtVaCreateManagedWidget("Network", xmLabelWidgetClass,
				     handle,
				     XmNtranslations,     XtParseTranslationTable (list_translations64),
				     NULL);
     
     right = XtVaCreateManagedWidget("Specifications", xmLabelWidgetClass,
				     handle,
				     XmNtranslations,     XtParseTranslationTable (list_translations64),
				     NULL);


     GetNetGlobalTotals(&totalactive,&totalchecks);
     
     sprintf(temp," (%d/%d active)",totalactive,totalchecks);

     NetGlobalTotals = XtVaCreateManagedWidget(temp, xmLabelWidgetClass,
					    handle,
					    XmNtranslations,     XtParseTranslationTable (list_translations64),
					    NULL);
     



     outline = XtVaCreateManagedWidget("outline", xmOutlineWidgetClass,
				       handle,
				       XmNindentation, 20,
				       XmNoutline, TRUE,
				       XmNtranslations,     XtParseTranslationTable (list_translations64),
				       NULL);

     
     mydata3  = (MyData *) (malloc(sizeof(MyData)));
     if(mydata3==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
     mydata3->outlinewid = (XmOutlineWidget)outline;
     mydata3->level = 1;

     XtAddCallback(left, 
		   XmNactivateCallback, (XtCallbackProc)NetConfigToggleButtonHandleCB, 
		   (XtPointer) mydata3);
               
     XtVaSetValues(handle, 
		   XmNsubWidget, outline,
		   NULL);

     if(NetConfigOnOff1==0)
       {
	 
	 XtUnmanageChild(outline);
	 XtVaSetValues(left, XmNlabelPixmap, plus_pix, NULL);
       }



     for(checknum=1;checknum<=CONDITION_DEFINITIONS;checknum++)
	 {
        if(checknum==NETWORKCHECK)
		{
		   BuildEntries(outline,checknum,0,1);

		   for(j=0;j<ErrorLookup[checknum].num_clones;j++)
		   {
		     BuildEntries(outline,checknum,j+1,1);
		   }
		}  
	} 



    XtManageChild(sw2);






    form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       XmNtranslations,     XtParseTranslationTable (translations_global),
			       NULL);
      
	  
	button = XtVaCreateManagedWidget ("Create Networks Based on Intersections",
						   xmToggleButtonWidgetClass, form,
						   XmNtopAttachment,    XmATTACH_FORM,
						   XmNbottomAttachment, XmATTACH_FORM,
						   XmNtraversalOn,      False,
						   XmNbottomAttachment, XmATTACH_FORM,
						   XmNleftAttachment,   XmATTACH_FORM,
						   XmNlabelString,      STRING("Create Networks Based on Intersections"),
						   XmNtranslations,     XtParseTranslationTable (translations_global),
						   TOGGLEINCLUDE,
						   NULL);

	XtAddCallback (button, XmNvalueChangedCallback, toggle_int,(XtPointer)NULL);
	XmToggleButtonSetState(button,(Boolean)INTERSECTION_BASED,(Boolean)0);


    XtManageChild(button);
    XtManageChild(form);
      


    form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       XmNtranslations,     XtParseTranslationTable (translations_global),
			       NULL);
      
	  
	button = XtVaCreateManagedWidget ("Create Networks When Performing Inspections",
						   xmToggleButtonWidgetClass, form,
						   XmNtopAttachment,    XmATTACH_FORM,
						   XmNbottomAttachment, XmATTACH_FORM,
						   XmNtraversalOn,      False,
						   XmNbottomAttachment, XmATTACH_FORM,
						   XmNleftAttachment,   XmATTACH_FORM,
						   XmNlabelString,      STRING("Create Networks When Performing Inspections"),
						   XmNtranslations,     XtParseTranslationTable (translations_global),
						   TOGGLEINCLUDE,
						   NULL);

	XtAddCallback (button, XmNvalueChangedCallback, toggle_add_nets,(XtPointer)NULL);
	XmToggleButtonSetState(button,(Boolean)ADDNETS,(Boolean)0);


    XtManageChild(button);
    XtManageChild(form);



    form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       XmNtranslations,     XtParseTranslationTable (translations_global),
			       NULL);


    network_edge_menu = BuildNetEdgeMenu (form, XmMENU_OPTION, "Networks on database edge",network_edge_type);

    XtVaSetValues(network_edge_menu,
		    XmNtopAttachment,          XmATTACH_FORM,
		    XmNbottomAttachment,       XmATTACH_FORM,
		    XmNleftAttachment,         XmATTACH_FORM,
		    NULL);

    XtManageChild (network_edge_menu);
    XtManageChild(form);









    form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      

    button = XtVaCreateManagedWidget ("Help4",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    33,
					XmNlabelString,      STRING("Save settings..."),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback (button, XmNactivateCallback,
		     SaveSettingsCallback, (XtPointer)1);
      XtManageChild(button);


      
      button = XtVaCreateManagedWidget ("Help4",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     33,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    66,
					XmNlabelString,      STRING("Load settings..."),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback (button, XmNactivateCallback,
		     LoadSettingsCallback,(XtPointer)1);
      XtManageChild(button);

      button = XtVaCreateManagedWidget("Selectall", xmPushButtonWidgetClass, form,
					     XmNtraversalOn,      False,
					     XmNtopAttachment,    XmATTACH_FORM,
					     XmNbottomAttachment, XmATTACH_FORM,
					     XmNleftAttachment,   XmATTACH_POSITION,
					     XmNleftPosition,     66,
					     XmNrightAttachment,  XmATTACH_POSITION,
					     XmNrightPosition,    99,
					     XmNlabelString,      STRING("Revert to Defaults"),
				         XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					     NULL);
      XtAddCallback(button, XmNactivateCallback,
		    revertCallback, (XtPointer)7);
      XtManageChild(button);

      XtManageChild(form);








      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);


      button = XtVaCreateManagedWidget("DSelectall", xmPushButtonWidgetClass, form,
					     XmNtraversalOn,      False,
					     XmNtopAttachment,    XmATTACH_FORM,
					     XmNbottomAttachment, XmATTACH_FORM,
					     XmNleftAttachment,   XmATTACH_POSITION,
					     XmNleftPosition,     1,
					     XmNrightAttachment,  XmATTACH_POSITION,
					     XmNrightPosition,    33,
					     XmNlabelString,      STRING("De-Select ALL"),
				             XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					     NULL);
      XtAddCallback(button, XmNactivateCallback,
		    revertCallback, (XtPointer)8);
      XtManageChild(button);


      button = XtVaCreateManagedWidget ("Help4",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     33,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    66,
					XmNlabelString,      STRING("Help"),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback (button, XmNactivateCallback,
		     NetInfoCallback, (XtPointer)NULL);
      XtManageChild(button);


	  button = XtVaCreateManagedWidget ("Help4",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     66,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    99,
					XmNlabelString,      STRING("Done"),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback(button, XmNactivateCallback, exitCallback, (XtPointer)55);
      XtManageChild(button);
      XtManageChild(form);



      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);


      button = XtVaCreateManagedWidget("DSelectall", xmPushButtonWidgetClass, form,
					     XmNtraversalOn,      False,
					     XmNtopAttachment,    XmATTACH_FORM,
					     XmNbottomAttachment, XmATTACH_FORM,
					     XmNleftAttachment,   XmATTACH_POSITION,
					     XmNleftPosition,     1,
					     XmNrightAttachment,  XmATTACH_POSITION,
					     XmNrightPosition,    99,
					     XmNlabelString,      STRING("Generate networks for viewing using these specifications"),
				             XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					     NULL);
      XtAddCallback(button, XmNactivateCallback,
		    buildNetworksCallback, (XtPointer)NULL);
      XtManageChild(button);
      XtManageChild(form);






      XtManageChild (rowcol);

      
      if(net_head_in_use==0)
	{
	  net_deader_head=0;

	  XtRealizeWidget(param_net_head);
	  MyPopup(param_net_head); 

	  XtAddCallback(param_net_head,XmNdestroyCallback,ShellDeath,(XtPointer)4098);


	  XtVaGetValues(param_net_head, XmNwidth,     &Pwidth, XmNheight, &Pheight, NULL);	  
	  XtVaSetValues(param_net_head, XmNminWidth,  Pwidth+50,  NULL);
	  XtVaSetValues(param_net_head, XmNmaxWidth,  1000,  NULL);
	  if(fixheight==1)
	    {
	      XtVaSetValues(param_net_head, XmNminHeight, Pheight, NULL);
	      XtVaSetValues(param_net_head, XmNmaxHeight, Pheight, NULL);
	      XtAddEventHandler(param_net_head,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)Pheight));
	    }
	}
      else if(net_head_in_use==1)
	{
	  net_deader_phead=0;
	  XtRealizeWidget(param2_net_head);
	  MyPopup(param2_net_head); 

	  XtAddCallback(param2_net_head,XmNdestroyCallback,ShellDeath,(XtPointer)4099);

	  
	  XtVaGetValues(param2_net_head, XmNwidth,     &Pwidth, XmNheight, &Pheight, NULL);	  
	  XtVaSetValues(param2_net_head, XmNminWidth,  Pwidth+50,  NULL);
	  XtVaSetValues(param2_net_head, XmNmaxWidth,  1000,  NULL);
	  if(fixheight==1)
	    {
	      XtVaSetValues(param2_net_head, XmNminHeight, Pheight,  NULL);
	      XtVaSetValues(param2_net_head, XmNmaxHeight, Pheight,  NULL);
	      XtAddEventHandler(param2_net_head,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)Pheight));
	    }
	}
      XtVaSetValues(sb2,XmNincrement,30,NULL);

    }
  else
    {
      if(net_head_in_use==1)
	{
	  if(DEBUG==1){printf("raising 1\n");}
	  ResetWidget(param2_net_head);
	}
      else if(net_head_in_use==0)
	{
	  if(DEBUG==1){printf("raising 2\n");}
	  ResetWidget(param_net_head);
	}      
    }
  set_cursor(mydisplay,mywindow,GOOD);
}








void SaveLODColors(Widget w)
{
  FILE *lodsavefile;
  char outfile[5000];
  char failmess[5000];
  int layer_num;
  
  sprintf(outfile,"%slayercolors.txt",indirectory);
  
  lodsavefile = fopen(outfile,"w");
  if(lodsavefile==NULL)
    {
      sprintf(failmess,"Failed to open %s\nfor writing.  Unable to save color specifications.\n",outfile);
      not_while_running(w,failmess,1088,"File Open Failed",5);
      return;
    }


  fprintf(lodsavefile,"%d\n",PrimaryLODSort);
  fprintf(lodsavefile,"%d\n",SecondaryLODSort);


  
  for(layer_num=0;layer_num<NumLODbands;layer_num++)
    {
      fprintf(lodsavefile,"%d\n",LODindex_DYN[layer_num].other_index);
    }

  
  for(layer_num=0;layer_num<NumLODbands;layer_num++)
    {
      

      if(LODindex[LODindex_DYN[layer_num].other_index].color>=0)
	{
	  fprintf(lodsavefile,"%d\n",LODindex[LODindex_DYN[layer_num].other_index].rcolor);
	  fprintf(lodsavefile,"%d\n",LODindex[LODindex_DYN[layer_num].other_index].gcolor);
	  fprintf(lodsavefile,"%d\n",LODindex[LODindex_DYN[layer_num].other_index].bcolor);
	}
      else
	{
	  fprintf(lodsavefile,"-1\n");
	  fprintf(lodsavefile,"-1\n");
	  fprintf(lodsavefile,"-1\n");
	}


      
      fprintf(lodsavefile,"%d\n",LODindex_DYN[layer_num].draw_priority);

      
      fprintf(lodsavefile,"%d\n",LODindex_DYN[layer_num].draw_style);

      
      fprintf(lodsavefile,"%d\n",LODindex_DYN[layer_num].ECC);

      
      fprintf(lodsavefile,"%d\n",LODindex_DYN[layer_num].geom);

      
      fprintf(lodsavefile,"%d\n",LODindex_DYN[layer_num].do_discrete);

      
      fprintf(lodsavefile,"%d\n",LODindex_DYN[layer_num].equal_type);

      
      fprintf(lodsavefile,"%d\n",LODindex_DYN[layer_num].do_outline);

      
      fprintf(lodsavefile,"%lf\n",LODindex_DYN[layer_num].discrete_ignore_value);


    }
  fclose(lodsavefile);
}




void layergeomhelpCallback(Widget w,XtPointer data,XtPointer callData)
{
  not_while_running(w,"This window is used to select or de-select the\n\
layers on the \"Layer Options\" window, using their geometries.\n\n\
Example:  To de-select all \"Area\" feature layers, click the \"De-Select\n\
all Area layers\" button.\n\n\
Only those geometries present in the project are shown.",
		    1447,"Layer Selection by Geometry Help",5);

}

void layerfchelpCallback(Widget w,XtPointer data,XtPointer callData)
{
  not_while_running(w,"This window is used to select or de-select the\n\
layers on the \"Layer Options\" window, using their functional categories.\n\n\
Example:  To de-select all \"Inland Water\" feature layers, click the \"De-Select\n\
all Inland Water layers\" button.\n\n\
Only those functional categories present in the project are shown",
		    1448,"Layer Selection by Functional Category Help",5);
}


void layermgcphelpCallback(Widget w,XtPointer data,XtPointer callData)
{
  not_while_running(w,"This window is used to select or de-select area layers\n\
on the \"Layer Options\" window, using MGCP categories.\n\n\
Example:  To de-select all area \"Activity\" feature layers,\n\
click the \"De-Select all Area \"Activity\" layers\" button.\n\n\
Only those MGCP categories present in the project are shown.",
		    1470,"Layer Selection by MGCP Category Help",5);
}


void LODHelpCallback(Widget w,XtPointer data,XtPointer callData)
{

  if(NGA_TYPE==1)
    {
      not_while_running(w,"This window is used to select Layers.\n\
GAIT will only use selected Layers for its operations\n\
(ie zooming, profile drawing, information query, etc).\n\n\
The \"Color/Style\" buttons may be used to specify\n\
colors and styles to draw particular layers.\n\
Red is not a good choice, due to the fact that GAIT uses red\n\
for highlighting.\n\n\
The \"Drawing Priority\" option allows stacking of layers when\n\
drawing.  GAIT always stacks: gridded elevation data, then area\n\
features, then line features, then point features.  Drawing\n\
priorities may be set within one of these classes to, say, always\n\
draw area BUILDINGs on top of area LAKEs by setting the area\n\
BUILDING layer to have a higher priority than the area LAKE layer.\n\n\
The \"Identifier\" listed is the root shapefile name for shapefiles,\n\
the table name for Geodatabase and Geomedia Access, and the user\n\
specified layer identifier for DTED.\n",1092,"Layer Help",5);
    }
  else
    {
      not_while_running(w,"This window is used to select those LODs to consider.\n\
SEE-IT will only use selected LODs for its operations\n\
(ie error checking, zooming, profile drawing, etc).\n\n\
This window has no effect on those database elements for\n\
which no LOD information was found (such elements are\n\
always \"turned on\").\n\n\
The \"Choose color...\" buttons may be used to specify\n\
colors to draw particular LODs.  These colors are used\n\
to override the color the objects would normally be drawn.\n\
Red is not a good choice, due to the fact that SEE-IT uses red\n\
for highlighting.\n\n\
If an overriding color has been specified, that color will\n\
be shown in place of the \"specify color...\" button.",1093,"LOD Help",5);
    }
  

}






void SetLayerColorWin(int layer_num,long int color, int style)
{
  char thestr[500];
  
  
  
  
  if((LODindex_DYN[layer_num].geom!=C_AREA)&&(LODindex_DYN[layer_num].geom!=C_GRID))
    {
      
      XSetForeground(mydisplay,mygc,color);
      XFillRectangle(mydisplay,layer_colorpix[layer_num],              mygc,0,0,450,100);
    }
  else
    {
      
      XSetForeground(mydisplay,mygc,color);
      XFillRectangle(mydisplay,layer_colorpix[layer_num],              mygc,0,0,225,100);
      
      
      
      XSetForeground(mydisplay,mygc,mycolors[DRAW_COLOR_WHITE]);
      XFillRectangle(mydisplay,layer_colorpix[layer_num],              mygc,225,0,225,100);
      
      
      XSetForeground(mydisplay,mygc,color);
      
      if((LODindex_DYN[layer_num].geom==C_GRID) && ((style==0)||(style==1)))
        {
	  
	  
	  if(style==0)
            {
              SetColorRight();
              sprintf(thestr,"In \"Grey Shaded\"");
              XDrawString(mydisplay,layer_colorpix[layer_num],mygc,
		      225,15,
		      thestr,(int)strlen(thestr));

              sprintf(thestr,"style, grids are");
              XDrawString(mydisplay,layer_colorpix[layer_num],mygc,
		      225,35,
		      thestr,(int)strlen(thestr));

              sprintf(thestr,"shaded in grey");
              XDrawString(mydisplay,layer_colorpix[layer_num],mygc,
		      225,55,
		      thestr,(int)strlen(thestr));

              sprintf(thestr,"using their");
              XDrawString(mydisplay,layer_colorpix[layer_num],mygc,
		      225,75,
		      thestr,(int)strlen(thestr));

              sprintf(thestr,"elevation data");
              XDrawString(mydisplay,layer_colorpix[layer_num],mygc,
		      225,95,
		      thestr,(int)strlen(thestr));
            }
	  else
            {
              SetColorRight();
              sprintf(thestr,"%s",GetECCLabel(0));
              XDrawString(mydisplay,layer_colorpix[layer_num],mygc,
		      225,15,
		      thestr,(int)strlen(thestr));

              sprintf(thestr,"(Color): Posts are");
              XDrawString(mydisplay,layer_colorpix[layer_num],mygc,
		      225,35,
		      thestr,(int)strlen(thestr));

              sprintf(thestr,"drawn as X marks");
              XDrawString(mydisplay,layer_colorpix[layer_num],mygc,
		      225,55,
		      thestr,(int)strlen(thestr));

              sprintf(thestr,"using the selected");
              XDrawString(mydisplay,layer_colorpix[layer_num],mygc,
		      225,75,
		      thestr,(int)strlen(thestr));

              sprintf(thestr,"color (at left)");
              XDrawString(mydisplay,layer_colorpix[layer_num],mygc,
		      225,95,
		      thestr,(int)strlen(thestr));
            }
        } 
      else
        {
	  switch(style)
	    {
	    case 1: 
	      break;
	    case 2: 
	      XSetStipple   (mydisplay,mygc,stipmap_lgt);
	      XSetFillStyle (mydisplay,mygc,FillStippled);
              XFillRectangle(mydisplay,layer_colorpix[layer_num],mygc,225,0,225,100);
              XSetFillStyle (mydisplay,mygc,FillSolid);
              break;
          case 3: 
	  XSetStipple   (mydisplay,mygc,stipmap_avg);
	  XSetFillStyle (mydisplay,mygc,FillStippled);
	  XFillRectangle(mydisplay,layer_colorpix[layer_num],mygc,225,0,225,100);
	  XSetFillStyle (mydisplay,mygc,FillSolid);
	  break;
	case 4: 
	  XSetStipple   (mydisplay,mygc,stipmap_hvy);
	  XSetFillStyle (mydisplay,mygc,FillStippled);
	  XFillRectangle(mydisplay,layer_colorpix[layer_num],mygc,225,0,225,100);
	  XSetFillStyle (mydisplay,mygc,FillSolid);
	  break;
	case 5: 
	  XFillRectangle(mydisplay,layer_colorpix[layer_num],mygc,225,0,225,100);
	  break;

	case 6: 
	  XSetStipple   (mydisplay,mygc,stipmapstypes[0]);
	  XSetFillStyle (mydisplay,mygc,FillStippled);
	  XFillRectangle(mydisplay,layer_colorpix[layer_num],mygc,225,0,225,100);
	  XSetFillStyle (mydisplay,mygc,FillSolid);
	  break;
	case 7: 
	  XSetStipple   (mydisplay,mygc,stipmapstypes[1]);
	  XSetFillStyle (mydisplay,mygc,FillStippled);
	  XFillRectangle(mydisplay,layer_colorpix[layer_num],mygc,225,0,225,100);
	  XSetFillStyle (mydisplay,mygc,FillSolid);
	  break;
	case 8: 
	  XSetStipple   (mydisplay,mygc,stipmapstypes[2]);
	  XSetFillStyle (mydisplay,mygc,FillStippled);
	  XFillRectangle(mydisplay,layer_colorpix[layer_num],mygc,225,0,225,100);
	  XSetFillStyle (mydisplay,mygc,FillSolid);
	  break;
	case 9: 
	  XSetStipple   (mydisplay,mygc,stipmapstypes[3]);
	  XSetFillStyle (mydisplay,mygc,FillStippled);
	  XFillRectangle(mydisplay,layer_colorpix[layer_num],mygc,225,0,225,100);
	  XSetFillStyle (mydisplay,mygc,FillSolid);
	  break;
	case 10: 
	  XSetStipple   (mydisplay,mygc,stipmapstypes[5]);
	  XSetFillStyle (mydisplay,mygc,FillStippled);
	  XFillRectangle(mydisplay,layer_colorpix[layer_num],mygc,225,0,225,100);
	  XSetFillStyle (mydisplay,mygc,FillSolid);
	  break;
	case 11: 
	  XSetStipple   (mydisplay,mygc,stipmapstypes[4]);
	  XSetFillStyle (mydisplay,mygc,FillStippled);
	  XFillRectangle(mydisplay,layer_colorpix[layer_num],mygc,225,0,225,100);
	  XSetFillStyle (mydisplay,mygc,FillSolid);
	  break;
	case 12: 
	  XSetStipple   (mydisplay,mygc,stipmapstypes[6]);
	  XSetFillStyle (mydisplay,mygc,FillStippled);
	  XFillRectangle(mydisplay,layer_colorpix[layer_num],mygc,225,0,225,100);
	  XSetFillStyle (mydisplay,mygc,FillSolid);
	  break;
	case 13: 
	  XSetStipple   (mydisplay,mygc,stipmapstypes[7]);
	  XSetFillStyle (mydisplay,mygc,FillStippled);
	  XFillRectangle(mydisplay,layer_colorpix[layer_num],mygc,225,0,225,100);
	  XSetFillStyle (mydisplay,mygc,FillSolid);
	  break;
	default:
	  printf("(3) should not be in default fill style\n");
	}
      }
    }


  

  XCopyArea (mydisplay,layer_colorpix[layer_num],XtWindow(layer_colorwindows[layer_num]), 
             mygc, 0, 0, 450,100, 0, 0);

  SetColorRight();
}






void new_value(Widget scale_w, XtPointer client_data, XtPointer call_data)
{
  int rgb = (int) client_data;
  int layer_num = rgb/1000;
  int savered,savegreen,saveblue;
  char temp[100];
  XmScaleCallbackStruct *cbs = (XmScaleCallbackStruct *) call_data;
  Colormap local_cmap = DefaultColormapOfScreen (XtScreen (scale_w));
  
  rgb = rgb%1000;
  
  sprintf(temp,"%d",cbs->value);



  switch (rgb) 
    {
      
      
    case DoRed :
      layer_colors[layer_num].red = (cbs->value << 8);
      if(layer_colors[layer_num].red==65280)
	{
	  layer_colors[layer_num].red = 65535;
	}
      break;
    case DoGreen :
      layer_colors[layer_num].green = (cbs->value << 8);
      if(layer_colors[layer_num].green==65280)
	{
	  layer_colors[layer_num].green = 65535;
	}
      break;
    case DoBlue :
      layer_colors[layer_num].blue = (cbs->value << 8);
      if(layer_colors[layer_num].blue==65280)
	{
	  layer_colors[layer_num].blue = 65535;
	}
      break;
    }
  

  
  
  if(LODindex[LODindex_DYN[layer_num].other_index].firsttime==0)
    {
      if(LODindex[LODindex_DYN[layer_num].other_index].temp_color>=0)
	{
          	  
	  XFreeColors (XtDisplay (scale_w), local_cmap, &layer_colors[layer_num].pixel, 1, 0);
	}
    }
  LODindex[LODindex_DYN[layer_num].other_index].firsttime = 0;
  

  savered   = layer_colors[layer_num].red;
  savegreen = layer_colors[layer_num].green;
  saveblue  = layer_colors[layer_num].blue;


  if (!XAllocColor (XtDisplay (scale_w), local_cmap, &layer_colors[layer_num])) 
    {
      printf("Couldn't XAllocColor (1)!\n"); 
      LODindex[LODindex_DYN[layer_num].other_index].temp_color = -1;
    }
  else
    {
      

      
      SetLayerColorWin(layer_num,layer_colors[layer_num].pixel,
		       LODindex_DYN[layer_num].temp_style);

    }


  
  switch (rgb) 
    {
    case DoRed :
      XtVaSetValues (layer_text1[layer_num], XmNvalue, temp, NULL);
      break;
    case DoGreen :
      XtVaSetValues (layer_text2[layer_num], XmNvalue, temp, NULL);
      break;
    case DoBlue :
      XtVaSetValues (layer_text3[layer_num], XmNvalue, temp, NULL);
      break;
    }


  


  layer_colors[layer_num].red   = savered;
  layer_colors[layer_num].green = savegreen;
  layer_colors[layer_num].blue  = saveblue;
  
  
  LODindex[LODindex_DYN[layer_num].other_index].temp_color  = layer_colors[layer_num].pixel;
  LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor = savered;
  LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor = savegreen;
  LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor = saveblue;



  SetColorRight();
}




void new_value2(Widget w, XtPointer client_data, XtPointer call_data)
{
  int rgb = (int) client_data;
  int layer_num = rgb/1000;
  int myindex = rgb % 1000;
  int savered,savegreen,saveblue;
  char temp[100];



  switch(myindex)
    {
    case DRAW_COLOR_BLACK:
      LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor = BLACK_R;
      LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor = BLACK_G;
      LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor = BLACK_B;
      break;
    case DRAW_COLOR_WHITE:
      LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor = WHITE_R;
      LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor = WHITE_G;
      LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor = WHITE_B;
      break;
    case DRAW_COLOR_YELLOW:
      LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor = YELLOW_R;
      LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor = YELLOW_G;
      LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor = YELLOW_B;
      break;
    case DRAW_COLOR_MEDGREEN:
      LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor = MEDGREEN_R;
      LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor = MEDGREEN_G;
      LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor = MEDGREEN_B;
      break;
    case DRAW_COLOR_MEDGREEN2:
      LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor = MEDGREEN2_R;
      LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor = MEDGREEN2_G;
      LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor = MEDGREEN2_B;
      break;
    case DRAW_COLOR_BROWN:
      LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor = BROWN_R;
      LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor = BROWN_G;
      LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor = BROWN_B;
      break;
    case DRAW_COLOR_LAVENDER:
      LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor = LAVENDER_R;
      LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor = LAVENDER_G;
      LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor = LAVENDER_B;
      break;
    case DRAW_COLOR_LTGREEN:
      LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor = LTGREEN_R;
      LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor = LTGREEN_G;
      LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor = LTGREEN_B;
      break;
    case DRAW_COLOR_DKCYAN:
      LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor = DKCYAN_R;
      LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor = DKCYAN_G;
      LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor = DKCYAN_B;
      break;
    case DRAW_COLOR_PURPLE:
      LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor = PURPLE_R;
      LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor = PURPLE_G;
      LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor = PURPLE_B;
      break;
    case DRAW_COLOR_LTCYAN:
      LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor = LTCYAN_R;
      LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor = LTCYAN_G;
      LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor = LTCYAN_B;
      break;
    case DRAW_COLOR_BLUE:
      LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor = BLUE_R;
      LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor = BLUE_G;
      LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor = BLUE_B;
      break;
    case DRAW_COLOR_MAGENTA:
      LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor = MAGENTA_R;
      LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor = MAGENTA_G;
      LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor = MAGENTA_B;
      break;
    case DRAW_COLOR_SALMON:
      LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor = SALMON_R;
      LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor = SALMON_G;
      LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor = SALMON_B;
      break;
    case DRAW_COLOR_TAN:
      LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor = TAN_R;
      LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor = TAN_G;
      LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor = TAN_B;
      break;
    case DRAW_COLOR_ORANGE:
      LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor = ORANGE_R;
      LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor = ORANGE_G;
      LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor = ORANGE_B;
      break;
    case DRAW_COLOR_GRAY64:
      LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor = GRAY64_R;
      LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor = GRAY64_G;
      LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor = GRAY64_B;
      break;
    case DRAW_COLOR_GRAY128:
      LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor = GRAY128_R;
      LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor = GRAY128_G;
      LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor = GRAY128_B;
      break;
    case DRAW_COLOR_GRAY192:
      LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor = GRAY192_R;
      LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor = GRAY192_G;
      LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor = GRAY192_B;
      break;
    default:
      printf("bad color %d to new_value2\n",myindex);
      break;
    }
  


  layer_colors[layer_num].red   = LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor;
  layer_colors[layer_num].green = LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor;
  layer_colors[layer_num].blue  = LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor;
  

  if(layers_up[layer_num]==1)
    {
      XtVaSetValues (scale1[layer_num], XmNvalue, LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor/256, NULL);
      XtVaSetValues (scale2[layer_num], XmNvalue, LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor/256, NULL);
      XtVaSetValues (scale3[layer_num], XmNvalue, LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor/256, NULL);
      
      

      


      SetLayerColorWin(layer_num,mycolors[myindex],LODindex_DYN[layer_num].temp_style);


      savered   = layer_colors[layer_num].red;
      savegreen = layer_colors[layer_num].green;
      saveblue  = layer_colors[layer_num].blue;

      sprintf(temp,"%d",LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor/256);
      XtVaSetValues (layer_text1[layer_num], XmNvalue, temp, NULL);
      
      sprintf(temp,"%d",LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor/256);
      XtVaSetValues (layer_text2[layer_num], XmNvalue, temp, NULL);
      
      sprintf(temp,"%d",LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor/256);
      XtVaSetValues (layer_text3[layer_num], XmNvalue, temp, NULL);

      

      LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor = savered;
      LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor = savegreen;
      LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor = saveblue;
      
      layer_colors[layer_num].red   = savered;
      layer_colors[layer_num].green = savegreen;
      layer_colors[layer_num].blue  = saveblue;


    }

  LODindex[LODindex_DYN[layer_num].other_index].temp_color = mycolors[myindex];


  SetColorRight();
}








void layer_new_text_value(Widget w, XtPointer client_data, XtPointer call_data)
{
  char *value = XmTextFieldGetString (w);
  int rgb = (int) client_data;
  int layer_num = rgb/1000;
  int i,savered,savegreen,saveblue;
  int test;
  char temp[50];
  Colormap local_cmap = DefaultColormapOfScreen (XtScreen (w));
 
  rgb = rgb%1000;


  
  


  if(rgb==DoRed)
    {
      sprintf(temp,"%d",LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor/256);
    }
  else if(rgb==DoGreen)
    {
      sprintf(temp,"%d",LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor/256);
    }
  else if(rgb==DoBlue)
    {
      sprintf(temp,"%d",LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor/256);
    }


  
  for(i=0;i<(int)(strlen(value));i++)
    {
      if((value[i]<'0')||(value[i]>'9'))
	{
          
	  
	  XmTextFieldSetString(w,temp);
	  XtFree(value);
          return; 
	}
    }
  

  if(strlen(value)==0)
    {
      XtFree(value);
      return;
    }
  
    
  
  sscanf(value,"%d",&test);


  if((test<0)||(test>255))
    {
      XmTextFieldSetString(w,temp);
      XtFree(value);
      return;
    }



  test = test*256;

  if(test==65280)
    {
      test = 65535;
    }

  
  switch (rgb) 
    {
    case DoRed :
      layer_colors[layer_num].red = test;
      break;
    case DoGreen :
      layer_colors[layer_num].green = test;
      break;
    case DoBlue :
      layer_colors[layer_num].blue = test;
      break;
    }
  
  
  
  
  if(LODindex[LODindex_DYN[layer_num].other_index].firsttime==0)
    {
      if(LODindex[LODindex_DYN[layer_num].other_index].temp_color>=0)
	{
	  
	  XFreeColors (XtDisplay (w), local_cmap, &layer_colors[layer_num].pixel, 1, 0);
	}
    }
  
  LODindex[LODindex_DYN[layer_num].other_index].firsttime = 0;
  
  savered   = layer_colors[layer_num].red;
  savegreen = layer_colors[layer_num].green;
  saveblue  = layer_colors[layer_num].blue;
  
  if (!XAllocColor (XtDisplay (w), local_cmap, &layer_colors[layer_num])) 
    {
      printf("Couldn't XAllocColor (1)!\n"); 
      LODindex[LODindex_DYN[layer_num].other_index].temp_color = -1;
    }
  else
    {
      


      
      SetLayerColorWin(layer_num,layer_colors[layer_num].pixel,LODindex_DYN[layer_num].temp_style);


      layer_colors[layer_num].red   = savered;
      layer_colors[layer_num].green = savegreen;
      layer_colors[layer_num].blue  = saveblue;

      LODindex[LODindex_DYN[layer_num].other_index].temp_color  = layer_colors[layer_num].pixel;
      LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor = layer_colors[layer_num].red;
      LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor = layer_colors[layer_num].green;
      LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor = layer_colors[layer_num].blue;      

    }

  XtVaSetValues (scale1[layer_num], XmNvalue, LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor/256, NULL);
  XtVaSetValues (scale2[layer_num], XmNvalue, LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor/256, NULL);
  XtVaSetValues (scale3[layer_num], XmNvalue, LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor/256, NULL);

  SetColorRight();
}






void help_layer_callback(Widget w, XtPointer client_data, XtPointer call_data)
{
  int layer_num = (int)client_data;
  char message[2000];
  
  
  sprintf(message,"This window can be used to set the color for the layer:\n\
%s (%s) (%s) (%s)\n\n\
The color may either be selected from the list of predefined\n\
colors by clicking on one of them, or the color may be set\n\
using red, green, and blue values using the sliders.\n\n\
Using either method, the color is previewed on the top\n\
of this window when selections or modifications are made.\n\n\
To accept the currently displayed color, use the Apply button.\n\n\
When a new color is selected, it will appear on the \"View->By Layer\"\n\
window next to it's layer, and that color will be used to draw\n\
objects in that layer.\n\n\
Red is not a good choice, because red is used for highlighting objects.",
	  GetECCCode (LODindex_DYN[layer_num].ECC),
	  GetECCLabel(LODindex_DYN[layer_num].ECC),
	  GetShortGeomName(LODindex_DYN[layer_num].geom),
	  LODindex[LODindex_DYN[layer_num].other_index].filename); 
  
  not_while_running(w,message,1094,"Layer Color Setting Help",5);
  
}



void apply_layer_callback(Widget button, XtPointer client_data, XtPointer call_data)
{ 
  int layer_num = (int)client_data,centerx,centery,negflag=0;
  Pixmap temp_pixmap;
  
  if(layer_num<0)
    {
      
      negflag = 1;
      layer_num = layer_num * -1;
    }

  if(LODindex[LODindex_DYN[layer_num].other_index].temp_color != -1)
    {
      LODindex[LODindex_DYN[layer_num].other_index].color  = LODindex[LODindex_DYN[layer_num].other_index].temp_color;
      LODindex[LODindex_DYN[layer_num].other_index].rcolor = LODindex[LODindex_DYN[layer_num].other_index].temp_rcolor;
      LODindex[LODindex_DYN[layer_num].other_index].gcolor = LODindex[LODindex_DYN[layer_num].other_index].temp_gcolor;
      LODindex[LODindex_DYN[layer_num].other_index].bcolor = LODindex[LODindex_DYN[layer_num].other_index].temp_bcolor;
    }
  else
    {
      printf("tried to apply bad color -1 for layer %d\n",layer_num);
    }

  LODindex_DYN[layer_num].draw_style = LODindex_DYN[layer_num].temp_style;
  

  
  
  
  
  
  temp_pixmap = XCreatePixmap(mydisplay,
			      RootWindowOfScreen (XtScreen (drawing_a)),
			      100,NEW_BOTTOM,DefaultDepthOfScreen(XtScreen(drawing_a)));
  
  
  XSetForeground(mydisplay,mygc,mycolors[DRAW_COLOR_WHITE]);
  XFillRectangle(mydisplay,temp_pixmap,mygc,0,0,100,NEW_BOTTOM);
  XSetForeground(mydisplay,mygc,LODindex[LODindex_DYN[layer_num].other_index].color);
  
  if( (LODindex_DYN[layer_num].geom==C_AREA) || (LODindex_DYN[layer_num].geom==C_GRID) )
    {
      if((LODindex_DYN[layer_num].geom==C_GRID) && (LODindex_DYN[layer_num].draw_style<2))
	{
	  if(LODindex_DYN[layer_num].draw_style==0)
	    {
	      
	      SetColorRight();
	      XDrawString(mydisplay,temp_pixmap,mygc,
			  0,13," Shaded",7);
	    }
	  else
	    {
	      centerx = 91;
	      centery = 8;

	      XDrawLine(mydisplay,temp_pixmap,     mygc,
			centerx-7,centery,
			centerx+7,centery);

	      XDrawLine(mydisplay,temp_pixmap,     mygc,
			centerx,centery-7,
			centerx,centery+7);

	      XDrawLine(mydisplay,temp_pixmap,     mygc,
			centerx-5,centery-5,
			centerx+5,centery+5);

	      XDrawLine(mydisplay,temp_pixmap,     mygc,
			centerx+5,centery-5,
			centerx-5,centery+5);
	      	      

	      
	      SetColorRight();

	      XDrawString(mydisplay,temp_pixmap,mygc,
			  0,13,"Symbol:",7);
	      
	    }
	}
      else
	{
	  switch(LODindex_DYN[layer_num].draw_style)
	    {
	    case 1: 
	      break;
	    case 2: 
	      XSetStipple   (mydisplay,mygc, stipmap_lgt);
	      XSetFillStyle (mydisplay,mygc,FillStippled);
	      XFillRectangle(mydisplay,temp_pixmap,mygc,0,0,100,NEW_BOTTOM);
	      XSetFillStyle (mydisplay,mygc,FillSolid);
	      break;
	    case 3: 
	      XSetStipple   (mydisplay,mygc, stipmap_avg);
	      XSetFillStyle (mydisplay,mygc,FillStippled);
	      XFillRectangle(mydisplay,temp_pixmap,mygc,0,0,100,NEW_BOTTOM);
	      XSetFillStyle (mydisplay,mygc,FillSolid);
	      break;
	    case 4: 
	      XSetStipple   (mydisplay,mygc, stipmap_hvy);
	      XSetFillStyle (mydisplay,mygc,FillStippled);
	      XFillRectangle(mydisplay,temp_pixmap,mygc,0,0,100,NEW_BOTTOM);
	      XSetFillStyle (mydisplay,mygc,FillSolid);
	      break;
	    case 5: 
	      XFillRectangle(mydisplay,temp_pixmap,mygc,0,0,100,NEW_BOTTOM);
	      break;
	    case 6: 
	      XSetStipple   (mydisplay,mygc, stipmapstypes[0]);
	      XSetFillStyle (mydisplay,mygc,FillStippled);
	      XFillRectangle(mydisplay,temp_pixmap,mygc,0,0,100,NEW_BOTTOM);
	      XSetFillStyle (mydisplay,mygc,FillSolid);
	      break;
	    case 7: 
	      XSetStipple   (mydisplay,mygc, stipmapstypes[1]);
	      XSetFillStyle (mydisplay,mygc,FillStippled);
	      XFillRectangle(mydisplay,temp_pixmap,mygc,0,0,100,NEW_BOTTOM);
	      XSetFillStyle (mydisplay,mygc,FillSolid);
	      break;
	    case 8: 
	      XSetStipple   (mydisplay,mygc, stipmapstypes[2]);
	      XSetFillStyle (mydisplay,mygc,FillStippled);
	      XFillRectangle(mydisplay,temp_pixmap,mygc,0,0,100,NEW_BOTTOM);
	      XSetFillStyle (mydisplay,mygc,FillSolid);
	      break;
	    case 9: 
	      XSetStipple   (mydisplay,mygc, stipmapstypes[3]);
	      XSetFillStyle (mydisplay,mygc,FillStippled);
	      XFillRectangle(mydisplay,temp_pixmap,mygc,0,0,100,NEW_BOTTOM);
	      XSetFillStyle (mydisplay,mygc,FillSolid);
	      break;
	    case 10: 
	      XSetStipple   (mydisplay,mygc, stipmapstypes[5]);
	      XSetFillStyle (mydisplay,mygc,FillStippled);
	      XFillRectangle(mydisplay,temp_pixmap,mygc,0,0,100,NEW_BOTTOM);
	      XSetFillStyle (mydisplay,mygc,FillSolid);
	      break;
	    case 11: 
	      XSetStipple   (mydisplay,mygc, stipmapstypes[4]);
	      XSetFillStyle (mydisplay,mygc,FillStippled);
	      XFillRectangle(mydisplay,temp_pixmap,mygc,0,0,100,NEW_BOTTOM);
	      XSetFillStyle (mydisplay,mygc,FillSolid);
	      break;
	    case 12: 
	      XSetStipple   (mydisplay,mygc, stipmapstypes[6]);
	      XSetFillStyle (mydisplay,mygc,FillStippled);
	      XFillRectangle(mydisplay,temp_pixmap,mygc,0,0,100,NEW_BOTTOM);
	      XSetFillStyle (mydisplay,mygc,FillSolid);
	      break;
	    case 13: 
	      XSetStipple   (mydisplay,mygc, stipmapstypes[7]);
	      XSetFillStyle (mydisplay,mygc,FillStippled);
	      XFillRectangle(mydisplay,temp_pixmap,mygc,0,0,100,NEW_BOTTOM);
	      XSetFillStyle (mydisplay,mygc,FillSolid);
	      break;
	    default:
	      printf("should not be indefault fill style\n");
	    }
	  XDrawRectangle(mydisplay,temp_pixmap,mygc,0,0,100-1,NEW_BOTTOM-1);
	}
    }
  else if(LODindex_DYN[layer_num].geom==C_LINE)
    {
      XDrawLine(mydisplay,temp_pixmap,mygc,1, 24,33,1);
      XDrawLine(mydisplay,temp_pixmap,mygc,33,1, 65,24);
      XDrawLine(mydisplay,temp_pixmap,mygc,65,24,97,1);
	}
  else if(LODindex_DYN[layer_num].geom==C_POFE)
    {
	  int x1 = 50;
	  int y1 = 12;
	  int halfxlen = 5;
	  XDrawLine(mydisplay,temp_pixmap,mygc,x1-halfxlen,y1-halfxlen,x1+halfxlen,y1+halfxlen);
      XDrawLine(mydisplay,temp_pixmap,mygc,x1-halfxlen,y1+halfxlen,x1+halfxlen,y1-halfxlen);
    }
  
  
  XtVaSetValues(LODindex[LODindex_DYN[layer_num].other_index].color_wid, XmNlabelType  , XmPIXMAP, NULL);
  XtVaSetValues(LODindex[LODindex_DYN[layer_num].other_index].color_wid, XmNlabelPixmap, temp_pixmap, NULL);
  


  
  
  if(no_layer_reset_flag!=789987)
  {
    if(LODindex_DYN[layer_num].geom==C_GRID)
      {
		if(layers_up[layer_num]!=0)
		{
	      
	      discrete_result(LODindex_DYN[layer_num].discrete_value_wid,(XtPointer)layer_num,(XtPointer)layer_num);
		}
      }
  }
  else
  {
    
  }



  SaveLODColors(button);

  SetColorRight();

  if(NO_REBUILD==0)
    {
      RebuildTopImage(3);
    }
}











void reset_layer_colors(Widget pb, XtPointer client_data, XtPointer call_data)
{
  int i;
  
  for(i=0;i<NumLODbands;i++)
    {
      if(LODindex[LODindex_DYN[i].other_index].color>=0)
	{
	  reset_layer_color(pb,(XtPointer)i, (XtPointer)i);
	}
    }
}




void area_style_cb(Widget menu_item,XtPointer client_data,XtPointer call_data)
{
  int item_no = (int) client_data;
  int layer,style;

  layer = item_no/1000;
  style = item_no%1000;

  LODindex_DYN[layer].temp_style = style;
  

  
  SetLayerColorWin(layer,LODindex[LODindex_DYN[layer].other_index].temp_color,style);
}


void equal_style_cb(Widget menu_item,XtPointer client_data,XtPointer call_data)
{
  int item_no = (int) client_data;
  int layer,style;

  layer = item_no/1000;
  style = item_no%1000;

  LODindex_DYN[layer].equal_type = style;
}




void override_cb(Widget menu_item,XtPointer client_data,XtPointer call_data)
{
  int newtype = (int) client_data;

  if(OVERRIDING_STYLE!=newtype)
    {
      RebuildTopImage(2);
    }

  OVERRIDING_STYLE = (int) client_data;
}





Widget BuildStyleMenu(Widget parent,int menu_type,char *menu_title,MenuItem *items, int layer_num)
{
  Widget menu, cascade, widget;
  int i,n=0,cbvalue;
  XmString str;
  Arg args[5];
  
  
  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);
  
  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId, menu);  n++;
  XtSetArg (args[n], XmNlabelString, str); n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;
  
  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);
  
  for (i = 0; items[i].label != NULL; i++) 
    {
      cbvalue = (int)items[i].callback_data + layer_num*1000;
      
      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);
      

      if(
		  

		  ((LODindex_DYN[layer_num].geom==C_AREA)&&((i+1)==0) &&(LODindex_DYN[layer_num].draw_style==0))  ||
		  ((LODindex_DYN[layer_num].geom==C_AREA)&&((i+1)==1) &&(LODindex_DYN[layer_num].draw_style==1))  ||
		  ((LODindex_DYN[layer_num].geom==C_AREA)&&((i+1)==2) &&(LODindex_DYN[layer_num].draw_style==2))  ||
		  ((LODindex_DYN[layer_num].geom==C_AREA)&&((i+1)==3) &&(LODindex_DYN[layer_num].draw_style==3))  ||
		  ((LODindex_DYN[layer_num].geom==C_AREA)&&((i+1)==4) &&(LODindex_DYN[layer_num].draw_style==4))  ||
		  ((LODindex_DYN[layer_num].geom==C_AREA)&&((i+1)==5) &&(LODindex_DYN[layer_num].draw_style==5))  ||
		  ((LODindex_DYN[layer_num].geom==C_AREA)&&((i+1)==6) &&(LODindex_DYN[layer_num].draw_style==6))  ||
		  ((LODindex_DYN[layer_num].geom==C_AREA)&&((i+1)==7) &&(LODindex_DYN[layer_num].draw_style==7))  ||
		  ((LODindex_DYN[layer_num].geom==C_AREA)&&((i+1)==8) &&(LODindex_DYN[layer_num].draw_style==8))  ||
		  ((LODindex_DYN[layer_num].geom==C_AREA)&&((i+1)==9) &&(LODindex_DYN[layer_num].draw_style==9))  ||
		  ((LODindex_DYN[layer_num].geom==C_AREA)&&((i+1)==10)&&(LODindex_DYN[layer_num].draw_style==10)) ||
		  ((LODindex_DYN[layer_num].geom==C_AREA)&&((i+1)==11)&&(LODindex_DYN[layer_num].draw_style==12)) ||
		  ((LODindex_DYN[layer_num].geom==C_AREA)&&((i+1)==12)&&(LODindex_DYN[layer_num].draw_style==11)) ||
		  ((LODindex_DYN[layer_num].geom==C_AREA)&&((i+1)==13)&&(LODindex_DYN[layer_num].draw_style==13)) ||

		  ((LODindex_DYN[layer_num].geom==C_GRID)&&(i==0) &&(LODindex_DYN[layer_num].draw_style==0))  ||
		  ((LODindex_DYN[layer_num].geom==C_GRID)&&(i==1) &&(LODindex_DYN[layer_num].draw_style==1))  ||
		  ((LODindex_DYN[layer_num].geom==C_GRID)&&(i==2) &&(LODindex_DYN[layer_num].draw_style==2))  ||
		  ((LODindex_DYN[layer_num].geom==C_GRID)&&(i==3) &&(LODindex_DYN[layer_num].draw_style==3))  ||
		  ((LODindex_DYN[layer_num].geom==C_GRID)&&(i==4) &&(LODindex_DYN[layer_num].draw_style==4))  ||
		  ((LODindex_DYN[layer_num].geom==C_GRID)&&(i==5) &&(LODindex_DYN[layer_num].draw_style==5))  ||
		  ((LODindex_DYN[layer_num].geom==C_GRID)&&(i==6) &&(LODindex_DYN[layer_num].draw_style==6))  ||
		  ((LODindex_DYN[layer_num].geom==C_GRID)&&(i==7) &&(LODindex_DYN[layer_num].draw_style==7))  ||
		  ((LODindex_DYN[layer_num].geom==C_GRID)&&(i==8) &&(LODindex_DYN[layer_num].draw_style==8))  ||
		  ((LODindex_DYN[layer_num].geom==C_GRID)&&(i==9) &&(LODindex_DYN[layer_num].draw_style==9))  ||
		  ((LODindex_DYN[layer_num].geom==C_GRID)&&(i==10)&&(LODindex_DYN[layer_num].draw_style==10)) ||
		  ((LODindex_DYN[layer_num].geom==C_GRID)&&(i==11)&&(LODindex_DYN[layer_num].draw_style==12)) ||
		  ((LODindex_DYN[layer_num].geom==C_GRID)&&(i==12)&&(LODindex_DYN[layer_num].draw_style==11)) ||
		  ((LODindex_DYN[layer_num].geom==C_GRID)&&(i==13)&&(LODindex_DYN[layer_num].draw_style==13))

        )
	{
	  
	  XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);
	}
      
      
      if (items[i].callback)
	XtAddCallback (widget,
		       (items[i].cclass == &xmToggleButtonWidgetClass ||
			items[i].cclass == &xmToggleButtonWidgetClass) ?
		       XmNvalueChangedCallback : 
		       XmNactivateCallback,      
		       (XtCallbackProc)items[i].callback, (XtPointer)cbvalue);
    }
  return menu_type == XmMENU_POPUP ? menu : cascade;
}




Widget BuildEqualMenu(Widget parent,int menu_type,char *menu_title,MenuItem *items, int layer_num)
{
  Widget menu, cascade, widget;
  int i,n=0,cbvalue;
  XmString str;
  Arg args[5];
  
  
  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);
  
  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId, menu);  n++;
  XtSetArg (args[n], XmNlabelString, str); n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;
  
  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);
  
  for (i = 0; items[i].label != NULL; i++) 
    {
      cbvalue = (int)items[i].callback_data + layer_num*1000;
      
      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);
      
      
      if(i==LODindex_DYN[layer_num].equal_type)
	{
	  
	  XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);
	}
      
      
      if (items[i].callback)
	XtAddCallback (widget,
		       (items[i].cclass == &xmToggleButtonWidgetClass ||
			items[i].cclass == &xmToggleButtonWidgetClass) ?
		       XmNvalueChangedCallback : 
		       XmNactivateCallback,      
		       (XtCallbackProc)items[i].callback, (XtPointer)cbvalue);
    }
  return menu_type == XmMENU_POPUP ? menu : cascade;
}




void choose_layer_color(Widget pb, XtPointer client_data, XtPointer call_data)
{ 
  Widget rowcol,form,Done,area_style_menu,grid_style_menu,label1,tempwid,equal_menu;
  Dimension Pheight;
  Arg resources[50];
  char junk[1000],text_setr[100],text_setg[100],text_setb[100],tempstr[100];
  int n=0,setr,setg,setb,colornum,i,thiswidth=620;
  int layer_num = (int)client_data;
  
  
  MenuItem area_style[] = {
    {"Outline Only",            &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())area_style_cb,(XtPointer)1,(MenuItem *)NULL },
    {"Light Filling",           &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())area_style_cb,(XtPointer)2,(MenuItem *)NULL },
    {"Medium Filling",          &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())area_style_cb,(XtPointer)3,(MenuItem *)NULL },
    {"Heavy Filling",           &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())area_style_cb,(XtPointer)4,(MenuItem *)NULL },
    {"Fully Filled",            &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())area_style_cb,(XtPointer)5,(MenuItem *)NULL },
    {"Dense Horizontal Lines",  &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())area_style_cb,(XtPointer)6,(MenuItem *)NULL },
    {"Sparse Horizontal Lines", &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())area_style_cb,(XtPointer)7,(MenuItem *)NULL },
    {"Dense Vertical Lines",    &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())area_style_cb,(XtPointer)8,(MenuItem *)NULL },
    {"Sparse Vertical Lines",   &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())area_style_cb,(XtPointer)9,(MenuItem *)NULL },
    {"Dense NW/SE Lines",       &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())area_style_cb,(XtPointer)10,(MenuItem *)NULL },
    {"Sparse NW/SE Lines",      &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())area_style_cb,(XtPointer)12,(MenuItem *)NULL },
    {"Dense NE/SW Lines",       &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())area_style_cb,(XtPointer)11,(MenuItem *)NULL },
    {"Sparse NE/SW Lines",      &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())area_style_cb,(XtPointer)13,(MenuItem *)NULL },
    {NULL},
  };


  MenuItem grid_style[] = {
    {"Grey Shaded",                     &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())area_style_cb,(XtPointer)0,(MenuItem *)NULL },
    {"Posts (Color)",         &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())area_style_cb,(XtPointer)1,(MenuItem *)NULL },
    {"Light Filling (Color)",           &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())area_style_cb,(XtPointer)2,(MenuItem *)NULL },
    {"Medium Filling (Color)",          &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())area_style_cb,(XtPointer)3,(MenuItem *)NULL },
    {"Heavy Filling (Color)",           &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())area_style_cb,(XtPointer)4,(MenuItem *)NULL },
    {"Fully Filled (Color)",            &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())area_style_cb,(XtPointer)5,(MenuItem *)NULL },
    {"Dense Horizontal Lines (Color)",  &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())area_style_cb,(XtPointer)6,(MenuItem *)NULL },
    {"Sparse Horizontal Lines (Color)", &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())area_style_cb,(XtPointer)7,(MenuItem *)NULL },
    {"Dense Vertical Lines (Color)",    &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())area_style_cb,(XtPointer)8,(MenuItem *)NULL },
    {"Sparse Vertical Lines (Color)",   &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())area_style_cb,(XtPointer)9,(MenuItem *)NULL },
    {"Dense NW/SE Lines (Color)",       &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())area_style_cb,(XtPointer)10,(MenuItem *)NULL },
    {"Sparse NW/SE Lines (Color)",      &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())area_style_cb,(XtPointer)12,(MenuItem *)NULL },
    {"Dense NE/SW Lines (Color)",       &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())area_style_cb,(XtPointer)11,(MenuItem *)NULL },
    {"Sparse NE/SW Lines (Color)",      &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())area_style_cb,(XtPointer)13,(MenuItem *)NULL },
    {NULL},
  };


  MenuItem equal_style[] = {
    {"Less than",                     &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())equal_style_cb,(XtPointer)0,(MenuItem *)NULL },
    {"Equal to",         &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())equal_style_cb,(XtPointer)1,(MenuItem *)NULL },
    {"Greater than",           &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())equal_style_cb,(XtPointer)2,(MenuItem *)NULL },
    {NULL},
  };





  if(layers_up[layer_num]==0)
    {
      sprintf(junk,"Set color for layer: %s (%s) (%s) (%s)",
	      GetECCCode (LODindex_DYN[layer_num].ECC),
	      GetECCLabel(LODindex_DYN[layer_num].ECC),
	      GetShortGeomName(LODindex_DYN[layer_num].geom),
	      LODindex[LODindex_DYN[layer_num].other_index].filename);

      


      
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++; 
      XtSetArg(resources[n],  XmNwidth         , thiswidth); n++; 
      XtSetArg(resources[n],  XmNmaxWidth,       thiswidth); n++;

      toplevel[layer_num] = XtCreatePopupShell
	(junk,topLevelShellWidgetClass,drawing_a,resources,n);
      
      layer_colors[layer_num].flags = DoRed | DoGreen | DoBlue;
      
      
      if(LODindex[LODindex_DYN[layer_num].other_index].color!=-1)
	{
	  setr = LODindex[LODindex_DYN[layer_num].other_index].rcolor/256;
	  setg = LODindex[LODindex_DYN[layer_num].other_index].gcolor/256;
	  setb = LODindex[LODindex_DYN[layer_num].other_index].bcolor/256;



	  
	  layer_colors[layer_num].red   = LODindex[LODindex_DYN[layer_num].other_index].rcolor;
	  layer_colors[layer_num].green = LODindex[LODindex_DYN[layer_num].other_index].gcolor;
	  layer_colors[layer_num].blue  = LODindex[LODindex_DYN[layer_num].other_index].bcolor;



	  LODindex[LODindex_DYN[layer_num].other_index].temp_color = LODindex[LODindex_DYN[layer_num].other_index].color;
	  LODindex[LODindex_DYN[layer_num].other_index].firsttime = 1;
	}
      else
	{
	  layer_colors[layer_num].red   = 0;
	  layer_colors[layer_num].green = 0;
	  layer_colors[layer_num].blue  = 0;
	  setr = 0;
	  setg = 0;
	  setb = 0;
	  LODindex[LODindex_DYN[layer_num].other_index].temp_color = mycolors[DRAW_COLOR_BLACK];
	  LODindex[LODindex_DYN[layer_num].other_index].firsttime = 1;
	}
      
      
      sprintf(text_setr,"%d",setr);
      sprintf(text_setg,"%d",setg);
      sprintf(text_setb,"%d",setb);
            
      
      rowcol = XtVaCreateManagedWidget ("rowcol",
					xmRowColumnWidgetClass, toplevel[layer_num], NULL);
      



      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      

      if( (LODindex_DYN[layer_num].geom==C_AREA)|| (LODindex_DYN[layer_num].geom==C_GRID))
	{
	  

	  label1 = XtVaCreateManagedWidget ("lab1",
					    xmLabelWidgetClass, form,
					    XmNtopAttachment,     XmATTACH_FORM,
					    XmNbottomAttachment,  XmATTACH_FORM,
					    XmNrightAttachment,   XmATTACH_POSITION,
					    XmNrightPosition,     50,
					    XmNleftAttachment,    XmATTACH_POSITION,
					    XmNleftPosition,      0,
					    XmNalignment,         XmALIGNMENT_CENTER,
					    XmNlabelString,       STRING("Color"),
					    LABELWTRANSLATE,
					    NULL);
	  
	  label1 = XtVaCreateManagedWidget ("lab1",
					    xmLabelWidgetClass, form,
					    XmNtopAttachment,     XmATTACH_FORM,
					    XmNbottomAttachment,  XmATTACH_FORM,
					    XmNrightAttachment,   XmATTACH_POSITION,
					    XmNrightPosition,     100,
					    XmNleftAttachment,    XmATTACH_POSITION,
					    XmNleftPosition,      50,
					    XmNalignment,         XmALIGNMENT_CENTER,
					    XmNlabelString,       STRING("Color with Style"),
					    LABELWTRANSLATE,
					    NULL);
	}
      else
	{
	  label1 = XtVaCreateManagedWidget ("lab1",
					    xmLabelWidgetClass, form,
					    XmNtopAttachment,     XmATTACH_FORM,
					    XmNbottomAttachment,  XmATTACH_FORM,
					    XmNrightAttachment,   XmATTACH_POSITION,
					    XmNrightPosition,     100,
					    XmNleftAttachment,    XmATTACH_POSITION,
					    XmNleftPosition,      0,
					    XmNalignment,         XmALIGNMENT_CENTER,
					    XmNlabelString,       STRING("Color"),
					    LABELWTRANSLATE,
					    NULL);
	}

      XtManageChild(form);



      

      layer_colorwindows[layer_num] = 
	XtVaCreateManagedWidget ("colorwindow",
				 xmDrawingAreaWidgetClass, rowcol,
				 XmNunitType,     XmPIXELS,
				 XmNwidth,        thiswidth, 
				 XmNheight,       100, 
				 XmNresizePolicy, XmNONE,
				 XmNbackground,   LODindex[LODindex_DYN[layer_num].other_index].temp_color,
				 NULL);


      XtAddCallback (layer_colorwindows[layer_num], XmNexposeCallback, redraw_net, (XtPointer) (layer_num+5000));  

      if(layer_colorpix[layer_num]==123987517)
	{

	  layer_colorpix[layer_num] = 
	    XCreatePixmap (mydisplay,
			   RootWindowOfScreen (XtScreen (layer_colorwindows[layer_num])), 450,100,
			   DefaultDepthOfScreen (XtScreen (layer_colorwindows[layer_num])));
	}


      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
 


      scale1[layer_num] = XtVaCreateManagedWidget ("Red",
						   xmScaleWidgetClass, form,
						   XmNtraversalOn,     False,
						   XmNshowValue,       True,
						   XmNmaximum,         255,
						   XmNscaleMultiple,   5,
						   XmNvalue,           setr,
						   XmNleftAttachment,  XmATTACH_POSITION,
						   XmNleftPosition,    0,
						   XmNrightAttachment, XmATTACH_POSITION,
						   XmNrightPosition,   33,
						   XtVaTypedArg,       XmNtitleString, XmRString, "Red", 4,
						   XtVaTypedArg,       XmNforeground,  XmRString, "Red", 4,
						   NULL);
      XtAddCallback (scale1[layer_num], XmNdragCallback, new_value, (XtPointer)(layer_num*1000 + DoRed));
      XtAddCallback (scale1[layer_num], XmNvalueChangedCallback, new_value, (XtPointer)(layer_num*1000 + DoRed));
      
      
      scale2[layer_num] = XtVaCreateManagedWidget ("Green",
						   xmScaleWidgetClass, form,
						   XmNtraversalOn,     False,
						   XmNshowValue,       True,
						   XmNmaximum,         255,
						   XmNscaleMultiple,   5,
						   XmNvalue,           setg,
						   XmNleftAttachment,  XmATTACH_POSITION,
						   XmNleftPosition,    33,
						   XmNrightAttachment, XmATTACH_POSITION,
						   XmNrightPosition,   66,
						   XtVaTypedArg,       XmNtitleString, XmRString, "Green", 6,
						   XtVaTypedArg,       XmNforeground,  XmRString, "Green", 6,
						   NULL);
      XtAddCallback (scale2[layer_num], XmNdragCallback, new_value, (XtPointer)(layer_num*1000 + DoGreen));
      XtAddCallback (scale2[layer_num], XmNvalueChangedCallback, new_value, (XtPointer)(layer_num*1000 + DoGreen));
      
      scale3[layer_num] = XtVaCreateManagedWidget ("Blue",
						   xmScaleWidgetClass, form,
						   XmNtraversalOn,     False,
						   XmNshowValue,       True,
						   XmNmaximum,         255,
						   XmNscaleMultiple,   5,
						   XmNvalue,           setb,
						   XmNleftAttachment,  XmATTACH_POSITION,
						   XmNleftPosition,    66,
						   XmNrightAttachment, XmATTACH_POSITION,
						   XmNrightPosition,   99,
						   XtVaTypedArg,       XmNtitleString, XmRString, "Blue", 5,
						   XtVaTypedArg,       XmNforeground, XmRString, "Blue", 5,
						   NULL);
      XtAddCallback (scale3[layer_num], XmNdragCallback, new_value, (XtPointer)(layer_num*1000 + DoBlue));
      XtAddCallback (scale3[layer_num], XmNvalueChangedCallback, new_value, (XtPointer)(layer_num*1000 + DoBlue));
      
      XtManageChild(form);
      
      
      




      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      layer_text1[layer_num] = XtVaCreateManagedWidget ("Red",
							  xmTextFieldWidgetClass, form,
							  XmNvalue,           text_setr,
							  XmNmaxLength,       3, 
							  XmNleftAttachment,  XmATTACH_POSITION,
							  XmNleftPosition,    0,
							  XmNrightAttachment, XmATTACH_POSITION,
							  XmNrightPosition,   33,
                              XmNtranslations,    XtParseTranslationTable ( translations_paste ) ,
							  NULL);
      XtAddCallback (layer_text1[layer_num], XmNvalueChangedCallback, layer_new_text_value, 
		     (XtPointer)(layer_num*1000 + DoRed));
      
      
      
      
      layer_text2[layer_num] = XtVaCreateManagedWidget ("Green",
							  xmTextFieldWidgetClass, form,
							  XmNvalue,           text_setg,
							  XmNmaxLength,       3, 
							  XmNleftAttachment,  XmATTACH_POSITION,
							  XmNleftPosition,    33,
							  XmNrightAttachment, XmATTACH_POSITION,
							  XmNrightPosition,   66,
                              XmNtranslations,    XtParseTranslationTable ( translations_paste ) ,
							  NULL);
      XtAddCallback (layer_text2[layer_num], XmNvalueChangedCallback, layer_new_text_value, 
		     (XtPointer)(layer_num*1000 + DoGreen));
      
      
      
      layer_text3[layer_num] = XtVaCreateManagedWidget ("Blue",
							  xmTextFieldWidgetClass, form,
							  XmNvalue,           text_setb,
							  XmNmaxLength,       3, 
							  XmNleftAttachment,  XmATTACH_POSITION,
							  XmNleftPosition,    66,
							  XmNrightAttachment, XmATTACH_POSITION,
							  XmNrightPosition,   99,
                              XmNtranslations,    XtParseTranslationTable ( translations_paste ) ,
							  NULL);
      XtAddCallback (layer_text3[layer_num], XmNvalueChangedCallback, layer_new_text_value, 
		     (XtPointer)(layer_num*1000 + DoBlue));
      
      
      XtManageChild(form);
















      
      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      for(i=0;i<4;i++)
	{
	  
	  if(i==1){colornum = DRAW_COLOR_GRAY64;  }
	  if(i==2){colornum = DRAW_COLOR_GRAY128; }
	  if(i==3){colornum = DRAW_COLOR_GRAY192; }
	  if(i==0){colornum = DRAW_COLOR_BLACK;   }
	  
	  
	  
	  pb  = XtVaCreateManagedWidget("A color",xmPushButtonWidgetClass,form,
					XmNlabelString,       STRING("   "),
					XmNtraversalOn,       False,
					XmNbackground,        mycolors[colornum],
					XmNforeground,        mycolors[colornum],
					XmNtopShadowColor,    mycolors[DRAW_COLOR_BLACK],
					XmNbottomShadowColor, mycolors[DRAW_COLOR_BLACK],
					XmNleftAttachment,    XmATTACH_POSITION,
					XmNleftPosition,      (0+25*i),
					XmNrightAttachment,   XmATTACH_POSITION,
					XmNrightPosition,     (25+25*i),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
	  XtAddCallback(pb, XmNactivateCallback,
			new_value2, (XtPointer) (layer_num*1000 +colornum));
	  XtManageChild(pb);
	  
	}
      
      XtManageChild(form);
      
      
      
      
      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      for(i=0;i<4;i++)
	{
	  
	  if(i==0){colornum = DRAW_COLOR_LTGREEN;   }
	  if(i==1){colornum = DRAW_COLOR_MEDGREEN;  }
	  if(i==2){colornum = DRAW_COLOR_MEDGREEN2; }
	  if(i==3){colornum = DRAW_COLOR_TAN;     }
	  
	  pb  = XtVaCreateManagedWidget("A color",xmPushButtonWidgetClass,form,
					XmNlabelString, STRING("   "),
					XmNtraversalOn,      False,
					XmNbackground,       mycolors[colornum],
					XmNforeground,       mycolors[colornum],
					XmNtopShadowColor,   mycolors[DRAW_COLOR_BLACK],
					XmNbottomShadowColor,mycolors[DRAW_COLOR_BLACK],
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     (0+25*i),
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    (25+25*i),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
	  XtAddCallback(pb, XmNactivateCallback,
			new_value2, (XtPointer) (layer_num*1000 +colornum));
	  XtManageChild(pb);
	  
	}
      
      XtManageChild(form);
      



      
      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      for(i=0;i<4;i++)
	{
	  if(i==0){colornum = DRAW_COLOR_LAVENDER; }
	  if(i==1){colornum = DRAW_COLOR_LTCYAN;   }
	  if(i==2){colornum = DRAW_COLOR_DKCYAN;   }
	  if(i==3){colornum = DRAW_COLOR_BLUE;     }
	  
	  
	  pb  = XtVaCreateManagedWidget("A color",xmPushButtonWidgetClass,form,
					XmNlabelString, STRING("   "),
					XmNtraversalOn,      False,
					XmNbackground,       mycolors[colornum],
					XmNforeground,       mycolors[colornum],
					XmNtopShadowColor,   mycolors[DRAW_COLOR_BLACK],
					XmNbottomShadowColor,mycolors[DRAW_COLOR_BLACK],
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     (0+25*i),
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    (25+25*i),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
	  XtAddCallback(pb, XmNactivateCallback,
			new_value2, (XtPointer) (layer_num*1000 +colornum));
	  XtManageChild(pb);
	  
	}
      
      XtManageChild(form);
      
      
      
      
      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      for(i=0;i<4;i++)
	{
	  
	  if(i==0){colornum = DRAW_COLOR_MAGENTA;  }
	  if(i==1){colornum = DRAW_COLOR_YELLOW; }
	  if(i==2){colornum = DRAW_COLOR_BROWN;  }
	  if(i==3){colornum = DRAW_COLOR_PURPLE; }
	  
	  pb  = XtVaCreateManagedWidget("A color",xmPushButtonWidgetClass,form,
					XmNlabelString, STRING("   "),
					XmNbackground,       mycolors[colornum],
					XmNtraversalOn,      False,
					XmNforeground,       mycolors[colornum],
					XmNtopShadowColor,   mycolors[DRAW_COLOR_BLACK],
					XmNbottomShadowColor,mycolors[DRAW_COLOR_BLACK],
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    (0+25*i),
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    (25+25*i),
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
	  XtAddCallback(pb, XmNactivateCallback,
			new_value2, (XtPointer) (layer_num*1000 +colornum));
	  XtManageChild(pb);
	  
	}
      
      XtManageChild(form);
      
      
      


      if(LODindex_DYN[layer_num].geom==C_AREA)
	{
      
	  form = XtVaCreateWidget ("form2", xmFormWidgetClass, rowcol,
				   XmNfractionBase,  100,  
				   NULL);
	  
	  
	  area_style_menu = BuildStyleMenu (form, XmMENU_OPTION, "Fill/Transparency/Style:", area_style,layer_num);
	  
	  XtManageChild(area_style_menu);
	  
	  XtManageChild(form);
	  
	}
      
      else if(LODindex_DYN[layer_num].geom==C_GRID)
	{
      
	  form = XtVaCreateWidget ("form2", xmFormWidgetClass, rowcol,
				   XmNfractionBase,  100,  
				   NULL);
	  
	  
	  grid_style_menu = BuildStyleMenu (form, XmMENU_OPTION, "Grid Draw Style:", grid_style,layer_num);
	  
	  XtManageChild(grid_style_menu);
	  
	  XtManageChild(form);
	  


	  form = XtVaCreateWidget ("form2", xmFormWidgetClass, rowcol,
				   XmNfractionBase,  100,  
				   NULL);

	  tempwid =
	    XtVaCreateManagedWidget ("the_test",
				     xmToggleButtonWidgetClass, form,
				     XmNtopAttachment,    XmATTACH_FORM,
				     XmNbottomAttachment, XmATTACH_FORM,
				     
				     XmNleftAttachment,  XmATTACH_POSITION,
					 XmNleftPosition,    0,

				     XmNtraversalOn,      False,
				     XmNlabelString,      STRING("Do not draw posts with value:"),
				     XmNtranslations,     XtParseTranslationTable (translations_global),
				     TOGGLEINCLUDE,
				     NULL);
	  

	  XmToggleButtonSetState(tempwid,
				 (Boolean)LODindex_DYN[layer_num].do_discrete,(Boolean)0);
	  XtManageChild(tempwid);





	  equal_menu = BuildEqualMenu (form, XmMENU_OPTION, "", equal_style,layer_num);

	  XtVaSetValues(equal_menu,  
			XmNleftAttachment,   XmATTACH_WIDGET,
			XmNleftWidget,       tempwid,
			XmNtopAttachment,    XmATTACH_FORM,
			XmNbottomAttachment, XmATTACH_FORM,
			XmNtraversalOn,      False,

			NULL);	  
	  XtManageChild(equal_menu);






      sprintf(tempstr,"%.4lf",LODindex_DYN[layer_num].discrete_ignore_value);
      
      LODindex_DYN[layer_num].discrete_value_wid = XtVaCreateManagedWidget ("dvw",
					  xmTextFieldWidgetClass, form,	  
					  XmNvalue,            tempstr,
					  XmNtraversalOn,      True,
			XmNleftAttachment,   XmATTACH_WIDGET,
			XmNleftWidget,       equal_menu,

	  XmNrightAttachment,  XmATTACH_POSITION,
	  XmNrightPosition,    99,

					  XmNmaxLength,10,
                      XmNtranslations,     XtParseTranslationTable ( translations_paste ) ,
					  NULL);
      XtManageChild(LODindex_DYN[layer_num].discrete_value_wid);
      XtAddCallback (LODindex_DYN[layer_num].discrete_value_wid, XmNactivateCallback,
		     (XtCallbackProc)discrete_result, (XtPointer)layer_num);








	  XtManageChild(form);
	  XtAddCallback (tempwid, XmNvalueChangedCallback, TogDiscreteCallback, (XtPointer)layer_num);







	  form = XtVaCreateWidget ("form2", xmFormWidgetClass, rowcol,
				   XmNfractionBase,  100,  
				   NULL);


	  tempwid =
	    XtVaCreateManagedWidget ("the_test",
				     xmToggleButtonWidgetClass, form,
				     XmNtopAttachment,    XmATTACH_FORM,
				     XmNbottomAttachment, XmATTACH_FORM,
				     XmNleftAttachment,  XmATTACH_POSITION,
					 XmNleftPosition,    10,
				     XmNtraversalOn,      False,
				     XmNlabelString,      STRING("Draw outline around non-excluded posts"),
				     XmNtranslations,     XtParseTranslationTable (translations_global),
				     TOGGLEINCLUDE,
				     NULL);
	  

	  XmToggleButtonSetState(tempwid,
				 (Boolean)LODindex_DYN[layer_num].do_outline,(Boolean)0);
	  XtManageChild(tempwid);

	  XtManageChild(form);
	  XtAddCallback (tempwid, XmNvalueChangedCallback, TogOutlineCallback, (XtPointer)layer_num);


	}


	  


      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      Done  = XtVaCreateManagedWidget("Apply color/style",xmPushButtonWidgetClass,form,
				      XmNlabelString, STRING("Apply Color/Style"),
				      XmNtraversalOn,     False,
				      XmNleftAttachment,  XmATTACH_POSITION,
				      XmNleftPosition,    0,
				      XmNrightAttachment, XmATTACH_POSITION,
				      XmNrightPosition,   65,
				      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 
      
      XtAddCallback(Done, XmNactivateCallback,
		    apply_layer_callback, (XtPointer) layer_num);
      XtManageChild(Done);


      Done  = XtVaCreateManagedWidget("Reset color",xmPushButtonWidgetClass,form,
				      XmNlabelString, STRING("Reset color"),
				      XmNtraversalOn,     False,
				      XmNleftAttachment,  XmATTACH_POSITION,
				      XmNleftPosition,    65,
				      XmNrightAttachment, XmATTACH_POSITION,
				      XmNrightPosition,   99,
				      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 
      
      XtAddCallback(Done, XmNactivateCallback,
		    reset_layer_color, (XtPointer) layer_num);
      XtManageChild(Done);


      XtManageChild(form);
      
      
      
      
      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      Done  = XtVaCreateManagedWidget("Done/Cancel",xmPushButtonWidgetClass,form,
				      XmNlabelString, STRING("Done/Cancel"),
				      XmNtraversalOn,     False,
				      XmNleftAttachment,  XmATTACH_POSITION,
				      XmNleftPosition,    51,
				      XmNrightAttachment, XmATTACH_POSITION,
				      XmNrightPosition,   99,
				      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 
      
      XtAddCallback(Done, XmNactivateCallback,
		    exitCallback, (XtPointer) 34);
      XtManageChild(Done);
      
      
            
      Done  = XtVaCreateManagedWidget("Abort color",xmPushButtonWidgetClass,form,
				      XmNlabelString, STRING("Help"),
				      XmNtraversalOn,     False,
				      XmNleftAttachment,  XmATTACH_POSITION,
				      XmNleftPosition,    0,
				      XmNrightAttachment, XmATTACH_POSITION,
				      XmNrightPosition,   50,
				      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 
      
      XtAddCallback(Done, XmNactivateCallback,
		    help_layer_callback, (XtPointer) layer_num);
      XtManageChild(Done);
      
      
      XtManageChild(form);
      
      XtManageChild (rowcol);
      MyPopup(toplevel[layer_num]); 
      XtAddCallback(toplevel[layer_num],XmNdestroyCallback,ShellDeath,(XtPointer)(15000+layer_num));
      layers_up[layer_num] = 1;


      XtVaGetValues(toplevel[layer_num], XmNheight,    &Pheight,   NULL);	  
      XtVaSetValues(toplevel[layer_num], XmNminHeight,  Pheight, NULL);
      XtVaSetValues(toplevel[layer_num], XmNmaxHeight,  Pheight, NULL);

      XtAddEventHandler(toplevel[layer_num],StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)Pheight));

    }
  else
    {
      ResetWidget(toplevel[layer_num]);
    }

  
  SetLayerColorWin(layer_num,LODindex[LODindex_DYN[layer_num].other_index].temp_color,
		   LODindex_DYN[layer_num].draw_style);

}





void all_layers_onoff(Widget w, XtPointer userData, XtPointer callData)
{
  int onoff = (int)userData;
  int i;
  
  for(i=0;i<NumLODbands;i++)
    {
      XmToggleButtonSetState(LOD[i],(Boolean)onoff,(Boolean)1);
    }
}


void layergeom_offCallback(Widget w, XtPointer userData, XtPointer callData)
{
  int diegeom = (int)userData;
  int i,onoff = 0;

  for(i=0;i<NumLODbands;i++)
    {
      if(LODindex[i].geomtype_single==diegeom)
	{
	  XmToggleButtonSetState(LOD[i],(Boolean)onoff,(Boolean)1);
	}
    }
}


void layergeom_onCallback(Widget w, XtPointer userData, XtPointer callData)
{
  int diegeom = (int)userData;
  int i,onoff = 1;

  for(i=0;i<NumLODbands;i++)
    {
      if(LODindex[i].geomtype_single==diegeom)
	{
	  XmToggleButtonSetState(LOD[i],(Boolean)onoff,(Boolean)1);
	}
    }
}



int DomainFound(int thisdomain)
{
  int i;

  for(i=0;i<NumLODbands;i++)
    {
      if(DOMAINS[LODindex_DYN[i].ECC]==thisdomain)
	{
	  return 1;
	}
    }
  return 0;
}



int MGCPFound(int thisdomain)
{
  int i;

  

  for(i=0;i<NumLODbands;i++)
    {
       if(
		   (thisdomain==0)                             &&
		   (IS_MGCP_OTHER(LODindex_DYN[i].ECC)==1)     &&
		   (LODindex_DYN[i].geom==C_AREA)
		   )
	   {
		   return 1;
	   }
       if(
		   (thisdomain==1)                             &&
		   (IS_MGCP_ACTIVITY(LODindex_DYN[i].ECC)==1)  &&
		   (LODindex_DYN[i].geom==C_AREA)
		   )
	   {
		   return 1;
	   }
       if(
		   (thisdomain==2)                             &&
		   (IS_MGCP_LANDCOVER(LODindex_DYN[i].ECC)==1) &&
		   (LODindex_DYN[i].geom==C_AREA)
		   )
	   {
		   return 1;
	   }
   }
  return 0;
}



void layerfc_offCallback(Widget w, XtPointer userData, XtPointer callData)
{
  int diedomain = (int)userData;
  int i,onoff = 0;
  
  for(i=0;i<NumLODbands;i++)
    {
      if(DOMAINS[LODindex_DYN[LODindex[i].other_index].ECC]==diedomain)
	{
	  XmToggleButtonSetState(LOD[i],(Boolean)onoff,(Boolean)1);
	}
    }
}


void layerfc_onCallback(Widget w, XtPointer userData, XtPointer callData)
{
  int diedomain = (int)userData;
  int i,onoff   = 1;
  
  for(i=0;i<NumLODbands;i++)
    {
      if(DOMAINS[LODindex_DYN[LODindex[i].other_index].ECC]==diedomain)
	{
	  XmToggleButtonSetState(LOD[i],(Boolean)onoff,(Boolean)1);
	}
    }
}




void layermgcp_offCallback(Widget w, XtPointer userData, XtPointer callData)
{
  int thisdomain = (int)userData;
  int i,onoff = 0;
  
  for(i=0;i<NumLODbands;i++)
    {
      if(
		  (thisdomain==0)                                            &&
		  (IS_MGCP_OTHER(LODindex_DYN[LODindex[i].other_index].ECC)) &&
          (LODindex_DYN[LODindex[i].other_index].geom==C_AREA)
		  )
	  {
	    XmToggleButtonSetState(LOD[i],(Boolean)onoff,(Boolean)1);
	  }
      if(
		  (thisdomain==1)                                               &&
		  (IS_MGCP_ACTIVITY(LODindex_DYN[LODindex[i].other_index].ECC)) &&
          (LODindex_DYN[LODindex[i].other_index].geom==C_AREA)
		  )
	  {
	    XmToggleButtonSetState(LOD[i],(Boolean)onoff,(Boolean)1);
	  }
      if(
		  (thisdomain==2)                                                &&
		  (IS_MGCP_LANDCOVER(LODindex_DYN[LODindex[i].other_index].ECC)) &&
          (LODindex_DYN[LODindex[i].other_index].geom==C_AREA)
		  )
	  {
	    XmToggleButtonSetState(LOD[i],(Boolean)onoff,(Boolean)1);
	  }

    }
}


void layermgcp_onCallback(Widget w, XtPointer userData, XtPointer callData)
{
  int thisdomain = (int)userData;
  int i,onoff = 1;
  
  for(i=0;i<NumLODbands;i++)
    {
      if(
		  (thisdomain==0)                                            &&
		  (IS_MGCP_OTHER(LODindex_DYN[LODindex[i].other_index].ECC)) &&
          (LODindex_DYN[LODindex[i].other_index].geom==C_AREA)
		  )
	  {
	    XmToggleButtonSetState(LOD[i],(Boolean)onoff,(Boolean)1);
	  }
      if(
		  (thisdomain==1)                                               &&
		  (IS_MGCP_ACTIVITY(LODindex_DYN[LODindex[i].other_index].ECC)) &&
          (LODindex_DYN[LODindex[i].other_index].geom==C_AREA)
		  )
	  {
	    XmToggleButtonSetState(LOD[i],(Boolean)onoff,(Boolean)1);
	  }
      if(
		  (thisdomain==2)                                                &&
		  (IS_MGCP_LANDCOVER(LODindex_DYN[LODindex[i].other_index].ECC)) &&
          (LODindex_DYN[LODindex[i].other_index].geom==C_AREA)
		  )
	  {
	    XmToggleButtonSetState(LOD[i],(Boolean)onoff,(Boolean)1);
	  }

    }
}




void select_layers_by_fc(Widget w, XtPointer userData, XtPointer callData)
{

  static Widget dialog;
  Widget rc,form,button;
  Arg resources[15];
  char temp[1000];
  int n=0,i;
  
  if(LAYER_FC_UP==1)
    {
      ResetWidget(dialog);
      return;
    }


  n=0;
  XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++;

  dialog = XtCreatePopupShell("Select layers by functional category",topLevelShellWidgetClass,w,resources,n);
  
  
  rc = XtVaCreateManagedWidget
    (
     "XformWidget", xmPanedWindowWidgetClass, dialog,
     XmNrubberPositioning, False,
     XmNresizable,         True,
     XmNseparatorOn,       False,
     XmNsashHeight,        1,
     NULL
     );
  



  for(i=0;i<NUM_D;i++)
    {
      if(DomainFound(i)==1)
	{
	  form = XtVaCreateWidget ("form17i", xmFormWidgetClass, rc,
				   XmNpaneMinimum,   25,
				   XmNpaneMaximum,   25,
				   XmNseparatorOn,   False,
				   XmNfractionBase,  100,  
				   NULL);      
	  
	  sprintf(temp,"Select all %s layers",DNAME[i]);
	  
	  button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
					    XmNlabelString,       STRING(temp),
					    XmNtopAttachment,     XmATTACH_FORM,
					    XmNbottomAttachment,  XmATTACH_FORM,
					    XmNrightAttachment,   XmATTACH_POSITION,
					    XmNrightPosition,     50,
					    XmNleftAttachment,    XmATTACH_POSITION,
					    XmNleftPosition,      1,
					    XmNtraversalOn,       False,
					    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					    NULL
					    );
	  
	  XtAddCallback(button, XmNactivateCallback, layerfc_onCallback, (XtPointer)i);
	  XtManageChild(button);
	  
	  sprintf(temp,"De-Select all %s layers",DNAME[i]);
	  
	  button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
					    XmNlabelString,       STRING(temp),
					    XmNtopAttachment,     XmATTACH_FORM,
					    XmNbottomAttachment,  XmATTACH_FORM,
					    XmNrightAttachment,   XmATTACH_POSITION,
					    XmNrightPosition,     99,
					    XmNleftAttachment,    XmATTACH_POSITION,
					    XmNleftPosition,      51,
					    XmNtraversalOn,       False,
					    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					    NULL
					    );
	  
	  XtAddCallback(button, XmNactivateCallback, layerfc_offCallback, (XtPointer)i);
	  XtManageChild(button);
	  
	  XtManageChild(form);
	  
	}
    }

  
  
  form = XtVaCreateWidget ("form17j", xmFormWidgetClass, rc,
			   XmNpaneMinimum,   25,
			   XmNpaneMaximum,   25,
			   XmNseparatorOn,   False,
			   XmNfractionBase,  100,  
			   NULL);      
  
  button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
				    XmNlabelString,       STRING("Help"),
				    XmNtopAttachment,     XmATTACH_FORM,
				    XmNbottomAttachment,  XmATTACH_FORM,
				    XmNrightAttachment,   XmATTACH_POSITION,
				    XmNrightPosition,     33,
				    XmNleftAttachment,    XmATTACH_POSITION,
				    XmNleftPosition,      1,
				    XmNtraversalOn,       False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    );
  
  XtAddCallback(button, XmNactivateCallback, layerfchelpCallback, (XtPointer) NULL);
  XtManageChild(button);
  
  
  
  button  = XtVaCreateManagedWidget("SCR3",xmPushButtonWidgetClass,form,
				    XmNlabelString,       STRING("Cancel"),
				    XmNtopAttachment,     XmATTACH_FORM,
				    XmNbottomAttachment,  XmATTACH_FORM,
				    XmNrightAttachment,   XmATTACH_POSITION,
				    XmNrightPosition,     66,
				    XmNleftAttachment,    XmATTACH_POSITION,
				    XmNleftPosition,      33,
				    XmNtraversalOn,       False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    );
  
  XtAddCallback(button, XmNactivateCallback, die_callback, (XtPointer) 46);
  XtManageChild(button);



  button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
				    XmNlabelString,       STRING("Done"),
				    XmNtopAttachment,     XmATTACH_FORM,
				    XmNbottomAttachment,  XmATTACH_FORM,
				    XmNrightAttachment,   XmATTACH_POSITION,
				    XmNrightPosition,     99,
				    XmNleftAttachment,    XmATTACH_POSITION,
				    XmNleftPosition,      66,
				    XmNtraversalOn,       False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    ); 
  
  XtAddCallback(button, XmNactivateCallback, die_callback, (XtPointer) 46);
  XtManageChild(button);
  XtManageChild(form);


  XtManageChild(rc);
  MyPopup(dialog); 
  
    
  XtAddCallback(dialog,XmNdestroyCallback,ShellDeath,(XtPointer)118);
  
  LAYER_FC_UP = 1;

}



void select_layers_by_geom(Widget w, XtPointer userData, XtPointer callData)
{
  static Widget dialog;
  Widget rc,form,button;
  Arg resources[15];
  int n=0;
  
  if(LAYER_GEOM_UP==1)
    {
      ResetWidget(dialog);
      return;
    }


  n=0;
  XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++;

  dialog = XtCreatePopupShell("Select layers by geometry",topLevelShellWidgetClass,w,resources,n);
  
  
  rc = XtVaCreateManagedWidget
    (
     "XformWidget", xmPanedWindowWidgetClass, dialog,
     XmNrubberPositioning, False,
     XmNresizable,         True,
     XmNseparatorOn,       False,
     XmNsashHeight,        1,
     NULL
     );
  
  
  

  if((Total2DPoint+Total3DPoint)>0)
    {
      form = XtVaCreateWidget ("form17k", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNseparatorOn,   False,
			       XmNfractionBase,  100,  
			       NULL);      
      
      button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
					XmNlabelString,       STRING("Select all Point layers"),
					XmNtopAttachment,     XmATTACH_FORM,
					XmNbottomAttachment,  XmATTACH_FORM,
					XmNrightAttachment,   XmATTACH_POSITION,
					XmNrightPosition,     50,
					XmNleftAttachment,    XmATTACH_POSITION,
					XmNleftPosition,      1,
					XmNtraversalOn,       False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					);
      
      XtAddCallback(button, XmNactivateCallback, layergeom_onCallback, (XtPointer)C_POFE);
      XtManageChild(button);
      
      
      button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
					XmNlabelString,       STRING("De-Select all Point layers"),
					XmNtopAttachment,     XmATTACH_FORM,
					XmNbottomAttachment,  XmATTACH_FORM,
					XmNrightAttachment,   XmATTACH_POSITION,
					XmNrightPosition,     99,
					XmNleftAttachment,    XmATTACH_POSITION,
					XmNleftPosition,      51,
					XmNtraversalOn,       False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					);
      
      XtAddCallback(button, XmNactivateCallback, layergeom_offCallback, (XtPointer)C_POFE);
      XtManageChild(button);
      
      XtManageChild(form);
    }






  if((Total2DLine+Total3DLine)>0)
    {
      form = XtVaCreateWidget ("form17l", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNseparatorOn,   False,
			       XmNfractionBase,  100,  
			       NULL);      
      
      button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
					XmNlabelString,       STRING("Select all Line layers"),
					XmNtopAttachment,     XmATTACH_FORM,
					XmNbottomAttachment,  XmATTACH_FORM,
					XmNrightAttachment,   XmATTACH_POSITION,
					XmNrightPosition,     50,
					XmNleftAttachment,    XmATTACH_POSITION,
					XmNleftPosition,      1,
					XmNtraversalOn,       False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					);
      
      XtAddCallback(button, XmNactivateCallback, layergeom_onCallback, (XtPointer)C_LINE);
      XtManageChild(button);
      
      
      button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
					XmNlabelString,       STRING("De-Select all Line layers"),
					XmNtopAttachment,     XmATTACH_FORM,
					XmNbottomAttachment,  XmATTACH_FORM,
					XmNrightAttachment,   XmATTACH_POSITION,
					XmNrightPosition,     99,
					XmNleftAttachment,    XmATTACH_POSITION,
					XmNleftPosition,      51,
					XmNtraversalOn,       False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					);
      
      XtAddCallback(button, XmNactivateCallback, layergeom_offCallback, (XtPointer)C_LINE);
      XtManageChild(button);
      XtManageChild(form);
    }
      
      
      
  if((Total2DArea+Total3DArea)>0)
    {
      form = XtVaCreateWidget ("form17m", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNseparatorOn,   False,
			       XmNfractionBase,  100,  
			       NULL);      
      
      button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
					XmNlabelString,       STRING("Select all Area layers"),
					XmNtopAttachment,     XmATTACH_FORM,
					XmNbottomAttachment,  XmATTACH_FORM,
					XmNrightAttachment,   XmATTACH_POSITION,
					XmNrightPosition,     50,
					XmNleftAttachment,    XmATTACH_POSITION,
					XmNleftPosition,      1,
					XmNtraversalOn,       False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					);
      
      XtAddCallback(button, XmNactivateCallback, layergeom_onCallback, (XtPointer)C_AREA);
      XtManageChild(button);
      
      
      button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
					XmNlabelString,       STRING("De-Select all Area layers"),
					XmNtopAttachment,     XmATTACH_FORM,
					XmNbottomAttachment,  XmATTACH_FORM,
					XmNrightAttachment,   XmATTACH_POSITION,
					XmNrightPosition,     99,
					XmNleftAttachment,    XmATTACH_POSITION,
					XmNleftPosition,      51,
					XmNtraversalOn,       False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					);
      
      XtAddCallback(button, XmNactivateCallback, layergeom_offCallback, (XtPointer)C_AREA);
      XtManageChild(button);
      XtManageChild(form);
    }


  if(strcmp(GetVariousPeices(4),"0"))
    {
      form = XtVaCreateWidget ("form17n", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNseparatorOn,   False,
			       XmNfractionBase,  100,  
			       NULL);      
      
      button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
					XmNlabelString,       STRING("Select all Gridded layers"),
					XmNtopAttachment,     XmATTACH_FORM,
					XmNbottomAttachment,  XmATTACH_FORM,
					XmNrightAttachment,   XmATTACH_POSITION,
					XmNrightPosition,     50,
					XmNleftAttachment,    XmATTACH_POSITION,
					XmNleftPosition,      1,
					XmNtraversalOn,       False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					);
      
      XtAddCallback(button, XmNactivateCallback, layergeom_onCallback, (XtPointer)C_GRID);
      XtManageChild(button);
      
      
      button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
					XmNlabelString,       STRING("De-Select all Gridded layers"),
					XmNtopAttachment,     XmATTACH_FORM,
					XmNbottomAttachment,  XmATTACH_FORM,
					XmNrightAttachment,   XmATTACH_POSITION,
					XmNrightPosition,     99,
					XmNleftAttachment,    XmATTACH_POSITION,
					XmNleftPosition,      51,
					XmNtraversalOn,       False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					);
      
      XtAddCallback(button, XmNactivateCallback, layergeom_offCallback, (XtPointer)C_GRID);
      XtManageChild(button);
      
      XtManageChild(form);
    }



  
  form = XtVaCreateWidget ("form17o", xmFormWidgetClass, rc,
			   XmNpaneMinimum,   25,
			   XmNpaneMaximum,   25,
			   XmNseparatorOn,   False,
			   XmNfractionBase,  100,  
			   NULL);      
  
  button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
				    XmNlabelString,       STRING("Help"),
				    XmNtopAttachment,     XmATTACH_FORM,
				    XmNbottomAttachment,  XmATTACH_FORM,
				    XmNrightAttachment,   XmATTACH_POSITION,
				    XmNrightPosition,     33,
				    XmNleftAttachment,    XmATTACH_POSITION,
				    XmNleftPosition,      1,
				    XmNtraversalOn,       False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    );
  
  XtAddCallback(button, XmNactivateCallback, layergeomhelpCallback, (XtPointer) NULL);
  XtManageChild(button);
  
  
  
  button  = XtVaCreateManagedWidget("SCR3",xmPushButtonWidgetClass,form,
				    XmNlabelString,       STRING("Cancel"),
				    XmNtopAttachment,     XmATTACH_FORM,
				    XmNbottomAttachment,  XmATTACH_FORM,
				    XmNrightAttachment,   XmATTACH_POSITION,
				    XmNrightPosition,     66,
				    XmNleftAttachment,    XmATTACH_POSITION,
				    XmNleftPosition,      33,
				    XmNtraversalOn,       False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    );
  
  XtAddCallback(button, XmNactivateCallback, die_callback, (XtPointer) 45);
  XtManageChild(button);



  button  = XtVaCreateManagedWidget("SCR4",xmPushButtonWidgetClass,form,
				    XmNlabelString,       STRING("Done"),
				    XmNtopAttachment,     XmATTACH_FORM,
				    XmNbottomAttachment,  XmATTACH_FORM,
				    XmNrightAttachment,   XmATTACH_POSITION,
				    XmNrightPosition,     99,
				    XmNleftAttachment,    XmATTACH_POSITION,
				    XmNleftPosition,      66,
				    XmNtraversalOn,       False,
				    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				    NULL
				    ); 
  
  XtAddCallback(button, XmNactivateCallback, die_callback, (XtPointer) 45);
  XtManageChild(button); 
  XtManageChild(form);


  XtManageChild(rc);
  MyPopup(dialog); 
  
    
  XtAddCallback(dialog,XmNdestroyCallback,ShellDeath,(XtPointer)117);

  
  LAYER_GEOM_UP = 1;

}






int PartitionbyLOD(int p,int r, int type)
{
  char x[500];
  int i,j,xint,temp1,temp2,temp3,temp4,temp5,temp6,temp7,temp8,temp10;
  double temp9;



  if(type==0) 
    {
      sprintf(x,"%s",GetECCCode(LODindex_DYN[p].ECC));
    }
  else if(type==1) 
    {
      xint = LODindex_DYN[p].ECC;
    }
  else if(type==2) 
    {
      xint = LODindex_DYN[p].draw_priority;
    }
  else if(type==3) 
    {
      xint = LODindex_DYN[p].geom;
    }
  else if(type==4) 
    {
      sprintf(x,"%s",LODindex[LODindex_DYN[p].other_index].filename);
    }

  i = p-1;
  j = r+1;
  while(1)
    {
      if(type==0) 
	{
	  do{j=j-1;}
	  while(strcmp(GetECCCode(LODindex_DYN[j].ECC),x)>0);
	  
	  do{i=i+1;}
	  while(strcmp(GetECCCode(LODindex_DYN[i].ECC),x)<0);
	}
      else if(type==1) 
	{
	  do{j=j-1;}
	  while(LODindex_DYN[j].ECC>xint);
	  
	  do{i=i+1;}
	  while(LODindex_DYN[i].ECC<xint);
	}
      else if(type==2) 
	{
	  do{j=j-1;}
	  while(LODindex_DYN[j].draw_priority>xint);
	  
	  do{i=i+1;}
	  while(LODindex_DYN[i].draw_priority<xint);
	}
      else if(type==3) 
	{
	  do{j=j-1;}
	  while(LODindex_DYN[j].geom<xint);
	  
	  do{i=i+1;}
	  while(LODindex_DYN[i].geom>xint);
	}
      else if(type==4) 
	{
	  do{j=j-1;}
	  while(strcmp(LODindex[LODindex_DYN[j].other_index].filename,x)>0);
	  
	  do{i=i+1;}
	  while(strcmp(LODindex[LODindex_DYN[i].other_index].filename,x)<0);
	}

      
      if(i<j)
	{
	  

	  temp1 = LODindex_DYN[i].other_index;
	  temp2 = LODindex_DYN[i].draw_priority;
	  temp3 = LODindex_DYN[i].draw_style;
	  temp4 = LODindex_DYN[i].ECC;
	  temp5 = LODindex_DYN[i].geom;
	  temp6 = LODindex_DYN[i].temp_style;

      temp7 = LODindex_DYN[i].do_discrete;
      temp8 = LODindex_DYN[i].equal_type;
      temp9 = LODindex_DYN[i].discrete_ignore_value;
      temp10= LODindex_DYN[i].do_outline;


	  LODindex_DYN[i].other_index   = LODindex_DYN[j].other_index;
	  LODindex_DYN[i].draw_priority = LODindex_DYN[j].draw_priority;
	  LODindex_DYN[i].draw_style    = LODindex_DYN[j].draw_style;
	  LODindex_DYN[i].ECC           = LODindex_DYN[j].ECC;
	  LODindex_DYN[i].geom          = LODindex_DYN[j].geom;
	  LODindex_DYN[i].temp_style    = LODindex_DYN[j].temp_style;
      LODindex_DYN[i].do_discrete           = LODindex_DYN[j].do_discrete;
      LODindex_DYN[i].equal_type            = LODindex_DYN[j].equal_type;
      LODindex_DYN[i].discrete_ignore_value = LODindex_DYN[j].discrete_ignore_value;
      LODindex_DYN[i].do_outline            = LODindex_DYN[j].do_outline;

	  
	  LODindex_DYN[j].other_index           = temp1;
	  LODindex_DYN[j].draw_priority         = temp2;
	  LODindex_DYN[j].draw_style            = temp3;
	  LODindex_DYN[j].ECC                   = temp4;
	  LODindex_DYN[j].geom                  = temp5;
	  LODindex_DYN[j].temp_style            = temp6;
	  LODindex_DYN[j].do_discrete           = temp7;
	  LODindex_DYN[j].equal_type            = temp8;
	  LODindex_DYN[j].discrete_ignore_value = temp9;
	  LODindex_DYN[j].do_outline            = temp10;
	}
      else
	{
	  return j;
	}
    }
}



void SortLODs(int p, int r, int type)
{
  int q;

  




  if(p<r)
    {
      q = PartitionbyLOD(p,r,type);
      SortLODs(p,q,type);
      SortLODs(q+1,r,type);
    }
}





void MidSortLODs(int start,int end,int secondthird,int key)
{
  int startindex,endindex,i;


  if(secondthird==2)
    {
      
      
      SortLODs(start,end,SecondaryLODSort);
    }
  else
    {
      


      startindex = start;
      endindex   = start;


      for(i=start+1;i<=end;i++)
	{
	  if(SecondaryLODSort==0) 
	    {
	      if(!strcmp(GetECCCode(LODindex_DYN[endindex].ECC),GetECCCode(LODindex_DYN[i].ECC)))
		{	      
		  endindex = i;
		}
	      else
		{
		  if(startindex!=endindex)
		    {
		      SortLODs(startindex,endindex,key);
		    }
		  startindex = i;
		  endindex   = i;
		}
	    }
	  else if(SecondaryLODSort==1) 
	    {
	      if(LODindex_DYN[endindex].ECC==LODindex_DYN[i].ECC)
		{
		  endindex = i;
		}
	      else
		{
		  if(startindex!=endindex)
		    {
		      SortLODs(startindex,endindex,key);
		    }
		  startindex = i;
		  endindex   = i;
		}
	    }
	  else if(SecondaryLODSort==2) 
	    {
	      if(LODindex_DYN[endindex].draw_priority==LODindex_DYN[i].draw_priority)
		{
		  endindex = i;
		}
	      else
		{
		  if(startindex!=endindex)
		    {
		      SortLODs(startindex,endindex,key);
		    }
		  startindex = i;
		  endindex   = i;
		}
	    }
	  else if(SecondaryLODSort==3) 
	    {
	      if(LODindex_DYN[endindex].geom==LODindex_DYN[i].geom)
		{
		  endindex = i;
		}
	      else
		{
		  if(startindex!=endindex)
		    {
		      SortLODs(startindex,endindex,key);
		    }
		  startindex = i;
		  endindex   = i;
		}
	    }
	  else if(SecondaryLODSort==4) 
	    {
	      if(LODindex[LODindex_DYN[endindex].other_index].filename==LODindex[LODindex_DYN[i].other_index].filename)
		{
		  endindex = i;
		}
	      else
		{
		  if(startindex!=endindex)
		    {
		      SortLODs(startindex,endindex,key);
		    }
		  startindex = i;
		  endindex   = i;
		}
	    }
	}
      
      
      if(startindex!=endindex)
	{
	  
	  SortLODs(startindex,endindex,key);
	}
      
            
      
      
      
    }
  
  
}




void SortSecondary(int secondthird, int key)
{
  int startindex,endindex,i;
  
  startindex = 0;
  endindex   = 0;
  
  for(i=1;i<NumLODbands;i++)
    {
      
      
      if(PrimaryLODSort==0) 
	{
	  if(!strcmp(GetECCCode(LODindex_DYN[endindex].ECC),GetECCCode(LODindex_DYN[i].ECC)))
	    {	      
	      endindex = i;
	    }
	  else
	    {
	      if(startindex!=endindex)
		{
		  MidSortLODs(startindex,endindex,secondthird,key);
		}
	      startindex = i;
	      endindex   = i;
	    }
	}
      else if(PrimaryLODSort==1) 
	{
	  if(LODindex_DYN[endindex].ECC==LODindex_DYN[i].ECC)
	    {
	      endindex = i;
	    }
	  else
	    {
	      if(startindex!=endindex)
		{
		  MidSortLODs(startindex,endindex,secondthird,key);
		}
	      startindex = i;
	      endindex   = i;
	    }
	}
      else if(PrimaryLODSort==2) 
	{
	  if(LODindex_DYN[endindex].draw_priority==LODindex_DYN[i].draw_priority)
	    {
	      endindex = i;
	    }
	  else
	    {
	      if(startindex!=endindex)
		{
		  MidSortLODs(startindex,endindex,secondthird,key);
		}
	      startindex = i;
	      endindex   = i;
	    }
	}
      else if(PrimaryLODSort==3) 
	{
	  if(LODindex_DYN[endindex].geom==LODindex_DYN[i].geom)
	    {
	      endindex = i;
	    }
	  else
	    {
	      if(startindex!=endindex)
		{
		  MidSortLODs(startindex,endindex,secondthird,key);
		}
	      startindex = i;
	      endindex   = i;
	    }
	}
      else if(PrimaryLODSort==4) 
	{
	  if(LODindex[LODindex_DYN[endindex].other_index].filename==LODindex[LODindex_DYN[i].other_index].filename)
	    {
	      endindex = i;
	    }
	  else
	    {
	      if(startindex!=endindex)
		{
		  MidSortLODs(startindex,endindex,secondthird,key);
		}
	      startindex = i;
	      endindex   = i;
	    }
	}
    }
  
  
  if(startindex!=endindex)
    {
      
      MidSortLODs(startindex,endindex,secondthird,key);
    }
  
   

}



void SortLayers(Widget w, XtPointer userData, XtPointer callData)
{
  Position px1, py1;
  int i,nopop  = (int)userData;

  


  for(i=0;i<NumLODbands;i++)
  {
	  if(LODindex_DYN[i].geom==C_GRID)
	  {
		
		LODindex_DYN[i].geom = 0;
	  }
  }



  SortLODs(0,NumLODbands-1,PrimaryLODSort);

  

  if(PrimaryLODSort!=SecondaryLODSort)
    {
      SortSecondary(2,-1); 
    }


  if((PrimaryLODSort!=1)&&(SecondaryLODSort!=1))
    {
      SortSecondary(3,1); 
    }


   for(i=0;i<NumLODbands;i++)
   {
    if(LODindex_DYN[i].geom==0)
	 {
	   
	   LODindex_DYN[i].geom = C_GRID;
	 }
   }


  SaveLODColors(drawing_a);


  if(nopop==999)
    {
      
      return;
    }


  

  if((lod_head_in_use==0)&&(dead_lod_head==0))
    {
      XtVaGetValues(lod_head,XmNx,     &px1,NULL);  
      XtVaGetValues(lod_head,XmNy,     &py1,NULL);  
      XtVaGetValues(lod_head,XmNheight,&lod_hgt,NULL);  


      if(USE_DOS==1)
	{
	  px1 = px1 - 4;     
	  py1 = py1 - 30;     
	}

      if(px1<10)
        {
          px1 = 10;
        }
      if(py1<10)
        {
          py1 = 10;
        } 

      XtDestroyWidget(lod_head);
      dead_lod_head=1;
      lod_head_in_use=1;
      LODCallback(drawing_a,(XtPointer)((int)px1),(XtPointer)((int)py1));
    }
  else if((lod_head_in_use==1)&&(dead_lod_head2==0))
    {
      XtVaGetValues(lod_head2,XmNx,     &px1,NULL);  
      XtVaGetValues(lod_head2,XmNy,     &py1,NULL);  
      XtVaGetValues(lod_head2,XmNheight,&lod_hgt,NULL);  

      if(USE_DOS==1)
	{
	  px1 = px1 - 4;     
	  py1 = py1 - 30;     
	}

      if(px1<10)
        {
          px1 = 10;
        }
      if(py1<10)
        {
          py1 = 10;
        } 

      XtDestroyWidget(lod_head2);
      dead_lod_head2=1;
      lod_head_in_use=0;
      LODCallback(drawing_a,(XtPointer)((int)px1),(XtPointer)((int)py1));
    }
}


void sort1_cb(Widget menu_item,XtPointer client_data,XtPointer call_data)
{
  int item_no = (int) client_data;
  
  PrimaryLODSort = item_no;
}


void sort2_cb(Widget menu_item,XtPointer client_data,XtPointer call_data)
{
  int item_no = (int) client_data;

  SecondaryLODSort = item_no;
}


void render_cb(Widget menu_item,XtPointer client_data,XtPointer call_data)
{
  int item_no = (int) client_data;
  int layer,priority;

  layer    = item_no/1000;
  priority = item_no%1000;
  

  if(priority==LODindex_DYN[layer].draw_priority)
    {
      return;
    }
     
  LODindex_DYN[layer].draw_priority = priority;
  
  
  SaveLODColors(drawing_a);
  RebuildTopImage(4);
  
}



Widget BuildSort1Menu(Widget parent,int menu_type,char *menu_title,MenuItem *items)
{
  Widget menu, cascade, widget;
  int i,n=0;
  XmString str;
  Arg args[5];
  
  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);
  
  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId, menu);  n++;
  XtSetArg (args[n], XmNlabelString, str); n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;
  
  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);
  
  for (i = 0; items[i].label != NULL; i++) 
    {
      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);

      if(i==PrimaryLODSort)
	{
	  
	  XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);
	}

      
      if (items[i].callback)
	XtAddCallback (widget,
		       (items[i].cclass == &xmToggleButtonWidgetClass ||
			items[i].cclass == &xmToggleButtonWidgetClass) ?
		       XmNvalueChangedCallback : 
		       XmNactivateCallback,      
		       (XtCallbackProc)items[i].callback, items[i].callback_data);
    }
  return menu_type == XmMENU_POPUP ? menu : cascade;
}





Widget BuildOverrideMenu(Widget parent,int menu_type,char *menu_title,MenuItem *items)
{
  Widget menu, cascade, widget;
  int i,n=0;
  XmString str;
  Arg args[5];
  
  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);
  
  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId, menu);  n++;
  XtSetArg (args[n], XmNlabelString, str); n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;
  
  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);
  
  for (i = 0; items[i].label != NULL; i++) 
    {
      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);

      if((i+1)==OVERRIDING_STYLE)
	{
	  
	  XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);
	}
      
      
      if (items[i].callback)
	XtAddCallback (widget,
		       (items[i].cclass == &xmToggleButtonWidgetClass ||
			items[i].cclass == &xmToggleButtonWidgetClass) ?
		       XmNvalueChangedCallback : 
		       XmNactivateCallback,      
		       (XtCallbackProc)items[i].callback, items[i].callback_data);
    }
  return menu_type == XmMENU_POPUP ? menu : cascade;
}





Widget BuildSort2Menu(Widget parent,int menu_type,char *menu_title,MenuItem *items)
{
  Widget menu, cascade, widget;
  int i,n=0;
  XmString str;
  Arg args[5];
  
  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);
  
  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId, menu);  n++;
  XtSetArg (args[n], XmNlabelString, str); n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;
  
  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);
  
  for (i = 0; items[i].label != NULL; i++) 
    {
      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);

      if(i==SecondaryLODSort)
	{
	  
	  XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);
	}

      
      if (items[i].callback)
	XtAddCallback (widget,
		       (items[i].cclass == &xmToggleButtonWidgetClass ||
			items[i].cclass == &xmToggleButtonWidgetClass) ?
		       XmNvalueChangedCallback : 
		       XmNactivateCallback,      
		       (XtCallbackProc)items[i].callback, items[i].callback_data);
    }
  return menu_type == XmMENU_POPUP ? menu : cascade;
}




Widget BuildRenderMenu(Widget parent,int menu_type,char *menu_title,MenuItem *items, int layer_num)
{
  Widget menu, cascade, widget;
  int i,n=0,cbvalue;
  XmString str;
  Arg args[5];


  menu = XmCreatePulldownMenu (parent, "_pulldown", NULL, 0);
  
  str = XmStringCreateLocalized (menu_title);
  XtSetArg (args[n], XmNsubMenuId, menu);  n++;
  XtSetArg (args[n], XmNlabelString, str); n++;
  XtSetArg (args[n], XmNtranslations, XtParseTranslationTable ( translations_global )); n++;
  
  cascade = XmCreateOptionMenu (parent, menu_title, args, n);
  XmStringFree (str);
  
  for (i = 0; items[i].label != NULL; i++) 
    {
      cbvalue = (int)items[i].callback_data + layer_num*1000;

      widget = XtVaCreateManagedWidget (items[i].label,
					*items[i].cclass, menu,
					NULL);


      if((i+1)==LODindex_DYN[layer_num].draw_priority)
	{
	  
	  XtVaSetValues(cascade,				
			XmNmenuHistory, widget,
			NULL);
	}
      
      
      if (items[i].callback)
	XtAddCallback (widget,
		       (items[i].cclass == &xmToggleButtonWidgetClass ||
			items[i].cclass == &xmToggleButtonWidgetClass) ?
		       XmNvalueChangedCallback : 
		       XmNactivateCallback,      
		       (XtCallbackProc)items[i].callback, (XtPointer)cbvalue);
    }
  return menu_type == XmMENU_POPUP ? menu : cascade;
}






void ApplyLayerCallback(Widget w, XtPointer userData, XtPointer callData)
{
  Widget parent_wid = XtParent(XtParent(XtParent(w)));

  set_cursor(XtDisplay(parent_wid),XtWindow(parent_wid),WATCH);

  if(SAVE_TOPCHANGE>0)
	  {
	    
	    RebuildTopImage(0);
	  }
 refreshCallback((Widget)NULL,(XtPointer)NULL,(XtPointer)NULL);  
 set_cursor(XtDisplay(parent_wid),XtWindow(parent_wid),ARROW);

}



void toggled9(Widget widget,XtPointer client_data,XtPointer call_data)
{
  if(DO_OVERRIDE==0){DO_OVERRIDE=1;}
  else {DO_OVERRIDE=0;}

  RebuildTopImage(1);
}



void LODCallback(Widget w, XtPointer userData, XtPointer callData)
{
  Widget button,button2,button3,form,sw2,rowcol,rc2,label1,label2,label3,sb2,
    sort1_menu,sort2_menu,render_menu,override_menu,togwid;
  Pixmap temp_pixmap;
  Arg resources[20];
  XmString str;
  char *message;
  char temp[2000];
  int i,n=0,px1=-1,py1=-1;

  MenuItem sort1[] = {
    {"FCODE",&xmPushButtonWidgetClass,'!',NULL,NULL,         (void (*)())sort1_cb,(XtPointer)0,(MenuItem *)NULL },
    {"FCODE Name",&xmPushButtonWidgetClass,'!',NULL,NULL,    (void (*)())sort1_cb,(XtPointer)1,(MenuItem *)NULL },
    {"Draw Priority", &xmPushButtonWidgetClass,'!',NULL,NULL,(void (*)())sort1_cb,(XtPointer)2,(MenuItem *)NULL },
    {"Geometry", &xmPushButtonWidgetClass,'!',NULL,NULL,     (void (*)())sort1_cb,(XtPointer)3,(MenuItem *)NULL },
    {"Identifier", &xmPushButtonWidgetClass,'!',NULL,NULL,   (void (*)())sort1_cb,(XtPointer)4,(MenuItem *)NULL },
    {NULL},
  };


  MenuItem sort2[] = {
    {"FCODE",&xmPushButtonWidgetClass,'!',NULL,NULL,         (void (*)())sort2_cb,(XtPointer)0,(MenuItem *)NULL },
    {"FCODE Name",&xmPushButtonWidgetClass,'!',NULL,NULL,    (void (*)())sort2_cb,(XtPointer)1,(MenuItem *)NULL },
    {"Draw Priority", &xmPushButtonWidgetClass,'!',NULL,NULL,(void (*)())sort2_cb,(XtPointer)2,(MenuItem *)NULL },
    {"Geometry", &xmPushButtonWidgetClass,'!',NULL,NULL,     (void (*)())sort2_cb,(XtPointer)3,(MenuItem *)NULL },
    {"Identifier", &xmPushButtonWidgetClass,'!',NULL,NULL,   (void (*)())sort2_cb,(XtPointer)4,(MenuItem *)NULL },
    {NULL},
  };

  
  MenuItem render[] = {
    {"1 (top)",   &xmPushButtonWidgetClass,'!',NULL,NULL, (void (*)())render_cb,(XtPointer)1,(MenuItem *)NULL },
    {"2",         &xmPushButtonWidgetClass,'!',NULL,NULL, (void (*)())render_cb,(XtPointer)2,(MenuItem *)NULL },
    {"3 (middle)",&xmPushButtonWidgetClass,'!',NULL,NULL, (void (*)())render_cb,(XtPointer)3,(MenuItem *)NULL },
    {"4",         &xmPushButtonWidgetClass,'!',NULL,NULL, (void (*)())render_cb,(XtPointer)4,(MenuItem *)NULL },
    {"5 (bottom)",&xmPushButtonWidgetClass,'!',NULL,NULL, (void (*)())render_cb,(XtPointer)5,(MenuItem *)NULL },
    {NULL},
  };



  MenuItem override[] = {
    {"Outline Only",            &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())override_cb,(XtPointer)1,(MenuItem *)NULL },
    {"Light Filling",           &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())override_cb,(XtPointer)2,(MenuItem *)NULL },
    {"Medium Filling",          &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())override_cb,(XtPointer)3,(MenuItem *)NULL },
    {"Heavy Filling",           &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())override_cb,(XtPointer)4,(MenuItem *)NULL },
    {"Fully Filled",            &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())override_cb,(XtPointer)5,(MenuItem *)NULL },
    {"Dense Horizontal Lines",  &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())override_cb,(XtPointer)6,(MenuItem *)NULL },
    {"Sparse Horizontal Lines", &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())override_cb,(XtPointer)7,(MenuItem *)NULL },
    {"Dense Vertical Lines",    &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())override_cb,(XtPointer)8,(MenuItem *)NULL },
    {"Sparse Vertical Lines",   &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())override_cb,(XtPointer)9,(MenuItem *)NULL },
    {"Dense NW/SE Lines",       &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())override_cb,(XtPointer)10,(MenuItem *)NULL },
    {"Sparse NW/SE Lines",      &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())override_cb,(XtPointer)12,(MenuItem *)NULL },
    {"Dense NE/SW Lines",       &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())override_cb,(XtPointer)11,(MenuItem *)NULL },
    {"Sparse NE/SW Lines",      &xmPushButtonWidgetClass,'!',NULL,NULL, 
     (void (*)())override_cb,(XtPointer)13,(MenuItem *)NULL },
    {NULL},
  };


  if((userData!=NULL)     &&
     ((int)userData>=10)  &&
     ((int)userData<1000) &&
     (callData!=NULL)     &&
     ((int)callData>=10)  &&
     ((int)callData<1000)
     )
    {
      px1 = (int)userData;
      py1 = (int)callData;
    }

  if(running==1)
    {
      if(NGA_TYPE==1)
        {
          not_while_running(w,"You may not set Layer parameters while running.",1095,"Illegal Manuever",1);
        }
      else
        {
          not_while_running(w,"You may not set LOD parameters while running.",1096,"Illegal Manuever",1);
        }
      return;
    }
  
  if(input_source==0)
    {
      if(NGA_TYPE==1)
	{
	  message ="You must open a GAIT project before\n\
you can set Layers.";
	}
      else
	{
	  message ="You must select an input data source directory before\n\
you can set LODs.";
	}
      
      not_while_running(w,message,1097,"No input source",1);
      return;
    }
  
  if(output_source==0)
    {
      if(NGA_TYPE==1)
	{
	  message ="You must select an output data directory before\n\
you can set Layers.";
	}
      else
	{
	  message ="You must select an output data directory before\n\
you can set LODs.";
	}
      not_while_running(w,message,1098,"No output directory",1);
      return;
    }
  
  if(NumLODbands==0)
    {
      if(NGA_TYPE==1)
	{
          message ="No Layers were found in this project.";
          not_while_running(w,message,1099,"No Layers present",1);
        }
      else
        {
          message ="No LODs were found in this DB.";
          not_while_running(w,message,1100,"No LODs present",1);
        }
      
      return;
    }
  



  if(((lod_head_in_use==0)&&(dead_lod_head ==1))||  
     ((lod_head_in_use==1)&&(dead_lod_head2==1)))   
    {

      set_cursor(mydisplay,mywindow,WATCH);

      Record_SAVE_TOPCHANGE(0);

      n=0;
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++; 
      if(px1>0)
	{
	  XtSetArg(resources[n],  XmNx,              px1);          n++;
	  XtSetArg(resources[n],  XmNy,              py1);          n++;
	}

      if(lod_hgt>100)
	{
	  XtSetArg(resources[n],  XmNheight, lod_hgt);          n++;
	}

     if(lod_head_in_use==0)
	{
	  if(NGA_TYPE==1)
	    {
	      lod_head = XtCreatePopupShell
		("Layer Options",topLevelShellWidgetClass,w,resources,n);
	    }
	  else
	    {
	      lod_head = XtCreatePopupShell
		("LOD Options",topLevelShellWidgetClass,w,resources,n);
	    }     

	  rowcol = XtVaCreateManagedWidget
	    (
	     "XformWidget", xmPanedWindowWidgetClass, lod_head,
	     XmNrubberPositioning, False,
	     XmNresizable,         True,
	     XmNseparatorOn,       False,
	     XmNsashHeight,        1,
	     NULL
	     );
  	}
      else if(lod_head_in_use==1)
	{
	  if(NGA_TYPE==1)
	    {
	      lod_head2 = XtCreatePopupShell
		("Layer Options",topLevelShellWidgetClass,w,resources,n);
	    }
	  else
	    {
	      lod_head2 = XtCreatePopupShell
		("LOD Options",topLevelShellWidgetClass,w,resources,n);
	    }  

	  rowcol = XtVaCreateManagedWidget
	    (
	     "XformWidget", xmPanedWindowWidgetClass, lod_head2,
	     XmNrubberPositioning, False,
	     XmNresizable,         True,
	     XmNseparatorOn,       False,
	     XmNsashHeight,        1,
	     NULL
	     );
  	}



      form = XtVaCreateWidget ("form.sw.errors", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   15,
			       XmNpaneMaximum,   15,
			       XmNfractionBase,  100,  
			       NULL);
      
      if(NGA_TYPE==1)
        {
	  sprintf(temp,"Layers Found (%d):",NumLODbands);
          str = XmStringCreate (temp, "mytag1");
        }
      else
        {
	  sprintf(temp,"LODs (%d):",NumLODbands);
          str = XmStringCreate (temp, "mytag1");
        }
      label1 = XtVaCreateManagedWidget ("lab1",
					xmLabelWidgetClass, form,
					XmNtopAttachment,     XmATTACH_FORM,
					XmNbottomAttachment,  XmATTACH_FORM,
					XmNrightAttachment,   XmATTACH_POSITION,
					XmNrightPosition,     100,
					XmNleftAttachment,    XmATTACH_POSITION,
					XmNleftPosition,      0,
					XmNalignment,         XmALIGNMENT_CENTER,
					XmNlabelString,       str,
					LABELWTRANSLATE,
					NULL);
      XtManageChild(form);
      XmStringFree (str);
      



      if(NGA_TYPE==1)
	{
	  form = XtVaCreateWidget ("form.sw.errors", xmFormWidgetClass, rowcol,
				   XmNpaneMinimum,   15,
				   XmNpaneMaximum,   15,
				   XmNfractionBase,  100,  
				   NULL);

	  label1 = XtVaCreateManagedWidget ("lab1",
					    xmLabelWidgetClass, form,
					    XmNtopAttachment,     XmATTACH_FORM,
					    XmNbottomAttachment,  XmATTACH_FORM,
					    XmNleftAttachment,    XmATTACH_FORM,
					    XmNalignment,         XmALIGNMENT_CENTER,
					    XmNlabelString,       STRING(" Color/Style "),
					    LABELWTRANSLATE,
					    NULL);

	  label2 = XtVaCreateManagedWidget ("lab1",
					    xmLabelWidgetClass, form,
					    XmNtopAttachment,     XmATTACH_FORM,
					    XmNbottomAttachment,  XmATTACH_FORM,
					    XmNleftAttachment,    XmATTACH_WIDGET,
					    XmNleftWidget,        label1,
					    XmNalignment,         XmALIGNMENT_CENTER,
					    XmNlabelString,       STRING("Drawing Priority"),
					    LABELWTRANSLATE,
					    NULL);

	  label3 = XtVaCreateManagedWidget ("lab1",
					    xmLabelWidgetClass, form,
					    XmNtopAttachment,     XmATTACH_FORM,
					    XmNbottomAttachment,  XmATTACH_FORM,
					    XmNleftAttachment,    XmATTACH_WIDGET,
					    XmNleftWidget,        label2,
					    XmNalignment,         XmALIGNMENT_CENTER,
					    XmNlabelString,       STRING("  FCODE (FCODE Name) (Geometry) (Identifier)"),
					    LABELWTRANSLATE,
					    NULL);

	  XtManageChild(form);
	}






      form = XtVaCreateWidget ("form.sw.errors", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       XmNtranslations, XtParseTranslationTable (list_translations3),
			       NULL);
      
      sw2 = XtVaCreateManagedWidget ("scrolled_win",
				     xmScrolledWindowWidgetClass, form,
				     XmNtranslations, XtParseTranslationTable (list_translations3),
				     XmNwidth,                  450,
				     XmNheight,                 200,
				     XmNincrement,              100,
				     XmNscrollingPolicy,        XmAUTOMATIC,
				     XmNscrollBarDisplayPolicy, XmSTATIC,
				     XmNtopAttachment,          XmATTACH_FORM,
				     XmNbottomAttachment,       XmATTACH_FORM,
				     XmNleftAttachment,         XmATTACH_FORM,
				     XmNrightAttachment,        XmATTACH_FORM,
				     NULL);


      XtVaGetValues(sw2,XmNverticalScrollBar,&sb2,NULL);
      XtVaGetValues(sw2,XmNverticalScrollBar,&vert_scroll[LOD_SCROLL],NULL);


      
      rc2 = XtVaCreateWidget ("rc.error.editor",xmRowColumnWidgetClass, sw2, 
			      XmNtranslations, XtParseTranslationTable (list_translations3),
			      NULL);

      XtManageChild(form);


    


      
      if(LODS_INNITTED==1)
	{
	  free(LOD);
	}
      
      LOD = (Widget *) (malloc(sizeof(Widget)*NumLODbands));
      if(LOD==NULL){printf("lod: out of allocation memory!\n"); ExitWrapper(-1);}
      
      for(i=0;i<NumLODbands;i++)
	{
	  form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rc2,
				   XmNtranslations, XtParseTranslationTable (list_translations3),
				   XmNfractionBase,  100,  
				   NULL); 
	  



	  if(lod_head_in_use==0)
	    {
	      temp_pixmap = XCreatePixmap(XtDisplay(lod_head),
					  RootWindowOfScreen (XtScreen (lod_head)),
					  100,NEW_BOTTOM,DefaultDepthOfScreen(XtScreen(lod_head)));
	      
	      
	      if(LODindex[LODindex_DYN[i].other_index].color!=-1)
		{				      
		  
		  XFillRectangle(XtDisplay(lod_head),temp_pixmap,mygc,0,0,100,NEW_BOTTOM);
		  XSetForeground(XtDisplay(lod_head),mygc,mycolors[DRAW_COLOR_WHITE]);
		}
	    }
	  else
	    {
	      temp_pixmap = XCreatePixmap(XtDisplay(lod_head2),
					  RootWindowOfScreen (XtScreen (lod_head2)),
					  100,NEW_BOTTOM,DefaultDepthOfScreen(XtScreen(lod_head2)));
	      
	      
	      if(LODindex[LODindex_DYN[i].other_index].color!=-1)
		{				      
		  
		  XFillRectangle(XtDisplay(lod_head2),temp_pixmap,mygc,0,0,100,NEW_BOTTOM);
		  XSetForeground(XtDisplay(lod_head2),mygc,mycolors[DRAW_COLOR_WHITE]);
		}
	    }





	  
	  if(LODindex[LODindex_DYN[i].other_index].color==-1)
	    {
	      

	      LODindex[LODindex_DYN[i].other_index].color_wid = 
		XtVaCreateManagedWidget("col_wid",xmPushButtonWidgetClass,form,
					XmNlabelString,      STRING("Choose color..."),
					XmNlabelType,        XmSTRING,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNleftAttachment,   XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNtranslations, XtParseTranslationTable (list_translations3),
					NULL);
	    }
	  else
	    {

	      LODindex[LODindex_DYN[i].other_index].color_wid = 
		XtVaCreateManagedWidget("col_wid",xmPushButtonWidgetClass,form,
					XmNlabelType,        XmPIXMAP,
					XmNlabelPixmap,      temp_pixmap,
					XmNalignment,        XmALIGNMENT_CENTER,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNleftAttachment,   XmATTACH_FORM,
					XmNbackground,       mycolors[DRAW_COLOR_WHITE],
					XmNtraversalOn,      False,
				    XmNtranslations,     XtParseTranslationTable (list_translations3),
					NULL);
	    }

	  
	  XtAddCallback(LODindex[LODindex_DYN[i].other_index].color_wid,
			XmNactivateCallback, choose_layer_color, (XtPointer)i);
	  



	
	  render_menu = BuildRenderMenu (form, XmMENU_OPTION, "", render,i);
	  
	  XtVaSetValues(render_menu,  
			XmNleftAttachment,   XmATTACH_WIDGET,
			XmNleftWidget,       LODindex[LODindex_DYN[i].other_index].color_wid,
			XmNtopAttachment,    XmATTACH_FORM,
			XmNbottomAttachment, XmATTACH_FORM,
			XmNtraversalOn,      False,

			NULL);
	  
   	  XtManageChild(render_menu);




		  
	  sprintf(temp,"%s (%s) (%s) (%s)",
		  GetECCCode (LODindex_DYN[i].ECC),
		  GetECCLabel(LODindex_DYN[i].ECC),
		  GetShortGeomName(LODindex_DYN[i].geom),
		  LODindex[LODindex_DYN[i].other_index].filename);
		  
	  
	  str = XmStringCreateLtoR (temp, "mytag1");


	  LOD[LODindex_DYN[i].other_index] =
	    XtVaCreateManagedWidget ("the_test",
				     xmToggleButtonWidgetClass, form,
				     XmNtopAttachment,    XmATTACH_FORM,
				     XmNbottomAttachment, XmATTACH_FORM,
				     XmNleftAttachment,   XmATTACH_WIDGET,
				     XmNleftWidget,       render_menu,
				     XmNtraversalOn,      False,
				     XmNlabelString,      str,
				     XmNtranslations,     XtParseTranslationTable (list_translations3),
				     TOGGLEINCLUDE,
				     NULL);
	  

	  XmToggleButtonSetState(LOD[LODindex_DYN[i].other_index],
				 (Boolean)LODindex[LODindex_DYN[i].other_index].active,(Boolean)0);
	  XtManageChild(LOD[LODindex_DYN[i].other_index]);
	  XtManageChild(form);
	  XtAddCallback (LOD[LODindex_DYN[i].other_index], XmNvalueChangedCallback, TogLODCallback, (XtPointer)i);
	  XmStringFree (str);
	}
      
      LODS_INNITTED = 1;
      
      XtManageChild(rc2);
      XtManageChild(sw2);


    
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   32,
			       XmNpaneMaximum,   32,
			       XmNfractionBase,  100,
			       NULL);



      sort1_menu = BuildSort1Menu (form, XmMENU_OPTION, "Sort list first by:", sort1);
      
      XtManageChild (sort1_menu);

      XtVaSetValues(sort1_menu,  
		    XmNleftAttachment,   XmATTACH_FORM,
		    XmNtopAttachment,    XmATTACH_FORM,
		    XmNbottomAttachment, XmATTACH_FORM,
		    XmNtraversalOn,      False,
		    NULL);



      sort2_menu = BuildSort2Menu (form, XmMENU_OPTION, "then by:", sort2);
      
      XtManageChild (sort2_menu);

      XtVaSetValues(sort2_menu,  
		    XmNleftAttachment,   XmATTACH_WIDGET,
		    XmNleftWidget,       sort1_menu,
		    XmNtopAttachment,    XmATTACH_FORM,
		    XmNbottomAttachment, XmATTACH_FORM,
		    XmNtraversalOn,      False,
		    NULL);



      button = XtVaCreateManagedWidget ("Help4",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNleftAttachment,   XmATTACH_WIDGET,
					XmNleftWidget,       sort2_menu,
					XmNlabelString,      STRING("Re-Sort List Now"),
					XmNtraversalOn,      False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback (button, XmNactivateCallback,
		     SortLayers, (XtPointer)NULL);
      
      XtManageChild (sort2_menu);
      XtManageChild(form);






      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   32,
			       XmNpaneMaximum,   32,
			       XmNfractionBase,  100,
			       NULL);
      


    
      togwid = XtVaCreateManagedWidget ("Override all area feature styles with:",
					xmToggleButtonWidgetClass, form,
					XmNtraversalOn,      False,
					XmNleftAttachment,   XmATTACH_FORM,
					XmNlabelString,      STRING("Override all area feature styles with:"),
					TOGGLETRANSLATE,     TOGGLEINCLUDE,
					NULL);

      XtAddCallback (togwid, XmNvalueChangedCallback, toggled9, NULL);
      XtManageChild(togwid);
      
      XmToggleButtonSetState(togwid,(Boolean)DO_OVERRIDE,(Boolean)0);
      


      
      override_menu = BuildOverrideMenu (form, XmMENU_OPTION, "", override);
      
      XtManageChild (override_menu);

      XtVaSetValues(override_menu,  
		    XmNleftAttachment,   XmATTACH_WIDGET,
		    XmNleftWidget,       togwid,
		    XmNtopAttachment,    XmATTACH_FORM,
		    XmNbottomAttachment, XmATTACH_FORM,
		    XmNtraversalOn,      False,
		    NULL);





      XtManageChild(form);














      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,
			       NULL);
      
      button = XtVaCreateManagedWidget ("Help4",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    33,
					XmNlabelString,      STRING("Select all layers"),
					XmNtraversalOn,      False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback (button, XmNactivateCallback,
		     all_layers_onoff, (XtPointer)1);
      
      
      button = XtVaCreateManagedWidget ("Help4",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     33,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    66,
					XmNlabelString,      STRING("De-select all layers"),
					XmNtraversalOn,      False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback (button, XmNactivateCallback,
		     all_layers_onoff, (XtPointer)0);
      
      
	  button = XtVaCreateManagedWidget ("Help4",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     66,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    99,
					XmNlabelString,      STRING("Save/Load Preferences..."),
					XmNtraversalOn,      False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback (button, XmNactivateCallback,
		     save_layer_prefs, (XtPointer)NULL);
 
      
      XtManageChild(form);
      
      
      
      
      
      







     form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,
			       NULL);

	 label1 = XtVaCreateManagedWidget ("",
				xmLabelWidgetClass,  form,
			    XmNtopAttachment,    XmATTACH_FORM,
				XmNbottomAttachment, XmATTACH_FORM,
				XmNleftAttachment,   XmATTACH_POSITION,
				XmNleftPosition,     0,
				XmNalignment,        XmALIGNMENT_CENTER,
 			    XmNlabelString,      STRING("Select layers by:"),
			    XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				NULL);

      
      button = XtVaCreateManagedWidget ("Help4",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNleftAttachment,   XmATTACH_WIDGET,
					XmNleftWidget,       label1,
					XmNlabelString,      STRING("    Geometry...    "),
					XmNtraversalOn,      False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
     XtAddCallback (button, XmNactivateCallback,
		     select_layers_by_geom, (XtPointer)NULL);
      
      
      button2 = XtVaCreateManagedWidget ("Help4",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNleftAttachment,   XmATTACH_WIDGET,
					XmNleftWidget,       button,
					XmNlabelString,      STRING("Functional Category..."),
					XmNtraversalOn,      False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback (button2, XmNactivateCallback,
		     select_layers_by_fc, (XtPointer)NULL);
      
      
	 
	  button3 = XtVaCreateManagedWidget ("Help4",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNleftAttachment,   XmATTACH_WIDGET,
					XmNleftWidget,       button2,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    99,
					XmNlabelString,      STRING("  MGCP Category...  "),
					XmNtraversalOn,      False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback (button3, XmNactivateCallback,
		     select_layers_by_mgcp, (XtPointer)NULL);
 

      
      XtManageChild(form);
      
      

      
      
      
      
      
      
      
      
      
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,
			       NULL);
      
      button = XtVaCreateManagedWidget ("Help4",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     1,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    25,
					XmNlabelString,      STRING("Help"),
					XmNtraversalOn,      False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback (button, XmNactivateCallback,
		     LODHelpCallback, (XtPointer)NULL);
      
      
      button = XtVaCreateManagedWidget ("Help4",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     25,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    50,
					XmNlabelString,      STRING("Reset all colors"),
					XmNtraversalOn,      False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback (button, XmNactivateCallback,
		     reset_layer_colors,(XtPointer)NULL);
      
      
      
      
      button = XtVaCreateManagedWidget ("Help4",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     50,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    75,
					XmNlabelString,      STRING("Apply/Refresh View"),
					XmNtraversalOn,      False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback (button, XmNactivateCallback,
		     ApplyLayerCallback,NULL);
      

	  button = XtVaCreateManagedWidget ("Help4",
					xmPushButtonWidgetClass, form,
					XmNtopAttachment,    XmATTACH_FORM,
					XmNtraversalOn,      False,
					XmNbottomAttachment, XmATTACH_FORM,
					XmNleftAttachment,   XmATTACH_POSITION,
					XmNleftPosition,     75,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    99,
					XmNlabelString,      STRING("Done/Refresh View"),
					XmNtraversalOn,      False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL);
      XtAddCallback (button, XmNactivateCallback,
		     exitCallback,(XtPointer)7);
 


      XtManageChild(form);
      XtManageChild(rowcol);
      

      if(lod_head_in_use==0)
	{
	  dead_lod_head = 0;

	  XtRealizeWidget(lod_head);
	  MyPopup(lod_head); 

	  XtAddCallback(lod_head,XmNdestroyCallback,ShellDeath,(XtPointer)233);
	}
      else if(lod_head_in_use==1)
	{
	  dead_lod_head2 = 0;
	  XtRealizeWidget(lod_head2);
	  MyPopup(lod_head2); 

	  XtAddCallback(lod_head2,XmNdestroyCallback,ShellDeath,(XtPointer)234);
	}

      XtVaSetValues(sb2,XmNincrement,30,NULL);

    }
  else
    {
      if(lod_head_in_use==1)
	{
	  ResetWidget(lod_head2);
	}
      else if(lod_head_in_use==0)
	{
	  ResetWidget(lod_head);
	}      
    }



  for(i=0;i<NumLODbands;i++)
    {
      
      if(LODindex[i].temp_color != -1)
	{
	  LODindex[i].temp_color  = LODindex[i].color;
	  LODindex[i].temp_rcolor = LODindex[i].rcolor;
	  LODindex[i].temp_gcolor = LODindex[i].gcolor;
	  LODindex[i].temp_bcolor = LODindex[i].bcolor;
	}
      LODindex_DYN[i].temp_style = LODindex_DYN[i].draw_style;
    }
  

  NO_REBUILD = 1;
  for(i=0;i<NumLODbands;i++)
    {
      


      
      no_layer_reset_flag=789987;
      apply_layer_callback(drawing_a,(XtPointer)i,(XtPointer)i);
      no_layer_reset_flag=0;
    }
  NO_REBUILD = 0;

  set_cursor(mydisplay,mywindow,GOOD);

  SetColorRight();
}







void DrawInfoItem(struct InfoPrintContent *curr)
{
  int temp,temp1,color;
  char thestr[50];

  
  set_cursor(mydisplay,mywindow,WATCH);
  if(info_window_up==1)
  {
    set_cursor(XtDisplay(infohead),XtWindow(infohead),WATCH);
  }


  switch(curr->geom)
    {
    case C_POLY:
    case C_MOLI:
    case C_AREA:
    case C_COVP: 


      temp  = DO_OVERRIDE;
      temp1 = OVERRIDING_STYLE; 
      DO_OVERRIDE = 1;

      if((curr->ishole==1)||(curr->ishole==4))
	{
	  

	  OVERRIDING_STYLE = 1;
	  
	  MAPdrawpoly(curr->numcoords,curr->X,curr->Y, 1,0,1,2,DRAW_NOW);	  
	}
      
      else
	{
	  OVERRIDING_STYLE = LODindex_DYN[LODindex[CrsWlk[curr->longindex].LODband-1].other_index].draw_style;
	  
	  if(curr->innerings!=NULL)
	    {
	      

		  

		  

          NO_CIRCLES = 1;
          DrawPolyWithHoles(curr->numcoords,curr->X,curr->Y,1,curr->numholes,curr->innerings,DRAW_NOW);
          NO_CIRCLES = 0;
	    }
	  else
	    {
	      
	      
	      MAPdrawpoly(curr->numcoords,curr->X,curr->Y, 1,0,1,2,DRAW_NOW);
	    }

	}

      DO_OVERRIDE      = temp;
      OVERRIDING_STYLE = temp1;

      break;
    case C_LINE:
      MAPdrawfullline(curr->X,curr->Y,curr->numcoords,1,DRAW_NOW);
      break;
    case C_POFE:
      MAPdrawX(curr->X[0],curr->Y[0],1,DRAW_NOW);
      break;
    case C_GRID:

      MAPdrawStar(curr->X[0],curr->Y[0],MY2DSENTINEL,1,DRAW_NOW,1);

	  if(INFO_GRIDVALUES==1)
	  {
	    sprintf(thestr,"%.2lf",curr->Z[0]);
	    color = 1;
        MAPdrawstring(curr->X[0],curr->Y[0],thestr,color,18,DRAW_NOW,1); 
	  }

      break;
    case C_POMO:     
    case C_COVS: 
      MAPdrawcircle(curr->X[0],curr->Y[0],curr->radius*2,2,DRAW_NOW);
      break;
      
    default:
      printf("unrecognized geometry  %d\n",curr->geom);
    }
  CleanScreen();

  set_cursor(mydisplay,mywindow,GOOD);
  if(info_window_up==1)
  {
    set_cursor(XtDisplay(infohead),XtWindow(infohead),ARROW);
  }
}




void DrawSpecialInfoVertex()
{
  if(SPECIAL_VERTEX>=0)
    {
      MAPdrawcircle(GLOBAL_SAVE_COORDS_X[SPECIAL_VERTEX],GLOBAL_SAVE_COORDS_Y[SPECIAL_VERTEX],20,1,DRAW_NOW);
    }
}

void UnderlineSpecialVertex()
{

  if((SPECIAL_VERTEX>=0)&&(INFO_COORDS==1))
    {
      XmTextSetHighlight(info_text_area,
			 0,INFOLEN,
			 XmHIGHLIGHT_NORMAL);
      
      XmTextSetHighlight(info_text_area,
			 GLOBAL_SAVE_COORDS_start[SPECIAL_VERTEX],GLOBAL_SAVE_COORDS_end[SPECIAL_VERTEX],
			 XmHIGHLIGHT_SECONDARY_SELECTED); 
    }
}
  



void GetCodeDist(int *paddist1, int *paddist2)
{
  struct InfoPrintContent *curr;
  int i,j,thislen1,thislen2,foundcode,thiscode,intvalue,maxlen = 0, maxlen2 = 0;
  char junk[1000];
  extern char *GetEECode(int attr_code, int enum_num);

  
   
  if(UNIQARRAYBUILT==0)
    {
      BuildUNIQArray();
    }

  curr = InfoRoot;
  while(curr!=NULL)
  {
	 for(i=0; i<curr->numattr; i++)
	 {
	  if(curr->A[i].Label[0] != '*')
	  {
		thislen1 = strlen(curr->A[i].code);
       

        foundcode = 0;

        for(j=1;j<INsac_loop;j++)
		{
		  if(UNIQSAC[j]==1)  
		    {
			  if(!strcmp(GetEACCode(j),curr->A[i].code))
			    {
			      foundcode = 1;
			      thiscode = j;
			      break;
			    }			
		    }
		}



		if(foundcode==1)
		{
		  if(curr->A[i].valueLabel == NULL)
		    {
		      sprintf(junk,"%s ",curr->A[i].value);
		    }
		  else
		    {
		      sscanf(curr->A[i].value,"%d",&intvalue);
			  sprintf(junk,"%s",GetEECode(thiscode,intvalue));
		    }
		  thislen2 = strlen(junk);


    
		  if(InfoSac[thiscode]==1)
		    {
              

			  if(thislen1>maxlen)
			  {
				  maxlen = thislen1;
			  }

			  if(thislen2>maxlen2)
			  {
				  maxlen2 = thislen2;
			  }
		    }
		}
		else
		{
			printf("did not find code %s\n",curr->A[i].code);
		}

	  }
	 }
	curr = curr->next;
  }

 

  if(maxlen<3)
  {
    *paddist1 = 10;
  }
  else
  {
    *paddist1 = maxlen + 3;
  }

  if(maxlen2<3)
  {
	*paddist2 = 10;
  }

  else
  {
    *paddist2 = maxlen2 + 3;
  }

  if(*paddist1>21)  
  {
	*paddist1 = 21;
  }

  if(*paddist2>21)
  {
	*paddist2 = 21;
  }

}


char *GetInfoGeomType(int geom, int ishole, int numholes)
{
  static char junk[500];

  switch(geom)
	{
	   case C_AREA:
         if(ishole==0)
            {
	          if(numholes>0)
			  {
		        sprintf(junk,"Closed Area Feature with %d total cut-outs",numholes);
		        return junk;
			  }
	          else
			  {
		        return "Closed Area Feature";
			  }
            }
          else if(ishole==1)
            {
              return "Closed Cut-Out of Area Feature";
            }
          else if(ishole == 3)
	    {
	      if(numholes>0)
		{
		  sprintf(junk,"Unclosed Area Feature with %d total cut-outs",numholes);
		  return junk;
		}
	      else
		{
		  return "Unclosed Area Feature";
		}
	    }
          else if(ishole==4)
	    {
	      return "Unclosed Cut-Out of Area Feature";
	    }
	  else
	    {
	      return "Problem Area Feature"; 
	    }
	  break;
	case C_LINE:
	  return "Line Feature";
	  break;
	case C_POLY:
	  return "Polygon";
	  break;
	case C_MOLI:
	  return "Model Library Polygon";
	  break;
	case C_GRID:
	  return "Grid Point";
	  break;
	case C_POFE:
	  return "Point Feature";
	  break;
	case C_POMO:
	  return "Point Model (Stamp)";
	  break;
	case C_COVS:
	  return "Spherical Collision Volume";
	  break;
	case C_COVP:
	  return "Parallelpiped Collision Volume";
	  break;
	default:
	  printf("(2) unrecognized geometry  %d\n",geom);
  }

  return "Error";
}






char *GetLengthName(int geomtype)
{
  if(geomtype==C_AREA)
  {
    return "Perimeter length";
  }	
  else if(geomtype==C_LINE)
  {
    return "Length";
  }
  else
  {
	printf("Bad flag %d to GLN\n",geomtype);
  }
  return "??";
}



char *FixUTF(char *value)
{
  int i,len,insertindex,started=0;
  static char newvalue[310];

  len = strlen(value);

  if(len>300)
  {
    return value;
  }

  if(value[0]!='"')
  {
    return value;
  }


  insertindex = 0;
  for(i=0;i<len;i++)
  {
    if((unsigned char)value[i]<=127)
	{
      started = 0;
	  newvalue[insertindex] = value[i];
	  insertindex = insertindex + 1;
	}
	else if(started==0)
	{ 
      newvalue[insertindex] = '?';
      insertindex = insertindex + 1;
      started = 1;
	}
  }
  newvalue[insertindex] = '\0';

  return newvalue;
}


void AddHTML(FILE *outfile,char *outstring)
{
  fprintf(outfile,"%s",outstring);
}


int CreateHTML(char *instring)
{
  FILE *outfile;
  unsigned int cp=0;
  int i,j,insertindex=0,len,msz_byte,retval=0;
  char chunk[1000],smallchunk[100];
  extern unsigned int GoodUTF2(const unsigned char *instring);


  


  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
  { 
    sprintf(chunk,"%sinternal_data\\queryresults.htm",indirectory);
  }
  else
  {  
    sprintf(chunk,"%sinternal_data/queryresults.htm",indirectory);
  }

  outfile = fopen(chunk,"w");
  if(outfile==NULL)
  {
    printf("Error: unable to open %s for write\n",chunk);
	printf("  Unable to display HTML version of query results\n");
	XBell(mydisplay,50);
  }



  AddHTML(outfile,"<html lang=\"en\">\n");
  AddHTML(outfile," <head>\n");
  AddHTML(outfile,"  <title>Query Results</title>\n");
  AddHTML(outfile,"  <style type=\"text/css\">\n");
  AddHTML(outfile,"   pre { margin-bottom: 1em; padding-bottom: 1em; border-bottom: solid thin; }\n");
  AddHTML(outfile,"  </style>\n");
  AddHTML(outfile," </head>\n");
  AddHTML(outfile," <body>\n");

  AddHTML(outfile," <pre>\n");
  AddHTML(outfile," </pre>\n");


  AddHTML(outfile," <pre>\n");

  AddHTML(outfile,"<b>Decoded for UTF-8:</b>\n\n");


  len = strlen(instring);

  for(i=0;i<len;i++)
  {

    msz_byte = msz(instring[i]);

	


    if((unsigned char)instring[i]<=127)
	{
       

       if(insertindex>0)
	   {
         retval = 1;

         cp = GoodUTF2((unsigned char *)chunk);
		 if(cp>0)
		 {
           sprintf(chunk,"&#x%04x;",cp);
           AddHTML(outfile,chunk);
		 }
		 else
		 {
           AddHTML(outfile,"(Invalid sequence for UTF-8:");
           for(j=0;j<(int)strlen(chunk);j++)
		   { 
             sprintf(smallchunk," %02x ",(unsigned char)chunk[j]);

             AddHTML(outfile,smallchunk);
		   } 
           AddHTML(outfile,")");
		 }

         
	   }

	   chunk[0] = instring[i];
	   chunk[1] = '\0';
       AddHTML(outfile,chunk);
	   insertindex = 0;
	}
    else if((msz_byte>=1)&&(msz_byte<=5))
	{
       

       if(insertindex>0)
	   {
         retval = 1;

         cp = GoodUTF2((unsigned char *)chunk);
		 if(cp>0)
		 {
           sprintf(chunk,"&#x%04x;",cp);
           AddHTML(outfile,chunk);
		 }
		 else
		 {
           AddHTML(outfile,"(Invalid sequence for UTF-8:");
           for(j=0;j<(int)strlen(chunk);j++)
		   { 
             sprintf(smallchunk," %02x ",(unsigned char)chunk[j]);

             AddHTML(outfile,smallchunk);
		   } 
           AddHTML(outfile,")");
		 }

         
	   }

	  insertindex = 0;
      chunk[insertindex] = instring[i];
	  insertindex = insertindex + 1;
	  chunk[insertindex] = '\0';
	}
	else
	{
      
	  retval = 1;
      chunk[insertindex] = instring[i];
	  insertindex = insertindex + 1;
	  chunk[insertindex] = '\0';
	}
  }

  if(insertindex>0)
  {
    
    printf("Post-process %d-character %s: %d\n",insertindex,chunk,GoodUTF2((unsigned char *)chunk));
  }


  AddHTML(outfile," </pre>\n");



  AddHTML(outfile," <pre>\n");
  AddHTML(outfile,"<b>Left in the original encoding:</b>\n\n");
  AddHTML(outfile,instring);
  AddHTML(outfile," </pre>\n");



  AddHTML(outfile," </body>\n");
  AddHTML(outfile,"</html>\n");

  fclose(outfile);

  return retval;
}



char *showutf(char *thestring)
{
  char tempval[100];
  static char retval[500];
  int i;


  retval[0] = '\0';

  if(!strcmp(thestring,FixUTF(thestring)))
  {
    
    return thestring;
  }


  strcat(retval,thestring);


  strcat(retval," (Hex:");


  for(i=0;i<(int)strlen(thestring);i++)
  {

	
    if((i==0)||(i==((int)strlen(thestring)-1)))
	{
      continue;
	}

    sprintf(tempval," %02x",(unsigned char)thestring[i]);
    strcat(retval,tempval);
  }

  strcat(retval,")");

  return retval;

}

  
void DisplayFixedString(Widget w,char *value)
{
  

  int i,len,insertindex,started=0;
  char *newvalue;

  len = strlen(value);

  newvalue = (char *)malloc(len+50);
  if(newvalue==NULL)
  {
    printf("Error: out of memory trying to _allocate %d\n",len);
	XBell(mydisplay,50);
	return;
  }


  insertindex = 0;
  for(i=0;i<len;i++)
  {
    if((unsigned char)value[i]<=127)
	{
      started = 0;
	  newvalue[insertindex] = value[i];
	  insertindex = insertindex + 1;
	}
	else if(started==0)
	{ 
      newvalue[insertindex] = '?';
      insertindex = insertindex + 1;
      started = 1;
	}
  }
  newvalue[insertindex] = '\0';


  XmTextSetString(w,newvalue);	      

  free(newvalue);
}


void QueryInfoItem(int num, int num2)
{
  
  
  struct InfoPrintContent *curr,*curr2,*tempcurr;
  char *messagestring,*messagestring1,*messagestring2;
  char junk[1000],junk2[1000],junk3[1000],junk4[1000],newstring[1000],savejunk[1000],tempstr[1000];
  int thisindex=1,i,j,k,len,goodvalue,foundcode,intvalue,thiscode,thisECC,thisgeom,compare;
  int paddist,paddist1,paddist2,dopad,num_spaces,looper,outerloop;
  int addy,addy2,insertpoint,thislen,added=0,starter=0,metastarted=0;
  extern Widget html_button;
  extern int VertexPrintLimit;
  extern char *GetEECode(int attr_code, int enum_num);


  if((NO_QUERY==1)&&(num2>0))
    {
      
	  XmTextSetString(info_text_area,"\n");	      
      return;
    }
  

  

  if(NGA_TYPE==1)
    {
      
      GetCodeDist(&paddist1,&paddist2);
      
      paddist = 20;	  
    }
  else
    {
      paddist = 40;
    }
  
  
  curr = InfoRoot;
  thisindex = 1;
  while(thisindex<num)
    {
      curr=curr->next;
      thisindex++;
      
      if(curr==NULL)
	{
	  
	  return;
	}
    }
  
  
  
  if(num2>0)
    {
      compare = 1;
    }
  else
    {
      compare = 0;
    }
  
  
  if(compare==1)
    {
      curr2 = InfoRoot;
      thisindex = 1;
      while(thisindex<num2)
	{
	  curr2=curr2->next;
	  thisindex++;
	  
	  if(curr2==NULL)
	    {
	      
	      return;
	    }
	}
    }
  
  
  

  
  set_cursor(mydisplay,mywindow,WATCH);
  set_cursor(XtDisplay(infohead),XtWindow(infohead),WATCH);
  
  
  
  
  messagestring = (char *)malloc(10);
  messagestring[0] = '\0';

  
  if(NGA_TYPE==1)
    {
      if(compare==1)
	{
	  if(curr->ECC!=curr2->ECC)
	    {
	      sprintf(junk,"Different Feature Types: \n%s (%s) and %s (%s)\n",
		      GetECCCode(curr->ECC),GetECCLabel(curr->ECC),
		      GetECCCode(curr2->ECC),GetECCLabel(curr2->ECC));
	      
	      messagestring = (char *) realloc(messagestring,strlen(messagestring)+strlen(junk)+10);
	      strcat(messagestring,junk);
	    }
	}
      else
	{
	  if(curr->geom==C_GRID)
	  {
	    sprintf(junk,"Grid Post:\n");
	  }
	  else
	  {
	    sprintf(junk,"Feature Type: %s (%s):\n",
		  GetECCCode(curr->ECC),GetECCLabel(curr->ECC));
	  }

	  messagestring = (char *) realloc(messagestring,strlen(messagestring)+strlen(junk)+10);
	  strcat(messagestring,junk);
	}
    }
  

  
  
  messagestring = (char *) realloc(messagestring,strlen(messagestring)+ 10000);
  
  
  if(INFO_GEOMETRY==1)
    {
      if(compare==1)
	{
	  sprintf(junk,"%s",GetInfoGeomType(curr->geom,curr->ishole,curr->numholes));
	  sprintf(junk2,"%s",GetInfoGeomType(curr2->geom,curr2->ishole,curr2->numholes));
	  if(strcmp(junk,junk2))
	    {
	      sprintf(junk3,"Different Geometries: \n%s and %s\n",junk,junk2);
	      strcat(messagestring,junk3);
	    }
	}
      else if(curr->geom!=C_GRID)
	{
	  sprintf(junk,"%s\n",GetInfoGeomType(curr->geom,curr->ishole,curr->numholes));
	  strcat(messagestring,junk);
	}
    }
  
  
  if(INFO_DOMAIN==1)
    {
      junk[0] = '\0';
      
      if(compare==1)
	{
	  if(curr->domain!=curr2->domain)
	    {
	      sprintf(junk2,"%s",ParseDomainClass(curr->domain));
	      sprintf(junk3,"%s",ParseDomainClass(curr2->domain));
	      
	      if(NGA_TYPE==1)
		{
		  sprintf(junk,"Different Functional Categories: \n%s and %s\n",junk2,junk3);
		}
	      else
		{
		  sprintf(junk,"Different Domains: \n%s and %s\n",junk2,junk3);
		}
	    }
	}
      else
	{
	  if(NGA_TYPE==1)
	    {
	      sprintf(junk,"Functional Category: %s\n",ParseDomainClass(curr->domain));
	    }
	  else
	    {
	      sprintf(junk,"Domain: %s\n",ParseDomainClass(curr->domain));
	    }
	}
      
      strcat(messagestring,junk);
    }
  


  if(INFO_LENGTH==1)
    {
      if(compare==1)
	{
	  if (
		  (curr->length!=curr2->length) &&
		  (((curr->geom == C_LINE) && (curr2->geom == C_LINE)) ||
	      ((curr->geom == C_AREA) && (curr2->geom == C_AREA)))
	     )
	    {
		  sprintf(junk, "%lf",curr->X[curr->numcoords]);
		  sprintf(junk2,"%lf",curr->length);
		  sprintf(junk3,"%lf",curr2->X[curr2->numcoords]);
		  sprintf(junk4,"%lf",curr2->length);
		  if(  (!strcmp(junk,junk2))  && (!strcmp(junk3,junk4))  )
		  {
	        sprintf(junk,"Different %ss: \n%lf and %lf meters\n",
		      GetLengthName(curr->geom),curr->length,curr2->length);	
	        strcat(messagestring,junk);
		  }
		  else
		  {
	        sprintf(junk,"Different (2D) %ss: \n%lf and %lf meters\n",
		      GetLengthName(curr->geom),curr->length,curr2->length);	
	        strcat(messagestring,junk);
		  }
	    }

	  if(
		  ((curr->geom == C_AREA) && (curr2->geom == C_AREA))  ||
		  ((curr->geom == C_LINE) && (curr2->geom == C_LINE))
		)
	  {
		  sprintf(junk, "%lf",curr->X[curr->numcoords]);
		  sprintf(junk2,"%lf",curr->length);
		  sprintf(junk3,"%lf",curr2->X[curr2->numcoords]);
		  sprintf(junk4,"%lf",curr2->length);

		  if(
			  (  (strcmp(junk,junk2))  ||  (strcmp(junk3,junk4))  )  &&
			  (strcmp(junk,junk3))
			)
		  {
	        sprintf(junk,"Different (3D) %ss: \n%lf and %lf meters\n",
		      GetLengthName(curr->geom),
			  curr->X[curr->numcoords],curr2->X[curr2->numcoords]);	
	        strcat(messagestring,junk);
		  }
	  }
	}
      else
	{
	  if((curr->geom==C_LINE)||(curr->geom==C_AREA))
	    {
		  sprintf(junk, "%lf",curr->X[curr->numcoords]);
		  sprintf(junk2,"%lf",curr->length);
		  if(!strcmp(junk,junk2))
		  {
	        sprintf(junk,"%s: %lf meters\n",
		      GetLengthName(curr->geom),curr->length);
	        strcat(messagestring,junk);
		  }
		  else
		  {
		    sprintf(junk,"%s (2D): %lf meters\n",GetLengthName(curr->geom),curr->length);
	        strcat(messagestring,junk);

	        sprintf(junk,"%s (3D): %lf meters\n",GetLengthName(curr->geom),curr->X[curr->numcoords]);
	        strcat(messagestring,junk);
		  }
	    }
	}
    }
  
  
  if(INFO_AREA==1)
    {
      if(compare==1)
	{
	  if( 
	     (curr->geom == C_AREA)  &&
	     (curr2->geom == C_AREA) &&
	     (curr->area!=curr2->area)
	     )
	    {
	      if(USE_DOS==1)
		{
		  sprintf(junk,"Different (2D) Areas: \n%lf and %lf square meters (m^2)\n",
			  curr->area,curr2->area);
		}
	      else
		{
		  sprintf(junk,"Different (2D) Areas: \n%lf and %lf square meters\n",
			  curr->area,curr2->area);
		}
	      strcat(messagestring,junk);
	    }
	}
      else
	{
	  if(curr->geom == C_AREA)
	    {
	      if(USE_DOS==1)
		{
		  sprintf(junk,"Area (2D): %lf square meters (m^2)\n",curr->area);
		}
	      else
		{
		  sprintf(junk,"Area (2D): %lf square meters\n",curr->area);
		}
	      strcat(messagestring,junk);
	    }
	} 
    }
  

 
  if((INFO_FID==1)&&(NGA_TYPE==1))
    {
      if(compare==1)
	{
	  if(curr->FID!=curr2->FID)
	    {
	      sprintf(junk,"Different ID Numbers (FID/Objid/OBJECTID): \n%d and %d\n",
		      curr->FID,curr2->FID);
	      strcat(messagestring,junk);
	    }
	}
      else if(curr->FID>=0)
	{
	  sprintf(junk,"ID Number (FID/Objid/OBJECTID): %d\n",curr->FID);
	  strcat(messagestring,junk);
	}
    }


  if(
     (INFO_GFID==1)&&
	 (ATTRTYPE_TREX()!=1) &&
     (HAS_ID[ATTRIBUTION_TYPE]==1)
     )
  { 
    if(compare==1)
	{
	  if(strcmp(curr->IDstr,curr2->IDstr))
	  {
	    
	    sprintf(junk,"Different %s      and %s",curr->IDstr,curr2->IDstr);
	    strcat(messagestring,junk);
	  }
	}
	else
	{
	  sprintf(junk,"%s",curr->IDstr);
      strcat(messagestring,junk);
	}
  }

  
  if(  ((INFO_COORDS==1)||(curr->geom==C_GRID))  && (compare==0)  )
    {
      
      
      if(curr->numcoords>GLOBAL_SAVE_COORDS)
	{
	  
	  if(GLOBAL_SAVE_COORDS_X!=NULL)
	    {
	      free(GLOBAL_SAVE_COORDS_X);
	      free(GLOBAL_SAVE_COORDS_Y);
	      free(GLOBAL_SAVE_COORDS_start);
	      free(GLOBAL_SAVE_COORDS_end);
	    }
	  
	  GLOBAL_SAVE_COORDS_X     = (double *)malloc(SzD*curr->numcoords);
	  GLOBAL_SAVE_COORDS_Y     = (double *)malloc(SzD*curr->numcoords);
	  GLOBAL_SAVE_COORDS_start = (int *)   malloc(SzI*curr->numcoords);
	  GLOBAL_SAVE_COORDS_end   = (int *)   malloc(SzI*curr->numcoords);
	}
      
      GLOBAL_SAVE_COORDS = curr->numcoords;
      
      
      
      if(curr->numcoords == 1)
	{
	  if(curr->geom==C_GRID)
	  {
	    strcat(messagestring,"\nLocation/Elevation:\n ");
	  }
	  else
	  {
	    strcat(messagestring,"1 vertex:\n");
	  }
	}
      else if(curr->numcoords <= VertexPrintLimit)
	{
	  sprintf(junk,"%d vertices:\n",curr->numcoords);
	  strcat(messagestring,junk);
	}
      else
	{
	  sprintf(junk,"%d vertices (more than current print tolerance of %d)\n",
		  curr->numcoords,VertexPrintLimit);
	  strcat(messagestring,junk);
	}



      if(curr->numcoords <= VertexPrintLimit)
	{

      insertpoint = strlen(messagestring);


	  for(i=0; i<curr->numcoords; i++)
       {

	      GLOBAL_SAVE_COORDS_X[i]     = curr->X[i];
	      GLOBAL_SAVE_COORDS_Y[i]     = curr->Y[i];

	      GLOBAL_SAVE_COORDS_start[i] = insertpoint;
		  
	      if(i%1000==0)
		  {
		  

		  messagestring = (char *) realloc(messagestring,strlen(messagestring)+ 200000);
		  }
	      
	      if((i+1)<10)
		{
		  sprintf(junk,"%d:    ",i+1);
		}
	      else if((i+1)<100)
		{
		  sprintf(junk,"%d:   ",i+1);
		}
	      else if((i+1)<1000)
		{
		  sprintf(junk,"%d:  ",i+1);
		}
	      else
		{
		  sprintf(junk,"%d: ",i+1);
		}

		  if(curr->geom==C_GRID)
		  {
			  
			  junk[0] = '\0';
		  }

	      UseDMScoordinates = IUseDMScoordinates;

		  sprintf(tempstr,"%s%s\n",
			  junk,
			  Coordinate3DtoString(curr->X[i],curr->Y[i],curr->Z[i]));


		  thislen = strlen(tempstr);
		  for(j=0;j<thislen;j++)
		  {
			  messagestring[j+insertpoint] = tempstr[j];
		  }
		  messagestring[j+insertpoint] = '\0';
		  insertpoint = insertpoint + thislen;


		  GLOBAL_SAVE_COORDS_end[i]   = insertpoint;

		  UseDMScoordinates = 0;
            }
	  

	  if((curr->geom == C_AREA) && (curr->ishole < 2))  
	    {
	      UseDMScoordinates = IUseDMScoordinates;
	      sprintf(junk,"closing vertex:\n      %s\n",Coordinate3DtoString(curr->X[0],curr->Y[0],curr->Z[0]));
	      strcat(messagestring,junk);
	      UseDMScoordinates = 0;
	    }
	}
    }



   if(compare==1)
   {
     if((curr->geom==C_GRID)&&(curr2->geom==C_GRID))
	 {
	   if((curr->ID2str!=NULL)&&(curr2->ID2str!=NULL))
	   {
         if(strcmp(curr->ID2str,curr2->ID2str))
		 {  
           
           sprintf(junk,"Different filenames: %s\n and %s\n\n\n",curr->ID2str,curr2->ID2str);
           strcat(messagestring,junk);
		 } 
	   } 
	 } 
   }
  else if(curr->ID2str!=NULL)
  {
    if(curr->geom==C_GRID)
	{ 
      sprintf(junk,"%s",curr->IDstr);
      strcat(messagestring,junk);

      if(curr->ID2str!=NULL)
	  { 
        sprintf(junk,"\nOriginal filename:  %s\n",curr->ID2str);
        strcat(messagestring,junk);
	  } 
	}
  }




  
  messagestring  = (char *) realloc(messagestring,strlen(messagestring)+ 100000);
  messagestring1 = (char *) malloc(100000);
  messagestring2 = (char *) malloc(100000);


  messagestring1[0] = '\0';
  messagestring2[0] = '\0';

  if(UNIQARRAYBUILT==0)
    {
      BuildUNIQArray();
    }



  
  
  
  if(compare==1)
    {
      looper = 2;
    }
  else
    {
      looper = 1;
    }
  
  
  for(outerloop=1;outerloop<=looper;outerloop++)
    {
      if(outerloop==1)
	{
	  tempcurr = curr;
	}	
      else
	{
	  tempcurr = curr2;
	}
      
      for(i=0; i<tempcurr->numattr; i++)
	{
	  if(tempcurr->A[i].Label[0] == '*')
	    {
	      if((NGA_TYPE==1)&&(!strcmp(&tempcurr->A[i].Label[1],"Layer")))
		  {
		   sscanf(tempcurr->A[i].valueLabel,"%d%d",&thisECC,&thisgeom);
		   thisECC = thisECC + 1;
		  
		   num_spaces = 0;
		   k = 0;
		  
		  for(j=0;j<(int)strlen(tempcurr->A[i].valueLabel);j++)
		    {
		      if(num_spaces>=2)
			{
			  junk2[k] = tempcurr->A[i].valueLabel[j];
			  k = k + 1;
			}
		      
		      if(tempcurr->A[i].valueLabel[j]==' ')
			{
			  num_spaces = num_spaces + 1;
			}
		    }
		  junk2[k] = '\0';
		  
		  if(compare==0)
		    {
		      sprintf(junk,"\nLayer: %s (%s) (%s) (%s)\n",
			      GetECCCode (thisECC),
			      GetECCLabel(thisECC),
			      GetShortGeomName(thisgeom),
			      junk2);
			 
		    }
		  else
		    {
		      sprintf(junk,"\nLayer: %s (%s) (%s) (%s)!!\n",
			      GetECCCode (thisECC),
			      GetECCLabel(thisECC),
			      GetShortGeomName(thisgeom),
			      junk2);
		    }
		}
	      else
		{
		  
		  sprintf(junk,"%s %s\n",&tempcurr->A[i].Label[1], tempcurr->A[i].valueLabel);
		}
	      
	      if(outerloop==1)
		{
		  sprintf(savejunk,"%s",junk);
		}
	    }
	}
    }
  

  if(compare==0)
    {
      strcat(messagestring,junk);
	  strcat(messagestring,"\n");
    }
  else if(strcmp(junk,savejunk))
    {
      strcat(messagestring,"Different Layers:");
      
      len = strlen(savejunk);
      savejunk[len-3] = '\0';  
      savejunk[len-2] = '\0';
      strcat(messagestring,savejunk);
      
      strcat(messagestring,"   and:");
      
      len = strlen(junk);
      junk[len-3] = '\n';
      junk[len-2] = '\0';
      strcat(messagestring,junk);
	  strcat(messagestring,"\n");
	  strcat(messagestring,"\n");
    }
  
  
  
  if(INFO_ATTRIBUTES==1)
    {
      if((compare==0)&&(NGA_TYPE==1))
	  {
	   if(curr->numattr==1)
	   {
		
	    sprintf(junk,"Non-Metadata Attributes:\n\n\n");
	    strcat(messagestring,junk);
	    sprintf(junk,"Metadata Attributes:\n\n");
	   }
	   else if(curr->geom==C_GRID)
	     {
	       sprintf(junk,"\n\n");
	     }
	   else
	   {
	    sprintf(junk,"Non-Metadata Attributes:\n\n");
	   }
	   strcat(messagestring,junk);
	  }
      
      
  
      
      
      for(outerloop=1;outerloop<=looper;outerloop++)
	{
	  if(outerloop==1)
	    {
	      tempcurr = curr;
	    }
	  else
	    {
	      tempcurr = curr2;
	    }
	  
	  
	  for(i=0; i<tempcurr->numattr; i++)
	    {
	      if(tempcurr->A[i].Label[0] == '*')
		  {
           if(NGA_TYPE==0)
		   {
		    
		    sprintf(junk,"%s %s\n",&tempcurr->A[i].Label[1], tempcurr->A[i].valueLabel);
		  
		    if(outerloop==1)
			{
		      strcat(messagestring1,junk);
		    }
		    else
		    {
		      strcat(messagestring2,junk);
		    }
		  }
		}
	      else
		{		  
		  goodvalue = 0;
		  foundcode = 0;
		  
		  if(
			  (IsMetadata(tempcurr->A[i].code))  &&
			  (compare==0)                       &&
			  (outerloop==1)                     &&
			  (metastarted==0)
			)
		  {
			 
			 metastarted = 1;
			 strcat(messagestring1,"\nMetadata Attributes:\n\n");
		  }


		  for(j=1;j<INsac_loop;j++)
		    {
		      if(UNIQSAC[j]==1)  
			{
			  if(NGA_TYPE==1)
			    {
			      if(!strcmp(GetEACCode(j),tempcurr->A[i].code))
				{
				  foundcode = 1;
				  thiscode = j;
				  break;
				}
			    }
			  else
			    {
			      if(!strcmp(GetEACLabel(j),tempcurr->A[i].code))
				{
				  foundcode = 1;
				  thiscode = j;
				  break;
				}
			    }
			}
		    }
		  
		  if(foundcode==1)
		    {
		      if(InfoSac[j]==1)
			{
			  goodvalue = 1;
			}
		    }
		  else
		    {
		      printf("could not find code %s\n",tempcurr->A[i].code);
		    }
		  
		  
		  if(goodvalue==1)
		    {
		      if(NGA_TYPE==1)
			{
			  sprintf(junk,"%s ",tempcurr->A[i].code);
			}
		      else
			{
			  sprintf(junk,"%s ",GetEACLabel(thiscode));
			}
		      
		      len = strlen(junk);
		      for(j=len;j<paddist1;j++)
			{
			  strcat(junk," ");
			}
		      
		      if(outerloop==1)
			{
			  strcat(messagestring1,junk);
			}
		      else
			{
			  strcat(messagestring2,junk);
			}
		      
		      
		      
		      if(tempcurr->A[i].valueLabel == NULL)
			{
			  if((INFO_HEX)&&(tempcurr->A[i].value[0]=='"')) 
			  {
				
			    sprintf(junk,"%s",showutf(tempcurr->A[i].value));
			  }
			  else
			  {
			    

				
			    sprintf(junk,"%s ",tempcurr->A[i].value);
			  }


			 
			  dopad = 1;
			}
		      else
			{
			  
			  
			  sscanf(tempcurr->A[i].value,"%d",&intvalue);
			  if(NGA_TYPE==1)
			    {
			      sprintf(junk,"%s",GetEECode(thiscode,intvalue));
			      dopad = 1;
			    }
			  else
			    {
			      			  
			      dopad = 0;
			    }
			}
		      
		      
		      if(dopad==1)
			{
			  len = strlen(junk);
			  for(j=len;j<paddist2;j++)
			    {
			      strcat(junk," ");
			    }	    
			  
			  if(outerloop==1)
			    {
			      strcat(messagestring1,junk);
			    }
			  else
			    {
			      strcat(messagestring2,junk);
			    }
			}
		      
		      
		      
		      if(INFO_ATTR_LABELS==1)
			{
			  sprintf(junk,"%s ",tempcurr->A[i].Label);
			  len = strlen(junk);
			  for(j=len;j<paddist;j++)
			    {
			      strcat(junk," ");
			    }
			  
			  if(outerloop==1)
			    {
			      strcat(messagestring1,junk);
			    }
			  else
			    {
			      strcat(messagestring2,junk);
			    }
			}
		      
		      
		      
		      if(INFO_ATTR_VALUES==1)
			{
			  if(tempcurr->A[i].valueLabel != NULL)
			    {
			      if(NGA_TYPE==1)
				{
				  sprintf(junk,"(%s) ",tempcurr->A[i].valueLabel);
				}
			      else
				{
				  sprintf(junk,"%s ",tempcurr->A[i].valueLabel);
				}
			      
			      len = strlen(junk);
			      for(j=len;j<paddist;j++)
				{
				  strcat(junk," ");
				}
			      if(outerloop==1)
				{
				  strcat(messagestring1,junk);
				}
			      else
				{
				  strcat(messagestring2,junk);
				}
			    }
			}			  
		      
		      if(compare==0)
			{
			  strcat(messagestring1,"\n");
			}
		      else
			{
			  if(outerloop==1)
			    {
			      strcat(messagestring1,"!!\n");
			    }
			  else
			    {
			      strcat(messagestring2,"!!\n");
			    }
			}
		    }
		}
	    }
	}    
    }
  
  
  
  if(INFO_ATTRIBUTES==1)
    {
      if((compare==1)&&(curr->geom!=C_GRID)&&(curr2->geom!=C_GRID))
	{
	  addy = (int)messagestring1;
	  starter = 0;
	  added = 0;
	  
	  
	  strcat(messagestring,"\nAttributes assigned to first feature but not second:\n\n");
	  
	  addy2 = (int)strstr(messagestring1,"!!\n");
	  while(addy2>addy)
	    {
	      
	      
	      
	      
	      for(i=0;i<addy2-addy-starter+3;i++)
		{
		  newstring[i] = messagestring1[i+starter];
		}
	      newstring[i] = '\0';
	      starter = addy2-addy+3;
	      
	      
	      
	      
	      if(strstr(messagestring2,newstring)==0)
		{
		  sprintf(junk,"%s",newstring);
		  len = strlen(junk);
		  junk[len-3] = '\n';
		  junk[len-2] = '\0';
		  strcat(messagestring,junk);
		  added = 1;
		}
	      addy2 = (int)strstr(&messagestring1[addy2-addy+3],"!!\n");		  
	    }
	  

	  if(added==0)
	  {
	     strcat(messagestring,"  None\n");
	  }
	  

	  addy = (int)messagestring2;
	  starter = 0;
	  added   = 0;
	  
	  strcat(messagestring,"\nAttributes assigned to second feature but not first:\n\n");
	  
	  addy2 = (int)strstr(messagestring2,"!!\n");
	  while(addy2>addy)
	    {
	      
	      
	      
	      
	      for(i=0;i<addy2-addy-starter+3;i++)
		{
		  newstring[i] = messagestring2[i+starter];
		}
	      newstring[i] = '\0';
	      starter = addy2-addy+3;
	      
	      
	      
	      
	      if(strstr(messagestring1,newstring)==0)
		{
		  sprintf(junk,"%s",newstring);
		  len = strlen(junk);
		  junk[len-3] = '\n';
		  junk[len-2] = '\0';
		  strcat(messagestring,junk);
		  added = 1;
		}
	      addy2 = (int)strstr(&messagestring2[addy2-addy+3],"!!\n");		  
	    }

	  if(added==0)
	  {
	     strcat(messagestring,"  None\n");
	  }
	  added = 0;

	  
	}
      else
	{
	  strcat(messagestring,messagestring1);
	}
    }


  if(USE_DOS==1)
  {
    if(CreateHTML(messagestring)>0)
	{ 
      XtSetSensitive(html_button,True);
	} 
    else
	{ 
      XtSetSensitive(html_button,False);
	} 
  }

  DisplayFixedString(info_text_area,messagestring);



  INFOLEN = strlen(messagestring);
  free(messagestring);
  free(messagestring1);
  free(messagestring2);
  UnderlineSpecialVertex();

  set_cursor(mydisplay,mywindow,GOOD);
  set_cursor(XtDisplay(infohead),XtWindow(infohead),ARROW);
}



void HandlePostDescribe()
{
  
  int *pos_list;
  int pos_count;

  if(info_list==NULL)
  {
	return;
  }

  XmListGetSelectedPos(info_list,&pos_list,&pos_count);

  if(pos_count>1)
  {
    XmTextSetString(info_text_area,"\n");
  }
  else if(InfoItemsQueried==1)
  {
	QueryInfoItem(1,-1);
  }
}



void choose_specific_info(Widget unused,XtPointer client_data,XtPointer call_data)
{ 
  XmString *selectlist;
  char *text;
  int *pos_list;
  int pos_count,thisindex,i=0,refresh=(int)client_data;
  struct InfoPrintContent *curr;
  double tmpLLX,tmpURX,tmpLLY,tmpURY;
  static int LOCALBUSY = 0;

  

  if(LOCALBUSY==1)
    {
      
      return;
    }


  LOCALBUSY         = 1;
  DRAWING_INFO_ITEM = 1;

  if(refresh!=4)
  {
	
    INFOLEN           = 0;
  }

  
  XmListGetSelectedPos(info_list,&pos_list,&pos_count);


  if(pos_count<1)
    {
      TransferCleanPixmap();
      SPECIAL_VERTEX = -1;
      XmTextSetString(info_text_area,"\n");	      
      LOCALBUSY = 0;
      DRAWING_INFO_ITEM = 0;  
      
      DrawTopGrid();
      return;
    }


  
  
  XtVaGetValues(info_list,
		XmNselectedItems    ,&selectlist,
		NULL);
  
  XmStringGetLtoR(selectlist[0],
		  (XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &text);
  
  if(!strncmp(text,"     ",5))
    {
      TransferCleanPixmap();
      SPECIAL_VERTEX = -1;
      XmTextSetString(info_text_area,"\n");	      
      LOCALBUSY = 0;
      DRAWING_INFO_ITEM = 0;  
      
      DrawTopGrid();
      return;
    }


  if((refresh==1)||(refresh==4))
    {
      
      if((CenterZoomOnVertices==1)&&(SPECIAL_VERTEX>=0))
	{
	  

	  
	  
	  
	  tmpLLX = GLOBAL_SAVE_COORDS_X[SPECIAL_VERTEX] - VPAD_DIST;
	  tmpLLY = GLOBAL_SAVE_COORDS_Y[SPECIAL_VERTEX] - VPAD_DIST;
	  tmpURX = GLOBAL_SAVE_COORDS_X[SPECIAL_VERTEX] + VPAD_DIST;
	  tmpURY = GLOBAL_SAVE_COORDS_Y[SPECIAL_VERTEX] + VPAD_DIST;
	  
	  
	 

	  

	  SaveXScroll = ScrollPercent(1);
      SaveYScroll = ScrollPercent(2);

	  SetZoomValues(tmpLLX,tmpLLY,tmpURX,tmpURY);


	  MakePixmap3();
	  set_color (drawing_a, "White",(XtPointer)NULL);
	  XFillRectangle (XtDisplay (drawing_a), pixmap,   mygc, 0, 0, width, height);
	  XFillRectangle (XtDisplay (drawing_a), mywindow, mygc, 0, 0, width, height);
	  SetColorRight();
	  
	  NOT_ZOOMED = 0; 
	  
	  SAVE_ZOOM_STATE(SaveXScroll,SaveYScroll); 
	  DRAWING_INFO_ITEM = 0;
	  DrawAll();
	  DRAWING_INFO_ITEM = 1;
	}
      else
	{
	  TransferCleanPixmap();
	}
    }
  else if(refresh==2)
    {
      
      TransferCleanPixmap();
      SPECIAL_VERTEX = -1;
    }


  DrawSpecialInfoVertex();

  for(i=0;i<pos_count;i++)
    {
      curr = InfoRoot;
      thisindex = 0;


      if(curr==NULL) 
	{
	  XBell(mydisplay,50);
	  printf("error: NULL root\n");
	  LOCALBUSY         = 0;
	  DRAWING_INFO_ITEM = 0;
      
      DrawTopGrid();
	  return;
	}

      while(thisindex<(pos_list[i]-1))
	{
	  curr=curr->next;

	  thisindex++;
	  
	  if(curr==NULL)
	    {
	      LOCALBUSY         = 0;
	      DRAWING_INFO_ITEM = 0;
		  XmTextSetString(info_text_area,"\n");	      
          
          DrawTopGrid();
	      return;
	    }
	}
      DrawInfoItem(curr);
    }

  
  DrawTopGrid();

  if(pos_count==1)
    {
      if(refresh==4)
	  {
        UnderlineSpecialVertex();  
	  }
      else
	  {
        QueryInfoItem(pos_list[0],-1);
	  }
  }
  else if(pos_count==2)
    {
      QueryInfoItem(pos_list[0],pos_list[1]);
  }
  else
    {
      XmTextSetString(info_text_area,"\n");	      
    }

  CleanScreen();
  LOCALBUSY = 0;
  DRAWING_INFO_ITEM = 0;
}



void ErrFixMarkCallback(Widget w,XtPointer client_data,XtPointer call_data)
{ 
  int num=(int)client_data;
  int *pos_list;
  int pos_count,i,numtotal,errtype;
  XmString newstring;
  XmString *replace;
  char temp[1000];
  

  if(num>8000)
    {
      errtype = num-8000;
      num = 8;
    }
  else if(num>7000)
    {
      errtype = num-7000;
      num = 7;
    }
  else if(num>6000)
    {
      errtype = num-6000;
      num = 6;
    }
  else if(num>5000)
    {
      errtype = num-5000;
      num = 5;
    }
  else if(num>4000)
    {
      errtype = num-4000;
      num = 4;
    }
  else if(num>3000)
    {
      errtype = num-3000;
      num = 3;
    }
  else if(num>2000)
    {
      errtype = num-2000;
      num = 2;
    }
  else if(num>1000)
    {
      errtype = num-1000;
      num = 1;   
    }
  

  


  if((num==3)||(num==4)||(num==6)||(num==7))
    {
      XtVaGetValues(FixList[errtype],XmNitemCount,&numtotal,NULL);
      
      replace = (XmString *) (malloc(sizeof(XmString *) * numtotal));
      if(replace==NULL){printf("ErrFixMarkCallback: out of allocation memory!\n"); ExitWrapper(-1);}

      for(i=0;i<numtotal;i++)
	{
	  if(num==3)
	    {
	      sprintf(temp,"%s #%d <repair with algorithm #1>",ErrorLookup[errtype].name,i+1);
	    }
	  else if(num==4)
	    {
	      sprintf(temp,"%s #%d <repair with algorithm #2>",ErrorLookup[errtype].name,i+1);
	    }
	  else if(num==6)
	    {
	      sprintf(temp,"%s #%d <repair with algorithm #3>",ErrorLookup[errtype].name,i+1);
	    }
	  else if(num==7)
	    {
	      sprintf(temp,"%s #%d <repair with algorithm #4>",ErrorLookup[errtype].name,i+1);
	    }
	  else
	    {
	      printf("(1) bad arg %d to ErrFixMarkCallback\n",num);
	    }
	  replace[i] = XmStringCreate(temp,"mytag1"); 
	}
      XmListReplaceItemsPos(FixList[errtype],replace,numtotal,1);

      for(i=0;i<numtotal;i++)
	{
	  XmStringFree(replace[i]);
	}
      free(replace);
    }
  else
    {
      XmListGetSelectedPos(FixList[errtype],&pos_list,&pos_count);
      
      for(i=0;i<pos_count;i++)
	{
	  if(num==1)
	    {
	      sprintf(temp,"%s #%d <repair with algorithm #1>",ErrorLookup[errtype].name,pos_list[i]);
	      newstring = XmStringCreate(temp,"mytag1"); 
	    }
	  else if(num==2)
	    {
	      sprintf(temp,"%s #%d <repair with algorithm #2>",ErrorLookup[errtype].name,pos_list[i]);
	      newstring = XmStringCreate(temp,"mytag1"); 
	    }
	  else if(num==5)
	    {
	      sprintf(temp,"%s #%d <repair with algorithm #3>",ErrorLookup[errtype].name,pos_list[i]);
	      newstring = XmStringCreate(temp,"mytag1"); 
	    }
	  else if(num==8)
	    {
	      sprintf(temp,"%s #%d <repair with algorithm #4>",ErrorLookup[errtype].name,pos_list[i]);
	      newstring = XmStringCreate(temp,"mytag1"); 
	    }
	  else
	    {
	      printf("(2) bad arg %d to ErrFixMarkCallback\n",num);
	    }
	  XmListReplaceItemsPos(FixList[errtype],&newstring,1,pos_list[i]);
	}
      free(pos_list);
    }
  XmListDeselectAllItems(FixList[errtype]);
}



void Help_Fix_Callback(Widget w,XtPointer data,XtPointer callData)
{
  int errtype=(int)data;
  char message[2000];
  

  sprintf(message,"This window is used to select algorithms to repair conditions.\n\
The conditions found are listed in the scrolling pane at the top of the\n\
window.  These conditions are ordered exactly the same as in the\n\
\"Specific Conditions\" list, if one wants to examine their values\n\
precisely.\n\n\
The procedure for repairing conditions is to specify which of 2 algorithms\n\
are to be used to repair the conditions, and then click the \"Create\n\
Patch File\" button to create the patch file \"seeit-patch\".  This\n\
patch file will then contain the information needed to repair the\n\
conditions.  However, SEE-IT only repairs T-Vertices at this time, so\n\
repairs for any other conditions using the patch file are possible, but\n\
are not done by SEE-IT at this time.\n\n\
To specify which algorithm is to be used to fix which conditions,\n\
select any number of the conditions in the list, and then click either\n\
the \"Mark Selected to be repaired with algorithm #1\" or the\n\
\"Mark Selected to be repaired with algorithm #2\" buttons to specify\n\
which algorithm those selected conditions are to be repaired with.\n\
Alternatively, one may choose a short cut method of specifying that\n\
ALL T-Vertices are to be repaired with a particular algorithm by selecting\n\
the \"Mark ALL to be repaired with algorithm #1\" button or the \"Mark ALL\n\
to be repaired with algorithm #1\" button.\n\n");

  if(errtype==TVERT)
    {
      strcat(message,"T-Vertex note: It is allowed to repair some T-Vertices with 1 algorithm and\n\
others with another algorithm.  However, it is NOT allowed to repair the\n\
same polygon with more than 1 algorithm (several T-Vertices may occur on\n\
a single polygon).  If the user attemps to create a patch file specifying\n\
both algorithms to be used on a single polygon, an error alert will be\n\
generated and the patch file will not be made.\n\n");
    }

  strcat(message,"Patch files may be applied to an STF using the \"Apply Patch File\" option\n\
under the \"Inspection\" menu.\n");

not_while_running(w,message,1003,"Repair help",5);
}


void Help_Fix1_Callback(Widget w,XtPointer data,XtPointer callData)
{
  int errnum = (int)data;
  
  if(errnum==TVERT)
    {
      not_while_running(w,"T-Vertex repairing algorithm #1:\n\n\
This algorithm repairs a T-Vertex by adding a new vertex to\n\
the polygon which contains a T-Vertex at that point.  This\n\
new vertex will lie on an edge of the existing polygon,\n\
and it's elevation will be interpolated from it's adjacent\n\
vertices.\n\n\
Example:\n\
Consider the polygon:\n\
    (100,100,0)  \n\
    (200,100,100)\n\
    (200,200,200)\n\
Assume another polygon exists with vertices:\n\
    (200,150,95)\n\
    (300,100,15)\n\
    (300,200,65)\n\n\
Then, a T-Vertex exists at the point (200,150) on the\n\
first polygon.  This algorithm will re-form the first\n\
polygon as:\n\
    (100,100,0)  \n\
    (200,100,100)\n\
    (200,150,150)  <-- new vertex\n\
    (200,200,200)\n\n\
Note that the elevation of the new vertex is 150,\n\
not 95, as given by the other point involved in the\n\
T-Vertex.  (150 = (100+200)/2)",1004,"T-Vertex repair: algorithm 1 description",5);
    }
  else if((errnum==G_DUPS)||(errnum==C_DUPS))
    {
      not_while_running(w,"Duplicate repairing algorithm #1:\n\n\
All conditions of type \"Geometric Duplicates\" of \"Complete Duplicates\" will\n\
involve 2 objects.  The first repair technique (this one) is to remove the\n\
first of these 2 objects from the transmittal.",1005,"Duplicate repair: algorithm 1 description",5);
    }
  else if(errnum==VTEAR)
    {
      not_while_running(w,"Vertical Tear repairing algorithm #1:\n\n\
All vertical tear conditions are defined by a 2 points having the\n\
same (x,y) with different z-values.  This algorithm is used to modify\n\
the upper z-value, changing it to be the same as the lower z-value.",
			1006,"Vertical Tear repair: algorithm 1 description",5);
    }
  else if(errnum==ELEVADJCHANGE)
    {
      not_while_running(w,"Elevation Change Between Adjacent Vertices repairing algorithm #1:\n\n\
All such conditions are defined by 2 adjacent vertices whose\n\
Z coordinates differ by too much. This repair technique changes\n\
the larger Z value to be identical to the smaller value.",
			1008,"Elevation Change Between Adjacent Vertices repair: algorithm 1 description",5);
    }
  else
    {
      not_while_running(w,"No primary repair is currently available for this condition."
			,1009,"No repair #1 available for this condition",5);
    }
}


void Help_Fix2_Callback(Widget w,XtPointer data,XtPointer callData)
{
  int errnum = (int)data;
  
  if(errnum==TVERT)
    {
      not_while_running(w,"T-Vertex repairing algorithm #2:\n\n\
This algorithm repairs a T-Vertex by breaking up polygons\n\
containing T-Vertices into new polygons.  The new polygons are\n\
defined by adding an edge from the T-Vertex to another vertex\n\
on the polygon (not an adjacent vertex).  The elevation of the\n\
T-Vertex will be interpolated from it's adjacent vertices.\n\n\
Example:\n\
Consider the polygon:\n\
    (100,100,0)  \n\
    (200,100,100)\n\
    (200,200,200)\n\
Assume another polygon exists with vertices:\n\
    (200,150,95)\n\
    (300,100,15)\n\
    (300,200,65)\n\n\
Then, a T-Vertex exists at the point (200,150) on the\n\
first polygon.  This algorithm will re-form the first\n\
polygon as 2 new polygons:\n\n\
    (100,100,0)  \n\
    (200,100,100)\n\
    (200,150,150)  <-- new vertex\n\n\
and\n\n\
    (200,150,150)  <-- new vertex\n\
    (200,200,200)\n\
    (100,100,0)  \n\n\
Note that the elevation of the new vertex is 150,\n\
not 95, as given by the other point involved in the\n\
T-Vertex.  (150 = (100+200)/2)",1010,"T-Vertex repair: algorithm 2 description",5);
    }
  else if((errnum==G_DUPS)||(errnum==C_DUPS))
    {
      not_while_running(w,"Duplicate repairing algorithm #1:\n\n\
All conditions of type \"Geometric Duplicates\" of \"Complete Duplicates\" will\n\
involve 2 objects.  The second repair technique (this one) is to remove the\n\
second of these 2 objects from the transmittal.",1011,"Duplicate repair: algorithm 2 description",5);
    }
  else if(errnum==VTEAR)
    {
      not_while_running(w,"Vertical Tear repairing algorithm #2:\n\n\
All vertical tear conditions are defined by a 2 points having the\n\
same (x,y) with different z-values.  This algorithm is used to modify\n\
the lower z-value, changing it to be the same as the upper z-value.",
			1012,"Vertical Tear repair: algorithm 2 description",5);
    }
  else if(errnum==ELEVADJCHANGE)
    {
      not_while_running(w,"Elevation Change Between Adjacent Vertices repairing algorithm #2:\n\n\
All such conditions are defined by 2 adjacent vertices whose\n\
Z coordinates differ by too much. This repair technique changes\n\
the smaller Z value to be identical to the larger value.",
			1014,"Elevation Change Between Adjacent Vertices repair: algorithm 2 description",5);
    }
  else
    {
      not_while_running(w,"No secondary repair is currently available for this condition."
			,1015,"No repair #2 available for this condition",5);
    }
}


void Help_Fix3_Callback(Widget w,XtPointer data,XtPointer callData)
{
  int errnum = (int)data;
  
  if(errnum==VTEAR)
    {
      not_while_running(w,"Vertical Tear repairing algorithm #3:\n\n\
All vertical tear conditions are defined by a 2 points having the\n\
same (x,y) with different z-values.  This algorithm is used to modify\n\
both the 2 z-values, changing them both to the average of the 2 values.",
			1016,"Vertical Tear repair: algorithm 3 description",5);
    }
  else if(errnum==ELEVADJCHANGE)
    {
      not_while_running(w,"Elevation Change Between Adjacent Vertices repairing algorithm #3:\n\n\
All such conditions are defined by 2 adjacent vertices whose\n\
Z coordinates differ by too much. This repair technique changes\n\
both Z values to be the average of the two values.",
			1018,"Elevation Change Between Adjacent Vertices repair: algorithm 3 description",5);
    }
  else
    {
      not_while_running(w,"No tertiary repair is currently available for this condition."
			,1019,"No repair #3 available for this condition",5);
    }
}



void Help_Fix4_Callback(Widget w,XtPointer data,XtPointer callData)
{
  int errnum = (int)data;

  if(errnum==ELEVADJCHANGE)
    {

      not_while_running(w,"Elevation Change Between Adjacent Vertices repairing algorithm #4:\n\n\
All such conditions are defined by 2 adjacent vertices whose\n\
Z coordinates differ by too much. This repair technique attempts\n\
to find 2 such conditions adjacent to each other (sharing 1 point),\n\
which form either a spike or depression at the shared point.  The\n\
elevation at the shared point is then discarded and replaced with\n\
a linear interpolation of the 2 neighbors' elevations.\n\n\
If adjacent conditions are not found, or a spike or depression\n\
is not found at the shared point between adjacent conditions,\n\
no repair is performed.",
			1021,"Elevation Change Between Adjacent Vertices repair: algorithm #4 description",5);
      
    }
  else
    {
      not_while_running(w,"No quaternary repair is currently available for this condition."
			,1022,"No repair #4 available for this condition",5);
    }
}




void GenerateFixWindow(Widget w, MyData *mydata)
{
  

  Widget rc,form,label1,Done;
  XmString *error_items;
  Arg resources[20];
  int n=0,total,i,mid;
  Dimension y1;
  char temp[200];
  char temp2[200];
  char temp3[200];
 
  int errtype    = mydata->check_num;
  int cloneindex = mydata->clonenum;
  int clonenum;


  clonenum = GetCloneNumber(cloneindex,errtype);
    
  if(deadfix[errtype]==1) 
    {
      XtSetArg(resources[n], XmNdeleteResponse, XmDESTROY); n++;

      if(clonenum==0)
	{
	  sprintf(temp3,"%s repair area",ErrorLookup[errtype].name);
	}
      else
	{
	  sprintf(temp3,"%s repair area (additional instantiation %d)",
		  ErrorLookup[errtype].name,clonenum);
	}


      fixhead[errtype] = 
	XtCreatePopupShell(temp3,topLevelShellWidgetClass,w,resources,n);
      
      rc = XtVaCreateWidget ("rc.error.list",xmRowColumnWidgetClass, fixhead[errtype], NULL);
      
      form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);
      

      sprintf(temp2,"%s conditions found:",ErrorLookup[errtype].name);

      label1 = XtVaCreateManagedWidget (temp2,
					xmLabelWidgetClass, form,
					XmNrightAttachment,  XmATTACH_POSITION,
					XmNrightPosition,    100,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    0,
					XmNalignment,        XmALIGNMENT_CENTER,
					LABELWTRANSLATE,
					NULL);
      XtManageChild(form);



      if(clonenum==0)
	{
	  total=ErrorLookup[errtype].number;
	}
      else
	{
	  total=CloneErrorLookup[cloneindex].number;
	}


      if(total==0)
	{
	  sprintf(temp,"No %s to repair!",ErrorLookup[errtype].name);
	  not_while_running(w,temp,1104,"No Selections",5);
	  return;
	}


      error_items = (XmString *) (malloc(sizeof(XmString *) * total));
      if(error_items==NULL){printf("error_items: out of allocation memory!\n"); ExitWrapper(-1);}

    
      for(i=1;i<=total;i++)
	{
	  sprintf(temp,"%s #%d <no repair algorithm specified>",ErrorLookup[errtype].name,i);
	  error_items[i-1] = XmStringCreate (temp, "mytag1");
	}


      FixList[errtype] = XmCreateScrolledList (rc, "list", NULL,0);
      
      if(total<10)
	{
	  i=total+1;
	}
      else
	{
	  i=10;
	}
      
      XtVaSetValues (FixList[errtype],
		     XmNitems,  error_items,
		     XmNitemCount, total,
		     XmNvisibleItemCount,     i,
		     XmNselectionPolicy, XmEXTENDED_SELECT,
		     NULL);
      XtManageChild (FixList[errtype]);
      

      for(i=0;i<total;i++)
	{
	  XmStringFree (error_items[i]);
	}     
      free(error_items);


      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);
      
      Done  = XtVaCreateManagedWidget("Help",xmPushButtonWidgetClass,form,
				      XmNlabelString, STRING("Mark Selected to be repaired with algorithm #1"),
				      XmNleftAttachment,  XmATTACH_POSITION,
				      XmNleftPosition,    1,
				      XmNrightAttachment,  XmATTACH_POSITION,
				      XmNrightPosition,    99,
				      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 
      
      XtAddCallback(Done, XmNactivateCallback,
		    ErrFixMarkCallback, (XtPointer) (1000+errtype));
      XtManageChild(Done);
      XtManageChild(form);
      
 
      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);
      Done  = XtVaCreateManagedWidget("Help",xmPushButtonWidgetClass,form,
				      XmNlabelString, STRING("Mark Selected to be repaired with algorithm #2"),
				      XmNleftAttachment,  XmATTACH_POSITION,
				      XmNleftPosition,    1,
				      XmNrightAttachment,  XmATTACH_POSITION,
				      XmNrightPosition,    99,
				      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 
      
      XtAddCallback(Done, XmNactivateCallback,
		    ErrFixMarkCallback, (XtPointer) (2000+errtype));
      XtManageChild(Done);
      XtManageChild(form);



      if((errtype==VTEAR)||(errtype==ELEVADJCHANGE))
	{
	  form = XtVaCreateWidget ("form2", xmFormWidgetClass, rc,
				   XmNfractionBase,  100,  
				   NULL);
	  Done  = XtVaCreateManagedWidget("Help",xmPushButtonWidgetClass,form,
					  XmNlabelString, STRING("Mark Selected to be repaired with algorithm #3"),
					  XmNleftAttachment,  XmATTACH_POSITION,
					  XmNleftPosition,    1,
					  XmNrightAttachment,  XmATTACH_POSITION,
					  XmNrightPosition,    99,
					  XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					  NULL
					  ); 
	  
	  XtAddCallback(Done, XmNactivateCallback,
			ErrFixMarkCallback, (XtPointer) (5000+errtype));
	  XtManageChild(Done);
	  XtManageChild(form);
	}

      
      if(errtype==ELEVADJCHANGE)
	{
	  form = XtVaCreateWidget ("form2", xmFormWidgetClass, rc,
				   XmNfractionBase,  100,  
				   NULL);
	  Done  = XtVaCreateManagedWidget("Help",xmPushButtonWidgetClass,form,
					  XmNlabelString, STRING("Mark Selected to be repaired with algorithm #4"),
					  XmNleftAttachment,  XmATTACH_POSITION,
					  XmNleftPosition,    1,
					  XmNrightAttachment,  XmATTACH_POSITION,
					  XmNrightPosition,    99,
					  XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					  NULL
					  ); 
	  
	  XtAddCallback(Done, XmNactivateCallback,
			ErrFixMarkCallback, (XtPointer) (8000+errtype));
	  XtManageChild(Done);
	  XtManageChild(form);
	}


      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);
      Done  = XtVaCreateManagedWidget("Help",xmPushButtonWidgetClass,form,
				      XmNlabelString, STRING("Mark ALL to be repaired with algorithm #1"),
				      XmNleftAttachment,  XmATTACH_POSITION,
				      XmNleftPosition,    1,
				      XmNrightAttachment,  XmATTACH_POSITION,
				      XmNrightPosition,    99,
				      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 
      
      XtAddCallback(Done, XmNactivateCallback,
		    ErrFixMarkCallback, (XtPointer) (3000+errtype));
      XtManageChild(Done);
      XtManageChild(form);


      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);
      Done  = XtVaCreateManagedWidget("Help",xmPushButtonWidgetClass,form,
				      XmNlabelString, STRING("Mark ALL to be repaired with algorithm #2"),
				      XmNleftAttachment,  XmATTACH_POSITION,
				      XmNleftPosition,    1,
				      XmNrightAttachment,  XmATTACH_POSITION,
				      XmNrightPosition,    99,
				      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 
      
      XtAddCallback(Done, XmNactivateCallback,
		    ErrFixMarkCallback, (XtPointer) (4000+errtype));
      XtManageChild(Done);
      XtManageChild(form);

    
      if((errtype==VTEAR)||(errtype==ELEVADJCHANGE))
	{
	  form = XtVaCreateWidget ("form2", xmFormWidgetClass, rc,
				   XmNfractionBase,  100,  
				   NULL);
	  Done  = XtVaCreateManagedWidget("Help",xmPushButtonWidgetClass,form,
					  XmNlabelString, STRING("Mark ALL to be repaired with algorithm #3"),
					  XmNleftAttachment,  XmATTACH_POSITION,
					  XmNleftPosition,    1,
					  XmNrightAttachment,  XmATTACH_POSITION,
					  XmNrightPosition,    99,
					  XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					  NULL
					  ); 
	  
	  XtAddCallback(Done, XmNactivateCallback,
			ErrFixMarkCallback, (XtPointer) (6000+errtype));
	  XtManageChild(Done);
	  XtManageChild(form);
	}


      if(errtype==ELEVADJCHANGE)
	{
	  form = XtVaCreateWidget ("form2", xmFormWidgetClass, rc,
				   XmNfractionBase,  100,  
				   NULL);
	  Done  = XtVaCreateManagedWidget("Help",xmPushButtonWidgetClass,form,
					  XmNlabelString, STRING("Mark ALL to be repaired with algorithm #4"),
					  XmNleftAttachment,  XmATTACH_POSITION,
					  XmNleftPosition,    1,
					  XmNrightAttachment,  XmATTACH_POSITION,
					  XmNrightPosition,    99,
					  XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					  NULL
					  ); 
	  
	  XtAddCallback(Done, XmNactivateCallback,
			ErrFixMarkCallback, (XtPointer) (7000+errtype));
	  XtManageChild(Done);
	  XtManageChild(form);
	}
    

      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);
      
      Done  = XtVaCreateManagedWidget("Help",xmPushButtonWidgetClass,form,
				      XmNlabelString, STRING("Describe algorithm #1"),
				      XmNleftAttachment,  XmATTACH_POSITION,
				      XmNleftPosition,    1,
				      XmNrightAttachment,  XmATTACH_POSITION,
				      XmNrightPosition,    50,
				      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 
      
      XtAddCallback(Done, XmNactivateCallback,
		    Help_Fix1_Callback, (XtPointer) errtype);
      XtManageChild(Done);


      Done  = XtVaCreateManagedWidget("Help",xmPushButtonWidgetClass,form,
				      XmNlabelString, STRING("Describe algorithm #2"),
				      XmNleftAttachment,  XmATTACH_POSITION,
				      XmNleftPosition,    50,
				      XmNrightAttachment,  XmATTACH_POSITION,
				      XmNrightPosition,    99,
				      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 
      
      XtAddCallback(Done, XmNactivateCallback,
		    Help_Fix2_Callback, (XtPointer) (errtype));
      XtManageChild(Done);
      XtManageChild(form);


      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);

      if((errtype==VTEAR)||(errtype==ELEVADJCHANGE))
	{

	  if(errtype==VTEAR)
	    {
	      mid = 99;
	    }
	  else
	    {
	      mid = 50;
	    }

	  Done  = XtVaCreateManagedWidget("Help",xmPushButtonWidgetClass,form,
					  XmNlabelString, STRING("Describe algorithm #3"),
					  XmNleftAttachment,  XmATTACH_POSITION,
					  XmNleftPosition,    1,
					  XmNrightAttachment,  XmATTACH_POSITION,
					  XmNrightPosition,    mid,
					  XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					  NULL
					  ); 

	  XtAddCallback(Done, XmNactivateCallback,
			Help_Fix3_Callback, (XtPointer) errtype);
	  XtManageChild(Done);	  

	  if(errtype==ELEVADJCHANGE)
	    {
	      Done  = XtVaCreateManagedWidget("Help",xmPushButtonWidgetClass,form,
					      XmNlabelString, STRING("Describe algorithm #4"),
					      XmNleftAttachment,  XmATTACH_POSITION,
					      XmNleftPosition,    mid,
					      XmNrightAttachment,  XmATTACH_POSITION,
					      XmNrightPosition,    99,
					      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					      NULL
					      ); 

	      XtAddCallback(Done, XmNactivateCallback,
			    Help_Fix4_Callback, (XtPointer) errtype);
	      XtManageChild(Done);	  
	    }

	  XtManageChild(form);
	}



      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);

      Done  = XtVaCreateManagedWidget("Help",xmPushButtonWidgetClass,form,
				      XmNlabelString, STRING("Attempt to create SEE-IT patch file"),
				      XmNleftAttachment,  XmATTACH_POSITION,
				      XmNleftPosition,    1,
				      XmNrightAttachment,  XmATTACH_POSITION,
				      XmNrightPosition,    99,
				      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 

      XtAddCallback(Done, XmNactivateCallback,
		    (XtCallbackProc)PatchCreateCallback, mydata);
      XtManageChild(Done);
      XtManageChild(form);


      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       NULL);
      
      Done  = XtVaCreateManagedWidget("Help",xmPushButtonWidgetClass,form,
				      XmNlabelString, STRING("Help"),
				      XmNleftAttachment,  XmATTACH_POSITION,
				      XmNleftPosition,    1,
				      XmNrightAttachment,  XmATTACH_POSITION,
				      XmNrightPosition,    50,
				      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 
      
      XtAddCallback(Done, XmNactivateCallback,
		    Help_Fix_Callback, (XtPointer) errtype);
      XtManageChild(Done);

      Done  = XtVaCreateManagedWidget("Done7",xmPushButtonWidgetClass,form,
				      XmNlabelString, STRING("Done"),
				      XmNleftAttachment,  XmATTACH_POSITION,
				      XmNleftPosition,    50,
				      XmNrightAttachment,  XmATTACH_POSITION,
				      XmNrightPosition,    99,
				      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 

      XtAddCallback(Done, XmNactivateCallback,
		    die_callback, (XtPointer) (8300+errtype));

      XtManageChild(Done);
      XtManageChild(form);
      XtManageChild(rc);
      
      MyPopup(fixhead[errtype]); 
      XtAddCallback(fixhead[errtype],XmNdestroyCallback,ShellDeath,
		    (XtPointer)(8300+errtype));


      deadfix[errtype]=0;

      XtVaGetValues (fixhead[errtype], XmNheight,    &y1,  NULL);
      XtVaSetValues (fixhead[errtype], XmNminHeight, y1 ,NULL);
      XtVaSetValues (fixhead[errtype], XmNmaxHeight, y1 ,NULL);

      XtAddEventHandler(fixhead[errtype],StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)y1));

    }
  else
    {
      ResetWidget(fixhead[errtype]);
    }
}


void fix_error(Widget w,MyData *mydata,XtPointer call_data)
{ 
  GenerateFixWindow(w,mydata);
}



void help_pad_callback(Widget w,XtPointer data,XtPointer callData)
{
  not_while_running(XtParent(w),"This window is used to set the amount of \"padding\" distance\n\
to be used when zooming the screen to individual conditions.\n\
When the screen is zoomed to individual conditions, the condition\n\
will be shown on the screen with at least this amount of distance,\n\
in meters, added on all sides of it.",1105,"Condition Padding Distance Help",5);
}

void help_vpad_callback(Widget w,XtPointer data,XtPointer callData)
{
  not_while_running(XtParent(w),"This window is used to set the amount of \"padding\" distance\n\
to be used when zooming the screen to individual vertices.\n\
When the screen is zoomed to individual vertices, the vertex\n\
will be shown on the screen with at least this amount of distance,\n\
in meters, added on all sides of it.",1411,"Vertex Padding Distance Help",5);
}

 


void select_all_retained(Widget w,XtPointer data,XtPointer callData)
{ 
  int type=(int)data;
  int i,j,totalselected,lastgroupfound,list_indexer;
  MyData *mydata;

  


  if((type!=1)&&(type!=2))
    {
      printf("bad type to SAL: %d\n",type);
      return;
    }

  set_cursor(mydisplay,mywindow,WATCH);
  set_cursor(XtDisplay(w),XtWindow(w),WATCH);
  set_cursor(XtDisplay(errorhead[Current_head]),XtWindow(errorhead[Current_head]),WATCH);



  for(i=1;i<=CONDITION_DEFINITIONS;i++)
    {
      if(ErrorLookup[i].number>0)
	{ 
	  if(ErrorLookup[i].pos_list_made>0)
	    {
	      free(ErrorLookup[i].pos_list);
	      ErrorLookup[i].pos_list_made = 0;
	    }
	  
	  totalselected  = 0;
	  lastgroupfound = -1;

	  for(j=1;j<=ErrorLookup[i].number;j++)
	    {
	      if(
		      ((type==1)&&(ErrorLookup[i].keepdismiss[j]==1)) || 
		      ((type==2)&&(ErrorLookup[i].keepdismiss[j]==0))    
		   )
		  {
            totalselected = totalselected + 1; 
		  } 
	    }


	  if(totalselected==0)
	    {
	      XmToggleButtonSetState(ErrorLookup[i].viewallwid, (Boolean)0,(Boolean)0);
	      XmToggleButtonSetState(ErrorLookup[i].viewsomewid,(Boolean)0,(Boolean)0);
	      
	      ErrorLookup[i].viewall  = 0;
	      ErrorLookup[i].viewsome = 0;
	      continue;
	    }

	  
	  ErrorLookup[i].pos_list = (int *)malloc(SzI*totalselected);
	  if(ErrorLookup[i].pos_list==NULL)
	    {
	      printf("Failed to alloc %d PLM2\n",totalselected);
	      ExitWrapper(-1);
	    }
	  ErrorLookup[i].pos_list_made = 0;



	  XmToggleButtonSetState(ErrorLookup[i].viewallwid, (Boolean)0,(Boolean)0);
	  XmToggleButtonSetState(ErrorLookup[i].viewsomewid,(Boolean)1,(Boolean)0);

	  ErrorLookup[i].viewall  = 0;
	  ErrorLookup[i].viewsome = 1;
	  
	  totalselected    = 0;
	  lastgroupfound   = -1;
	  list_indexer = 0;

	  for(j=1;j<=ErrorLookup[i].number;j++)
	    {

	      if(
		 ((type==1)&&(ErrorLookup[i].keepdismiss[j]==1)) || 
		 ((type==2)&&(ErrorLookup[i].keepdismiss[j]==0))    
		 )
		  { 
		  

		    ErrorLookup[i].pos_list[totalselected] = j;

		    totalselected = totalselected + 1;
		    ErrorLookup[i].pos_list_made = ErrorLookup[i].pos_list_made + 1;		 
		  } 
	    } 
	  


	  if(ErrorLookup[i].scrollwidmade==1)
	    {
	      mydata  = (MyData *) (malloc(sizeof(MyData)));
	      if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
	      mydata->clonenum  = -1;
	      mydata->check_num = i;
	      
	      
	      if(type==1)
		{
		  SelectRetainedOrIgnored(mydata,1);
		}
	      else
		{
		  SelectRetainedOrIgnored(mydata,0);
		}
	    }
	}
    }




  
  


  for(i=0;i<CLONE_DEFINITIONS;i++)
    {

      if(CloneErrorLookup[i].number>0)
	{ 
	  if(CloneErrorLookup[i].pos_list_made>0)
	    {
	      free(CloneErrorLookup[i].pos_list);
	      CloneErrorLookup[i].pos_list_made = 0;
	    }
	  
  totalselected  = 0;
  lastgroupfound = -1;

  for(j=1;j<=CloneErrorLookup[i].number;j++)
  {
	   if(
		 ((type==1)&&(CloneErrorLookup[i].keepdismiss[j]==1)) || 
		 ((type==2)&&(CloneErrorLookup[i].keepdismiss[j]==0))    
		 )
	   { 		
         totalselected = totalselected + 1;
	   }
  } 


	  if(totalselected==0)
	    {
	      XmToggleButtonSetState(CloneErrorLookup[i].viewallwid, (Boolean)0,(Boolean)0);
	      XmToggleButtonSetState(CloneErrorLookup[i].viewsomewid,(Boolean)0,(Boolean)0);
	      
	      CloneErrorLookup[i].viewall  = 0;
	      CloneErrorLookup[i].viewsome = 0;
	      continue;
	    }

	  
	  CloneErrorLookup[i].pos_list = (int *)malloc(SzI*totalselected);
	  if(CloneErrorLookup[i].pos_list==NULL)
	    {
	      printf("Failed to alloc %d PLM2\n",totalselected);
	      ExitWrapper(-1);
	    }
	  CloneErrorLookup[i].pos_list_made = 0;



	  XmToggleButtonSetState(CloneErrorLookup[i].viewallwid, (Boolean)0,(Boolean)0);
	  XmToggleButtonSetState(CloneErrorLookup[i].viewsomewid,(Boolean)1,(Boolean)0);

	  CloneErrorLookup[i].viewall  = 0;
	  CloneErrorLookup[i].viewsome = 1;
	  
	  totalselected    = 0;
	  lastgroupfound   = -1;
	  list_indexer = 0;

	  for(j=1;j<=CloneErrorLookup[i].number;j++)
	    {

	      if(
		 ((type==1)&&(CloneErrorLookup[i].keepdismiss[j]==1)) || 
		 ((type==2)&&(CloneErrorLookup[i].keepdismiss[j]==0))    
		 )
		{
		  
	      CloneErrorLookup[i].pos_list[totalselected] = j;
		  totalselected = totalselected + 1;
		  CloneErrorLookup[i].pos_list_made = CloneErrorLookup[i].pos_list_made + 1;
		}
	    } 
	  


	  if(CloneErrorLookup[i].scrollwidmade==1)
	    {
	      mydata  = (MyData *) (malloc(sizeof(MyData)));
	      if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
	      mydata->clonenum  = i; 
	      mydata->check_num = CloneErrorLookup[i].CloneNumber; 
	      
	      
	      if(type==1)
		{
		  SelectRetainedOrIgnored(mydata,1);
		}
	      else
		{
		  SelectRetainedOrIgnored(mydata,0);
		}
	    }
	}
    }


  
  UpdateAllTotals();

  set_cursor(mydisplay,mywindow,GOOD);
  set_cursor(XtDisplay(w),XtWindow(w),ARROW);
  set_cursor(XtDisplay(errorhead[Current_head]),XtWindow(errorhead[Current_head]),ARROW);

}





void KeepAllCB(Widget w, MyData  *closure, XtPointer call_data)
{
  Widget listwid;
  int cloneindex = closure->clonenum;
  int errnum     = closure->check_num;
  int itemCount,i,listwidmade;
  XmString *itemlist,*replace;
  char *thestr;
  char temp[1000];


  unsavedignore = 1;


  if(cloneindex<0)
    {
      listwid     = ErrorLookup[errnum].scrollwid;
      listwidmade = ErrorLookup[errnum].scrollwidmade;
      for(i=1;i<=ErrorLookup[errnum].number;i++)
	{
	  ErrorLookup[errnum].keepdismiss[i] = 1;
	}
    }
  else
    {
      listwid     = CloneErrorLookup[cloneindex].scrollwid;
      listwidmade = CloneErrorLookup[cloneindex].scrollwidmade;
      for(i=1;i<=CloneErrorLookup[cloneindex].number;i++)
	{
	  CloneErrorLookup[cloneindex].keepdismiss[i] = 1;
	}
    }

  if(listwidmade==0)
    {
      return;
    }

  
  XtVaGetValues(listwid,XmNitems,    &itemlist,NULL);
  XtVaGetValues(listwid,XmNitemCount,&itemCount,NULL);
  

  replace = (XmString *) (malloc(sizeof(XmString *) * itemCount));
  if(replace==NULL){printf("ErrFixMarkCallback2: out of allocation memory!\n"); ExitWrapper(-1);}


  for(i=0;i<itemCount;i++)
    {
      XmStringGetLtoR(itemlist[i],
		      (XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &thestr);
      
      if(thestr[1]=='I')
	{
	  
	  thestr[1] = 'R';
	  thestr[2] = 'E';
	  thestr[3] = 'T';
	  thestr[4] = 'A';
	  thestr[5] = 'I';
	  thestr[6] = 'N';
	}
      
      sprintf(temp,"%s",thestr);
      
      replace[i] = XmStringCreateLocalized(temp); 
    }
  

  if(cloneindex<0)
    {
      XmListReplaceItemsPos(ErrorLookup[errnum].scrollwid,replace,itemCount,1);
    }
  else
    {
      XmListReplaceItemsPos(CloneErrorLookup[cloneindex].scrollwid,replace,itemCount,1);
    }



  

  if(cloneindex<0)
  {
    if(ErrorLookup[errnum].pos_list_made<=0)
	{
      return;
	}
  }
  else
  {
    if(CloneErrorLookup[cloneindex].pos_list_made<=0)
	{
      return;
	}
  }


  


  XmListDeselectAllItems(listwid);

  XtVaSetValues (listwid,
		 XmNselectionPolicy,  XmMULTIPLE_SELECT,
		 NULL);
  
  if(cloneindex<0)
    {
      for(i=0;i<ErrorLookup[errnum].pos_list_made;i++)
	{
	  XmListSelectPos(ErrorLookup[errnum].scrollwid,
			  ErrorLookup[errnum].pos_list[i],0);
	}
    }
  else
    {
      for(i=0;i<CloneErrorLookup[cloneindex].pos_list_made;i++)
	{
	  XmListSelectPos(CloneErrorLookup[cloneindex].scrollwid,
			  CloneErrorLookup[cloneindex].pos_list[i],0);
	}
     }
  
    
  XtVaSetValues (listwid,
		 XmNselectionPolicy,  XmEXTENDED_SELECT,
		 NULL);
  
  XmListSetAddMode(listwid,False);
 
  
}



void DisAllCB(Widget unused, MyData  *closure, XtPointer call_data)
{
  Widget listwid;
  int cloneindex = closure->clonenum;
  int errnum     = closure->check_num;
  int itemCount,i,listwidmade;
  XmString *itemlist,*replace;
  char *thestr;
  char temp[1000];
  
  
  unsavedignore = 1;

  
  if(cloneindex<0)
    {
      listwid     = ErrorLookup[errnum].scrollwid;
      listwidmade = ErrorLookup[errnum].scrollwidmade;
      for(i=1;i<=ErrorLookup[errnum].number;i++)
	{
	  ErrorLookup[errnum].keepdismiss[i] = 0;
	}
    }
  else
    {
      listwid     = CloneErrorLookup[cloneindex].scrollwid;
      listwidmade = CloneErrorLookup[cloneindex].scrollwidmade;
      for(i=1;i<=CloneErrorLookup[cloneindex].number;i++)
	{
	  CloneErrorLookup[cloneindex].keepdismiss[i] = 0;
	}
    }

  if(listwidmade==0)
    {
      return;
    }


  
  XtVaGetValues(listwid,XmNitems,    &itemlist,NULL);
  XtVaGetValues(listwid,XmNitemCount,&itemCount,NULL);
  
  replace = (XmString *) (malloc(sizeof(XmString *) * itemCount));
  if(replace==NULL){printf("ErrFixMarkCallback2: out of allocation memory!\n"); ExitWrapper(-1);}
  
  
  for(i=0;i<itemCount;i++)
    {
      XmStringGetLtoR(itemlist[i],
		      (XmStringCharSet) XmSTRING_DEFAULT_CHARSET, &thestr);
      
      if(thestr[1]=='R')
	{
	  
	  thestr[1] = 'I';
	  thestr[2] = 'G';
	  thestr[3] = 'N';
	  thestr[4] = 'O';
	  thestr[5] = 'R';
	  thestr[6] = 'E';
	}
      
      sprintf(temp,"%s",thestr);
      
      replace[i] = XmStringCreateLocalized(temp); 
    }
  

  if(cloneindex<0)
    {
      XmListReplaceItemsPos(ErrorLookup[errnum].scrollwid,replace,itemCount,1);
    }
  else
    {
      XmListReplaceItemsPos(CloneErrorLookup[cloneindex].scrollwid,replace,itemCount,1);
    }




  

  if(cloneindex<0)
  {
    if(ErrorLookup[errnum].pos_list_made<=0)
	{
      return;
	}
  }
  else
  {
    if(CloneErrorLookup[cloneindex].pos_list_made<=0)
	{
      return;
	}
  }


  


  
  XmListDeselectAllItems(listwid);
  
  XtVaSetValues (listwid,
		 XmNselectionPolicy,  XmMULTIPLE_SELECT,
		 NULL);
  
  if(cloneindex<0)
    {
      for(i=0;i<ErrorLookup[errnum].pos_list_made;i++)
	{	      
	  XmListSelectPos(ErrorLookup[errnum].scrollwid,
			  ErrorLookup[errnum].pos_list[i],0);
	}
    }
  else
    {
      for(i=0;i<CloneErrorLookup[cloneindex].pos_list_made;i++)
	{
	  XmListSelectPos(CloneErrorLookup[cloneindex].scrollwid,
			  CloneErrorLookup[cloneindex].pos_list[i],0);
	}
    }
  
  
  XtVaSetValues (listwid,
		 XmNselectionPolicy,  XmEXTENDED_SELECT,
		 NULL);
  
  XmListSetAddMode(listwid,False);
 
}




void select_all_error(Widget w,XtPointer data,XtPointer callData)
{ 
  int type=(int)data;
  int i,errnum,cloneindex;
  MyData temp;

  


  if((type<0)||(type>4))
  {
    XBell(mydisplay,50);
	printf("Bad type %d to SAE\n",type);
	return;
  }


  if((type==2)||(type==3))
  {
    unsavedignore = 1;

    for(cloneindex=0;cloneindex<CLONE_DEFINITIONS;cloneindex++)
	{
      temp.clonenum = cloneindex;
      temp.check_num   = -1;

	  if(type==2)
	  {
        DisAllCB((Widget)NULL,&temp,(XtPointer)NULL);
	  }
	  else
	  {
        KeepAllCB((Widget)NULL,&temp,(XtPointer)NULL);
	  }
	}

    for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
	{
      temp.clonenum = -1;
      temp.check_num   = errnum;

	  if(type==2)
	  {
        DisAllCB((Widget)NULL,&temp,(XtPointer)NULL);
	  }
	  else
	  {
        KeepAllCB((Widget)NULL,&temp,(XtPointer)NULL);
	  }
	}

	return;
  }

  for(i=1;i<=CONDITION_DEFINITIONS;i++)
    {
      if(ErrorLookup[i].number>0)
	{
	  if(type==0)
	    {
	      XmToggleButtonSetState(ErrorLookup[i].viewallwid, (Boolean)0,(Boolean)0);
	      XmToggleButtonSetState(ErrorLookup[i].viewsomewid,(Boolean)0,(Boolean)0);

	      ErrorLookup[i].viewall  = 0;
	      ErrorLookup[i].viewsome = 0;
	    }
	  else if(type==1)
	    {
	      XmToggleButtonSetState(ErrorLookup[i].viewallwid, (Boolean)1,(Boolean)0);
	      XmToggleButtonSetState(ErrorLookup[i].viewsomewid,(Boolean)0,(Boolean)0);

	      ErrorLookup[i].viewall  = 1;
	      ErrorLookup[i].viewsome = 0;
	    }

	}
    }

  
  for(i=0;i<CLONE_DEFINITIONS;i++)
    {
      if(CloneErrorLookup[i].number>0)
	{
	  if(type==0)
	    {
	      XmToggleButtonSetState(CloneErrorLookup[i].viewallwid, (Boolean)0,(Boolean)0);
	      XmToggleButtonSetState(CloneErrorLookup[i].viewsomewid,(Boolean)0,(Boolean)0);

	      CloneErrorLookup[i].viewall  = 0;
	      CloneErrorLookup[i].viewsome = 0;
	    }
	  else if(type==1)
	    {
	      XmToggleButtonSetState(CloneErrorLookup[i].viewallwid, (Boolean)1,(Boolean)0);
	      XmToggleButtonSetState(CloneErrorLookup[i].viewsomewid,(Boolean)0,(Boolean)0);

	      CloneErrorLookup[i].viewall  = 1;
	      CloneErrorLookup[i].viewsome = 0;
	    } 
	}
    }




  

  if(type==0)
    {
      for(i=1;i<=CONDITION_DEFINITIONS;i++)
	  { 
	    ErrorLookup[i].viewall  = 0;
	    ErrorLookup[i].viewsome = 0;
	  } 
  
      for(i=0;i<CLONE_DEFINITIONS;i++)
	  { 
	    CloneErrorLookup[i].viewall  = 0;
	    CloneErrorLookup[i].viewsome = 0;
	  } 
    }
  else if(type==1)
    {
      for(i=1;i<=CONDITION_DEFINITIONS;i++)
	  { 
	    ErrorLookup[i].viewall  = 1;
	    ErrorLookup[i].viewsome = 0;
	  } 
  
      for(i=0;i<CLONE_DEFINITIONS;i++)
	  { 
	    CloneErrorLookup[i].viewall  = 1;
	    CloneErrorLookup[i].viewsome = 0;
	  } 
    }



  UpdateAllTotals();

}




void set_pad_distance(Widget w,XtPointer data,XtPointer callData)
{ 

  int n=0;
  Widget rowcol,form,exitbutton,sep;
  Arg resources[20];
  char temp[500];
  Dimension Pheight;

  if(PAD_UP==0)
    {
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++; 
      XtSetArg(resources[n],  XmNmaxWidth,       800);          n++;  

      pad_head = XtCreatePopupShell
	("Individual Condition Zoom Pad Distance",
	 topLevelShellWidgetClass,XtParent(XtParent(XtParent(w))),resources,n);
      
      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass, pad_head, NULL);
      

      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      
      XtVaCreateManagedWidget ("",
			       xmLabelWidgetClass, form,
			       XmNtopAttachment,    XmATTACH_FORM,
			       XmNbottomAttachment, XmATTACH_FORM,
			       XmNrightAttachment,  XmATTACH_POSITION,
			       XmNrightPosition,  100,
			       XmNleftAttachment,  XmATTACH_POSITION,
			       XmNleftPosition,     0,
			       XmNalignment,        XmALIGNMENT_CENTER,
			       XmNlabelString, STRING("Pad Distance:"),
			       LABELWTRANSLATE,
			       NULL);
      XtManageChild(form);
      


      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      sprintf(temp,"%lf",PAD_DIST);

      zoom_pad_w = XtVaCreateManagedWidget ("text_w",
					    xmTextFieldWidgetClass, form,	  
					    XmNvalue,           temp,
					    XmNtraversalOn,     True,
					    XmNrightAttachment, XmATTACH_POSITION,
					    XmNrightPosition,   80,
					    XmNleftAttachment,  XmATTACH_POSITION,
					    XmNleftPosition,    0,
					    XmNmaxLength,       15,
                        XmNtranslations,    XtParseTranslationTable ( translations_paste ) ,
					    NULL);

      XtAddCallback (zoom_pad_w, XmNactivateCallback,
		     los_result, (XtPointer)9);
      
      XtManageChild(form);
      

      sep = XtVaCreateManagedWidget ("sep1",
				     xmSeparatorWidgetClass, rowcol,
				     NULL);
      
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      exitbutton = XtVaCreateManagedWidget("Help", xmPushButtonWidgetClass, form,
					   XmNlabelString, STRING("Help"),
					   XmNleftAttachment,   XmATTACH_POSITION,
					   XmNleftPosition,     30,
					   XmNrightAttachment,   XmATTACH_POSITION,
					   XmNrightPosition,     50,
					   XmNtraversalOn,  False,
					   XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					   NULL);
      XtAddCallback(exitbutton, XmNactivateCallback, help_pad_callback, (XtPointer)NULL);
      XtManageChild(exitbutton);
      
      n = 0;  
      exitbutton = XtVaCreateManagedWidget("Exit",xmPushButtonWidgetClass, form,
					   XmNlabelString,      STRING("Done"),
					   XmNleftAttachment,   XmATTACH_POSITION,
					   XmNleftPosition,     50,
					   XmNrightAttachment,  XmATTACH_POSITION,
					   XmNrightPosition,    70,
					   XmNtraversalOn,      False,
					   XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					   NULL);

      XtAddCallback(exitbutton, XmNactivateCallback, kill_pad_callback, (XtPointer)NULL);
      XtManageChild(exitbutton);

      XtManageChild(form);
      XtManageChild (rowcol);
      
      XtAddCallback(pad_head,XmNdestroyCallback,(XtCallbackProc)ShellDeath,(XtPointer)302);       
      MyPopup(pad_head); 
      PAD_UP = 1;

      XtVaGetValues(pad_head,  XmNheight,     &Pheight, NULL);
      XtVaSetValues(pad_head,  XmNminHeight,   Pheight, NULL);
      XtVaSetValues(pad_head,  XmNmaxHeight,   Pheight, NULL);

      XtAddEventHandler(pad_head,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)Pheight));
    }
  else
    {
      ResetWidget(pad_head);
    }
}



void kill_vpad_callback(Widget button, XtPointer client_data, XtPointer call_data)
{
  extern int bad_los_result;
  
  los_result(vpad_text_sen_w,(XtPointer)10,(XtPointer)NULL);

  if(bad_los_result==1)
    {
      not_while_running(button,"The pad distance entered was invalid. It has been reset\nto the last valid value (valid range: 1-5000)",
			1464,"Invalid Pad Distance",1);
      return;
    }

  XtDestroyWidget(XtParent(XtParent(XtParent(button))));
}



void set_vpad_distance(Widget w,XtPointer data,XtPointer callData)
{ 
  
  int n=0;
  Widget rowcol,form,exitbutton,sep;
  Arg resources[20];
  char temp[500];
  Dimension Pheight;

  if(VPAD_UP==0)
    {
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY); n++; 
      XtSetArg(resources[n],  XmNmaxWidth,       800);          n++;  

      vpad_head = XtCreatePopupShell
	("Individual Vertex Zoom Pad Distance",
	 topLevelShellWidgetClass,XtParent(XtParent(XtParent(w))),resources,n);
      
      rowcol = XtVaCreateWidget ("rowcol",
				 xmRowColumnWidgetClass, vpad_head, NULL);
      

      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      
      XtVaCreateManagedWidget ("",
			       xmLabelWidgetClass, form,
			       XmNtopAttachment,    XmATTACH_FORM,
			       XmNbottomAttachment, XmATTACH_FORM,
			       XmNrightAttachment,  XmATTACH_POSITION,
			       XmNrightPosition,  100,
			       XmNleftAttachment,  XmATTACH_POSITION,
			       XmNleftPosition,     0,
			       XmNalignment,        XmALIGNMENT_CENTER,
			       XmNlabelString, STRING("Pad Distance:"),
			       LABELWTRANSLATE,
			       NULL);
      XtManageChild(form);
      


      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,  
			       NULL);
      
      sprintf(temp,"%lf",VPAD_DIST);

      vpad_text_sen_w = XtVaCreateManagedWidget ("text_w",
						 xmTextFieldWidgetClass, form,	  
						 XmNvalue,            temp,
						 XmNtraversalOn,      True,
						 XmNrightAttachment,  XmATTACH_POSITION,
						 XmNrightPosition,    80,
						 XmNleftAttachment,   XmATTACH_POSITION,
						 XmNleftPosition,     0,
						 XmNmaxLength,        15,
                         XmNtranslations,     XtParseTranslationTable ( translations_paste ) ,
						 NULL);
      
      XtAddCallback (vpad_text_sen_w, XmNactivateCallback,
		     los_result, (XtPointer)10);
      
      XtManageChild(form);


      sep = XtVaCreateManagedWidget ("sep1",
				     xmSeparatorWidgetClass, rowcol,
				     NULL);
      
      
      form = XtVaCreateWidget ("form", xmFormWidgetClass, rowcol,
			       XmNfractionBase,  100,
			       NULL);
      exitbutton = XtVaCreateManagedWidget("Help", xmPushButtonWidgetClass, form,
					   XmNlabelString, STRING("Help"),
					   XmNleftAttachment,   XmATTACH_POSITION,
					   XmNleftPosition,     30,
					   XmNrightAttachment,   XmATTACH_POSITION,
					   XmNrightPosition,     50,
					   XmNtraversalOn,  False,
					   XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					   NULL);
      XtAddCallback(exitbutton, XmNactivateCallback, help_vpad_callback, (XtPointer)NULL);
      XtManageChild(exitbutton);
      
      n = 0;  
      exitbutton = XtVaCreateManagedWidget("Exit",xmPushButtonWidgetClass, form,
					   XmNlabelString,      STRING("Done"),
					   XmNleftAttachment,   XmATTACH_POSITION,
					   XmNleftPosition,     50,
					   XmNrightAttachment,  XmATTACH_POSITION,
					   XmNrightPosition,    70,
					   XmNtraversalOn,      False,
					   XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					   NULL);

      XtAddCallback(exitbutton, XmNactivateCallback, kill_vpad_callback, (XtPointer)NULL);
      XtManageChild(exitbutton);

      XtManageChild(form);
      XtManageChild (rowcol);
      
      XtAddCallback(vpad_head,XmNdestroyCallback,(XtCallbackProc)ShellDeath,(XtPointer)4070);       
      MyPopup(vpad_head); 
      VPAD_UP = 1;

      XtVaGetValues(vpad_head,  XmNheight,     &Pheight, NULL);
      XtVaSetValues(vpad_head,  XmNminHeight,   Pheight, NULL);
      XtVaSetValues(vpad_head,  XmNmaxHeight,   Pheight, NULL);

      XtAddEventHandler(vpad_head,StructureNotifyMask,False, myResizeHandler, (XtPointer)((int)Pheight));
    }
  else
    {
      ResetWidget(vpad_head);
    }
}









void UpdateAllTotals()
{
  int totalchecks      = 0;
  int totalconds       = 0;
  int totalhighlighted = 0;
  int i,errnum;
  char temp[1000];
  extern struct CheckGroupNames CGN[NUMCHECKGROUPS];


  if(dead_error==0)
    {
      
      
      VCGetGlobalTotals(&totalchecks,&totalconds,&totalhighlighted);

      
      if(totalchecks==1)
	{
	  if(totalconds==1)
	    {
	      sprintf(temp," (%d instance, %d condition, %d highlighted)",
		      totalchecks,totalconds,totalhighlighted);
	    }
	  else
	    {
	      sprintf(temp," (%d instance, %d conditions, %d highlighted)",
		      totalchecks,totalconds,totalhighlighted);
	    }
	}
      else if(totalchecks>1)
	{
	  if(totalconds==1)
	    {
	      sprintf(temp," (%d instances, %d condition, %d highlighted)",
		      totalchecks,totalconds,totalhighlighted);
	    }
	  else
	    {
	      sprintf(temp," (%d instances, %d conditions, %d highlighted)",
		      totalchecks,totalconds,totalhighlighted);
	    }
	}

      XtVaSetValues(VCGlobalTotals,XmNlabelString, STRING(temp),NULL);
            

      
      
      
      for(i=0;i<NUMCHECKGROUPS;i++)
	{
	  totalconds         = 0;
	  totalchecks        = 0;
	  totalhighlighted   = 0;
	  
	  VCGetTotals(i,&totalchecks,&totalconds,&totalhighlighted);
	  
	  if(totalchecks==1)
	    {
	      if(totalconds==1)
		{
		  sprintf(temp,"%s (%d instance, %d condition, %d highlighted)",
			  CGN[i].name,
			  totalchecks,
			  totalconds,
			  totalhighlighted);
		}
	      else
		{
		  sprintf(temp,"%s (%d instance, %d conditions, %d highlighted)",
			  CGN[i].name,
			  totalchecks,
			  totalconds,
			  totalhighlighted);
		}
	      XtVaSetValues(CGN[i].VCgrouplevel,XmNlabelString, STRING(temp),NULL);
	    }
	  else if(totalchecks>1)
	    {
	      if(totalconds==1)
		{
		  sprintf(temp,"%s (%d instances, %d condition, %d highlighted)",
			  CGN[i].name,
			  totalchecks,
			  totalconds,
			  totalhighlighted);
		}
	      else
		{
		  sprintf(temp,"%s (%d instances, %d conditions, %d highlighted)",
			  CGN[i].name,
			  totalchecks,
			  totalconds,
			  totalhighlighted);
		}
	      XtVaSetValues(CGN[i].VCgrouplevel,XmNlabelString, STRING(temp),NULL);
	    }


	}
      
      
      
      
      
      
      for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
	{		  
	  totalconds       = 0;
	  totalchecks      = 0;
	  totalhighlighted = 0;
	  
	  VCGetTotal(errnum, &totalconds, &totalchecks, &totalhighlighted);
	  
	  if(totalconds==0)
	    {
	      
	      continue;
	    }
	  
	  if(totalchecks==1)
	    {
	      if(totalconds==1)
		{
		  sprintf(temp,"%s (%d instance, %d condition, %d highlighted)",
			  ParseErrType(errnum),
			  totalchecks,
			  totalconds,
			  totalhighlighted);
		}
	      else
		{
		  sprintf(temp,"%s (%d instance, %d conditions, %d highlighted)",
			  ParseErrType(errnum),
			  totalchecks,
			  totalconds,
			  totalhighlighted);
		}
	    }
	  else if(totalchecks>1)
	    {
	      if(totalconds==1)
		{
		  sprintf(temp,"%s (%d instances, %d condition, %d highlighted)",
			  ParseErrType(errnum),
			  totalchecks,
			  totalconds,
			  totalhighlighted);
		}
	      else
		{
		  sprintf(temp,"%s (%d instances, %d conditions, %d highlighted)",
			  ParseErrType(errnum),
			  totalchecks,
			  totalconds,
			  totalhighlighted);
		}
	    }

	  XtVaSetValues(ErrorLookup[errnum].checktype,XmNlabelString, STRING(temp),NULL); 
	}
    }






  
  
  
  
  if(dead_network==0)
    {
      
      
      NETGetGlobalTotals(&totalchecks,&totalconds,&totalhighlighted);
      
      if(totalchecks==1)
	{
	  if(totalconds==1)
	    {
	      sprintf(temp," (%d instance, %d network, %d highlighted)",
		      totalchecks,totalconds,totalhighlighted);
	    }
	  else
	    {
	      sprintf(temp," (%d instance, %d networks, %d highlighted)",
		      totalchecks,totalconds,totalhighlighted);
	    }
	}
      else
	{
	  if(totalconds==1)
	    {
	      sprintf(temp," (%d instances, %d network, %d highlighted)",
		      totalchecks,totalconds,totalhighlighted);
	    }
	  else
	    {
	      sprintf(temp," (%d instances, %d networks, %d highlighted)",
		      totalchecks,totalconds,totalhighlighted);
	    }
	}

      XtVaSetValues(NETGlobalTotals,XmNlabelString, STRING(temp),NULL);
            

      
      
      

      for(i=0;i<NUMCHECKGROUPS;i++)
	{
	  totalconds         = 0;
	  totalchecks        = 0;
	  totalhighlighted   = 0;
	  
	  NETGetTotals(i,&totalchecks,&totalconds,&totalhighlighted);
	  
	  if(totalchecks==1)
	    {
	      if(totalconds==1)
		{
		  sprintf(temp,"%s (%d instance, %d network, %d highlighted)",
			  CGN[i].name,
			  totalchecks,
			  totalconds,
			  totalhighlighted);
		}
	      else
		{
		  sprintf(temp,"%s (%d instance, %d networks, %d highlighted)",
			  CGN[i].name,
			  totalchecks,
			  totalconds,
			  totalhighlighted);
		}
	      
	    }
	  else if(totalchecks>1)
	    {
	      if(totalconds==1)
		{
		  sprintf(temp,"%s (%d instances, %d network, %d highlighted)",
			  CGN[i].name,
			  totalchecks,
			  totalconds,
			  totalhighlighted);
		}
	      else
		{
		  sprintf(temp,"%s (%d instances, %d networks, %d highlighted)",
			  CGN[i].name,
			  totalchecks,
			  totalconds,
			  totalhighlighted);
		}
	      
	    }
	}
      

      
      
      
      for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
	{		  
	  totalconds       = 0;
	  totalchecks      = 0;
	  totalhighlighted = 0;
	  
	  NETGetTotal(errnum, &totalconds, &totalchecks, &totalhighlighted);
	  
	  if(totalconds==0)
	    {
	      
	      continue;
	    }

	  if(totalchecks==1)
	    {
	      if(totalconds==1)
		{
		  sprintf(temp,"%s (%d instance, %d network, %d highlighted)",
			  ParseErrType(errnum),
			  totalchecks,
			  totalconds,
			  totalhighlighted);
		}
	      else
		{
		  sprintf(temp,"%s (%d instance, %d networks, %d highlighted)",
			  ParseErrType(errnum),
			  totalchecks,
			  totalconds,
			  totalhighlighted);
		}
	    }
	  else if(totalchecks>1)
	    {
	      if(totalconds==1)
		{
		  sprintf(temp,"%s (%d instances, %d network, %d highlighted)",
			  ParseErrType(errnum),
			  totalchecks,
			  totalconds,
			  totalhighlighted);
		}
	      else
		{
		  sprintf(temp,"%s (%d instances, %d networks, %d highlighted)",
			  ParseErrType(errnum),
			  totalchecks,
			  totalconds,
			  totalhighlighted);
		}
	    }
	  
	    
	}
    }
}

      

void ReBuildExeSummWin(char *message,char *title)
{
  if(RUNNING_INFO==1)
  {
    XtDestroyWidget(running_info);
    RUNNING_INFO = 0;
    not_while_running(drawing_a,message,1484,title,5);
  }
}




void myResizeWidthHandler2(Widget w, XtPointer userData, XEvent *event, Boolean *continue_to_dispatch)
{
  
  if(event->type == ConfigureNotify)  
    {
      XConfigureEvent *conf = (XConfigureEvent *)event;
      int new_width = conf->width;
      int errnum,cloneindex;
      
            
      new_width = new_width - 200;
      if(new_width<200)
	{
	  new_width = 200;
	}
     
      for(cloneindex=0;cloneindex<CLONE_DEFINITIONS;cloneindex++)
	{
	  if(CloneErrorLookup[cloneindex].scrollwidmade==1)
	    {
	      if(new_width>CloneErrorLookup[cloneindex].maxscrollsize)
		{
		  XtVaSetValues (CloneErrorLookup[cloneindex].scrollwid,
				 XmNwidth, CloneErrorLookup[cloneindex].maxscrollsize, 
				 NULL);
		}
	      else
		{
		  XtVaSetValues (CloneErrorLookup[cloneindex].scrollwid,XmNwidth, new_width, NULL);
		}
	    }
	}

      for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
	{
	  if(ErrorLookup[errnum].scrollwidmade==1)
	    {
	      if(new_width>ErrorLookup[errnum].maxscrollsize)
		{
		  XtVaSetValues (ErrorLookup[errnum].scrollwid,
				 XmNwidth, ErrorLookup[errnum].maxscrollsize, 
				 NULL);
		}
	      else
		{
		  XtVaSetValues (ErrorLookup[errnum].scrollwid,XmNwidth, new_width, NULL);
		}
	    }
	}
    }
}







void GenerateErrorEditor(int keepoldconfig)
{
  Widget handle,subhandle,subsubhandle,left,right,rc3,tempwid,
    outline,suboutline,subsuboutline,scrolloutline,checkhandle,junkwid;
  XmString str;
  MyData *mydata,*mydata3,*mydata4;
  Position px1,py1;
  Arg resources[15];
  int n=0,i=0,j;
  Widget rc,form,Done,sw2,toggleb,label1,setB,button,disallwid,keepallwid,repairb;
  char temp[1000],message[1000],thislabel[1000];
  int NumberOfErrorTypes=0, NumberOfErrors=0,totalchecks=0,totalconds=0, totalhighlighted=0;
  int checknum,cloneindex,clonenum;
  extern struct CheckGroupNames CGN[NUMCHECKGROUPS];



 if(dead_obhead[current_ob_head]==0)
    {
      if(NGA_TYPE==1)
	{
	  sprintf(message,"The \"View Conditions By Feature\" window is currently active.\n\
It is not possible to \"View Conditions\" when this window is active.\n\
To \"View Conditions\", dismiss the \"View Conditions By Feature\" window,\n\
and then select \"View Conditions\" again.");
	  not_while_running(drawing_a,message,1406,"Can not \"View Conditions\"",1);
	}
      else
	{
	  sprintf(message,"The \"View Conditions By Object\" window is currently active.\n\
It is not possible to \"View Conditions\" when this window is active.\n\
To \"View Conditions\", dismiss the \"View Conditions By Object\" window,\n\
and then select \"View Conditions\" again.");
	  not_while_running(drawing_a,message,1406,"Can not \"View Conditions\"",1);
	}
      return;
    }


  ABORT_ZOOM = 0;


  if(dead_error==0)
    {
      
   

     XtVaGetValues(errorhead[Current_head],XmNx,&px1,NULL);  
     XtVaGetValues(errorhead[Current_head],XmNy,&py1,NULL);  
     px1 = px1 - 4;     
     py1 = py1 - 30;     
     if(px1<10)
        {
          px1 = 10;
        }
      if(py1<10)
        {
          py1 = 10;
        } 


     XtDestroyWidget(errorhead[Current_head]);
     dead_error=1;
     Current_head++;
     if(Current_head==3){Current_head=0;}


     for(i=1;i<=CONDITION_DEFINITIONS;i++)
       {
	 if(keepoldconfig==0)
	   {
	     ErrorLookup[i].VConoff       = 0;
	     VCOnOff3[i]                  = 0;
	   }
	 ErrorLookup[i].scrollwidmade = 0;
       }
     for(i=0;i<CLONE_DEFINITIONS;i++)
       {
	 if(keepoldconfig==0)
	   {
	     CloneErrorLookup[i].VConoff       = 0;
	   }
	 CloneErrorLookup[i].scrollwidmade = 0;
       }

     if(keepoldconfig==0)
       {
	 for(i=0;i<NUMCHECKGROUPS;i++)
	   {
	     VCOnOff2[i] = 0;
	   }
       }
    }
  else
    {
      px1 = 10;
      py1 = 10;
    }



  if(dead_error==1)
    {
      for(i=1;i<=CONDITION_DEFINITIONS;i++)
	{
	  if(ErrorLookup[i].number>0)
	    {
	      if(ERRORDEBUG==1){printf("for %d, found %d %s\n",i,ErrorLookup[i].number,ErrorLookup[i].name);}
	      NumberOfErrorTypes = NumberOfErrorTypes + 1;
          NumberOfErrors = NumberOfErrors + ErrorLookup[i].number;
	    }
	}

      for(i=0;i<CLONE_DEFINITIONS;i++)
	{
	  if(CloneErrorLookup[i].number>0)
	    {
	      if(CLONEDEBUG==1){printf("for %d, found %d %s\n",
				       i,CloneErrorLookup[i].number,
				       ErrorLookup[CloneErrorLookup[i].CloneNumber].name);}
	      NumberOfErrorTypes++;
          NumberOfErrors = NumberOfErrors + CloneErrorLookup[i].number;
	    }
	}
      
      if(NumberOfErrorTypes==0)
	{
	  ReBuildExeSummWin(globalmessage,"Data Inspection Summary");

	  not_while_running(drawing_a,"No conditions found!",1106,"No Conditions",5);

	  return;
	}


      set_cursor(mydisplay,mywindow,WATCH);



      n=0;
      XtSetArg(resources[n],  XmNdeleteResponse, XmDESTROY);    n++;
      XtSetArg(resources[n],  XmNminWidth,       250);          n++;
      XtSetArg(resources[n],  XmNminHeight,      300);          n++;
      XtSetArg(resources[n],  XmNx,              px1);          n++;
      XtSetArg(resources[n],  XmNy,              py1);          n++;


	
      errorhead[Current_head] = 
	XtCreatePopupShell("Conditions Found",topLevelShellWidgetClass,drawing_a,resources,n);
      

      rc = XtVaCreateManagedWidget
	(
	 "XformWidget", xmPanedWindowWidgetClass, errorhead[Current_head],
	 XmNrubberPositioning, False,
	 XmNresizable,         True,
	 XmNseparatorOn,       False,
	 XmNsashHeight,        1,
	 XmNtranslations,      XtParseTranslationTable (list_translations8),
	 
	 NULL
	 );

      
      form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   15,
			       XmNpaneMaximum,   15,
			       XmNfractionBase,  100,  
			       XmNtraversalOn,   False,
				   XmNtranslations,  XtParseTranslationTable (list_translations8),
			       NULL);
   


      if(NumberOfErrorTypes==1)
	{
	  sprintf(temp,"Conditions Found: %d (from %d Inspection Instantiation)",NumberOfErrors,NumberOfErrorTypes);
	}
      else
	{
	  sprintf(temp,"Conditions Found: %d (from %d Inspection Instantiations)",NumberOfErrors,NumberOfErrorTypes);
	}


      
      label1 = XtVaCreateManagedWidget (temp,
					xmLabelWidgetClass, form,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,   100,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    0,
					XmNalignment,       XmALIGNMENT_CENTER,
					XmNtraversalOn,     False,
					XmNtranslations,    XtParseTranslationTable (list_translations8),
					NULL);
      XtManageChild(form);     


      form = XtVaCreateWidget ("form.sw.editor", xmFormWidgetClass, rc,
			       XmNfractionBase,  100,  
			       XmNtranslations,  XtParseTranslationTable (list_translations8),
			       NULL);
      
      sw2 = XtVaCreateManagedWidget ("scrolled_win",
				     xmScrolledWindowWidgetClass, form,
				     XmNwidth,                  700,
				     XmNheight,                 300,
				     XmNscrollingPolicy,        XmAUTOMATIC,
				     XmNscrollBarDisplayPolicy, XmSTATIC,
				     XmNtopAttachment,          XmATTACH_FORM,
				     XmNbottomAttachment,       XmATTACH_FORM,
				     XmNleftAttachment,         XmATTACH_FORM,
				     XmNrightAttachment,        XmATTACH_FORM,
				     XmNtranslations,           XtParseTranslationTable (list_translations8),
				     
				     NULL);
      
      
      XtManageChild(form);
      
      
      
      XtVaGetValues(sw2,XmNverticalScrollBar,&vert_scroll[CONDITION_SCROLL],NULL);
      XtVaGetValues(sw2,XmNhorizontalScrollBar,&junkwid,NULL);
      
      XtVaSetValues(vert_scroll[CONDITION_SCROLL], 
		    XmNtraversalOn,  False, 
		    
		    NULL);

      XtVaSetValues(junkwid,                       XmNtraversalOn, False, NULL);




      
      
      
      handle = XtVaCreateManagedWidget("roothandle", xmHandleWidgetClass,
				       sw2,
					   XmNtranslations, XtParseTranslationTable (list_translations8),
				       NULL);
      
      left = XtVaCreateManagedWidget("left", xmPushButtonWidgetClass,
				     handle,
				     XmNlabelType,    XmPIXMAP,
				     XmNlabelPixmap,  minus_pix,					 
				     XmNtraversalOn,  False,
				     XmNtranslations, XtParseTranslationTable (list_translations8),
				     NULL);
      
      right = XtVaCreateManagedWidget("All Inspection Categories", xmLabelWidgetClass,
				      handle,
				      LABELWTRANSLATE,
				      NULL);
      
      totalchecks      = 0;
      totalconds       = 0;
      totalhighlighted = 0;

      VCGetGlobalTotals(&totalchecks,&totalconds,&totalhighlighted);
      
      if(totalchecks==1)
	{
	  sprintf(temp," (%d instance, %d conditions, %d highlighted)",
		  totalchecks,totalconds,totalhighlighted);
	}
      else
	{
	  sprintf(temp," (%d instances, %d conditions, %d highlighted)",
		  totalchecks,totalconds,totalhighlighted);
	}

      VCGlobalTotals = XtVaCreateManagedWidget(temp, xmLabelWidgetClass,
					       handle,
					       XmNtraversalOn,   False,
					       XmNtranslations,  XtParseTranslationTable (list_translations8),
					       NULL);
      
      outline = XtVaCreateManagedWidget("outline", xmOutlineWidgetClass,
					handle,
					XmNindentation,  20,
					XmNoutline,      TRUE,
					XmNtranslations, XtParseTranslationTable (list_translations8),
					
					NULL);
      
      
      mydata3  = (MyData *) (malloc(sizeof(MyData)));
      if(mydata3==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
      mydata3->outlinewid = (XmOutlineWidget)outline;
      mydata3->level = 1;
      
      XtAddCallback(left, 
		    XmNactivateCallback, (XtCallbackProc)VCToggleButtonHandleCB, 
		    (XtPointer) mydata3);
      
      XtVaSetValues(handle, 
		    XmNsubWidget, outline,
		    NULL);
      
      
      if(VCOnOff1==0)
	{
	  
	  XtUnmanageChild(outline);
	  XtVaSetValues(left, XmNlabelPixmap, plus_pix, NULL);
	}
      
      
      
      for(i=0;i<NUMCHECKGROUPS;i++)
	{
	  totalconds         = 0;
	  totalchecks        = 0;
	  totalhighlighted   = 0;

	  VCGetTotals(i,&totalchecks,&totalconds,&totalhighlighted);
	  
	  if(totalchecks>0)
	    {
	      subhandle = XtVaCreateManagedWidget("subhandle",
						  xmHandleWidgetClass,
						  outline,
						  XmNtranslations, XtParseTranslationTable (list_translations8),
						  
						  NULL);
	      
	      left = XtVaCreateManagedWidget("left", xmPushButtonWidgetClass,
					     subhandle,
					     XmNlabelType,       XmPIXMAP,
					     XmNlabelPixmap,     minus_pix,
					     XmNarrowDirection,  XmARROW_DOWN,
					     XmNshadowThickness, 0,
					     XmNtraversalOn,     False,
						 XmNtranslations,    XtParseTranslationTable (list_translations8),
					     NULL);
	      
	      sprintf(thislabel,"%s (%d instances, %d conditions, %d highlighted)",
		      CGN[i].name,
		      totalchecks,
		      totalconds,
		      totalhighlighted);
	      
	      CGN[i].VCgrouplevel = XtVaCreateManagedWidget(thislabel, xmLabelWidgetClass,
						       subhandle,
                               XmNtranslations, XtParseTranslationTable (list_translations8),
						       NULL);
	      
	      suboutline = XtVaCreateManagedWidget("suboutline",
						   xmOutlineWidgetClass,
						   subhandle, 
						   XmNindentation,  20, 
						   XmNoutline,      TRUE,
						   XmNtranslations, XtParseTranslationTable (list_translations8),
						   
						   NULL);
	      
	      
	      
	      mydata4  = (MyData *) (malloc(sizeof(MyData)));
	      if(mydata4==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
	      mydata4->outlinewid = (XmOutlineWidget)suboutline;
	      mydata4->level     = 2;
	      mydata4->group_num = i;
	      
	      
	      XtAddCallback(left, 
			    XmNactivateCallback, (XtCallbackProc)VCToggleButtonHandleCB, 
			    (XtPointer) mydata4);
	      
	      
	      if(VCOnOff2[i]==0)
		{
		  
		  XtUnmanageChild(suboutline);
		  XtVaSetValues(left, XmNlabelPixmap, plus_pix, NULL);
		}
	      
	      
	      XtVaSetValues(subhandle, 
			    XmNsubWidget, suboutline, 
			    NULL);
	      






	      
	      
	      
	      
	      for(checknum=1;checknum<=CONDITION_DEFINITIONS;checknum++)
		{
		  
		  
		  if(ErrorLookup[checknum].mygroup!=i)
		    {
		      continue;
		    }
		  
		  
		  totalconds       = 0;
		  totalchecks      = 0;
		  totalhighlighted = 0;

		  VCGetTotal(checknum, &totalconds, &totalchecks,&totalhighlighted);
		  
		  
		  if(totalconds==0)
		    {
		      
		      continue;
		    }
		  
		  
		  
		  
		  subsubhandle = XtVaCreateManagedWidget("subsubhandle",
							 xmHandleWidgetClass,
							 suboutline,
							 XmNtranslations, XtParseTranslationTable (list_translations8),
							 NULL);
		  
		  left = XtVaCreateManagedWidget("left", xmPushButtonWidgetClass,
						 subsubhandle,
						 XmNlabelType,       XmPIXMAP,
						 XmNlabelPixmap,     minus_pix,
						 XmNarrowDirection,  XmARROW_DOWN,
						 XmNshadowThickness, 0,
						 XmNtraversalOn,     False,
						 XmNtranslations,    XtParseTranslationTable (list_translations8),
						 NULL);
		  
		  
		  sprintf(thislabel,"%s (%d instances, %d conditions, %d highlighted)",
			  ParseErrType(checknum),
			  totalchecks,
			  totalconds,
			  totalhighlighted);
		  

		  ErrorLookup[checknum].checktype = 
		    XtVaCreateManagedWidget(thislabel, xmLabelWidgetClass,
					    subsubhandle,
					    XmNtranslations, XtParseTranslationTable (list_translations8),
					    NULL);
		  
		  subsuboutline = XtVaCreateManagedWidget("subsuboutline",
							  xmOutlineWidgetClass,
							  subsubhandle, 
							  XmNindentation,  20, 
							  XmNoutline,      TRUE,
							  XmNtranslations, XtParseTranslationTable (list_translations8),
							  
							  NULL);
		  
		  mydata4  = (MyData *) (malloc(sizeof(MyData)));
		  if(mydata4==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		  mydata4->outlinewid = (XmOutlineWidget)subsuboutline;
		  mydata4->level     = 3;
		  mydata4->group_num = i;
		  mydata4->check_num = checknum;
		  
		  
		  XtAddCallback(left, 
				XmNactivateCallback, (XtCallbackProc)VCToggleButtonHandleCB, 
				(XtPointer) mydata4);
		  
		  
		  if(VCOnOff3[checknum]==0)
		    {
		      XtUnmanageChild(subsuboutline);
		      XtVaSetValues(left, XmNlabelPixmap, plus_pix, NULL);
		    }
		  
		  
		  XtVaSetValues(subsubhandle, 
				XmNsubWidget, subsuboutline, 
				XmNtranslations, XtParseTranslationTable (list_translations8),
				NULL);
		  
		  

		  
		  
		  if((ErrorLookup[checknum].mygroup==i)&&(ErrorLookup[checknum].number>0))
		    {
		      
		      checkhandle = XtVaCreateManagedWidget("subhandle",
							    xmHandleWidgetClass,
							    subsuboutline,
								XmNtranslations, XtParseTranslationTable (list_translations8),
							    
							    NULL);
		      
		      if(ErrorLookup[checknum].Annotation==NULL)
			{
			    sprintf(temp,"%s (%d) (Instantiation 1)",
				  ParseErrType(checknum),ErrorLookup[checknum].number);
			}
		      else
			{
			    sprintf(temp,"%s (%d) (Instantiation 1)\n(%s)",
				  ParseErrType(checknum),ErrorLookup[checknum].number,
				  ErrorLookup[checknum].Annotation);
			}
		      
		      
		      str = XmStringCreateLtoR (temp, "mytag1");
		      
		      
		      mydata  = (MyData *) (malloc(sizeof(MyData)));
		      if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		      
		      mydata->check_num = checknum;
		      mydata->clonenum  = -1;
		      

		      rc3 = XtVaCreateWidget ("rowcol",xmRowColumnWidgetClass, checkhandle, 
				  XmNtranslations, XtParseTranslationTable (list_translations8),
				  NULL);
		      
		      
		      form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rc3,
					       XmNfractionBase,  100,  
						   XmNtranslations,  XtParseTranslationTable (list_translations8),
					       NULL);
		      
		      
		      left = XtVaCreateManagedWidget("left", xmPushButtonWidgetClass,
						     form,
						     XmNlabelType,       XmPIXMAP,
						     XmNlabelPixmap,     minus_pix,
						     XmNarrowDirection,  XmARROW_DOWN,
						     XmNshadowThickness, 0,
						     XmNtraversalOn,     False,
							 XmNtranslations,    XtParseTranslationTable (list_translations8),
						     NULL);
		      
		      tempwid = 
			XtVaCreateManagedWidget ("the_test",
						 xmLabelWidgetClass, form,
						 XmNtopAttachment,    XmATTACH_FORM,
						 XmNtraversalOn,      True,
						 XmNbottomAttachment, XmATTACH_FORM,
						 XmNleftAttachment,   XmATTACH_POSITION,
						 XmNleftPosition,     4,
						 XmNrightAttachment,  XmATTACH_POSITION,
						 XmNrightPosition,    100,
						 XmNlabelString,      str,
						 XmNalignment,        XmALIGNMENT_BEGINNING,
						 XmNtranslations,     XtParseTranslationTable (list_translations8),
						 XmNtraversalOn,      False,
						 NULL);
		      
		      XtManageChild(form);
		      
		      
		      form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rc3,
					       XmNfractionBase,  100,  
					       XmNtranslations,  XtParseTranslationTable (list_translations8),
					       NULL);
		      
		      ErrorLookup[checknum].viewallwid = 
			XtVaCreateManagedWidget ("the_test",
						 xmToggleButtonWidgetClass, form,
						 XmNtopAttachment,    XmATTACH_FORM,
						 XmNtraversalOn,      True,
						 XmNbottomAttachment, XmATTACH_FORM,
						 XmNleftAttachment,   XmATTACH_POSITION,
						 XmNleftPosition,     5,
						 XmNlabelString,      STRING("Highlight All"),
						 XmNalignment,        XmALIGNMENT_BEGINNING,
						 XmNtranslations,     
						 XtParseTranslationTable (list_translations8),
						 TOGGLEINCLUDE,
						 XmNtraversalOn,      False,
						 NULL);
		      
		      ErrorLookup[checknum].viewsomewid = 
			XtVaCreateManagedWidget ("the_test",
						 xmToggleButtonWidgetClass, form,
						 XmNtopAttachment,    XmATTACH_FORM,
						 XmNtraversalOn,      True,
						 XmNbottomAttachment, XmATTACH_FORM,
						 XmNleftAttachment,   XmATTACH_WIDGET,
						 XmNleftWidget,       ErrorLookup[checknum].viewallwid,
						 XmNlabelString,      STRING("Highlight Selected"),
						 XmNalignment,        XmALIGNMENT_BEGINNING,
						 XmNtranslations,     
						 XtParseTranslationTable (list_translations8),
						 XmNtraversalOn,      False,
						 TOGGLEINCLUDE,
						 NULL);

		      keepallwid = 
			XtVaCreateManagedWidget ("Retain All",
						 xmPushButtonWidgetClass, form,
						 XmNtopAttachment,    XmATTACH_FORM,
						 XmNtraversalOn,      True,
						 XmNbottomAttachment, XmATTACH_FORM,
						 XmNleftAttachment,   XmATTACH_WIDGET,
						 XmNleftWidget,       ErrorLookup[checknum].viewsomewid,
						 XmNlabelString,      STRING("Retain All"),
						 XmNalignment,        XmALIGNMENT_BEGINNING,
						 XmNtranslations,     
						 XtParseTranslationTable (list_translations8),
						 XmNtraversalOn,      False,
						 NULL);
		      
		      disallwid = 
			XtVaCreateManagedWidget ("Ignore All",
						 xmPushButtonWidgetClass, form,
						 XmNtopAttachment,    XmATTACH_FORM,
						 XmNtraversalOn,      True,
						 XmNbottomAttachment, XmATTACH_FORM,
						 XmNleftAttachment,   XmATTACH_WIDGET,
						 XmNleftWidget,       keepallwid,
						 XmNlabelString,      STRING("Ignore All"),
						 XmNalignment,        XmALIGNMENT_BEGINNING,
						 XmNtranslations,     
						 XtParseTranslationTable (list_translations8),
						 XmNtraversalOn,      False,
						 NULL);


		      if(NGA_TYPE==0)
			{
			  repairb  = XtVaCreateManagedWidget("fix_error",xmPushButtonWidgetClass,form,
							     XmNlabelString,     STRING("repair..."),
							     XmNleftAttachment,  XmATTACH_WIDGET,
							     XmNleftWidget,      disallwid,
							     XmNtranslations, 
							     XtParseTranslationTable (list_translations8),
							     NULL
							     ); 
			  
			  XtAddCallback(repairb, XmNactivateCallback,
					(XtCallbackProc)fix_error, mydata);
			  XtManageChild(repairb);
			}



		      XtManageChild(form);
		      XtManageChild(rc3);
		      

		      XtAddCallback(keepallwid, 
				    XmNactivateCallback, (XtCallbackProc)KeepAllCB, 
				    (XtPointer) mydata);

		      XtAddCallback(disallwid, 
				    XmNactivateCallback, (XtCallbackProc)DisAllCB, 
				    (XtPointer) mydata);



		      
		      XtAddCallback (ErrorLookup[checknum].viewsomewid, 
				     XmNvalueChangedCallback, (XtCallbackProc)toggle_view_some,  mydata);
		      
		      XtAddCallback (ErrorLookup[checknum].viewallwid, 
				     XmNvalueChangedCallback, (XtCallbackProc)toggle_view_all, mydata);
		      
		      XmToggleButtonSetState(ErrorLookup[checknum].viewsomewid,
					     (Boolean)ErrorLookup[checknum].viewsome,
					     (Boolean)0);
		      XmToggleButtonSetState(ErrorLookup[checknum].viewallwid,
					     (Boolean)ErrorLookup[checknum].viewall,
					     (Boolean)0);





		      
		      XmStringFree (str);
		      
		      
		      
		      
		      
		      scrolloutline = XtVaCreateManagedWidget("subsuboutline",
							      xmOutlineWidgetClass,
							      checkhandle, 
							      XmNindentation,  20, 
							      XmNoutline,      TRUE,
								  XmNtranslations, XtParseTranslationTable (list_translations8),
							      
							      NULL);
		      
		      
		      mydata4  = (MyData *) (malloc(sizeof(MyData)));
		      if(mydata4==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
		      mydata4->outlinewid = (XmOutlineWidget)scrolloutline;
		      mydata4->level     = 4;
		      mydata4->group_num = i;
		      mydata4->check_num = checknum;
		      mydata4->clonenum  = -1;
		      
		      XtAddCallback(left, 
				    XmNactivateCallback, (XtCallbackProc)VCToggleButtonHandleCB, 
				    (XtPointer) mydata4);
		      
		      
		      if(ErrorLookup[checknum].VConoff==0)
			{
			  
			  XtUnmanageChild(scrolloutline);
			  XtVaSetValues(left, XmNlabelPixmap, plus_pix, NULL);
			}
		      else
			{
			  
			  
			  BuildSpecificCond(scrolloutline, checknum, -1, 500);
			  
			  ErrorLookup[checknum].scrollwidmade = 1;
			}
		      
		      XtVaSetValues(checkhandle, 
				    XmNsubWidget, scrolloutline, 
				    NULL);
		      
		    }

		  
		  
		  
		  
		  for(j=0;j<ErrorLookup[checknum].num_clones;j++)
		    {
		      cloneindex = GetCloneIndex(j+1,checknum);
		      
		      if((CloneErrorLookup[cloneindex].number>0)&&(ErrorLookup[checknum].mygroup==i))
			{
			  
			  checkhandle = XtVaCreateManagedWidget("subhandle",
								xmHandleWidgetClass,
								subsuboutline,
								XmNtranslations, XtParseTranslationTable (list_translations8),
								
								NULL);
			  
			  
			  if(CloneErrorLookup[cloneindex].Annotation==NULL)
			    {
			        sprintf(temp,"%s (%d) (Instantiation %d)",
				      ParseErrType(checknum),CloneErrorLookup[cloneindex].number,j+2);
			    }
			  else
			    {
			        sprintf(temp,"%s (%d) (Instantiation %d)\n(%s)",
				      ParseErrType(checknum),CloneErrorLookup[cloneindex].number,j+2,
				      CloneErrorLookup[cloneindex].Annotation);
			    }
			  
			  
			  str = XmStringCreateLtoR (temp, "mytag1");
			  
			  
			  mydata  = (MyData *) (malloc(sizeof(MyData)));
			  if(mydata==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
			  
			  mydata->check_num = checknum;
			  mydata->clonenum  = cloneindex;
			  
			  
			  rc3 = XtVaCreateWidget ("rowcol",xmRowColumnWidgetClass, checkhandle, 
				  XmNtranslations, XtParseTranslationTable (list_translations8),
				  NULL);
			  
			  
			  form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rc3,
						   XmNfractionBase,  100,  
						   XmNtranslations,  XtParseTranslationTable (list_translations8),
						   NULL);
			  
			  left = XtVaCreateManagedWidget("left", xmPushButtonWidgetClass,
							 form,
							 XmNlabelType,       XmPIXMAP,
							 XmNlabelPixmap,     minus_pix,
							 XmNarrowDirection,  XmARROW_DOWN,
							 XmNshadowThickness, 0,
							 XmNtraversalOn,     False,
							 XmNtranslations,    XtParseTranslationTable (list_translations8),
							 NULL);
			  
			  tempwid = 
			    XtVaCreateManagedWidget ("the_test",
						     xmLabelWidgetClass, form,
						     XmNtopAttachment,    XmATTACH_FORM,
						     XmNtraversalOn,      True,
						     XmNbottomAttachment, XmATTACH_FORM,
						     XmNleftAttachment,   XmATTACH_POSITION,
						     XmNleftPosition,     4,
						     XmNrightAttachment,  XmATTACH_POSITION,
						     XmNrightPosition,    100,
						     XmNlabelString,      str,
						     XmNalignment,        XmALIGNMENT_BEGINNING,
						     XmNtranslations,     
						     XtParseTranslationTable (list_translations8),
						     XmNtraversalOn,     False,
						     NULL);
			  
			  XtManageChild(form);
			  
			  
			  form = XtVaCreateWidget ("form.error.editor", xmFormWidgetClass, rc3,
						   XmNfractionBase,  100,  
						   XmNtranslations,  XtParseTranslationTable (list_translations8),
						   NULL);
			  
			  CloneErrorLookup[cloneindex].viewallwid = 
			    XtVaCreateManagedWidget ("the_test",
						     xmToggleButtonWidgetClass, form,
						     XmNtopAttachment,    XmATTACH_FORM,
						     XmNtraversalOn,      True,
						     XmNbottomAttachment, XmATTACH_FORM,
						     XmNleftAttachment,   XmATTACH_POSITION,
						     XmNleftPosition,     5,
						     XmNlabelString,      STRING("Highlight All"),
						     XmNalignment,        XmALIGNMENT_BEGINNING,
						     XmNtranslations,     
						     XtParseTranslationTable (list_translations8),
						     XmNtraversalOn,      False,
						     TOGGLEINCLUDE,
						     NULL);
			  
			  CloneErrorLookup[cloneindex].viewsomewid = 
			    XtVaCreateManagedWidget ("the_test",
						     xmToggleButtonWidgetClass, form,
						     XmNtopAttachment,    XmATTACH_FORM,
						     XmNtraversalOn,      True,
						     XmNbottomAttachment, XmATTACH_FORM,
						     XmNleftAttachment,   XmATTACH_WIDGET,
						     XmNleftWidget,       CloneErrorLookup[cloneindex].viewallwid,
						     XmNlabelString,      STRING("Highlight Selected"),
						     XmNalignment,        XmALIGNMENT_BEGINNING,
						     XmNtranslations,     
						     XtParseTranslationTable (list_translations8),
						     XmNtraversalOn,      False,
						     TOGGLEINCLUDE,
						     NULL);




			  keepallwid = 
			    XtVaCreateManagedWidget ("Retain All",
						     xmPushButtonWidgetClass, form,
						     XmNtopAttachment,    XmATTACH_FORM,
						     XmNtraversalOn,      True,
						     XmNbottomAttachment, XmATTACH_FORM,
						     XmNleftAttachment,   XmATTACH_WIDGET,
						     XmNleftWidget,       CloneErrorLookup[cloneindex].viewsomewid,
						     XmNlabelString,      STRING("Retain All"),
						     XmNalignment,        XmALIGNMENT_BEGINNING,
						     XmNtranslations,     
						     XtParseTranslationTable (list_translations8),
						     XmNtraversalOn,      False,
						     NULL);
			  
			  disallwid = 
			    XtVaCreateManagedWidget ("Ignore All",
						     xmPushButtonWidgetClass, form,
						     XmNtopAttachment,    XmATTACH_FORM,
						     XmNtraversalOn,      True,
						     XmNbottomAttachment, XmATTACH_FORM,
						     XmNleftAttachment,   XmATTACH_WIDGET,
						     XmNleftWidget,       keepallwid,
						     XmNlabelString,      STRING("Ignore All"),
						     XmNalignment,        XmALIGNMENT_BEGINNING,
						     XmNtranslations,     
						     XtParseTranslationTable (list_translations8),
						     XmNtraversalOn,      False,
						     NULL);




			  if(NGA_TYPE==0)
			    {
			      repairb  = XtVaCreateManagedWidget("fix_error",xmPushButtonWidgetClass,form,
								 XmNlabelString,     STRING("repair..."),
								 XmNleftAttachment,  XmATTACH_WIDGET,
								 XmNleftWidget,      disallwid,
								 XmNtranslations, 
								 XtParseTranslationTable (list_translations8),
								 NULL
								 ); 
			      
			      XtAddCallback(repairb, XmNactivateCallback,
					    (XtCallbackProc)fix_error, mydata);
			      XtManageChild(repairb);
			    }




			  XtManageChild(form);
			  XtManageChild(rc3);
			  



			  XtAddCallback(keepallwid, 
					XmNactivateCallback, (XtCallbackProc)KeepAllCB, 
					(XtPointer) mydata);
			  
			  XtAddCallback(disallwid, 
					XmNactivateCallback, (XtCallbackProc)DisAllCB, 
					(XtPointer) mydata);


			  
			  XtAddCallback (CloneErrorLookup[cloneindex].viewsomewid, 
					 XmNvalueChangedCallback, (XtCallbackProc)toggle_view_some,  mydata);
			  
			  XtAddCallback (CloneErrorLookup[cloneindex].viewallwid, 
					 XmNvalueChangedCallback, (XtCallbackProc)toggle_view_all, mydata);
			  
			  XmToggleButtonSetState(CloneErrorLookup[cloneindex].viewsomewid,
						 (Boolean)CloneErrorLookup[cloneindex].viewsome,
						 (Boolean)0);
			  XmToggleButtonSetState(CloneErrorLookup[cloneindex].viewallwid,
						 (Boolean)CloneErrorLookup[cloneindex].viewall,
						 (Boolean)0);
			  
			  XmStringFree (str);


			  
			  
			  
			  
			  scrolloutline = XtVaCreateManagedWidget("subsuboutline",
								  xmOutlineWidgetClass,
								  checkhandle, 
								  XmNindentation,  20, 
								  XmNoutline,      TRUE,
								  XmNtranslations, XtParseTranslationTable (list_translations8),
								  
								  NULL);
			  
			  
			  mydata4  = (MyData *) (malloc(sizeof(MyData)));
			  if(mydata4==NULL){printf("myb: out of allocation memory!\n"); ExitWrapper(-1);}
			  mydata4->outlinewid = (XmOutlineWidget)scrolloutline;
			  mydata4->level     = 4;
			  mydata4->group_num = i;
			  mydata4->check_num = checknum;
			  mydata4->clonenum  = j+1;
			  
			  XtAddCallback(left, 
					XmNactivateCallback, (XtCallbackProc)VCToggleButtonHandleCB, 
					(XtPointer) mydata4);
			  
			  
			  if(CloneErrorLookup[cloneindex].VConoff==0)
			    {
			      
			      XtUnmanageChild(scrolloutline);
			      XtVaSetValues(left, XmNlabelPixmap, plus_pix, NULL);
			    }
			  else
			    {
			      
			      
			      
			      clonenum = GetCloneNumber(cloneindex,checknum);
			      
			      BuildSpecificCond(scrolloutline, checknum, clonenum, 500);
			      
			      CloneErrorLookup[cloneindex].scrollwidmade = 1;
			    }
			  
			  
			  XtVaSetValues(checkhandle, 
					XmNsubWidget, scrolloutline, 
					NULL);
			  
			}
		    }
		}
	    }
	}
      
      
      
      
      
      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   23,
			       XmNpaneMaximum,   23,
			       XmNfractionBase,  100,  
			       NULL);
      
      toggleb = XtVaCreateManagedWidget ("Give Detailed Info",
					 xmToggleButtonWidgetClass, form,
					 XmNtraversalOn,      False,
					 XmNleftAttachment,   XmATTACH_FORM,
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    100,
					 XmNlabelString, 
					 STRING("Give detailed information about individual conditions"),
					 XmNtraversalOn,      False,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);

      XtAddCallback (toggleb, XmNvalueChangedCallback, toggled7, NULL);
      XtManageChild(toggleb);
      
      XmToggleButtonSetState(toggleb,(Boolean)DetailedInfo,(Boolean)0);
      XtManageChild(form);
      







      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       NULL);

      zoom_b = XtVaCreateManagedWidget ("Center Zoom on Individual Conditions",
					 xmToggleButtonWidgetClass, form,
					 XmNtraversalOn,      False,
					 XmNleftAttachment,   XmATTACH_FORM,
					 XmNrightAttachment,  XmATTACH_POSITION,
					 XmNrightPosition,    50,
					 XmNlabelString,      STRING("Zoom to individual conditions"),
					 XmNtraversalOn,      False,
					 TOGGLETRANSLATE,     TOGGLEINCLUDE,
					 NULL);
      
      XtAddCallback (zoom_b, XmNvalueChangedCallback, toggled6, NULL);
      XtManageChild(zoom_b);

      XmToggleButtonSetState(zoom_b,(Boolean)CenterZoomOnErrors,(Boolean)0);


      setB  = XtVaCreateManagedWidget("Set Zoom Pad Distance",xmPushButtonWidgetClass,form,
				      XmNleftAttachment,  XmATTACH_POSITION,
				      XmNleftPosition,    50,
				      XmNrightAttachment, XmATTACH_POSITION,
				      XmNrightPosition,   100,
				      XmNlabelString,     STRING("Set Zoom Pad Distance..."),
				      XmNtraversalOn,     False,
				      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 
      
      XtAddCallback (setB, XmNactivateCallback,
		     set_pad_distance, (XtPointer)NULL);

      XtManageChild(setB);
      XtManageChild(form);







      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       XmNtraversalOn,   False,
			       NULL);
      
      button  = XtVaCreateManagedWidget("s_all_error",xmPushButtonWidgetClass,form,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    0,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,   25,
					XmNlabelString, STRING("Select All"),
					XmNtraversalOn,     False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
      
      XtAddCallback(button, XmNactivateCallback,
		    select_all_error, (XtPointer) 1);
      XtManageChild(button);
      
      button  = XtVaCreateManagedWidget("s_all_error",xmPushButtonWidgetClass,form,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    26,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,   50,
					XmNlabelString, STRING("De-Select All"),
					XmNtraversalOn,     False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
      
      XtAddCallback(button, XmNactivateCallback,
		    select_all_error, (XtPointer) 0);
      XtManageChild(button);



      button  = XtVaCreateManagedWidget("r_all_error",xmPushButtonWidgetClass,form,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    51,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,   75,
					XmNlabelString, STRING("Retain All"),
					XmNtraversalOn,     False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 

      XtAddCallback(button, XmNactivateCallback,
		    select_all_error, (XtPointer) 3);
      XtManageChild(button);

      button  = XtVaCreateManagedWidget("i_all_error",xmPushButtonWidgetClass,form,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    76,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,   100,
					XmNlabelString, STRING("Ignore All"),
					XmNtraversalOn,     False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 

      XtAddCallback(button, XmNactivateCallback,
		    select_all_error, (XtPointer) 2);
      XtManageChild(button);


      XtManageChild(form);





      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       XmNtraversalOn,   False,
			       NULL);
      
      button  = XtVaCreateManagedWidget("s_all_error",xmPushButtonWidgetClass,form,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    0,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,   50,
					XmNlabelString, STRING("Select All Retained Conditions"),
					XmNtraversalOn,     False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
      
      XtAddCallback(button, XmNactivateCallback,
		    select_all_retained, (XtPointer) 1);
      XtManageChild(button);

      button  = XtVaCreateManagedWidget("s_all_error",xmPushButtonWidgetClass,form,
					XmNleftAttachment,  XmATTACH_POSITION,
					XmNleftPosition,    51,
					XmNrightAttachment, XmATTACH_POSITION,
					XmNrightPosition,   100,
					XmNlabelString,     STRING("Select All Ignored Conditions"),
					XmNtraversalOn,     False,
					XmNtranslations, XtParseTranslationTable ( translations_global ) ,
					NULL
					); 
      
      XtAddCallback(button, XmNactivateCallback,
		    select_all_retained, (XtPointer) 2);
      XtManageChild(button);
      
      XtManageChild(form);














      form = XtVaCreateWidget ("form2", xmFormWidgetClass, rc,
			       XmNpaneMinimum,   25,
			       XmNpaneMaximum,   25,
			       XmNfractionBase,  100,  
			       XmNtraversalOn,   False,
			       NULL);

      
      Done  = XtVaCreateManagedWidget("Help5",xmPushButtonWidgetClass,form,
				      XmNleftAttachment,  XmATTACH_POSITION,
				      XmNleftPosition,    0,
				      XmNrightAttachment, XmATTACH_POSITION,
				      XmNrightPosition,   50,
				      XmNlabelString, STRING("Apply Changes/Refresh View"),
				      XmNtraversalOn,     False,
				      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 
      XtAddCallback(Done, XmNactivateCallback,
		    refreshCallback, (XtPointer) NULL);
      XtManageChild(Done);




      Done  = XtVaCreateManagedWidget("Help5",xmPushButtonWidgetClass,form,
				      XmNleftAttachment,  XmATTACH_POSITION,
				      XmNleftPosition,    51,
				      XmNrightAttachment, XmATTACH_POSITION,
				      XmNrightPosition,   75,
				      XmNlabelString, STRING("Help"),
				      XmNtraversalOn,     False,
				      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 
      XtAddCallback(Done, XmNactivateCallback,
		    Help_errCallback, (XtPointer) NULL);
      XtManageChild(Done);



      Done  = XtVaCreateManagedWidget("Done7",xmPushButtonWidgetClass,form,
				      XmNleftAttachment,  XmATTACH_POSITION,
				      XmNleftPosition,    76,
				      XmNrightAttachment, XmATTACH_POSITION,
				      XmNrightPosition,   100,
				      XmNlabelString, STRING("Done"),
				      XmNtraversalOn,     False,
				      XmNtranslations, XtParseTranslationTable ( translations_global ) ,
				      NULL
				      ); 
      
      XtAddCallback(Done, XmNactivateCallback,
		    die_callback, (XtPointer) 1004);
      XtManageChild(Done);
      XtManageChild(form);
      XtManageChild(rc);



      if(keepoldconfig==0)
	  {
	    
	    dead_error = 0;
	    TransferCleanPixmap(); 
        MyDrawErrors();


	    ReBuildExeSummWin(globalmessage,"Data Inspection Summary");

		if(RUNNING_INFO!=0)  
		{
 		  XtVaSetValues(running_info,XmNcancelLabelString,STRING("OK"),NULL);
		}
	  } 


      MyPopup(errorhead[Current_head]); 
      XtAddCallback(errorhead[Current_head],
		    XmNdestroyCallback,ShellDeath,(XtPointer)(2000+Current_head));


      XtAddEventHandler(errorhead[Current_head],StructureNotifyMask,False, 
			myResizeWidthHandler2,NULL);

      

      XtVaSetValues(vert_scroll[CONDITION_SCROLL],XmNincrement,30,NULL);
      dead_error=0;

      set_cursor(mydisplay,mywindow,GOOD);
    }
  else
    {
      printf("Serious error in condition viewer generation\n");
      XBell(mydisplay,50);
    }

 
}





void periodic_fixing_redraw(int done)
{
  #if(NGA_TYPE==0)
  char combbuff[5000];
  char tempbuff[1000];
  extern int bad_conditions[],conditions_fixed[];
  int i;

  
  periodic_redraw();
  
  sprintf(combbuff,"\n");
  sprintf(tempbuff,"\n");

  if(done==1)
    {
      strcat(combbuff,"Done with repairs\n\n");
    }
  else
    {
      sprintf(tempbuff,"Repairing.\n\nSTF: %s\nPatch file %s\n\n",stffix,patchfile);
      strcat(combbuff,tempbuff);
      strcat(combbuff,"Repair progress:\n\n");
    }


  for(i=1;i<=CONDITION_DEFINITIONS;i++)
    {
      if(conditions_fixed[i]>0)
	{
	  sprintf(tempbuff,"%s conditions repaired:        %d\n\n",ErrorLookup[i].name,conditions_fixed[i]);
	  strcat(combbuff,tempbuff);
	}
      
      if(bad_conditions[i]>0)
	{      
	  sprintf(tempbuff,"%s conditions not repaired:        %d\n\n",ErrorLookup[i].name,bad_conditions[i]);
	  strcat(combbuff,tempbuff);
	  strcat(combbuff,"(Possible reason for non-repair is the condition is not in this STF)\n\n");
	}
    }

  strcat(combbuff,"Elapsed Time: ");
  strcat(combbuff,PrintTime(StartTime));
  
  not_while_running(drawing_a,combbuff,-4,"Repair progress",-1);

  
  XmUpdateDisplay(drawing_a);

  #endif
}



void UpdateSummaryInfo(int type,char *intmpmessage,char *intime,char *title)
{
  

  char finalmessage[2000],sendname[1000],midmessage[1000],inmessage[1000];
  int ignore_num,retain_num;
  extern char *GetProjName(char *inprojpath);
  extern int NETS_ONLY;

  if(NETS_ONLY==1)
  {
    sprintf(inmessage,"%s",intmpmessage);
  }
  else
  {
    sprintf(inmessage,"%s\nProject: %s\n\nInspection Profile: %s",intmpmessage,GetProjName(indirectory),masterrun);
  }

  if(type==1)
    {
      if(savemessage!=NULL)
	{
	  free(savemessage);
	  savemessage = NULL;
	}
      if(savetime!=NULL)
	{
	  free(savetime);
	  savetime = NULL;
	}
      
      savemessage = (char *)malloc(strlen(inmessage)+10);
      savetime    = (char *)malloc(strlen(intime)+10);
      
      sprintf(savemessage,"%s",inmessage);
      sprintf(savetime,   "%s",intime);


      
      sprintf(midmessage,"%s\n\n\
Elapsed time: %s\n",inmessage,intime);
      
      not_while_running(drawing_a,midmessage,-1,title,-1);
      

	  sprintf(globalmessage,"%s",midmessage);

    }
  else
    {
      ignore_num = -1;
      retain_num = -1;
      

      if(ConsultPreviouslyIgnored==1)
	  {
	    sprintf(sendname,"%scondreport.lk2",outdirectory);
	    CountIgnored(&ignore_num,&retain_num,sendname,1);
	    if(ignore_num<0)
	    {
	      ignore_num = 0;
	    }
	  } 

      if(ignore_num>=0)
	  { 
		  if(num_shapes_processed>SHAPE_IGNORE_LIMIT)
		  {
	        sprintf(finalmessage,"%s\n\n\
Conditions marked as ignore due to activating the\n\
\"Mark results using exported shapefiles\" option: %d\n\n\
Only %d of %d shapes marked IGNORE were processed.\n\n\
Elapsed time: %s\n",savemessage,ignore_num,SHAPE_IGNORE_LIMIT,num_shapes_processed,savetime);
		  }
		  else
		  {
	  sprintf(finalmessage,"%s\n\n\
Conditions marked as ignore due to activating the\n\
\"Mark results using exported shapefiles\" option: %d\n\n\
Elapsed time: %s\n",savemessage,ignore_num,savetime);
		  }

	  } 
      else
	  { 
	    sprintf(finalmessage,"%s\n\n\
Elapsed time: %s\n",savemessage,savetime);
	  }


	  
 
	  


	  if(NETS_ONLY==1)
	  {
        

		ReBuildExeSummWin(finalmessage,"Network Creation Summary");
	  }


	  sprintf(globalmessage,"%s",finalmessage);

      if(savemessage!=NULL)
	{
	  free(savemessage);
	  savemessage = NULL;
	}
      if(savetime!=NULL)
	{
	  free(savetime);
	  savetime = NULL;
	}
    }
}



int periodic_checking_redraw(int UseButton, char origtitle[],char message[])
{
  char newmessage[1000];
  char *title;
  char *nettitle = "Network Creation Progress";
  char *nettitle2 = "Network Creation Summary";
  static long int last_redraw=0,ThisTime;
  extern int GLOBAL_TIME,NETS_ONLY;


  ThisTime = time(NULL);


  
  UseButton = 1;


  if(strcmp(origtitle,"Data Inspection Summary"))
    {
      if((ThisTime-last_redraw)==0)
	  { 
	    return STOP_FLAG;
	  } 
    }
  else
  {
    GLOBAL_TIME =  ThisTime-StartTime;
  }

  if(NETS_ONLY==1)
  {
    if(!strcmp(origtitle,"Inspection Progress"))
	{
      title = nettitle;
	}
	else
	{
      title = nettitle2;
	}
  }
  else
  {
    title = origtitle;
  }


  if(batchsilent==1)
  {
	if(!strcmp(title,"Data Inspection Summary"))
	{
	  sprintf(newmessage,"Inspections Complete\nInspection Profile: %s\n\nElapsed Time: %s\n",masterrun,PrintTime(StartTime));
	  AddSilentStuff(newmessage,3);
      last_redraw = ThisTime;
	}
	else if((ThisTime-last_redraw)>10)
	{
	  sprintf(newmessage,"Inspection progress: %s\nInspection Profile: %s\n\nElapsed Time: %s\n",message,masterrun,PrintTime(StartTime));
	  AddSilentStuff(newmessage,3);
      last_redraw = ThisTime;
	}
    return STOP_FLAG; 
  }

  if(UseButton==0)
    {
      

      if(RUNNING_INFO==1)
	  { 
	    XtUnmanageChild(XmMessageBoxGetChild (running_info, XmDIALOG_CANCEL_BUTTON));
	  } 
      else
	  {
	   
	  }

    }

  
  periodic_redraw();

  if(NETS_ONLY==1)
  {
	if(strcmp(title,"Network Creation Summary"))
	{
      sprintf(newmessage,"Network creation progress:\n %s",message);
	}
	else
	{
      sprintf(newmessage,"%s",message);
	}
  }
  else
  {
	if(strcmp(title,"Data Inspection Summary"))
	{
      sprintf(newmessage,"Inspection progress:\n %s\n",message);
	}
	else
	{
      sprintf(newmessage,"%s",message);
	}
  }

  UpdateSummaryInfo(1,newmessage,PrintTime(StartTime),title);


  
  XmUpdateDisplay(drawing_a);

  last_redraw = ThisTime;

  return STOP_FLAG;
}




void RemoveAllLongListEntries()
{
  int errnum,cloneindex;


  for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
    {
      if(ErrorLookup[errnum].primaryEDCSstuff!=NULL)
	  { 
	   free(ErrorLookup[errnum].primaryEDCSstuff);
	   ErrorLookup[errnum].primaryEDCSstuff = NULL;
	  } 
      if(ErrorLookup[errnum].secondaryEDCSstuff!=NULL)
	  { 
	   free(ErrorLookup[errnum].secondaryEDCSstuff);
	   ErrorLookup[errnum].secondaryEDCSstuff = NULL;
	  } 
      if(ErrorLookup[errnum].tertiaryEDCSstuff!=NULL)
	  { 
	   free(ErrorLookup[errnum].tertiaryEDCSstuff);
	   ErrorLookup[errnum].tertiaryEDCSstuff = NULL;
	  } 



	  if(ErrorLookup[errnum].primaryFIDstuff!=NULL)
	  { 
	   free(ErrorLookup[errnum].primaryFIDstuff);
	   ErrorLookup[errnum].primaryFIDstuff = NULL;
	  } 
      if(ErrorLookup[errnum].secondaryFIDstuff!=NULL)
	  { 
	   free(ErrorLookup[errnum].secondaryFIDstuff);
	   ErrorLookup[errnum].secondaryFIDstuff = NULL;
	  } 
      if(ErrorLookup[errnum].tertiaryFIDstuff!=NULL)
	  { 
	   free(ErrorLookup[errnum].tertiaryFIDstuff);
	   ErrorLookup[errnum].tertiaryFIDstuff = NULL;
	  } 
 

    }

  for(cloneindex=0;cloneindex<CLONE_DEFINITIONS;cloneindex++)
    {
      if(CloneErrorLookup[cloneindex].primaryEDCSstuff!=NULL)
	  { 
	  free(CloneErrorLookup[cloneindex].primaryEDCSstuff);
	  CloneErrorLookup[cloneindex].primaryEDCSstuff = NULL;
	  } 
      if(CloneErrorLookup[cloneindex].secondaryEDCSstuff!=NULL)
	  { 
	  free(CloneErrorLookup[cloneindex].secondaryEDCSstuff);
	  CloneErrorLookup[cloneindex].secondaryEDCSstuff = NULL;
	  } 
      if(CloneErrorLookup[cloneindex].tertiaryEDCSstuff!=NULL)
	  { 
	  free(CloneErrorLookup[cloneindex].tertiaryEDCSstuff);
	  CloneErrorLookup[cloneindex].tertiaryEDCSstuff = NULL;
	  } 


      if(CloneErrorLookup[cloneindex].primaryFIDstuff!=NULL)
	  { 
	  free(CloneErrorLookup[cloneindex].primaryFIDstuff);
	  CloneErrorLookup[cloneindex].primaryFIDstuff = NULL;
	  } 
      if(CloneErrorLookup[cloneindex].secondaryFIDstuff!=NULL)
	  { 
	  free(CloneErrorLookup[cloneindex].secondaryFIDstuff);
	  CloneErrorLookup[cloneindex].secondaryFIDstuff = NULL;
	  } 
      if(CloneErrorLookup[cloneindex].tertiaryFIDstuff!=NULL)
	  { 
	  free(CloneErrorLookup[cloneindex].tertiaryFIDstuff);
	  CloneErrorLookup[cloneindex].tertiaryFIDstuff = NULL;
	  } 

    }
}







void SetCheckData()
{
  int errnum,axis,ADDER,clonenum,cloneindex,geomtype,strat_num,domain_num,
	  onedegreecheck,Ijunk;
  

  set_cursor(mydisplay,mywindow,WATCH);


  RemoveAllLongListEntries();


  

  onedegreecheck   = OneDegreeCheckOK(&Ijunk);
  RemovedOneDegree = 0;
  
  for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
    {
      if(
	 (onedegreecheck==0)                                                  &&
	 ((errnum==FEATOUTSIDE)||(errnum==BNDRYUNDERSHT)||(errnum==LBNDUSHT)) &&
	 (ErrorLookup[errnum].active>0)
	 )
	{
	  
	  ErrorLookup[errnum].active = -1;
	  RemovedOneDegree = RemovedOneDegree + 1;
	}
      
      
      for(axis=1;axis<=3;axis++)
	{
	  
	  if(ErrorLookup[errnum].participants<axis) { continue; }
	  
	  
	  for(ADDER=1;ADDER>=0;ADDER--)
	    {
	      for(geomtype=0;geomtype<NUM_C;geomtype++)
		{
		  clonenum = 0;
		  cloneindex = -999;
		  
		  
		  if(ErrorLookup[errnum].active==1)
		    {
		      if((NGA_TYPE==0)&&(geomtype==0))
			{
			  
			  CreateLongListEntries(errnum,axis,ADDER,0,clonenum,cloneindex,geomtype);
			  
			}
		      else if(NGA_TYPE==0)
			{
			  
			  
			  
			}
		      
		      
		      else if(geomtype==0)
			{
			  
			}
		      else 
			{
			  CreateLongListEntries(errnum,axis,ADDER,0,clonenum,cloneindex,geomtype);
			}
		    }
		  
		  
		  for(clonenum=1;clonenum<=ErrorLookup[errnum].num_clones;clonenum++)
		    {
		      cloneindex = GetCloneIndex(clonenum,errnum);
		      
		      if(
			 (onedegreecheck==0)                              &&
			 ((errnum==FEATOUTSIDE)||(errnum==BNDRYUNDERSHT)||(errnum==LBNDUSHT)) &&
			 (CloneErrorLookup[cloneindex].active>0)
			 )
			{
			  
			  CloneErrorLookup[cloneindex].active = -1;
			  RemovedOneDegree = RemovedOneDegree + 1;
			}
		      
		      
		      if(CloneErrorLookup[cloneindex].active==1)
			{
			  if((NGA_TYPE==0)&&(geomtype==0))
			    {
			      CreateLongListEntries(errnum,axis,ADDER,0,clonenum,cloneindex,geomtype);
			    }
			  else if(NGA_TYPE==0)
			    {
			      
			    }
			  else if(geomtype==0)
			    {
			      
			    }
			  else 
			    {
			      CreateLongListEntries(errnum,axis,ADDER,0,clonenum,cloneindex,geomtype);
			    }
			}
		    }
		}
	    }
	}
    }
  
  
  
  SetFidMarkTable(-999,NULL,-1,NULL,0,0,0,0,0);
	

  

		      
  if(NGA_TYPE==1)
    {
      



      


      

      for(errnum=1; errnum<=CONDITION_DEFINITIONS;errnum++)
	{

	  
	  
	  
	  for(clonenum=1;clonenum<=ErrorLookup[errnum].num_clones;clonenum++)
	    {
	      cloneindex = GetCloneIndex(clonenum,errnum);
	      
	      if(CloneErrorLookup[cloneindex].active==1)
		{
		  for(geomtype=1;geomtype<NUM_C;geomtype++)
		    {		  
		      if(ErrorLookup[errnum].participants>=1)
			{
			  if(CloneErrorLookup[cloneindex].Config1[geomtype]!=2)
			    {
			      CloneErrorLookup[cloneindex].Config1[geomtype] = 0;
			      
			      for(strat_num=0;strat_num<NUM_S;strat_num++)
				{
				  CloneErrorLookup[cloneindex].Stratum1[strat_num] = 0;
				}
			      for(domain_num=0;domain_num<NUM_D;domain_num++)
				{
				  CloneErrorLookup[cloneindex].Domain1[domain_num] = 0;
				}
			    }
			}
		      
		      
		      if(ErrorLookup[errnum].participants>=2)
			{
			  if(CloneErrorLookup[cloneindex].Config2[geomtype]!=2)
			    {
			      CloneErrorLookup[cloneindex].Config2[geomtype] = 0;
			      
			      for(strat_num=0;strat_num<NUM_S;strat_num++)
				{
				  CloneErrorLookup[cloneindex].Stratum2[strat_num] = 0;
				}
			      for(domain_num=0;domain_num<NUM_D;domain_num++)
				{
				  CloneErrorLookup[cloneindex].Domain2[domain_num] = 0;
				}
			    }
			}
		      
		      
		      if(ErrorLookup[errnum].participants>=3)
			{
			  if(CloneErrorLookup[cloneindex].Config3[geomtype]!=2)
			    {
			      CloneErrorLookup[cloneindex].Config3[geomtype] = 0;
			      
			      for(strat_num=0;strat_num<NUM_S;strat_num++)
				{
				  CloneErrorLookup[cloneindex].Stratum3[strat_num] = 0;
				}
			      for(domain_num=0;domain_num<NUM_D;domain_num++)
				{
				  CloneErrorLookup[cloneindex].Domain3[domain_num] = 0;
				}
			    }
			}
		    }
		}
	    }
	  


	  if(ErrorLookup[errnum].active==1)
	    {	      
	      
	      
	      for(geomtype=1;geomtype<NUM_C;geomtype++)
		{		  
		  if(ErrorLookup[errnum].participants>=1)
		    {
		      if(ErrorLookup[errnum].Config1[geomtype]!=2)
			{
			  ErrorLookup[errnum].Config1[geomtype] = 0;
			  
			  for(strat_num=0;strat_num<NUM_S;strat_num++)
			    {
			      ErrorLookup[errnum].Stratum1[strat_num] = 0;
			    }
			  for(domain_num=0;domain_num<NUM_D;domain_num++)
			    {
			      ErrorLookup[errnum].Domain1[domain_num] = 0;
			    }
			}
		    }


		  if(ErrorLookup[errnum].participants>=2)
		    {
		      if(ErrorLookup[errnum].Config2[geomtype]!=2)
			{
			  ErrorLookup[errnum].Config2[geomtype] = 0;
			  
			  for(strat_num=0;strat_num<NUM_S;strat_num++)
			    {
			      ErrorLookup[errnum].Stratum2[strat_num] = 0;
			    }
			  for(domain_num=0;domain_num<NUM_D;domain_num++)
			    {
			      ErrorLookup[errnum].Domain2[domain_num] = 0;
			    }
			}
		    }


		  if(ErrorLookup[errnum].participants>=3)
		    {
		      if(ErrorLookup[errnum].Config3[geomtype]!=2)
			{
			  ErrorLookup[errnum].Config3[geomtype] = 0;
			  
			  for(strat_num=0;strat_num<NUM_S;strat_num++)
			    {
			      ErrorLookup[errnum].Stratum3[strat_num] = 0;
			    }
			  for(domain_num=0;domain_num<NUM_D;domain_num++)
			    {
			      ErrorLookup[errnum].Domain3[domain_num] = 0;
			    }
			}
		    }
		}
	    }
	}






  




     




      for(errnum=1; errnum<=CONDITION_DEFINITIONS;errnum++)
	{
	  if(ErrorLookup[errnum].active==1)
	    {

	      if(ErrorLookup[errnum].participants>=1)
		{
		  for(geomtype=1;geomtype<NUM_C;geomtype++)
		    {
		      if(ErrorLookup[errnum].Config1[geomtype]!=2)
			{

			  if(ErrorLookup[errnum].AllConfigOn[1][geomtype]>0)
			    {
			      

			      ErrorLookup[errnum].Config1[geomtype] = 1;
			      
			      for(strat_num=0;strat_num<NUM_S;strat_num++)
				{
				  ErrorLookup[errnum].Stratum1[strat_num] = 1;
				}
			      for(domain_num=0;domain_num<NUM_D;domain_num++)
				{
				  ErrorLookup[errnum].Domain1[domain_num] = 1;
				}
			    }
			}
		    }
		}
	    

	      if(ErrorLookup[errnum].participants>=1)
		{
		  for(geomtype=1;geomtype<NUM_C;geomtype++)
		    {
		      if(ErrorLookup[errnum].Config2[geomtype]!=2)
			{

			  if(ErrorLookup[errnum].AllConfigOn[2][geomtype]>0)
			    {
			      
 
			      ErrorLookup[errnum].Config2[geomtype] = 1;
			      
			      for(strat_num=0;strat_num<NUM_S;strat_num++)
				{
				  ErrorLookup[errnum].Stratum2[strat_num] = 1;
				}
			      for(domain_num=0;domain_num<NUM_D;domain_num++)
				{
				  ErrorLookup[errnum].Domain2[domain_num] = 1;
				}
			    }
			}
		    }
		}


	      if(ErrorLookup[errnum].participants>=1)
		{
		  for(geomtype=1;geomtype<NUM_C;geomtype++)
		    {
		      if(ErrorLookup[errnum].Config3[geomtype]!=2)
			{

			  if(ErrorLookup[errnum].AllConfigOn[3][geomtype]>0)
			    {
			      
			      
			      ErrorLookup[errnum].Config3[geomtype] = 1;
			      
			      for(strat_num=0;strat_num<NUM_S;strat_num++)
				{
				  ErrorLookup[errnum].Stratum3[strat_num] = 1;
				}
			      for(domain_num=0;domain_num<NUM_D;domain_num++)
				{
				  ErrorLookup[errnum].Domain3[domain_num] = 1;
				}
			    }
			}
		    }
		}
	    }



	  for(clonenum=1;clonenum<=ErrorLookup[errnum].num_clones;clonenum++)
	    {
	      cloneindex = GetCloneIndex(clonenum,errnum);
	      
	      if(CloneErrorLookup[cloneindex].active==1)
		{
		  
		  if(ErrorLookup[errnum].participants>=1)
		    {
		      for(geomtype=1;geomtype<NUM_C;geomtype++)
			{
			  if(CloneErrorLookup[cloneindex].Config1[geomtype]!=2)
			    {
			      if(CloneErrorLookup[cloneindex].AllConfigOn[1][geomtype]>0)
				{
				  
				 
				  CloneErrorLookup[cloneindex].Config1[geomtype] = 1;
				  
				  for(strat_num=0;strat_num<NUM_S;strat_num++)
				    {
				      CloneErrorLookup[cloneindex].Stratum1[strat_num] = 1;
				    }
				  for(domain_num=0;domain_num<NUM_D;domain_num++)
				    {
				      CloneErrorLookup[cloneindex].Domain1[domain_num] = 1;
				    }
				}
			    }
			}
		    }



		  if(ErrorLookup[errnum].participants>=2)
		    {
		      for(geomtype=1;geomtype<NUM_C;geomtype++)
			{
			  if(CloneErrorLookup[cloneindex].Config2[geomtype]!=2)
			    {
			      if(CloneErrorLookup[cloneindex].AllConfigOn[2][geomtype]>0)
				{
				  
				  
				  CloneErrorLookup[cloneindex].Config2[geomtype] = 1;
				  
				  for(strat_num=0;strat_num<NUM_S;strat_num++)
				    {
				      CloneErrorLookup[cloneindex].Stratum2[strat_num] = 1;
				    }
				  for(domain_num=0;domain_num<NUM_D;domain_num++)
				    {
				      CloneErrorLookup[cloneindex].Domain2[domain_num] = 1;
				    }
				}
			    }
			}
		    }




		  if(ErrorLookup[errnum].participants>=3)
		    {
		      for(geomtype=1;geomtype<NUM_C;geomtype++)
			{
			  if(CloneErrorLookup[cloneindex].Config3[geomtype]!=2)
			    {
			      if(CloneErrorLookup[cloneindex].AllConfigOn[3][geomtype]>0)
				{
				  
				  
				  CloneErrorLookup[cloneindex].Config3[geomtype] = 1;
				  
				  for(strat_num=0;strat_num<NUM_S;strat_num++)
				    {
				      CloneErrorLookup[cloneindex].Stratum3[strat_num] = 1;
				    }
				  for(domain_num=0;domain_num<NUM_D;domain_num++)
				    {
				      CloneErrorLookup[cloneindex].Domain3[domain_num] = 1;
				    }
				}
			    }
			}
		    }
		}
	    }
	}
    }




  set_cursor(mydisplay,mywindow,GOOD);
}



void Begin_LongFiles(int type)
{
  char Cval[100];
  int Ijunk;
  double Djunk;

  if(type==LONG_ATTR_ID)
    {
      GetLongAttrVal(START_ID,999,&Ijunk,&Djunk,&Cval[0]);
    }
  else if(type==LONG_ATTR_CHECK_ID)
    {
      GetLongAttrVal(START_CHECK_ID,999,&Ijunk,&Djunk,&Cval[0]);
    }
  else if(type==LONG_ATTR_CHECK_HGT)
    {
      GetLongAttrVal(START_CHECK_HGT,999,&Ijunk,&Djunk,&Cval[0]);
    }
  else if(type==LONG_ATTR_CHECK_LEN)
    {
      GetLongAttrVal(START_CHECK_LEN,999,&Ijunk,&Djunk,&Cval[0]);
    }
  else if(type==LONG_ATTR_CHECK_NAM)
    {
      GetLongAttrVal(START_CHECK_NAM,999,&Ijunk,&Djunk,&Cval[0]);
    }
  else if(type==LONG_ATTR_CHECK_ZV2)
    {
      GetLongAttrVal(START_CHECK_ZV2,999,&Ijunk,&Djunk,&Cval[0]);
    }
  else if(type==LONG_ATTR_CHECK_AREA)
    {
      GetLongAttrVal(START_CHECK_AREA,999,&Ijunk,&Djunk,&Cval[0]);
    }
  else if(type==LONG_ATTR_AREA)
    {
      GetLongAttrVal(START_AREA,999,&Ijunk,&Djunk,&Cval[0]);
    }
  else if(type==LONG_ATTR_HGT)
    {
      GetLongAttrVal(START_HGT,999,&Ijunk,&Djunk,&Cval[0]);
    }
  else if(type==LONG_ATTR_LEN)
    {
      GetLongAttrVal(START_LEN,999,&Ijunk,&Djunk,&Cval[0]);
    }
  else if(type==LONG_ATTR_NAM)
    {
      GetLongAttrVal(START_NAM,999,&Ijunk,&Djunk,&Cval[0]);
    }
  else if(type==LONG_ATTR_ZV2)
    {
      GetLongAttrVal(START_ZV2,999,&Ijunk,&Djunk,&Cval[0]);
    }
  else
    {
      printf("bad flag %d to BLFs\n",type);
      ExitWrapper(-1);
    }
}




void End_LongFiles(int type)
{
  char Cval[100];
  int Ijunk;
  double Djunk;


  if(type==LONG_ATTR_ID)
    {
      GetLongAttrVal(STOP_ID,999,&Ijunk,&Djunk,&Cval[0]);
      FreeLLTable(); 
    }
  else if(type==LONG_ATTR_CHECK_ID)
    {
      GetLongAttrVal(STOP_CHECK_ID,999,&Ijunk,&Djunk,&Cval[0]);
      
    }
  else if(type==LONG_ATTR_CHECK_HGT)
    {
      GetLongAttrVal(STOP_CHECK_HGT,999,&Ijunk,&Djunk,&Cval[0]);
      
    }
  else if(type==LONG_ATTR_CHECK_LEN)
    {
      GetLongAttrVal(STOP_CHECK_LEN,999,&Ijunk,&Djunk,&Cval[0]);
      
    }
  else if(type==LONG_ATTR_CHECK_NAM)
    {
      GetLongAttrVal(STOP_CHECK_NAM,999,&Ijunk,&Djunk,&Cval[0]);
      
    }
  else if(type==LONG_ATTR_CHECK_ZV2)
    {
      GetLongAttrVal(STOP_CHECK_ZV2,999,&Ijunk,&Djunk,&Cval[0]);
      
    }
  else if(type==LONG_ATTR_CHECK_AREA)
    {
      GetLongAttrVal(STOP_CHECK_AREA,999,&Ijunk,&Djunk,&Cval[0]);
      
    }
  else if(type==LONG_ATTR_AREA)
    {
      GetLongAttrVal(STOP_AREA,999,&Ijunk,&Djunk,&Cval[0]);
 	  FreeLLTable(); 
   }
  else if(type==LONG_ATTR_HGT)
    {
      GetLongAttrVal(STOP_HGT,999,&Ijunk,&Djunk,&Cval[0]);
	  FreeLLTable(); 
    }
  else if(type==LONG_ATTR_LEN)
    {
      GetLongAttrVal(STOP_LEN,999,&Ijunk,&Djunk,&Cval[0]);
	  FreeLLTable(); 
    }
  else if(type==LONG_ATTR_NAM)
    {
      GetLongAttrVal(STOP_NAM,999,&Ijunk,&Djunk,&Cval[0]);
	  FreeLLTable(); 
    }
  else if(type==LONG_ATTR_ZV2)
    {
      GetLongAttrVal(STOP_ZV2,999,&Ijunk,&Djunk,&Cval[0]);
	  FreeLLTable(); 
    }
  else
    {
      printf("bad flag %d to ELFs\n",type);
      ExitWrapper(-1);
    }
}


void MatchFIDToLL(int fid, int lindex)
{
  if(LLFidTable==NULL)
  {
    printf("CombinedCheckApplies: NULL LLFidTable!\n");
    return;
  }


  if(fid>=LLFidTableCount)
  {
	  printf("CombinedCheckApplies: passed fid %d but max is %d\n",
		  fid,LLFidTableCount-1);
	  return;
  }

  if(LLFidTable[fid]!=lindex)
  {
	  printf("CombinedCheckApplies: fid %d maps to ll %d, not %d\n",
		  fid,LLFidTable[fid],lindex);
  }

}


void ResetOneDegree()
{
  int errnum,cloneindex,foundnegs=0;
  
  for(errnum=1;errnum<=CONDITION_DEFINITIONS;errnum++)
    {
      if(ErrorLookup[errnum].active==-1)
	{
	  ErrorLookup[errnum].active = 1;
	  foundnegs = foundnegs + 1;
	}
    }
  
  
  for(cloneindex=0;cloneindex<CLONE_DEFINITIONS;cloneindex++)
    {
      if(CloneErrorLookup[cloneindex].active==-1)
	{
	  CloneErrorLookup[cloneindex].active = 1;
	  foundnegs = foundnegs + 1;
	}
    }
  
  if(RemovedOneDegree!=foundnegs)
    {
      printf("Error: found %d ROD and %d FN\n",RemovedOneDegree,foundnegs);
    }
  
}


void WriteCRVersionFile()
{
  FILE *outfile;
  char fname[1000],errmsg[1000];
  int len1,len2,iconds=CONDITION_DEFINITIONS;
  extern char masterrun2[];

  sprintf(fname,"%scondreport.vr",outdirectory);

  outfile = fopen(fname,"wb");
  if(outfile==NULL)
  {
	sprintf(errmsg,"Error:  could not open:\n%s\nfor write",fname);
	not_while_running(drawing_a,errmsg,1481,"Could not open file for write",1);
	return;
  }

  len1 = strlen(VersionStr);
  len2 = strlen(masterrun2);


  SEEIT_fwrite_int(&iconds,outfile);
  SEEIT_fwrite_int(&len1,  outfile);
  SEEIT_fwrite_int(&len2,  outfile);
 
  fwrite(&VersionStr,SzUC,len1,outfile);
  fwrite(&masterrun2,SzUC,len2,outfile);

  fclose(outfile);
  
}


int TestMarkIgnored()
{
  if(ConsultPreviouslyIgnored==0)
  {
	return 1;
  }

  if(batch_mode==1)
  {
	return 1;
  }

  

   if((head_in_use==0)&&(deader_head==0))
	{
     EnterFileCallback(previousresults, (XtPointer)20, (XtPointer)20);
	}
   else if((head_in_use==1)&&(deader_phead==0))
	{
     EnterFileCallback(previousresults, (XtPointer)20, (XtPointer)20);
	}

   if((strlen(IgnoredLineFile)<2)&&(strlen(IgnoredPointFile)<2))
   {
	 

     if(batch_mode==1)
	 {
       printf("Error:  The \"Mark results using exported shapefiles\" option under the\n\
\"Inspection Options\" menu is active, but a valid GAIT project containing\n\
exported shapefiles has not been entered there.\n\n\
You must either deactivate this option or enter a valid GAIT project containing\n\
exported shapefiles before you may perform inspections.\n");
	 }
	 else
	 {
	   not_while_running(drawing_a,"\
Error:  The \"Mark results using exported shapefiles\" option under the\n\
\"Inspection Options\" menu is active, but a valid GAIT project containing\n\
exported shapefiles has not been entered there.\n\n\
You must either deactivate this option or enter a valid GAIT project containing\n\
exported shapefiles before you may perform inspections.",1541,"Cannot Continue",1);
	 }

	 return 0;
   }

   return 1;
}


int ICheckRegion(int iStart,int iLimit,int jStart,int jLimit)
{
  char *retstring;
  int i,totalchecks=0,totalconds=0,totalhighlighted=0,RemovedChecks=0,old[3];
  int OldChecks[CONDITION_DEFINITIONS+10];
  int *OldClones;
  double percentdone;
  extern int CHECK_DATA_SET,NETS_ONLY;
  extern char * LODelevDiffCheckOK(void);
  

  if(TestMarkIgnored()==0)
  {
	return 0;
  }

  if(CHECK_DATA_SET==0)
  {
    SetCheckData();
  }

  retstring = LODelevDiffCheckOK();
  
  if(strlen(retstring)<5)
    {

      

	  if(
		  (ADDNETS==0)  &&   
		  (NETS_ONLY==0))    
	  {
 
		RemovedChecks = 1;


	    for(i=0;i<=CONDITION_DEFINITIONS;i++)
		{ 
          OldChecks[i] = 0;

	      if(ErrorLookup[i].active==1)
		  { 
            if(IsNetCheck(i)==1)
			{ 
              ErrorLookup[i].active = 0;
		      OldChecks[i] = 1;
			} 
		  } 
		} 

	    OldClones = (int *)malloc(SzI*(CLONE_DEFINITIONS+5));

	    for(i=0;i<CLONE_DEFINITIONS;i++)
		{ 
          OldClones[i] = 0;

	      if(CloneErrorLookup[i].active==1)
		  {
            if(IsNetCheck(CloneErrorLookup[i].CloneNumber)==1)
			{ 
              CloneErrorLookup[i].active = 0;
		      OldClones[i] = 1;
			} 
		  } 
		} 
	  }




      StartTime = time(NULL);

      running = 1;
      BuildLLTable(1,LLFidTableCount); 
      Begin_LongFiles(LONG_ATTR_CHECK_ID);
      Begin_LongFiles(LONG_ATTR_CHECK_HGT);
      Begin_LongFiles(LONG_ATTR_CHECK_LEN);
      Begin_LongFiles(LONG_ATTR_CHECK_NAM);
      Begin_LongFiles(LONG_ATTR_CHECK_ZV2);
      Begin_LongFiles(LONG_ATTR_CHECK_AREA);


	  old[0] = SHOW_POLY_VERTICES;
	  old[1] = SHOW_LINE_VERTICES;
	  old[2] = SHOW_END_VERTICES;
	  SHOW_POLY_VERTICES = 0;
	  SHOW_LINE_VERTICES = 0;
	  SHOW_END_VERTICES  = 0;

      CheckRegion(iStart,iLimit,jStart,jLimit);

	  SHOW_POLY_VERTICES = old[0];
	  SHOW_LINE_VERTICES = old[1];
	  SHOW_END_VERTICES  = old[2];

      End_LongFiles(LONG_ATTR_CHECK_ID);
      End_LongFiles(LONG_ATTR_CHECK_HGT);
      End_LongFiles(LONG_ATTR_CHECK_LEN);
      End_LongFiles(LONG_ATTR_CHECK_NAM);
      End_LongFiles(LONG_ATTR_CHECK_ZV2);
      End_LongFiles(LONG_ATTR_CHECK_AREA);

      FreeLLTable(); 

      percentdone =  100.0 * ((double)((iLimit-iStart+1)*(jLimit-jStart+1)) / (double)((MaxXindex+1)*(MaxYindex+1)));
      BuildMasterRun(percentdone);


      if(RemovedChecks==1)
	  {
	    for(i=0;i<=CONDITION_DEFINITIONS;i++)
		{ 
	      if(OldChecks[i]==1)
		  { 
	        ErrorLookup[i].active = 1;
		  } 
		} 
	  
	    for(i=0;i<CLONE_DEFINITIONS;i++)
		{ 
	      if(OldClones[i]==1)
		  { 
	        CloneErrorLookup[i].active = 1;
		  } 
		} 

	    free(OldClones);
	  }



	  WriteCRVersionFile();

	  VCGetGlobalTotals(&totalchecks,&totalconds,&totalhighlighted);

	  if(totalconds>0)
	  {
        UnsavedConditions = 1;
	  }
	  else
	  {
		
		UnsavedConditions = 0;
	  }


      running = 0;
      if(RemovedOneDegree>0)
	{
	  ResetOneDegree();
	}
      return 1;
    }
  else
    {
      if(RemovedOneDegree>0)
	{
	  ResetOneDegree();
	}
      
      if(batch_mode==1)
	{
	  printf("%s\n",retstring);
	}
      else
	{
	  not_while_running(drawing_a,retstring,1107,"Illegal Manuever",1);
	}
      return 0;  
    }

}






char *GetSWLat(double *retval)
{
  static char tempstr[100];
  
  *retval = 0;

  if(Ctype()==2)
    {
      return "";
    }
  
  if(Ytranslation<0)
    {
      sprintf(tempstr,"%.7lf S",-1*Ytranslation);
	  *retval = -1*Ytranslation;
    }
  else
    {
      sprintf(tempstr,"%.7lf N",Ytranslation);
	  *retval = Ytranslation;
    }
  
  return tempstr;
}



char *GetSWLong(double *retval)
{
  static char tempstr[100];
  
  *retval = 0;

  if(Ctype()==2)
    {
      return "";
    }
  
  if(Xtranslation<0)
    {
      sprintf(tempstr,"%.7lf W",-1*Xtranslation);
	  *retval = -1*Xtranslation;
    }
  else
    {
      sprintf(tempstr,"%.7lf E",Xtranslation);
	  *retval = Xtranslation;
    }
  
  return tempstr;
}





char *GetVariousPeices(int type)
{
  char temp[1000];
  FILE *headfile;
  double MINYREAD;
  double MINXREAD;
  double MAXYREAD;
  double MAXXREAD;  
  double MINY_P_READ;
  double MINX_P_READ;
  double MAXY_P_READ;
  double MAXX_P_READ;
  unsigned int TERRAINPOLYSREAD;
  unsigned int GRIDPOINTSREAD;
  long int POINT_POINTSREAD;
  long int LINEAR_POINTSREAD;
  long int AREAL_POINTSREAD;
  int GRIDSREAD;
  int coordflag;
  int num_long_entries,num_short_entries;
  static char retstr[100];

  

  
  sprintf(temp,"%sheader.txt",indirectory);

  headfile = fopen(temp,"r");
  if(headfile==NULL)
    {
      return "";
    }
  
  fscanf(headfile,"%d %lf %lf %lf %lf %lf %lf %lf %lf %u %u %ld %ld %ld %d %d %d\n",
	 &coordflag,
	 &MINXREAD,&MINYREAD,&MAXXREAD,&MAXYREAD,
	 &MINX_P_READ,&MINY_P_READ,&MAXX_P_READ,&MAXY_P_READ,
	 &TERRAINPOLYSREAD,
	 &GRIDPOINTSREAD,&POINT_POINTSREAD,&LINEAR_POINTSREAD,&AREAL_POINTSREAD,&GRIDSREAD,
	 &num_long_entries,&num_short_entries);

  fclose(headfile);


  if(type==3)
    {
      sprintf(retstr,"%d",GRIDSREAD);
      return retstr;
    }

  if(type==4)
    {
      sprintf(retstr,"%u",GRIDPOINTSREAD);
      return retstr;
    }


  if((type==1)||(type==2))
    {
      
      if((MINXREAD<MAXXREAD)&&(MINYREAD<MAXYREAD))
	{
	  if(type==1)
	    {
	      if(MAXXREAD<0)
		{
		  sprintf(retstr,"%.7lf W",-1*MAXXREAD);
		}
	      else
		{
		  sprintf(retstr,"%.7lf E",MAXXREAD);
		}
	      return retstr;
	    }
	  else
	    {
	      if(MAXYREAD<0)
		{
		  sprintf(retstr,"%.7lf S",-1*MAXYREAD);
		}
	      else
		{
		  sprintf(retstr,"%.7lf N",MAXYREAD);
		}
	      return retstr;
	    }
	}
      
      else if((MINX_P_READ<MAXX_P_READ)&&(MINY_P_READ<MAXY_P_READ))
	{
	  if (MINX_P_READ < MINXREAD) 
	    MINXREAD = MINX_P_READ;
	  if (MAXX_P_READ < MAXXREAD) 
	    MAXXREAD = MAXX_P_READ;
	  if (MINY_P_READ < MINYREAD) 
	    MINYREAD = MINY_P_READ;
	  if (MAXY_P_READ < MAXYREAD) 
	    MAXYREAD = MAXY_P_READ;
	  
	  if(type==1)
	    {
	      if(MAXXREAD<0)
		{
		  sprintf(retstr,"%.7lf W",-1*MAXXREAD);
		}
	      else
		{
		  sprintf(retstr,"%.7lf E",MAXXREAD);
		}
	      return retstr;
	    }
	  else
	    {
	      if(MAXYREAD<0)
		{
		  sprintf(retstr,"%lf S",-1*MAXYREAD);
		}
	      else
		{
		  sprintf(retstr,"%lf N",MAXYREAD);
		}
	      return retstr;
	    }
	}
      else
	{
	  return "";
	}
    }
  
  return "";
  
}




void CheckFiles(char *thefolder, char *thename,int rawfinished)
{
  FILE *ptr;
  int i,len,numfiles,foundit;
  char cmd[1000],buf[1000],tempname[1000];
  extern int SLASHTYPE;
  extern FILE *badtrex;


#define num_raw_files 41
  char RawFiles[num_raw_files][70]; 

#define num_finished_files 28
  char FinishedFiles[num_finished_files][70]; 

  

  sprintf(RawFiles[0], "AUXFILES%s%s_HEM.tif",             GetSlash(),thename);
  sprintf(RawFiles[1], "AUXFILES%s%s_WAM.tif",             GetSlash(),thename);
  sprintf(RawFiles[2], "AUXFILES%s%s_COV.tif",             GetSlash(),thename);
  sprintf(RawFiles[3], "AUXFILES%s%s_AMP.tif",             GetSlash(),thename);
  sprintf(RawFiles[4], "AUXFILES%s%s_AM2.tif",             GetSlash(),thename);
  sprintf(RawFiles[5], "AUXFILES%s%s_COM.tif",             GetSlash(),thename);
  sprintf(RawFiles[6], "AUXFILES%s%s_LSM.tif",             GetSlash(),thename);
  sprintf(RawFiles[7], "AUXFILES%s%s_RLM.tif",             GetSlash(),thename);
  sprintf(RawFiles[8], "AUXFILES%s%s_SRC.shp",             GetSlash(),thename);
  sprintf(RawFiles[9], "AUXFILES%s%s_SRC.prj",             GetSlash(),thename);
  sprintf(RawFiles[10],"AUXFILES%s%s_SRC.shx",             GetSlash(),thename);
  sprintf(RawFiles[11],"AUXFILES%s%s_SRC.dbf",             GetSlash(),thename);
  sprintf(RawFiles[12],"DEM%s%s_DEM.tif",                  GetSlash(),thename);
  sprintf(RawFiles[13],"PREVIEW%s%s_DEM_QL.tif",           GetSlash(),thename);
  sprintf(RawFiles[14],"PREVIEW%s%s_DEM_QL.jpg",           GetSlash(),thename);
  sprintf(RawFiles[15],"PREVIEW%s%s_DEM_SHADED_QL.tif",    GetSlash(),thename);
  sprintf(RawFiles[16],"PREVIEW%s%s_DEM_SHADED_QL.jpg",    GetSlash(),thename);
  sprintf(RawFiles[17],"PREVIEW%s%s_DEM_SHADED_ABS_QL.tif",GetSlash(),thename);
  sprintf(RawFiles[18],"PREVIEW%s%s_DEM_SHADED_ABS_QL.jpg",GetSlash(),thename);
  sprintf(RawFiles[19],"PREVIEW%s%s_DEM_SHADED_REL_QL.tif",GetSlash(),thename);
  sprintf(RawFiles[20],"PREVIEW%s%s_DEM_SHADED_REL_QL.jpg",GetSlash(),thename);
  sprintf(RawFiles[21],"PREVIEW%s%s_HEM_QL.tif",           GetSlash(),thename);
  sprintf(RawFiles[22],"PREVIEW%s%s_HEM_QL.jpg",           GetSlash(),thename);
  sprintf(RawFiles[23],"PREVIEW%s%s_WAM_QL.tif",           GetSlash(),thename);
  sprintf(RawFiles[24],"PREVIEW%s%s_WAM_QL.jpg",           GetSlash(),thename);
  sprintf(RawFiles[25],"PREVIEW%s%s_COV_QL.tif",           GetSlash(),thename);
  sprintf(RawFiles[26],"PREVIEW%s%s_COV_QL.jpg",           GetSlash(),thename);
  sprintf(RawFiles[27],"PREVIEW%s%s_AMP_QL.tif",           GetSlash(),thename);
  sprintf(RawFiles[28],"PREVIEW%s%s_AMP_QL.jpg",           GetSlash(),thename);
  sprintf(RawFiles[29],"PREVIEW%s%s_AM2_QL.tif",           GetSlash(),thename);
  sprintf(RawFiles[30],"PREVIEW%s%s_AM2_QL.jpg",           GetSlash(),thename);
  sprintf(RawFiles[31],"PREVIEW%s%s_COM_QL.tif",           GetSlash(),thename);
  sprintf(RawFiles[32],"PREVIEW%s%s_COM_QL.jpg",           GetSlash(),thename);
  sprintf(RawFiles[33],"PREVIEW%s%s_LSM_QL.tif",           GetSlash(),thename);
  sprintf(RawFiles[34],"PREVIEW%s%s_LSM_QL.jpg",           GetSlash(),thename);
  sprintf(RawFiles[35],"PREVIEW%s%s_RLM_QL.tif",           GetSlash(),thename);
  sprintf(RawFiles[36],"PREVIEW%s%s_RLM_QL.jpg",           GetSlash(),thename);

  
  sprintf(RawFiles[37],"%s.xml",thename);

  
  sprintf(RawFiles[38],"AUXFILES");
  sprintf(RawFiles[39],"DEM");
  sprintf(RawFiles[40],"PREVIEW");



  

  sprintf(FinishedFiles[0], "AUXFILES%s%s_AMP.tif",             GetSlash(),thename);
  sprintf(FinishedFiles[1], "AUXFILES%s%s_EDM.tif",             GetSlash(),thename);
  sprintf(FinishedFiles[2], "AUXFILES%s%s_SDM.tif",             GetSlash(),thename);
  sprintf(FinishedFiles[3], "AUXFILES%s%s_HEM.tif",             GetSlash(),thename);
  sprintf(FinishedFiles[4], "AUXFILES%s%s_WBM.tif",             GetSlash(),thename);
  sprintf(FinishedFiles[5], "DEM%s%s_DEM.tif",                  GetSlash(),thename);
  sprintf(FinishedFiles[6], "PREVIEW%s%s_DEM_QL.tif",           GetSlash(),thename);
  sprintf(FinishedFiles[7], "PREVIEW%s%s_DEM_QL.jpg",           GetSlash(),thename);
  sprintf(FinishedFiles[8], "PREVIEW%s%s_DEM_SHADED_QL.tif",    GetSlash(),thename);
  sprintf(FinishedFiles[9], "PREVIEW%s%s_DEM_SHADED_QL.jpg",    GetSlash(),thename);
  sprintf(FinishedFiles[10],"PREVIEW%s%s_DEM_SHADED_ABS_QL.tif",GetSlash(),thename);
  sprintf(FinishedFiles[11],"PREVIEW%s%s_DEM_SHADED_ABS_QL.jpg",GetSlash(),thename);
  sprintf(FinishedFiles[12],"PREVIEW%s%s_DEM_SHADED_REL_QL.tif",GetSlash(),thename);
  sprintf(FinishedFiles[13],"PREVIEW%s%s_DEM_SHADED_REL_QL.jpg",GetSlash(),thename);
  sprintf(FinishedFiles[14],"PREVIEW%s%s_AMP_QL.tif",           GetSlash(),thename);
  sprintf(FinishedFiles[15],"PREVIEW%s%s_AMP_QL.jpg",           GetSlash(),thename);
  sprintf(FinishedFiles[16],"PREVIEW%s%s_EDM_QL.tif",           GetSlash(),thename);
  sprintf(FinishedFiles[17],"PREVIEW%s%s_EDM_QL.jpg",           GetSlash(),thename);
  sprintf(FinishedFiles[18],"PREVIEW%s%s_SDM_QL.tif",           GetSlash(),thename);
  sprintf(FinishedFiles[19],"PREVIEW%s%s_SDM_QL.jpg",           GetSlash(),thename);
  sprintf(FinishedFiles[20],"PREVIEW%s%s_HEM_QL.tif",           GetSlash(),thename);
  sprintf(FinishedFiles[21],"PREVIEW%s%s_HEM_QL.jpg",           GetSlash(),thename);
  sprintf(FinishedFiles[22],"PREVIEW%s%s_WBM_QL.tif",           GetSlash(),thename);
  sprintf(FinishedFiles[23],"PREVIEW%s%s_WBM_QL.jpg",           GetSlash(),thename);


  
  sprintf(FinishedFiles[24],"%s.xml",thename);

  
  sprintf(FinishedFiles[25],"AUXFILES");
  sprintf(FinishedFiles[26],"DEM");
  sprintf(FinishedFiles[27],"PREVIEW");


  if(rawfinished==1)
  {
	numfiles = num_raw_files;
  }
  else if(rawfinished==2)
  {
	numfiles = num_finished_files;
  }


  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
  {
    sprintf(cmd,"dir /s /b \"%s\"",thefolder);
  }
  else
  {
    sprintf(cmd, "find \"%s\"",thefolder);
  }

  if((ptr=POPEN(cmd,"r"))!=NULL)
  {
    while(fgets(buf,1000,ptr)!=NULL)
	{
	  len = strlen(buf);
	  for(i=0;i<len;i++)
	  {
	    if(buf[i]=='\n')
		{
		  buf[i] = '\0';
		  break;
		}
	  }

	  foundit = 0;


	  

	  for(i=0;i<numfiles;i++)
	  {

        
	    if(!strcmp(buf,thefolder))
	    {
	       foundit = 1;
	       break;
	    }

        
		sprintf(tempname,"%s%sRESOURCES",thefolder,GetSlash());

		if(!strncmp(buf,tempname,strlen(tempname)))
		{
		  foundit = 1;
		  break;
		}

		if(rawfinished==1)
		{
		  sprintf(tempname,"%s%s%s",thefolder,GetSlash(),RawFiles[i]);
		}
		else if(rawfinished==2)
		{
		  sprintf(tempname,"%s%s%s",thefolder,GetSlash(),FinishedFiles[i]);
		}

		if(!strcmp(buf,tempname))
		{
		  foundit = 1;
		  break;
		}
	  }

      if(foundit==0)
	  { 
       fprintf(badtrex,"IMPORT_SENTINEL Error:\n");
       fprintf(badtrex,"IMPORT_SENTINEL   Found unexpected file: %s\n",buf);

	   
	  } 

	}
    PCLOSE(ptr);
  }
}





void CheckForExtraFiles(char *thefolder,char *ancfolder,char *thename,int rawfinished)
{
  

  if(rawfinished==1)
  {
    CheckFiles(thefolder,thename,rawfinished);
  }
  else if(rawfinished==2)
  {
	CheckFiles(thefolder,thename,rawfinished);

	
  }
}

