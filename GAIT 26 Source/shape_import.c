/************
GAIT (Geospatial Analysis Integrity Tool) is a geospatial data validation tool developed by the Institute for Defense Analyses (IDA) for the National Geospatial-Intelligence Agency (NGA).  

This source code was used to generate GAIT 26 executable software in accordance with Amendment 6 to Task Order DH-8-3815 under Contract HQ0034-14-D-0001.

IDA is furnishing this item "as is". IDA was not tasked or funded to generate developer documentation or to provide support for this source code. IDA does not provide any warranty of the item whatsoever, whether express, implied, or statutory, including, but not limited to, any warranty of fitness for a particular purpose or any warranty that the contents of the item will be error-free. In no event shall NGA or IDA be held liable for damages arising, directly or indirectly, from the use of this source code. 

This material may be reproduced by the U.S. Government pursuant to its unlimited use rights under DFARS 252.227-7014 [Feb 2014].

The Institute for Defense Analyses (IDA) is a Federally Funded Research and Development Center that provides scientific and technical expertise on issues important to national security to the Office of the Secretary of Defense, Joint Staff, Unified Commands, and Defense Agencies. 

© 2017 Institute for Defense Analyses
  4850 Mark Center Drive
  Alexandria, Virginia 22311-1882
  703.845-2000
  www.ida.org
************/
#include "shapefil.h"
#include "share.h"
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>  



extern char *MGCP3_p_optional[];
extern char *MGCP3_l_optional[];
extern char *MGCP3_a_optional[];

extern int MGCP3_P_OPTCOUNT;
extern int MGCP3_L_OPTCOUNT;
extern int MGCP3_A_OPTCOUNT;

extern int NOTYPE;
extern int C_TYPE;
extern int D_TYPE;
extern int I_TYPE;

extern int LONG_ATTR_ID             ;
extern int LONG_ATTR_ID_INFO        ;
extern int LONG_ATTR_AREA           ;
extern int LONG_ATTR_HGT            ;
extern int LONG_ATTR_LEN            ;
extern int LONG_ATTR_NAM            ;
extern int LONG_ATTR_ZV2            ;
extern int START_ID                 ;
extern int STOP_ID                  ;
extern int HAS_ID[NUM_ATTR_SCHEMA+5];

extern int NULLFILE;
extern int CREATING_TREX;  
extern int NoZ_Values;

#define VERBOSE_UTF 0


#define MGCP_UTF8_WHITELIST_NUM 1438

unsigned int MGCP_UTF8_Whitelist[MGCP_UTF8_WHITELIST_NUM]={
 0x00A9,
 0x0020,
 0x0021,
 0x0022,
 0x0023,
 0x0024,
 0x0025,
 0x0026,
 0x0027,
 0x0028,
 0x0029,
 0x002A,
 0x002B,
 0x002C,
 0x002D,
 0x002E,
 0x002F,
 0x0030,
 0x0031,
 0x0032,
 0x0033,
 0x0034,
 0x0035,
 0x0036,
 0x0037,
 0x0038,
 0x0039,
 0x003A,
 0x003B,
 0x003C,
 0x003D,
 0x003E,
 0x003F,
 0x0040,
 0x0041,
 0x0042,
 0x0043,
 0x0044,
 0x0045,
 0x0046,
 0x0047,
 0x0048,
 0x0049,
 0x004A,
 0x004B,
 0x004C,
 0x004D,
 0x004E,
 0x004F,
 0x0050,
 0x0051,
 0x0052,
 0x0053,
 0x0054,
 0x0055,
 0x0056,
 0x0057,
 0x0058,
 0x0059,
 0x005A,
 0x005B,
 0x005C,
 0x005D,
 0x005E,
 0x005F,
 0x0060,
 0x0061,
 0x0062,
 0x0063,
 0x0064,
 0x0065,
 0x0066,
 0x0067,
 0x0068,
 0x0069,
 0x006A,
 0x006B,
 0x006C,
 0x006D,
 0x006E,
 0x006F,
 0x0070,
 0x0071,
 0x0072,
 0x0073,
 0x0074,
 0x0075,
 0x0076,
 0x0077,
 0x0078,
 0x0079,
 0x007A,
 0x007B,
 0x007C,
 0x007D,
 0x007E,
 0x00A0,
 0x00A1,
 0x00A6,
 0x00A8,
 0x00AA,
 0x00AB,
 0x00AD,
 0x00AE,
 0x00AF,
 0x00B0,
 0x00B4,
 0x00B5,
 0x00B7,
 0x00B8,
 0x00B9,
 0x00BA,
 0x00BB,
 0x00C0,
 0x00C1,
 0x00C2,
 0x00C3,
 0x00C4,
 0x00C5,
 0x00C6,
 0x00C7,
 0x00C8,
 0x00C9,
 0x00CA,
 0x00CB,
 0x00CC,
 0x00CD,
 0x00CE,
 0x00CF,
 0x00D0,
 0x00D1,
 0x00D2,
 0x00D3,
 0x00D4,
 0x00D5,
 0x00D6,
 0x00D7,
 0x00D8,
 0x00D9,
 0x00DA,
 0x00DB,
 0x00DC,
 0x00DD,
 0x00DE,
 0x00DF,
 0x00E0,
 0x00E1,
 0x00E2,
 0x00E3,
 0x00E4,
 0x00E5,
 0x00E6,
 0x00E7,
 0x00E8,
 0x00E9,
 0x00EA,
 0x00EB,
 0x00EC,
 0x00ED,
 0x00EE,
 0x00EF,
 0x00F0,
 0x00F1,
 0x00F2,
 0x00F3,
 0x00F4,
 0x00F5,
 0x00F6,
 0x00F7,
 0x00F8,
 0x00F9,
 0x00FA,
 0x00FB,
 0x00FC,
 0x00FD,
 0x00FE,
 0x00FF,
 0x0100,
 0x0101,
 0x0102,
 0x0103,
 0x0104,
 0x0105,
 0x0106,
 0x0107,
 0x0108,
 0x0109,
 0x010A,
 0x010B,
 0x010C,
 0x010D,
 0x010E,
 0x010F,
 0x0110,
 0x0111,
 0x0112,
 0x0113,
 0x0114,
 0x0115,
 0x0116,
 0x0117,
 0x0118,
 0x0119,
 0x011A,
 0x011B,
 0x011C,
 0x011D,
 0x011E,
 0x011F,
 0x0120,
 0x0121,
 0x0122,
 0x0123,
 0x0124,
 0x0125,
 0x0126,
 0x0127,
 0x0128,
 0x0129,
 0x012A,
 0x012B,
 0x012C,
 0x012D,
 0x012E,
 0x012F,
 0x0130,
 0x0131,
 0x0132,
 0x0133,
 0x0134,
 0x0135,
 0x0136,
 0x0137,
 0x0138,
 0x0139,
 0x013A,
 0x013B,
 0x013C,
 0x013D,
 0x013E,
 0x013F,
 0x0140,
 0x0141,
 0x0142,
 0x0143,
 0x0144,
 0x0145,
 0x0146,
 0x0147,
 0x0148,
 0x0149,
 0x014A,
 0x014B,
 0x014C,
 0x014D,
 0x014E,
 0x014F,
 0x0150,
 0x0151,
 0x0152,
 0x0153,
 0x0154,
 0x0155,
 0x0156,
 0x0157,
 0x0158,
 0x0159,
 0x015A,
 0x015B,
 0x015C,
 0x015D,
 0x015E,
 0x015F,
 0x0160,
 0x0161,
 0x0162,
 0x0163,
 0x0164,
 0x0165,
 0x0166,
 0x0167,
 0x0168,
 0x0169,
 0x016A,
 0x016B,
 0x016C,
 0x016D,
 0x016E,
 0x016F,
 0x0170,
 0x0171,
 0x0172,
 0x0173,
 0x0174,
 0x0175,
 0x0176,
 0x0177,
 0x0178,
 0x0179,
 0x017A,
 0x017B,
 0x017C,
 0x017D,
 0x017E,
 0x017F,
 0x0180,
 0x0181,
 0x0182,
 0x0183,
 0x0184,
 0x0185,
 0x0186,
 0x0187,
 0x0188,
 0x0189,
 0x018A,
 0x018B,
 0x018C,
 0x018D,
 0x018E,
 0x018F,
 0x0190,
 0x0191,
 0x0192,
 0x0193,
 0x0194,
 0x0195,
 0x0196,
 0x0197,
 0x0198,
 0x0199,
 0x019A,
 0x019B,
 0x019C,
 0x019D,
 0x019E,
 0x019F,
 0x01A0,
 0x01A1,
 0x01A2,
 0x01A3,
 0x01A4,
 0x01A5,
 0x01A6,
 0x01A7,
 0x01A8,
 0x01A9,
 0x01AA,
 0x01AB,
 0x01AC,
 0x01AD,
 0x01AE,
 0x01AF,
 0x01B0,
 0x01B1,
 0x01B2,
 0x01B3,
 0x01B4,
 0x01B5,
 0x01B6,
 0x01B7,
 0x01B8,
 0x01B9,
 0x01BA,
 0x01BB,
 0x01BC,
 0x01BD,
 0x01BE,
 0x01BF,
 0x01C0,
 0x01C1,
 0x01C2,
 0x01C3,
 0x01C4,
 0x01C5,
 0x01C6,
 0x01C7,
 0x01C8,
 0x01C9,
 0x01CA,
 0x01CB,
 0x01CC,
 0x01CD,
 0x01CE,
 0x01CF,
 0x01D0,
 0x01D1,
 0x01D2,
 0x01D3,
 0x01D4,
 0x01D5,
 0x01D6,
 0x01D7,
 0x01D8,
 0x01D9,
 0x01DA,
 0x01DB,
 0x01DC,
 0x01DD,
 0x01DE,
 0x01DF,
 0x01E0,
 0x01E1,
 0x01E2,
 0x01E3,
 0x01E4,
 0x01E5,
 0x01E6,
 0x01E7,
 0x01E8,
 0x01E9,
 0x01EA,
 0x01EB,
 0x01EC,
 0x01ED,
 0x01EE,
 0x01EF,
 0x01F0,
 0x01F1,
 0x01F2,
 0x01F3,
 0x01F4,
 0x01F5,
 0x01F6,
 0x01F7,
 0x01F8,
 0x01F9,
 0x01FA,
 0x01FB,
 0x01FC,
 0x01FD,
 0x01FE,
 0x01FF,
 0x0200,
 0x0201,
 0x0202,
 0x0203,
 0x0204,
 0x0205,
 0x0206,
 0x0207,
 0x0208,
 0x0209,
 0x020A,
 0x020B,
 0x020C,
 0x020D,
 0x020E,
 0x020F,
 0x0210,
 0x0211,
 0x0212,
 0x0213,
 0x0214,
 0x0215,
 0x0216,
 0x0217,
 0x0218,
 0x0219,
 0x021A,
 0x021B,
 0x021C,
 0x021D,
 0x021E,
 0x021F,
 0x0220,
 0x0221,
 0x0222,
 0x0223,
 0x0224,
 0x0225,
 0x0226,
 0x0227,
 0x0228,
 0x0229,
 0x022A,
 0x022B,
 0x022C,
 0x022D,
 0x022E,
 0x022F,
 0x0230,
 0x0231,
 0x0232,
 0x0233,
 0x0234,
 0x0235,
 0x0236,
 0x0237,
 0x0238,
 0x0239,
 0x023A,
 0x023B,
 0x023C,
 0x023D,
 0x023E,
 0x023F,
 0x0240,
 0x0241,
 0x0242,
 0x0243,
 0x0244,
 0x0245,
 0x0246,
 0x0247,
 0x0248,
 0x0249,
 0x024A,
 0x024B,
 0x024C,
 0x024D,
 0x024E,
 0x024F,
 0x0250,
 0x0251,
 0x0252,
 0x0253,
 0x0254,
 0x0255,
 0x0256,
 0x0257,
 0x0258,
 0x0259,
 0x025A,
 0x025B,
 0x025C,
 0x025D,
 0x025E,
 0x025F,
 0x0260,
 0x0261,
 0x0262,
 0x0263,
 0x0264,
 0x0265,
 0x0266,
 0x0267,
 0x0268,
 0x0269,
 0x026A,
 0x026B,
 0x026C,
 0x026D,
 0x026E,
 0x026F,
 0x0270,
 0x0271,
 0x0272,
 0x0273,
 0x0274,
 0x0275,
 0x0276,
 0x0277,
 0x0278,
 0x0279,
 0x027A,
 0x027B,
 0x027C,
 0x027D,
 0x027E,
 0x027F,
 0x0280,
 0x0281,
 0x0282,
 0x0283,
 0x0284,
 0x0285,
 0x0286,
 0x0287,
 0x0288,
 0x0289,
 0x028A,
 0x028B,
 0x028C,
 0x028D,
 0x028E,
 0x028F,
 0x0290,
 0x0291,
 0x0292,
 0x0293,
 0x0294,
 0x0295,
 0x0296,
 0x0297,
 0x0298,
 0x0299,
 0x029A,
 0x029B,
 0x029C,
 0x029D,
 0x029E,
 0x029F,
 0x02A0,
 0x02A1,
 0x02A2,
 0x02A3,
 0x02A4,
 0x02A5,
 0x02A6,
 0x02A7,
 0x02A8,
 0x02A9,
 0x02AA,
 0x02AB,
 0x02AC,
 0x02AD,
 0x02AE,
 0x02AF,
 0x02B0,
 0x02B1,
 0x02B2,
 0x02B3,
 0x02B4,
 0x02B5,
 0x02B6,
 0x02B7,
 0x02B8,
 0x02B9,
 0x02BA,
 0x02BB,
 0x02BC,
 0x02BD,
 0x02BE,
 0x02BF,
 0x02C0,
 0x02C1,
 0x02C2,
 0x02C3,
 0x02C4,
 0x02C5,
 0x02C6,
 0x02C7,
 0x02C8,
 0x02C9,
 0x02CA,
 0x02CB,
 0x02CC,
 0x02CD,
 0x02CE,
 0x02CF,
 0x02D0,
 0x02D1,
 0x02D2,
 0x02D3,
 0x02D4,
 0x02D5,
 0x02D6,
 0x02D7,
 0x02D8,
 0x02D9,
 0x02DA,
 0x02DB,
 0x02DC,
 0x02DD,
 0x02DE,
 0x02DF,
 0x02E0,
 0x02E1,
 0x02E2,
 0x02E3,
 0x02E4,
 0x02E5,
 0x02E6,
 0x02E7,
 0x02E8,
 0x02E9,
 0x02EA,
 0x02EB,
 0x02EC,
 0x02ED,
 0x02EE,
 0x02EF,
 0x02F0,
 0x02F1,
 0x02F2,
 0x02F3,
 0x02F4,
 0x02F5,
 0x02F6,
 0x02F7,
 0x02F8,
 0x02F9,
 0x02FA,
 0x02FB,
 0x02FC,
 0x02FD,
 0x02FE,
 0x02FF,
 0x0300,
 0x0301,
 0x0302,
 0x0303,
 0x0304,
 0x0305,
 0x0306,
 0x0307,
 0x0308,
 0x0309,
 0x030A,
 0x030B,
 0x030C,
 0x030D,
 0x030E,
 0x030F,
 0x0310,
 0x0311,
 0x0312,
 0x0313,
 0x0314,
 0x0315,
 0x0316,
 0x0317,
 0x0318,
 0x0319,
 0x031A,
 0x031B,
 0x031C,
 0x031D,
 0x031E,
 0x031F,
 0x0320,
 0x0321,
 0x0322,
 0x0323,
 0x0324,
 0x0325,
 0x0326,
 0x0327,
 0x0328,
 0x0329,
 0x032A,
 0x032B,
 0x032C,
 0x032D,
 0x032E,
 0x032F,
 0x0330,
 0x0331,
 0x0332,
 0x0333,
 0x0334,
 0x0335,
 0x0336,
 0x0337,
 0x0338,
 0x0339,
 0x033A,
 0x033B,
 0x033C,
 0x033D,
 0x033E,
 0x033F,
 0x0340,
 0x0341,
 0x0342,
 0x0343,
 0x0344,
 0x0345,
 0x0346,
 0x0347,
 0x0348,
 0x0349,
 0x034A,
 0x034B,
 0x034C,
 0x034D,
 0x034E,
 0x034F,
 0x0350,
 0x0351,
 0x0352,
 0x0353,
 0x0354,
 0x0355,
 0x0356,
 0x0357,
 0x0358,
 0x0359,
 0x035A,
 0x035B,
 0x035C,
 0x035D,
 0x035E,
 0x035F,
 0x0360,
 0x0361,
 0x0362,
 0x0363,
 0x0364,
 0x0365,
 0x0366,
 0x0367,
 0x0368,
 0x0369,
 0x036A,
 0x036B,
 0x036C,
 0x036D,
 0x036E,
 0x036F,
 0x1DC0,
 0x1DC1,
 0x1DC2,
 0x1DC3,
 0x1DC4,
 0x1DC5,
 0x1DC6,
 0x1DC7,
 0x1DC8,
 0x1DC9,
 0x1DCA,
 0x1DCB,
 0x1DCC,
 0x1DCD,
 0x1DCE,
 0x1DCF,
 0x1DD0,
 0x1DD1,
 0x1DD2,
 0x1DD3,
 0x1DD4,
 0x1DD5,
 0x1DD6,
 0x1DD7,
 0x1DD8,
 0x1DD9,
 0x1DDA,
 0x1DDB,
 0x1DDC,
 0x1DDD,
 0x1DDE,
 0x1DDF,
 0x1DE0,
 0x1DE1,
 0x1DE2,
 0x1DE3,
 0x1DE4,
 0x1DE5,
 0x1DE6,
 0x1DE7,
 0x1DE8,
 0x1DE9,
 0x1DEA,
 0x1DEB,
 0x1DEC,
 0x1DED,
 0x1DEE,
 0x1DEF,
 0x1DF0,
 0x1DF1,
 0x1DF2,
 0x1DF3,
 0x1DF4,
 0x1DF5,
 0x1DF6,
 0x1DF7,
 0x1DF8,
 0x1DF9,
 0x1DFA,
 0x1DFB,
 0x1DFC,
 0x1DFD,
 0x1DFE,
 0x1DFF,
 0x1E00,
 0x1E01,
 0x1E02,
 0x1E03,
 0x1E04,
 0x1E05,
 0x1E06,
 0x1E07,
 0x1E08,
 0x1E09,
 0x1E0A,
 0x1E0B,
 0x1E0C,
 0x1E0D,
 0x1E0E,
 0x1E0F,
 0x1E10,
 0x1E11,
 0x1E12,
 0x1E13,
 0x1E14,
 0x1E15,
 0x1E16,
 0x1E17,
 0x1E18,
 0x1E19,
 0x1E1A,
 0x1E1B,
 0x1E1C,
 0x1E1D,
 0x1E1E,
 0x1E1F,
 0x1E20,
 0x1E21,
 0x1E22,
 0x1E23,
 0x1E24,
 0x1E25,
 0x1E26,
 0x1E27,
 0x1E28,
 0x1E29,
 0x1E2A,
 0x1E2B,
 0x1E2C,
 0x1E2D,
 0x1E2E,
 0x1E2F,
 0x1E30,
 0x1E31,
 0x1E32,
 0x1E33,
 0x1E34,
 0x1E35,
 0x1E36,
 0x1E37,
 0x1E38,
 0x1E39,
 0x1E3A,
 0x1E3B,
 0x1E3C,
 0x1E3D,
 0x1E3E,
 0x1E3F,
 0x1E40,
 0x1E41,
 0x1E42,
 0x1E43,
 0x1E44,
 0x1E45,
 0x1E46,
 0x1E47,
 0x1E48,
 0x1E49,
 0x1E4A,
 0x1E4B,
 0x1E4C,
 0x1E4D,
 0x1E4E,
 0x1E4F,
 0x1E50,
 0x1E51,
 0x1E52,
 0x1E53,
 0x1E54,
 0x1E55,
 0x1E56,
 0x1E57,
 0x1E58,
 0x1E59,
 0x1E5A,
 0x1E5B,
 0x1E5C,
 0x1E5D,
 0x1E5E,
 0x1E5F,
 0x1E60,
 0x1E61,
 0x1E62,
 0x1E63,
 0x1E64,
 0x1E65,
 0x1E66,
 0x1E67,
 0x1E68,
 0x1E69,
 0x1E6A,
 0x1E6B,
 0x1E6C,
 0x1E6D,
 0x1E6E,
 0x1E6F,
 0x1E70,
 0x1E71,
 0x1E72,
 0x1E73,
 0x1E74,
 0x1E75,
 0x1E76,
 0x1E77,
 0x1E78,
 0x1E79,
 0x1E7A,
 0x1E7B,
 0x1E7C,
 0x1E7D,
 0x1E7E,
 0x1E7F,
 0x1E80,
 0x1E81,
 0x1E82,
 0x1E83,
 0x1E84,
 0x1E85,
 0x1E86,
 0x1E87,
 0x1E88,
 0x1E89,
 0x1E8A,
 0x1E8B,
 0x1E8C,
 0x1E8D,
 0x1E8E,
 0x1E8F,
 0x1E90,
 0x1E91,
 0x1E92,
 0x1E93,
 0x1E94,
 0x1E95,
 0x1E96,
 0x1E97,
 0x1E98,
 0x1E99,
 0x1E9A,
 0x1E9B,
 0x1E9C,
 0x1E9D,
 0x1E9E,
 0x1E9F,
 0x1EA0,
 0x1EA1,
 0x1EA2,
 0x1EA3,
 0x1EA4,
 0x1EA5,
 0x1EA6,
 0x1EA7,
 0x1EA8,
 0x1EA9,
 0x1EAA,
 0x1EAB,
 0x1EAC,
 0x1EAD,
 0x1EAE,
 0x1EAF,
 0x1EB0,
 0x1EB1,
 0x1EB2,
 0x1EB3,
 0x1EB4,
 0x1EB5,
 0x1EB6,
 0x1EB7,
 0x1EB8,
 0x1EB9,
 0x1EBA,
 0x1EBB,
 0x1EBC,
 0x1EBD,
 0x1EBE,
 0x1EBF,
 0x1EC0,
 0x1EC1,
 0x1EC2,
 0x1EC3,
 0x1EC4,
 0x1EC5,
 0x1EC6,
 0x1EC7,
 0x1EC8,
 0x1EC9,
 0x1ECA,
 0x1ECB,
 0x1ECC,
 0x1ECD,
 0x1ECE,
 0x1ECF,
 0x1ED0,
 0x1ED1,
 0x1ED2,
 0x1ED3,
 0x1ED4,
 0x1ED5,
 0x1ED6,
 0x1ED7,
 0x1ED8,
 0x1ED9,
 0x1EDA,
 0x1EDB,
 0x1EDC,
 0x1EDD,
 0x1EDE,
 0x1EDF,
 0x1EE0,
 0x1EE1,
 0x1EE2,
 0x1EE3,
 0x1EE4,
 0x1EE5,
 0x1EE6,
 0x1EE7,
 0x1EE8,
 0x1EE9,
 0x1EEA,
 0x1EEB,
 0x1EEC,
 0x1EED,
 0x1EEE,
 0x1EEF,
 0x1EF0,
 0x1EF1,
 0x1EF2,
 0x1EF3,
 0x1EF4,
 0x1EF5,
 0x1EF6,
 0x1EF7,
 0x1EF8,
 0x1EF9,
 0x1EFA,
 0x1EFB,
 0x1EFC,
 0x1EFD,
 0x1EFE,
 0x1EFF,
 0x2018,
 0x2019,
 0x201A,
 0x201B,
 0x201C,
 0x201D,
 0x201E,
 0x201F,
 0x2C60,
 0x2C61,
 0x2C62,
 0x2C63,
 0x2C64,
 0x2C65,
 0x2C66,
 0x2C67,
 0x2C68,
 0x2C69,
 0x2C6A,
 0x2C6B,
 0x2C6C,
 0x2C6D,
 0x2C6E,
 0x2C6F,
 0x2C70,
 0x2C71,
 0x2C72,
 0x2C73,
 0x2C74,
 0x2C75,
 0x2C76,
 0x2C77,
 0x2C78,
 0x2C79,
 0x2C7A,
 0x2C7B,
 0x2C7C,
 0x2C7D,
 0x2C7E,
 0x2C7F,
 0xA720,
 0xA721,
 0xA722,
 0xA723,
 0xA724,
 0xA725,
 0xA726,
 0xA727,
 0xA728,
 0xA729,
 0xA72A,
 0xA72B,
 0xA72C,
 0xA72D,
 0xA72E,
 0xA72F,
 0xA730,
 0xA731,
 0xA732,
 0xA733,
 0xA734,
 0xA735,
 0xA736,
 0xA737,
 0xA738,
 0xA739,
 0xA73A,
 0xA73B,
 0xA73C,
 0xA73D,
 0xA73E,
 0xA73F,
 0xA740,
 0xA741,
 0xA742,
 0xA743,
 0xA744,
 0xA745,
 0xA746,
 0xA747,
 0xA748,
 0xA749,
 0xA74A,
 0xA74B,
 0xA74C,
 0xA74D,
 0xA74E,
 0xA74F,
 0xA750,
 0xA751,
 0xA752,
 0xA753,
 0xA754,
 0xA755,
 0xA756,
 0xA757,
 0xA758,
 0xA759,
 0xA75A,
 0xA75B,
 0xA75C,
 0xA75D,
 0xA75E,
 0xA75F,
 0xA760,
 0xA761,
 0xA762,
 0xA763,
 0xA764,
 0xA765,
 0xA766,
 0xA767,
 0xA768,
 0xA769,
 0xA76A,
 0xA76B,
 0xA76C,
 0xA76D,
 0xA76E,
 0xA76F,
 0xA770,
 0xA771,
 0xA772,
 0xA773,
 0xA774,
 0xA775,
 0xA776,
 0xA777,
 0xA778,
 0xA779,
 0xA77A,
 0xA77B,
 0xA77C,
 0xA77D,
 0xA77E,
 0xA77F,
 0xA780,
 0xA781,
 0xA782,
 0xA783,
 0xA784,
 0xA785,
 0xA786,
 0xA787,
 0xA788,
 0xA789,
 0xA78A,
 0xA78B,
 0xA78C,
 0xA78D,
 0xA78E,
 0xA78F,
 0xA790,
 0xA791,
 0xA792,
 0xA793,
 0xA794,
 0xA795,
 0xA796,
 0xA797,
 0xA798,
 0xA799,
 0xA79A,
 0xA79B,
 0xA79C,
 0xA79D,
 0xA79E,
 0xA79F,
 0xA7A0,
 0xA7A1,
 0xA7A2,
 0xA7A3,
 0xA7A4,
 0xA7A5,
 0xA7A6,
 0xA7A7,
 0xA7A8,
 0xA7A9,
 0xA7AA,
 0xA7AB,
 0xA7AC,
 0xA7AD,
 0xA7AE,
 0xA7AF,
 0xA7B0,
 0xA7B1,
 0xA7B2,
 0xA7B3,
 0xA7B4,
 0xA7B5,
 0xA7B6,
 0xA7B7,
 0xA7B8,
 0xA7B9,
 0xA7BA,
 0xA7BB,
 0xA7BC,
 0xA7BD,
 0xA7BE,
 0xA7BF,
 0xA7C0,
 0xA7C1,
 0xA7C2,
 0xA7C3,
 0xA7C4,
 0xA7C5,
 0xA7C6,
 0xA7C7,
 0xA7C8,
 0xA7C9,
 0xA7CA,
 0xA7CB,
 0xA7CC,
 0xA7CD,
 0xA7CE,
 0xA7CF,
 0xA7D0,
 0xA7D1,
 0xA7D2,
 0xA7D3,
 0xA7D4,
 0xA7D5,
 0xA7D6,
 0xA7D7,
 0xA7D8,
 0xA7D9,
 0xA7DA,
 0xA7DB,
 0xA7DC,
 0xA7DD,
 0xA7DE,
 0xA7DF,
 0xA7E0,
 0xA7E1,
 0xA7E2,
 0xA7E3,
 0xA7E4,
 0xA7E5,
 0xA7E6,
 0xA7E7,
 0xA7E8,
 0xA7E9,
 0xA7EA,
 0xA7EB,
 0xA7EC,
 0xA7ED,
 0xA7EE,
 0xA7EF,
 0xA7F0,
 0xA7F1,
 0xA7F2,
 0xA7F3,
 0xA7F4,
 0xA7F5,
 0xA7F6,
 0xA7F7,
 0xA7F8,
 0xA7F9,
 0xA7FA,
 0xA7FB,
 0xA7FC,
 0xA7FD,
 0xA7FE,
 0xA7FF,
 0xAB30,
 0xAB31,
 0xAB32,
 0xAB33,
 0xAB34,
 0xAB35,
 0xAB36,
 0xAB37,
 0xAB38,
 0xAB39,
 0xAB3A,
 0xAB3B,
 0xAB3C,
 0xAB3D,
 0xAB3E,
 0xAB3F,
 0xAB40,
 0xAB41,
 0xAB42,
 0xAB43,
 0xAB44,
 0xAB45,
 0xAB46,
 0xAB47,
 0xAB48,
 0xAB49,
 0xAB4A,
 0xAB4B,
 0xAB4C,
 0xAB4D,
 0xAB4E,
 0xAB4F,
 0xAB50,
 0xAB51,
 0xAB52,
 0xAB53,
 0xAB54,
 0xAB55,
 0xAB56,
 0xAB57,
 0xAB58,
 0xAB59,
 0xAB5A,
 0xAB5B,
 0xAB5C,
 0xAB5D,
 0xAB5E,
 0xAB5F,
 0xAB60,
 0xAB61,
 0xAB62,
 0xAB63,
 0xAB64
};


int ggdm21_extra_num = 387;

char *ggdm21_extra[387*2] = {
"AA010","100001",
"AA011","100002",
"AA020","100003",
"AA040","100004",
"AA045","100696",
"AA052","100006",
"AA054","155023",
"AB000","100007",
"AB010","100008",
"AB021","100009",
"AB040","100010",
"AB507","-32687",
"AC010","100012",
"AC020","100013",
"AC030","100014",
"AC040","100015",
"AC060","100016",
"AC507","134665",
"AD010","100018",
"AD020","100019",
"AD025","100020",
"AD030","100021",
"AD041","100022",
"AD050","100023",
"AD055","100697",
"AD060","100687",
"AF010","100025",
"AF020","100026",
"AF021","100027",
"AF030","100028",
"AF040","100029",
"AF050","100030",
"AF060","100031",
"AF070","100032",
"AF080","100033",
"AG030","100034",
"AG040","100035",
"AG050","121638",
"AH025","132596",
"AH055","132626",
"AH060","100038",
"AH070","100039",
"AI020","100040",
"AI021","133168",
"AI030","100041",
"AJ030","100043",
"AJ050","100044",
"AJ051","100045",
"AJ055","100046",
"AJ080","100049",
"AJ085","100691",
"AJ110","100052",
"AK020","100053",
"AK030","100054",
"AK040","100055",
"AK060","100057",
"AK061","100058",
"AK070","100059",
"AK080","100060",
"AK090","100061",
"AK100","100062",
"AK101","100063",
"AK110","100064",
"AK120","100065",
"AK121","100066",
"AK130","100069",
"AK150","100072",
"AK155","100073",
"AK160","154703",
"AK161","121747",
"AK164","100074",
"AK170","100077",
"AK180","100078",
"AL010","100080",
"AL011","100081",
"AL012","100082",
"AL013","100083",
"AL014","100084",
"AL017","100086",
"AL018","100087",
"AL019","100088",
"AL020","100089",
"AL025","100091",
"AL030","100092",
"AL036","100094",
"AL060","100096",
"AL065","100097",
"AL070","100098",
"AL073","100099",
"AL080","100101",
"AL099","100103",
"AL105","100104",
"AL110","100105",
"AL120","100106",
"AL121","100107",
"AL130","100108",
"AL140","100110",
"AL142","100111",
"AL155","100112",
"AL165","100113",
"AL170","100114",
"AL175","100688",
"AL180","100689",
"AL195","100115",
"AL200","100116",
"AL201","100117",
"AL208","100118",
"AL211","130921",
"AL241","100122",
"AL250","100123",
"AL260","100124",
"AL270","100129",
"AL351","100126",
"AL375","100128",
"AL376","132642",
"AL510","100130",
"AM010","100131",
"AM011","100132",
"AM020","100133",
"AM030","100134",
"AM040","100136",
"AM060","100137",
"AM065","100138",
"AM070","100139",
"AM071","100140",
"AM075","100141",
"AM080","100142",
"AN010","100143",
"AN050","100144",
"AN060","100145",
"AN075","100146",
"AN076","100147",
"AN085","100149",
"AP010","100150",
"AP020","100151",
"AP030","100152",
"AP040","100154",
"AP041","100155",
"AP050","100156",
"AQ035","100159",
"AQ040","100161",
"AQ045","100162",
"AQ050","100163",
"AQ055","100164",
"AQ056","100165",
"AQ059","131083",
"AQ060","100167",
"AQ062","100168",
"AQ063","130381",
"AQ065","100170",
"AQ068","100171",
"AQ070","100172",
"AQ075","100173",
"AQ080","100174",
"AQ095","100176",
"AQ110","100177",
"AQ111","100178",
"AQ113","100179",
"AQ114","100180",
"AQ115","100181",
"AQ116","100182",
"AQ118","100183",
"AQ120","100185",
"AQ125","100186",
"AQ130","100187",
"AQ135","100188",
"AQ140","100189",
"AQ141","100190",
"AQ150","100191",
"AQ151","100192",
"AQ160","100194",
"AQ161","100195",
"AQ162","100196",
"AQ170","100197",
"AQ180","100198",
"AT005","100199",
"AT010","100200",
"AT011","100201",
"AT012","100202",
"AT041","100206",
"AT042","100558",
"AT045","100207",
"BA010","100212",
"BA023","100215",
"BA024","100216",
"BA030","100217",
"BA040","100218",
"BA050","100219",
"BB005","100222",
"BB008","-32599",
"BB009","100223",
"BB010","100224",
"BB019","100226",
"BB020","100227",
"BB050","100229",
"BB080","100230",
"BB081","100231",
"BB082","100232",
"BB090","100233",
"BB100","100235",
"BB110","100236",
"BB115","100237",
"BB150","100239",
"BB155","100241",
"BB199","100243",
"BB201","100244",
"BB241","100245",
"BC010","100247",
"BC020","100248",
"BC034","100251",
"BC040","100252",
"BC041","134663",
"BC050","100253",
"BC055","100254",
"BC060","100255",
"BC070","100256",
"BC080","100257",
"BD020","100264",
"BD030","100265",
"BD050","100266",
"BD061","100692",
"BD100","100271",
"BD115","100272",
"BD120","100273",
"BD130","100276",
"BD140","100277",
"BD180","100278",
"BD181","100279",
"BE010","100280",
"BE015","100281",
"BE019","100282",
"BE020","100283",
"BE050","100287",
"BF010","100288",
"BG010","100289",
"BG012","100290",
"BG030","100293",
"BH010","100295",
"BH012","131749",
"BH015","100296",
"BH020","100297",
"BH030","100298",
"BH040","100299",
"BH050","191874",
"BH051","191951",
"BH065","131810",
"BH070","100302",
"BH075","100303",
"BH077","100304",
"BH082","130384",
"BH090","100307",
"BH100","100309",
"BH110","100310",
"BH116","154640",
"BH120","100311",
"BH135","100313",
"BH140","100314",
"BH145","100315",
"BH150","100316",
"BH155","100317",
"BH160","100318",
"BH165","100319",
"BH170","100320",
"BH180","100321",
"BH190","100322",
"BH220","100325",
"BH230","100326",
"BI005","100328",
"BI006","132749",
"BI010","100329",
"BI020","100330",
"BI030","100331",
"BI040","100334",
"BI044","131207",
"BI045","131206",
"BI050","100337",
"BI060","100338",
"BI070","100339",
"BJ020","100340",
"BJ030","100341",
"BJ031","100342",
"BJ040","100343",
"BJ060","100344",
"BJ065","100345",
"BJ070","100346",
"BJ080","100347",
"BJ099","100348",
"BJ100","100349",
"BJ110","100350",
"CA010","100353",
"CA030","100355",
"DA005","100356",
"DA010","100358",
"DB010","100362",
"DB028","154959",
"DB029","154961",
"DB061","100365",
"DB070","100366",
"DB071","192101",
"DB080","100367",
"DB090","100368",
"DB100","100369",
"DB110","100370",
"DB115","100371",
"DB150","100372",
"DB160","100373",
"DB170","100374",
"DB180","100375",
"DB190","100377",
"DB211","100379",
"EA010","100380",
"EA020","100381",
"EA030","100382",
"EA031","100383",
"EA040","100384",
"EA050","100385",
"EA055","100386",
"EB010","100387",
"EB020","100388",
"EB070","100390",
"EC005","100392",
"EC010","100393",
"EC015","130380",
"EC020","100394",
"EC040","100396",
"EC050","100397",
"EC060","100398",
"ED010","100399",
"ED020","100400",
"EE010","100401",
"EE030","100403",
"FA000","100405",
"FA002","100406",
"FA003","100407",
"FA012","100409",
"FA015","100410",
"FA100","100414",
"FA110","100415",
"FA165","100416",
"FA210","100417",
"FC021","100418",
"FC034","106241",
"FC035","100420",
"FC037","100419",
"FC041","100422",
"FC100","100426",
"FC130","100429",
"FC165","100430",
"FC177","100432",
"GA033","171313",
"GB005","100436",
"GB013","133409",
"GB015","100438",
"GB030","100441",
"GB035","100442",
"GB040","100443",
"GB045","100444",
"GB050","100446",
"GB055","100448",
"GB065","100452",
"GB070","100453",
"GB075","100454",
"GB230","100456",
"GB250","100457",
"IA040","100458",
"SA050","100460",
"STB23","-32707",
"STBM1","-32600",
"SU001","100462",
"SU004","170162",
"SU999","-32699",
"ZB020","100464",
"ZB030","100465",
"ZB035","100466",
"ZB036","100467",
"ZB060","100468",
"ZC040","100469",
"ZD020","100473",
"ZD030","100474",
"ZD040","100475",
"ZD045","100476",
"ZD070","164755",
"ZI026","100503",
"ZI027","100504",
"ZI031","121591",
"ZI040","133101",
"ZI041","133102"
};


int ggdm22_extra_num = 405;

char *ggdm22_extra[405*2] = {
"AA010","100001",
"AA011","100002",
"AA020","100003",
"AA040","100004",
"AA045","100696",
"AA052","100006",
"AA054","155023",
"AB000","100007",
"AB010","100008",
"AB021","100009",
"AB040","100010",
"AB507","177962",
"AC010","100012",
"AC020","100013",
"AC030","100014",
"AC040","100015",
"AC060","100016",
"AC507","134665",
"AD010","100018",
"AD020","100019",
"AD025","100020",
"AD030","100021",
"AD041","100022",
"AD050","100023",
"AD055","100697",
"AD060","100687",
"AF010","100025",
"AF020","100026",
"AF030","100028",
"AF040","100029",
"AF050","100030",
"AF060","100031",
"AF070","100032",
"AF080","100033",
"AG030","100034",
"AG040","100035",
"AG050","121638",
"AH025","132596",
"AH055","132626",
"AH060","100038",
"AH070","100039",
"AI020","100040",
"AI021","133168",
"AI030","100041",
"AJ030","100043",
"AJ050","100044",
"AJ051","100045",
"AJ055","100046",
"AJ080","100049",
"AJ085","100691",
"AJ110","100052",
"AK020","100053",
"AK030","100054",
"AK040","100055",
"AK060","100057",
"AK061","100058",
"AK070","100059",
"AK080","100060",
"AK090","100061",
"AK100","100062",
"AK101","100063",
"AK110","100064",
"AK120","100065",
"AK121","100066",
"AK130","100069",
"AK150","100072",
"AK155","100073",
"AK160","154703",
"AK161","121747",
"AK164","100074",
"AK170","100077",
"AK180","100078",
"AL010","100080",
"AL011","100081",
"AL012","100082",
"AL013","100083",
"AL014","100084",
"AL017","100086",
"AL018","100087",
"AL019","100088",
"AL020","100089",
"AL025","100091",
"AL030","100092",
"AL036","100094",
"AL060","100096",
"AL065","100097",
"AL070","100098",
"AL073","100099",
"AL080","100101",
"AL099","100103",
"AL105","100104",
"AL110","100105",
"AL120","100106",
"AL121","100107",
"AL130","100108",
"AL140","100110",
"AL142","100111",
"AL155","100112",
"AL165","100113",
"AL170","100114",
"AL175","100688",
"AL180","100689",
"AL195","100115",
"AL200","100116",
"AL201","100117",
"AL208","100118",
"AL211","130921",
"AL241","100122",
"AL250","100123",
"AL260","100124",
"AL270","100129",
"AL351","100126",
"AL371","180086",
"AL375","100128",
"AL376","132642",
"AL510","100130",
"AM010","100131",
"AM011","100132",
"AM020","100133",
"AM030","100134",
"AM040","100136",
"AM060","100137",
"AM065","100138",
"AM070","100139",
"AM071","100140",
"AM075","100141",
"AM080","100142",
"AN010","100143",
"AN050","100144",
"AN060","100145",
"AN075","100146",
"AN076","100147",
"AN085","100149",
"AP010","100150",
"AP020","100151",
"AP030","100152",
"AP033","179969",
"AP040","100154",
"AP041","100155",
"AP050","100156",
"AP055","179906",
"AP056","180006",
"AQ035","100159",
"AQ040","100161",
"AQ045","100162",
"AQ050","100163",
"AQ055","100164",
"AQ056","100165",
"AQ059","131083",
"AQ060","100167",
"AQ062","100168",
"AQ063","130381",
"AQ065","100170",
"AQ068","100171",
"AQ070","100172",
"AQ075","100173",
"AQ080","100174",
"AQ095","100176",
"AQ110","100177",
"AQ111","100178",
"AQ113","100179",
"AQ114","100180",
"AQ115","100181",
"AQ116","100182",
"AQ118","100183",
"AQ120","100185",
"AQ125","100186",
"AQ130","100187",
"AQ135","100188",
"AQ140","100189",
"AQ141","100190",
"AQ150","100191",
"AQ151","100192",
"AQ160","100194",
"AQ161","100195",
"AQ162","100196",
"AQ170","100197",
"AT005","100199",
"AT010","100200",
"AT011","100201",
"AT012","100202",
"AT041","100206",
"AT042","100558",
"AT045","100207",
"BA010","100212",
"BA023","100215",
"BA024","100216",
"BA030","100217",
"BA040","100218",
"BA050","100219",
"BB005","100222",
"BB008","103",
"BB009","100223",
"BB010","100224",
"BB019","100226",
"BB020","100227",
"BB050","100229",
"BB080","100230",
"BB081","100231",
"BB082","100232",
"BB090","100233",
"BB100","100235",
"BB110","100236",
"BB115","100237",
"BB150","100239",
"BB155","100241",
"BB199","100243",
"BB201","100244",
"BB241","100245",
"BC010","100247",
"BC020","100248",
"BC034","100251",
"BC040","100252",
"BC041","134663",
"BC050","100253",
"BC055","100254",
"BC060","100255",
"BC070","100256",
"BC080","100257",
"BD020","100264",
"BD030","100265",
"BD050","100266",
"BD061","100692",
"BD100","100271",
"BD115","100272",
"BD120","100273",
"BD130","100276",
"BD140","100277",
"BD180","100278",
"BD181","100279",
"BE010","100280",
"BE015","100281",
"BE019","100282",
"BE020","100283",
"BE050","100287",
"BF010","100288",
"BG010","100289",
"BG012","100290",
"BG030","100293",
"BH010","100295",
"BH012","131749",
"BH015","100296",
"BH020","100297",
"BH030","100298",
"BH040","100299",
"BH050","191874",
"BH051","191951",
"BH065","131810",
"BH070","100302",
"BH075","100303",
"BH077","100304",
"BH082","130384",
"BH090","100307",
"BH100","100309",
"BH110","100310",
"BH116","154640",
"BH120","100311",
"BH135","100313",
"BH140","100314",
"BH145","100315",
"BH150","100316",
"BH155","100317",
"BH160","100318",
"BH165","100319",
"BH170","100320",
"BH180","100321",
"BH190","100322",
"BH220","100325",
"BH230","100326",
"BI005","100328",
"BI006","132749",
"BI010","100329",
"BI020","100330",
"BI030","100331",
"BI040","100334",
"BI044","131207",
"BI045","131206",
"BI050","100337",
"BI060","100338",
"BI070","100339",
"BJ020","100340",
"BJ030","100341",
"BJ031","100342",
"BJ040","100343",
"BJ060","100344",
"BJ065","100345",
"BJ070","100346",
"BJ080","100347",
"BJ099","100348",
"BJ100","100349",
"BJ110","100350",
"CA010","100353",
"CA030","100355",
"DA005","100356",
"DA010","100358",
"DB010","100362",
"DB028","154959",
"DB029","154961",
"DB061","100365",
"DB070","100366",
"DB071","192101",
"DB080","100367",
"DB090","100368",
"DB100","100369",
"DB110","100370",
"DB115","100371",
"DB150","100372",
"DB160","100373",
"DB170","100374",
"DB180","100375",
"DB185","100376",
"DB190","100377",
"DB211","100379",
"EA010","100380",
"EA020","100381",
"EA030","100382",
"EA031","100383",
"EA040","100384",
"EA050","100385",
"EA055","100386",
"EB010","100387",
"EB020","100388",
"EB070","100390",
"EC005","100392",
"EC010","100393",
"EC015","130380",
"EC020","100394",
"EC040","100396",
"EC050","100397",
"EC060","100398",
"ED010","100399",
"ED020","100400",
"EE010","100401",
"EE030","100403",
"FA000","100405",
"FA002","100406",
"FA003","100407",
"FA012","100409",
"FA015","100410",
"FA100","100414",
"FA110","100415",
"FA165","100416",
"FA210","100417",
"FC021","100418",
"FC034","106241",
"FC035","100420",
"FC037","100419",
"FC041","100422",
"FC100","100426",
"FC130","100429",
"FC165","100430",
"FC177","100432",
"GA033","171313",
"GB005","100436",
"GB013","133409",
"GB015","100438",
"GB030","100441",
"GB035","100442",
"GB040","100443",
"GB045","100444",
"GB050","100446",
"GB055","100448",
"GB065","100452",
"GB070","100453",
"GB075","100454",
"GB230","100456",
"GB250","100457",
"IA040","100458",
"NM010","200",
"NM020","201",
"NM030","203",
"NM082","204",
"NM140","208",
"NM160","209",
"NM170","205",
"NM230","212",
"NU010","202",
"NU070","210",
"NU113","206",
"NU116","207",
"NU170","211",
"SA050","100460",
"STB23","100",
"STBM1","102",
"SU001","100462",
"SU004","170162",
"SU030","180061",
"T0181","107",
"ZB020","100464",
"ZB030","100465",
"ZB036","100467",
"ZB050","177997",
"ZB060","100468",
"ZC040","100469",
"ZD020","100473",
"ZD030","100474",
"ZD040","100475",
"ZD045","100476",
"ZD070","164755",
"ZI002","100480",
"ZI026","100503",
"ZI027","100504",
"ZI031","121591",
"ZI039","132721",
"ZJ001","132723"
};



int ggdm3_extra_num = 406;

char *ggdm3_extra[406*2] = {
"AA010","100001",
"AA011","100002",
"AA020","100003",
"AA040","100004",
"AA045","100696",
"AA052","100006",
"AA054","155023",
"AB000","100007",
"AB010","100008",
"AB021","100009",
"AB040","100010",
"AB507","177962",
"AC010","100012",
"AC020","100013",
"AC030","100014",
"AC040","100015",
"AC060","100016",
"AC507","134665",
"AD010","100018",
"AD020","100019",
"AD025","100020",
"AD030","100021",
"AD041","100022",
"AD050","100023",
"AD055","100697",
"AD060","100687",
"AF010","100025",
"AF020","100026",
"AF030","100028",
"AF040","100029",
"AF050","100030",
"AF060","100031",
"AF070","100032",
"AF080","100033",
"AG030","100034",
"AG040","100035",
"AG050","121638",
"AH025","132596",
"AH055","132626",
"AH060","100038",
"AH070","100039",
"AI020","100040",
"AI021","133168",
"AI030","100041",
"AJ030","100043",
"AJ050","100044",
"AJ051","100045",
"AJ055","100046",
"AJ080","100049",
"AJ085","100691",
"AJ110","100052",
"AK020","100053",
"AK030","100054",
"AK040","100055",
"AK060","100057",
"AK061","100058",
"AK070","100059",
"AK080","100060",
"AK090","100061",
"AK100","100062",
"AK101","100063",
"AK110","100064",
"AK120","100065",
"AK121","100066",
"AK130","100069",
"AK150","100072",
"AK155","100073",
"AK160","154703",
"AK161","121747",
"AK164","100074",
"AK170","100077",
"AK180","100078",
"AL010","100080",
"AL011","100081",
"AL012","100082",
"AL013","100083",
"AL014","100084",
"AL017","100086",
"AL018","100087",
"AL019","100088",
"AL020","100089",
"AL024","191547",
"AL025","100091",
"AL030","100092",
"AL036","100094",
"AL060","100096",
"AL065","100097",
"AL070","100098",
"AL073","100099",
"AL080","100101",
"AL099","100103",
"AL105","100104",
"AL110","100105",
"AL120","100106",
"AL121","100107",
"AL130","100108",
"AL140","100110",
"AL142","100111",
"AL155","100112",
"AL165","100113",
"AL170","100114",
"AL175","100688",
"AL180","100689",
"AL195","100115",
"AL200","100116",
"AL201","100117",
"AL208","100118",
"AL211","130921",
"AL241","100122",
"AL250","100123",
"AL260","100124",
"AL270","100129",
"AL351","100126",
"AL371","180086",
"AL375","100128",
"AL376","132642",
"AL510","100130",
"AM010","100131",
"AM011","100132",
"AM020","100133",
"AM030","100134",
"AM040","100136",
"AM060","100137",
"AM065","100138",
"AM070","100139",
"AM071","100140",
"AM075","100141",
"AM080","100142",
"AN010","100143",
"AN050","100144",
"AN060","100145",
"AN075","100146",
"AN076","100147",
"AN085","100149",
"AP010","100150",
"AP020","100151",
"AP030","100152",
"AP033","179969",
"AP040","100154",
"AP041","100155",
"AP050","100156",
"AP055","179906",
"AP056","180006",
"AQ035","100159",
"AQ040","100161",
"AQ045","100162",
"AQ050","100163",
"AQ055","100164",
"AQ056","100165",
"AQ059","131083",
"AQ060","100167",
"AQ062","100168",
"AQ063","130381",
"AQ065","100170",
"AQ068","100171",
"AQ070","100172",
"AQ075","100173",
"AQ080","100174",
"AQ095","100176",
"AQ110","100177",
"AQ111","100178",
"AQ113","100179",
"AQ114","100180",
"AQ115","100181",
"AQ116","100182",
"AQ118","100183",
"AQ120","100185",
"AQ125","100186",
"AQ130","100187",
"AQ135","100188",
"AQ140","100189",
"AQ141","100190",
"AQ150","100191",
"AQ151","100192",
"AQ160","100194",
"AQ161","100195",
"AQ162","100196",
"AQ170","100197",
"AT005","100199",
"AT010","100200",
"AT011","100201",
"AT012","100202",
"AT041","100206",
"AT042","100558",
"AT045","100207",
"BA010","100212",
"BA023","100215",
"BA024","100216",
"BA030","100217",
"BA040","100218",
"BA050","100219",
"BB005","100222",
"BB008","103",
"BB009","100223",
"BB010","100224",
"BB019","100226",
"BB020","100227",
"BB050","100229",
"BB080","100230",
"BB081","100231",
"BB082","100232",
"BB090","100233",
"BB100","100235",
"BB110","100236",
"BB115","100237",
"BB150","100239",
"BB155","100241",
"BB199","100243",
"BB201","100244",
"BB241","100245",
"BC010","100247",
"BC020","100248",
"BC034","100251",
"BC040","100252",
"BC041","134663",
"BC050","100253",
"BC055","100254",
"BC060","100255",
"BC070","100256",
"BC080","100257",
"BD020","100264",
"BD030","100265",
"BD050","100266",
"BD061","100692",
"BD100","100271",
"BD115","100272",
"BD120","100273",
"BD130","100276",
"BD140","100277",
"BD180","100278",
"BD181","100279",
"BE010","100280",
"BE015","100281",
"BE019","100282",
"BE020","100283",
"BE050","100287",
"BF010","100288",
"BG010","100289",
"BG012","100290",
"BG030","100293",
"BH010","100295",
"BH012","131749",
"BH015","100296",
"BH020","100297",
"BH030","100298",
"BH040","100299",
"BH050","191874",
"BH051","191951",
"BH065","131810",
"BH070","100302",
"BH075","100303",
"BH077","100304",
"BH082","130384",
"BH090","100307",
"BH100","100309",
"BH110","100310",
"BH116","154640",
"BH120","100311",
"BH135","100313",
"BH140","100314",
"BH145","100315",
"BH150","100316",
"BH155","100317",
"BH160","100318",
"BH165","100319",
"BH170","100320",
"BH180","100321",
"BH190","100322",
"BH220","100325",
"BH230","100326",
"BI005","100328",
"BI006","132749",
"BI010","100329",
"BI020","100330",
"BI030","100331",
"BI040","100334",
"BI044","131207",
"BI045","131206",
"BI050","100337",
"BI060","100338",
"BI070","100339",
"BJ020","100340",
"BJ030","100341",
"BJ031","100342",
"BJ040","100343",
"BJ060","100344",
"BJ065","100345",
"BJ070","100346",
"BJ080","100347",
"BJ099","100348",
"BJ100","100349",
"BJ110","100350",
"CA010","100353",
"CA030","100355",
"DA005","100356",
"DA010","100358",
"DB010","100362",
"DB028","154959",
"DB029","154961",
"DB061","100365",
"DB070","100366",
"DB071","192101",
"DB080","100367",
"DB090","100368",
"DB100","100369",
"DB110","100370",
"DB115","100371",
"DB150","100372",
"DB160","100373",
"DB170","100374",
"DB180","100375",
"DB185","100376",
"DB190","100377",
"DB211","100379",
"EA010","100380",
"EA020","100381",
"EA030","100382",
"EA031","100383",
"EA040","100384",
"EA050","100385",
"EA055","100386",
"EB010","100387",
"EB020","100388",
"EB070","100390",
"EC005","100392",
"EC010","100393",
"EC015","130380",
"EC020","100394",
"EC040","100396",
"EC050","100397",
"EC060","100398",
"ED010","100399",
"ED020","100400",
"EE010","100401",
"EE030","100403",
"FA000","100405",
"FA002","100406",
"FA003","100407",
"FA012","100409",
"FA015","100410",
"FA100","100414",
"FA110","100415",
"FA165","100416",
"FA210","100417",
"FC021","100418",
"FC034","106241",
"FC035","100420",
"FC037","100419",
"FC041","100422",
"FC100","100426",
"FC130","100429",
"FC165","100430",
"FC177","100432",
"GA033","171313",
"GB005","100436",
"GB013","133409",
"GB015","100438",
"GB030","100441",
"GB035","100442",
"GB040","100443",
"GB045","100444",
"GB050","100446",
"GB055","100448",
"GB065","100452",
"GB070","100453",
"GB075","100454",
"GB230","100456",
"GB250","100457",
"IA040","100458",
"NA170","1813853",
"NM010","200",
"NM020","201",
"NM030","203",
"NM082","204",
"NM140","208",
"NM160","209",
"NM170","205",
"NM230","212",
"NU010","202",
"NU070","210",
"NU113","206",
"NU116","207",
"NU170","211",
"SA050","100460",
"STB23","100",
"STBM1","102",
"STDPP","110",
"SU001","100462",
"SU004","170162",
"SU030","180061",
"T0181","107",
"TBCDL","213",
"ZB020","100464",
"ZB030","100465",
"ZB036","100467",
"ZB050","177997",
"ZB060","100468",
"ZC040","100469",
"ZD020","100473",
"ZD030","100474",
"ZD040","100475",
"ZD045","100476",
"ZD070","164755",
"ZI002","100480",
"ZI031","121591",
"ZI039","132721"
};







int FoundNewest, NewestYear, NewestMonth, NewestDay;
int FoundOldest, OldestYear, OldestMonth, OldestDay;

struct SubregionPolyStruct *SubregionPolys;
int NumSubregionPolys;

struct SubregionSourceStruct *SubregionSources;
int NumSubregionSources;

struct SubregionDataStruct *SubregionData;
int NumSubregionData;


int ZONE_IN_USE    =  -999;
int ACEindex       =   -1;
int ALEindex       =  -1;
int ACE_EVALindex  =  -1;
int ALE_EVALindex  =  -1;
int SCPYRTindex    =  -1;
int SRCDATEindex   =  -1;
int SRCTYPEindex   =  -1;
int XMLnum_records =   0;
int     *XML_ACE_EVAL = NULL;
int     *XML_ALE_EVAL = NULL;
int     *XML_SRC_TYPE = NULL;
double  *XML_ACE      = NULL;
double  *XML_ALE      = NULL;
char   **XML_SCPYRT   = NULL;
char   **XML_SRC_DATE = NULL;
int POIINDEX = 0;
int LAST_ACE_INDEX      = -999;
int LAST_ALE2_INDEX     = -999;
int LAST_ALE3_INDEX     = -999;
int LAST_ALE_INDEX      = -999;
int LAST_ACE_EVAL_INDEX = -999;
int LAST_ALE_EVAL_INDEX = -999;
int LAST_SCPYRT_INDEX   = -999;
int LAST_CCPYRT_INDEX   = -999;
int LAST_SRC_INDEX      = -999;
int LAST_COLDNEW_INDEX  = -999;
int DoAce;
int Tim_EOF = 0;
int numsavednames = 0;
int startICESAT;

#define TESTVV 0

int ShapeTestVV=TESTVV;


char *MetaLeftTDS[num_TDS_meta]=
{
 "AHA",
 "AVA",
 "CID",
 "CPS",
 "DQS",
 "EVA",
 "EQC",
 "ETS",
 "ETZ",
 "HZD",
 "HVA",
 "IC2",
 "MDE",
 "MEM",
 "RCG",
 "ZI002_CCN",
 "ZI002_CDR",
 "ZI002_CUI",
 "ZI002_CUX",
 "OTH",
 "URI",
 "VDT"
};

char *MetaLeftMGCP[num_MGCP_meta]=
{
  "ACC",
  "ACE",
  "ACE_EVAL",
  "ALE",
  "ALE_EVAL",
  "CPYRT_NOTE",
  "SRC_DATE",
  "SRC_INFO",
  "SRC_NAME",
  "TIER_NOTE",
  "TXT",
  "UPD_NAME",
  "UPD_DATE",
  "UPD_INFO",
  "ZVAL_TYPE"
};



char *MetaLeft[num_meta]=
{
  "ACE",
  "ACE_EVAL_METHOD_CD",
  "ALE",
  "ALE_EVAL_METHOD_CD",
  "COMMENTS",
  "COMM_CPYRT_NOTICE",
  "COMM_LIC_TIER_NOTICE",
  "CREATION_DATE",
  "COMPLETENESS_CODE",
  "OPERATOR",
  "ORIG_SOURCE_DATE",
  "ORIG_SOURCE_INFO",
  "ORIGINATING_SOURCE",
  "ORIGINATOR",
  "RSTRN_DCLS_XMPT_CD",
  "RSTRN_DECLASS",
  "RSTRN_DSEM_CTRL_IC",
  "RSTRN_DSEM_CTRL_NIC",
  "RSTRN_FOREIGN_GOV",
  "RSTRN_RELEASIBILITY",
  "SCALE",
  "SEC_CD_CNTRL",
  "SEC_CLASS",
  "SEC_CLASS_SYS_ID",
  "SEC_CLS_AUTH_DESC",
  "SEC_CLS_AUTH_MULT",
  "SEC_CLS_AUTHORITY",
  "SPEC_ID",
  "UPDATE_SOURCE",
  "UPDATE_SOURCE_DATE",
  "UPDATE_SOURCE_INFO",
  "Z_VALUE_TYPE"
};






#define FACCDEBUG 0
#define SHAPEDEBUG 0

int verboseout = 0;
unsigned char OverLappingGrids[365][185];
int OneDegreeContent[365][185];
char specialAfilename[1000]; 

extern char timtoupper(char inchar);
extern int DoNFI();

extern int ATTRIBUTION_TYPE;
extern int EAREALNODELIMIT;
extern int ELINEARNODELIMIT;


short int *INNERRINGS=NULL;
int rings_allocced=0;

int num2point = 0;
int num3point = 0;
int num2line = 0;
int num3line = 0;
int num2area = 0;
int num3area = 0;
int UTF8_TYPE=0;
int scale_found[10];


extern int ABORT_EXTRACT;
extern int SLASHTYPE;

int *temp_short    = NULL;
int *temp_long     = NULL;
int *gifd_ids      = NULL;
int sh_nodes_freed = 0;
int global_gifd_id;
double maxgridspace;



double *GL_magnitudes;
int    *GL_instances;
int    *GL_condnums;
char  **GL_IDs        = NULL;
char  **GL_errnums    = NULL;
char  **GL_geoms      = NULL;



extern int CLIPEXTRACT;
extern double CLIPLLX;
extern double CLIPLLY;
extern double CLIPURX;
extern double CLIPURY;


extern int num_grids;
extern int scc_short_items;
extern int scc_long_items;
extern double MINXREAD;
extern double MINYREAD;
extern double MINZREAD;
extern double MINZREAD2;
extern double MAXXREAD;
extern double MAXYREAD;
extern double MAXZREAD;
extern double MAXZREAD2;
extern double MINY_P_READ;
extern double MINX_P_READ;
extern double MAXY_P_READ;
extern double MAXX_P_READ;
extern long int TestNumGridNodes;
extern long int TestNumArealNodes;
extern long int TestNumLinearNodes;
extern long int NumLinearNodes;
extern long int NumPointNodes;
extern long int NumArealNodes;
extern unsigned long int gridpointsread;
extern char codesoutfull    [1000];
extern char codesoutshort   [1000];
extern char codesoutfullbin [1000];
extern char codesoutshortbin[1000];


extern int SH_Points_Done  ;
extern int SH_Linears_Done ;
extern int SH_Areals_Done  ;
extern int SH_Linears_Prev ;
extern int SH_Areals_Prev  ;

extern int NumPointParts   ;
extern int NumLineParts    ;
extern int NumAreaParts    ; 
extern int NumHoles        ;

extern int NumMultiPartPointFeatures;
extern int NumMultiPartLineFeatures ;
extern int NumMultiPartAreaFeatures ;


int sh_bad_codes_found = 0;
int SH_bad_objects     = 0;
int SH_Grids_Prev      = 0;
int SH_BadCoords       = 0;
int SH_Zero_Shapes     = 0;
int SH_Bad_DBF         = 0;

int SH_Null_Shapes ;

unsigned char TIM_STRING    = 9;
unsigned char TIM_INTEGER   = 19;
unsigned char TIM_ENUMERANT = 29;
unsigned char TIM_DOUBLE    = 39;


unsigned char TIM_UNI   = 49;


unsigned char TIM_METRE = 59;
unsigned char TIM_UNITLESS = 69;


extern FILE      *id1bin,        *id2bin,
  *arealbin,     *roadnetbin,    *modelbin,     *sizesbin,
  *headertxt,    *headerbin,     *Gblanktxtout, *badattrtxtout,*badholetxtout,
  *badfcodeout,  *badshapeout,   *badcasetxtout,*nullshptxtout,*badcoordout,
  *badunktxtout, *badGunktxtout, *badfilename,  *nofcode,      *badshapetype,
  *nullattrval,  *mixnull,       *badtypeout,   *badlenout,    *emptyshapes,
  *llmapbin,     *hgt1bin,       *hgt2bin,      *zv1bin,       *zv2bin,
  *area1bin,     *area2bin,      *len1bin,      *len2bin,      *fidmapbin,
  *nullattrcsv,  *nam1bin,      *nam2bin;



extern int SzI, SzD, SzL, SzUC;

extern void update_shape_import(char *allshapes,char *curr_file,int files_done, 
				int dbfdone,int dbftotal,
				int points_done,int linears_done,int areals_done,unsigned long int gptsdone,
				int DONE, int extra_type,int extra1, int extra2, int badstuff,
				int badstuff2, int nullshapes, int zeropart, int baddbf);

extern char *GetFrontPart();
extern char *GetFrontPart2();



struct SH_FIDs
{
  int FID;
  struct SH_FIDs *next;
};

struct SH_BadCodes
{
  int num;
  struct SH_FIDs  *FIDs;
  char *code;
  char *message;
  struct SH_BadCodes *next;
};







struct XY
{
  double *x;
  double *y;
};

struct XY testpoly;
int numtestpolyverts=0;



struct SH_BadAttr
{
  int code;
  int numfound;   
  int firstfound; 
  
  
  char *ENUM;
  char *goodenum;
  struct SH_BadAttr *next;
};


struct SH_BadCodes *Gblankroot   = NULL;
struct SH_BadCodes *Gunkcoderoot = NULL;
struct SH_BadCodes *unkcoderoot  = NULL;
struct SH_BadCodes *badcoderoot  = NULL;
struct SH_BadAttr  *badattrroot  = NULL;
struct SH_BadAttr  *badenumroot  = NULL;
struct SH_BadAttr  *badlenroot   = NULL;
struct SH_BadAttr  *badtyperoot  = NULL;
struct SH_BadAttr  *badcaseroot  = NULL;
struct SH_BadAttr  *badNULLroot  = NULL;
struct SH_BadAttr  *badCoordroot = NULL;


struct SH_BadCodes *nofcoderoot  = NULL;
struct SH_BadCodes *badfnameroot = NULL;



struct SH_SccNode
{
  int scc;
  int numsac;
  int type;  
  struct sh_long_attr_list *sac;
  struct SH_SccNode * prev;
  struct SH_SccNode * next;
};




struct SH_SccNodeSH
{
  int scc;
  int numsac;
  int type;  
  struct sh_short_attr_list *sac;
  struct SH_SccNodeSH * next;
};

struct SH_SccNodeSH * SH_SHORT_LIST;







struct SH_recType{
  int stuff;                
  struct SH_SccNode *node;  
};




typedef struct SH_nodeTag {
  struct SH_nodeTag *left;       
  struct SH_nodeTag *right;      
  struct SH_nodeTag *parent;     
  nodeColor color;            
  char *key;                  
  struct SH_recType rec;         
} SH_nodeType_LIST;


#define SH_NILL &SH_sentinel         
SH_nodeType_LIST SH_sentinel = { SH_NILL, SH_NILL, 0, BLACK, 0};

SH_nodeType_LIST *SH_root = SH_NILL; 

SH_nodeType_LIST ** SH_FULL_PTRS=NULL;
int SH_FULL_ALLOC=0;












void SH_FreeEntry(struct SH_SccNode *current)
{
  int i;
  
  for(i=0;i<current->numsac;i++)
    {
      if(current->sac[i].lod_stuff!=NULL)
	{
	  free(current->sac[i].lod_stuff);
	}

      if(current->sac[i].nam_stuff!=NULL)
	{
	  free(current->sac[i].nam_stuff);
	}
      
      
      if(current->sac[i].geomtype==2)
	{
	  if(current->sac[i].Cvalue!=NULL)
	    {
	      free(current->sac[i].Cvalue);
	    }
	}
    }
  
  if(current->sac!=NULL)
    {
      free(current->sac);
      current->sac = NULL;
    }
  free(current);
}







void SH_RealFreeTree(SH_nodeType_LIST *node)
{  
  
  if(sh_nodes_freed%250==0)
    {
      update_shape_import("","",-1,-1,-1,
			  SH_Points_Done,SH_Linears_Done,SH_Areals_Done,gridpointsread,
			  0,2,sh_nodes_freed,scc_long_items,SH_bad_objects, SH_BadCoords,
			  SH_Null_Shapes,SH_Zero_Shapes,SH_Bad_DBF);
    }
  
  
  if((node->left!=SH_NILL)&&(node->right!=SH_NILL))
    {
      SH_RealFreeTree(node->left);
      SH_RealFreeTree(node->right);
      sh_nodes_freed++;
      free(node->key);
      SH_FreeEntry(node->rec.node);
      free(node);
    } 
  else if(node->left!=SH_NILL)
    {
      SH_RealFreeTree(node->left);
      sh_nodes_freed++;
      free(node->key);
      SH_FreeEntry(node->rec.node);
      free(node);  
    }
  else if(node->right!=SH_NILL)
    {
      SH_RealFreeTree(node->right);
      sh_nodes_freed++;
      free(node->key);
      SH_FreeEntry(node->rec.node);
      free(node);
    }
  else if(node!=SH_NILL)
    {
      sh_nodes_freed++;
      free(node->key);
      SH_FreeEntry(node->rec.node);
      free(node);
    }  
}


void SH_FreeTree()
{
  if(SH_FULL_ALLOC>0)
    {
      SH_FULL_ALLOC = 0;
      free(SH_FULL_PTRS);
    }
  
  SH_RealFreeTree(SH_root);
  SH_root = SH_NILL;
  scc_long_items = 0;
}


void SH_rotateLeft(SH_nodeType_LIST **thisroot, SH_nodeType_LIST *x) 
{
  
  SH_nodeType_LIST *y = x->right;
  
  x->right = y->left;
  if (y->left != SH_NILL) y->left->parent = x;
  
  if (y != SH_NILL) y->parent = x->parent;
  if (x->parent) 
    {
      if (x == x->parent->left)
	x->parent->left = y;
      else
	x->parent->right = y;
    } 
  else 
    {      
      *thisroot = y;
    }
  
  y->left = x;
  if (x != SH_NILL) x->parent = y;
}


void SH_rotateRight(SH_nodeType_LIST **thisroot, SH_nodeType_LIST *x) 
{
  
  SH_nodeType_LIST *y = x->left;
  
  
  x->left = y->right;
  if (y->right != SH_NILL) y->right->parent = x;
  
  if (y != SH_NILL) y->parent = x->parent;
  if (x->parent) 
    {
      if (x == x->parent->right)
	x->parent->right = y;
      else
	x->parent->left = y;
    }
  else 
    {
      *thisroot = y;
    }
  
  y->right = x;
  if (x != SH_NILL) x->parent = y;
}

void SH_insertFixup(SH_nodeType_LIST **thisroot, SH_nodeType_LIST *x) 
{
  
  
  while (x != *thisroot && x->parent->color == RED) 
    {
      
      if (x->parent == x->parent->parent->left) 
	{
	  SH_nodeType_LIST *y = x->parent->parent->right;
	  if (y->color == RED) 
	    {	      
	      
	      x->parent->color = BLACK;
	      y->color = BLACK;
	      x->parent->parent->color = RED;
	      x = x->parent->parent;
            } 
	  else 
	    {
	      
	      if (x == x->parent->right) 
		{
		  
		  x = x->parent;
		  SH_rotateLeft(thisroot, x);
		}                
	      x->parent->color = BLACK;
	      x->parent->parent->color = RED;
	      SH_rotateRight(thisroot, x->parent->parent);
            }
        }
      else 
	{
	  
	  SH_nodeType_LIST *y = x->parent->parent->left;
	  if (y->color == RED) 
	    {
	      
	      x->parent->color = BLACK;
	      y->color = BLACK;
	      x->parent->parent->color = RED;
	      x = x->parent->parent;
	    }
	  else 
	    {
	      
	      if (x == x->parent->left) 
		{
		  x = x->parent;
		  SH_rotateRight(thisroot, x);
		}
	      x->parent->color = BLACK;
	      x->parent->parent->color = RED;
	      SH_rotateLeft(thisroot, x->parent->parent);
            }
        }
    }
  (*thisroot)->color = BLACK;
}


statusEnum SH_insert(SH_nodeType_LIST **thisroot, char *key,int new_index, struct SH_SccNode *datanode) 
{
  SH_nodeType_LIST *current, *parent, *x;
  
  
  
  
  current = *thisroot;
  parent = 0;
  while (current != SH_NILL) 
    {
      if (compEQ(key, current->key)) 
	{
	  printf("found dupe in bad place\n"); exit(-1);
	  return STATUS_DUPLICATE_KEY;
	}
      parent = current;
      current = compLT(key, current->key) ?
	current->left : current->right;
    }
  
  
  if ((x = (SH_nodeType_LIST *)malloc (sizeof(*x))) == 0)
    return STATUS_MEM_EXHAUSTED;
  x->parent = parent;
  x->left = SH_NILL;
  x->right = SH_NILL;
  x->color = RED;
  
  
  x->key  = (char *) (malloc( strlen(key) + 2 )); 
  if(x->key==NULL){printf("r-insert: out of memory!\n"); exit(-1);}
  sprintf(x->key,"%s",key);
  
  x->rec.stuff = new_index;
  x->rec.node  = datanode;
  
  
  if(SH_FULL_ALLOC==0)
    {
      SH_FULL_PTRS = (SH_nodeType_LIST **) malloc(10000*sizeof(SH_nodeType_LIST));      
      if(SH_FULL_PTRS==NULL)
	{
	  printf("unable to malloc primary ptrs\n");
	  exit(-1);
	}
      SH_FULL_ALLOC = 10000;
    }
  else if((new_index+10)>SH_FULL_ALLOC)
    {
      
      SH_FULL_PTRS = (SH_nodeType_LIST **) realloc(SH_FULL_PTRS, (SH_FULL_ALLOC+10000)*sizeof(SH_nodeType_LIST));
      
      if(SH_FULL_PTRS==NULL)
	{
	  printf("unable to re-malloc primary ptrs\n");
	  exit(-1);
	}
      SH_FULL_ALLOC = SH_FULL_ALLOC + 10000;
    }
  
  SH_FULL_PTRS[new_index] = x;
  
  
  
  if(parent) 
    {
      if(compLT(key, parent->key))
	parent->left = x;
      else
	parent->right = x;
    } 
  else 
    {
      *thisroot = x;
    }
  SH_insertFixup(thisroot, x);
  return STATUS_OK;
}


statusEnum SH_find(SH_nodeType_LIST **thisroot, char *key, int *return_index) 
{
  
  SH_nodeType_LIST *current = *thisroot;
  
  
  while(current != SH_NILL) 
    {
      if(compEQ(key, current->key)) 
	{
	  *return_index = current->rec.stuff;
	  return STATUS_KEY_FOUND;
	}
      else
	{	  
	  current = compLT (key, current->key) ?
	    current->left : current->right;
	}
    }
  return STATUS_KEY_NOT_FOUND;
}







void AddBadCoord(int FID)
{
  struct SH_BadAttr *temp;
  int found;
  
  found = 0;
  temp  = badCoordroot;
  
  temp = (struct SH_BadAttr *) malloc(sizeof(struct SH_BadAttr));
  if(temp==NULL){printf("temp6: unable to malloc\n"); exit(-1);}
  temp->code = FID;
  temp->next = badCoordroot;
  temp->ENUM = NULL;
  badCoordroot = temp;
}



int TestGeodetic(double x, double y,int FID,char *shape_to_import)
{
  int xint,yint,xindex,yindex;
  
  if((x<-180.0)||(x>180.0)||(y<-90.0)||(y>90.0))
    {
      printf("%s, FID %d: bad coordinate %.15lf %.15lf found.  ignoring\n",
	     shape_to_import,FID,x,y);
      SH_BadCoords = SH_BadCoords + 1;
      AddBadCoord(FID);
      return 0;
    }

  

  xint = (int)x;
  yint = (int)y;

  if((x==xint)||(y==yint))
  {
	  return 1;
  }

  

  

  if(x<0)
  {
	xindex = (-1*(int)floor(x))+180;
  }
  else
  {
	xindex = xint;
  }

  if(y<0)
  {
	yindex = (-1*(int)floor(y))+90;
  }
  else
  {
	yindex = yint;
  }


  OneDegreeContent[xindex][yindex] = OneDegreeContent[xindex][yindex] + 1;

  return 1;
}



void WriteVertexCounts()
{
  extern FILE *gridspacefile;
  int x,y,total=0;

  for(x=0;x<=180;x++)
  {
     for(y=0;y<=90;y++)
	 {
	   if(OneDegreeContent[x][y]>0)
	   {
		 total = total + 1;
         
	   }
	 }
     for(y=91;y<=180;y++)
	 {
	   if(OneDegreeContent[x][y]>0)
	   {
		 total = total + 1;
		 
	   }
	 }
  }

  for(x=181;x<=360;x++)
  {
     for(y=0;y<=90;y++)
	 {
	   if(OneDegreeContent[x][y]>0)
	   {
		 total = total + 1;
		 
	   }
	 }
     for(y=91;y<=180;y++)
	 {
	   if(OneDegreeContent[x][y]>0)
	   {
		 total = total + 1;
		 
	   }
	 }
  }

 fprintf(gridspacefile,"%d\n",total);

 for(x=0;x<=180;x++)
  {
     for(y=0;y<=90;y++)
	 {
	   if(OneDegreeContent[x][y]>0)
	   {
		  fprintf(gridspacefile,"%d %d %d\n",x,y,OneDegreeContent[x][y]);
		 
	   }
	 }
     for(y=91;y<=180;y++)
	 {
	   if(OneDegreeContent[x][y]>0)
	   {
		  fprintf(gridspacefile,"%d %d %d\n",x,(-1*(y-90)),OneDegreeContent[x][y]);
		 
	   }
	 }
  }

  for(x=181;x<=360;x++)
  {
     for(y=0;y<=90;y++)
	 {
	   if(OneDegreeContent[x][y]>0)
	   {
		  fprintf(gridspacefile,"%d %d %d\n",(-1*(x-180)),y,OneDegreeContent[x][y]);
		 
	   }
	 }
     for(y=91;y<=180;y++)
	 {
	   if(OneDegreeContent[x][y]>0)
	   {
		  fprintf(gridspacefile,"%d %d %d\n",(-1*(x-180)),(-1*(y-90)),OneDegreeContent[x][y]);
		 
	   }
	 }
  }
}



void WriteGridSpaceFile()
{
  extern FILE *gridspacefile;
  fprintf(gridspacefile,"%lf\n",maxgridspace);

  
  WriteVertexCounts();
}



int tooclose(double a, double b)
{
  double smallamount;
  
  
  smallamount = 0.00001;
  
  
  if(fabs(a-b)<smallamount)
    {
      return 1;
    }
  return 0;
}



void sh_write_headers(unsigned char coord)
{
  int num_long_entries=0;
  int num_short_entries=0;
  
  unsigned char a,b,c,d;
  long int TERRAINPOLYSREAD=0;
  extern int USE_LITTLE;
  extern int COORDINATEKEEPER;
  extern void WriteMultiFile();
  extern void WriteVersionFile();
  
  


if((COORDINATEKEEPER!=1)&&(COORDINATEKEEPER!=2))
{
  printf("Error: Bad CK %d\n",COORDINATEKEEPER);
  coord = 1; 
}
else
{
  coord = COORDINATEKEEPER;
}



  WriteMultiFile();
  
  WriteGridSpaceFile();
  
  WriteVersionFile();
  
  num_long_entries  = scc_long_items;
  num_short_entries = scc_short_items;
  
  
  
  
  
  if(
     tooclose(MINXREAD,MAXXREAD)  &&
     tooclose(MINYREAD,MAXYREAD)
     )
    {
      
      MINXREAD = MINXREAD - 0.00001;
      MINYREAD = MINYREAD - 0.00001;
      MAXXREAD = MAXXREAD + 0.00001;
      MAXYREAD = MAXYREAD + 0.00001;
      
      MINX_P_READ  = MINXREAD;
      MINY_P_READ  = MINYREAD;
      MAXX_P_READ  = MAXXREAD;
      MAXY_P_READ  = MAXYREAD;
    }


 

  fprintf(headertxt,"%d %lf %lf %lf %lf %lf %lf %lf %lf %ld %lu %ld %ld %ld %d %d %d\n",
	  coord,
	  MINXREAD,MINYREAD,MAXXREAD,MAXYREAD,
	  MINX_P_READ,MINY_P_READ,MAXX_P_READ,MAXY_P_READ,
	  TERRAINPOLYSREAD,gridpointsread,
	  NumPointNodes,NumLinearNodes,NumArealNodes,
	  num_grids,num_long_entries,num_short_entries);
  
  fwrite(&coord,             SzUC,1,headerbin);
  fwrite(&MINXREAD,          SzD ,1,headerbin);
  fwrite(&MINYREAD,          SzD ,1,headerbin);
  fwrite(&MAXXREAD,          SzD ,1,headerbin);
  fwrite(&MAXYREAD,          SzD ,1,headerbin);
  fwrite(&MINX_P_READ,       SzD ,1,headerbin);
  fwrite(&MINY_P_READ,       SzD ,1,headerbin);
  fwrite(&MAXX_P_READ,       SzD ,1,headerbin);
  fwrite(&MAXY_P_READ,       SzD ,1,headerbin);
  
  fwrite(&TERRAINPOLYSREAD,  SzL ,1,headerbin);
  fwrite(&gridpointsread,    SzL ,1,headerbin);
  fwrite(&NumPointNodes,  SzL ,1,headerbin);
  fwrite(&NumLinearNodes, SzL ,1,headerbin);
  fwrite(&NumArealNodes,  SzL ,1,headerbin);
  fwrite(&num_grids,         SzI ,1,headerbin);
  
  fwrite(&num_long_entries,  SzI ,1,headerbin);
  fwrite(&num_short_entries, SzI ,1,headerbin);
  
  
  if(USE_LITTLE==1)
    {
      a = 0;
    }
  else
    {
      a = 1;
    }  
  
  b = (unsigned char)(SzI);
  c = (unsigned char)(SzD);
  d = (unsigned char)(SzL);
  
  fwrite(&a, SzUC,1,sizesbin);
  fwrite(&b, SzUC,1,sizesbin);
  fwrite(&c, SzUC,1,sizesbin);
  fwrite(&d, SzUC,1,sizesbin);
  
  
  
  printf("writing %d/%d point %d/%d line %d/%d area\n",
	 num2point,num3point,
	 num2line,num3line,
	 num2area,num3area
	 );
  
  fwrite(&num2point, SzI,1,sizesbin);
  fwrite(&num3point, SzI,1,sizesbin);
  fwrite(&num2line,  SzI,1,sizesbin);
  fwrite(&num3line,  SzI,1,sizesbin);
  fwrite(&num2area,  SzI,1,sizesbin);
  fwrite(&num3area,  SzI,1,sizesbin);
  
  
}



void sh_testxyglobalZONLY(double z)
{

  if(z < MINZREAD){MINZREAD = z;}
  if(z > MAXZREAD){MAXZREAD = z;}
  
  if(tempis3D(z))
  {
    if(z < MINZREAD2){MINZREAD2 = z;}
    if(z > MAXZREAD2){MAXZREAD2 = z;}  
  }  
 
}



void sh_testxyglobal(double x,double y,double z)
{
  extern int COORDINATEKEEPER;


  if(COORDINATEKEEPER!=2)
  {
    if((x<-180.0)||(x>180.0)||(y<-90)||(y>90))
	{
      printf("bad %lf %lf\n",x,y);
      return;
    }
  }
  
  if(x < MINXREAD){MINXREAD = x;  MINX_P_READ  = MINXREAD;}
  if(y < MINYREAD){MINYREAD = y;  MINY_P_READ  = MINYREAD;}
  if(z < MINZREAD){MINZREAD = z;}
  
  if(x > MAXXREAD){MAXXREAD = x;  MAXX_P_READ  = MAXXREAD;}
  if(y > MAXYREAD){MAXYREAD = y;  MAXY_P_READ  = MAXYREAD;}
  if(z > MAXZREAD){MAXZREAD = z;}
  

  if(tempis3D(z))
  {
    if(z < MINZREAD2){MINZREAD2 = z;}
    if(z > MAXZREAD2){MAXZREAD2 = z;}  
  }  
 
}







int TestCounterClockwise(int n)
{
  double maxx,maxy,minx,miny,z;
  int i,minxindex=0,maxxindex=0;
  int leftvertex,rightvertex;
  int reset;
  
  maxx = testpoly.x[0];
  maxy = testpoly.y[0];
  minx = testpoly.x[0];
  miny = testpoly.y[0];
  
  for(i=0;i<n;i++)
    {
      if(testpoly.x[i] < minx) { minx = testpoly.x[i]; minxindex = i;}
      if(testpoly.y[i] < miny) { miny = testpoly.y[i]; }
      if(testpoly.x[i] > maxx) { maxx = testpoly.x[i]; maxxindex = i;}
      if(testpoly.y[i] > maxy) { maxy = testpoly.y[i]; }
    }
  
  
  if((testpoly.y[minxindex]!=miny)&&(testpoly.y[minxindex]!=maxy))
    {
      
      
      for(i=minxindex;i<n;i++)
	{
	  
	  if(testpoly.y[i]==maxy) { return 0 ; }
	  if(testpoly.y[i]==miny) { return 1 ; }
	}
      
      for(i=0;i<minxindex;i++)
	{
	  if(testpoly.y[i]==maxy) { return 0 ; }
	  if(testpoly.y[i]==miny) { return 1 ; } 
	}
      
      printf("(1) failed to determine clockwise-ness!\n");
      return 0;  
    }
  
  
  else if((testpoly.y[maxxindex]!=maxy)&&(testpoly.y[maxxindex]!=miny))
    {
      
      
      for(i=maxxindex;i<n;i++)
	{
	  
	  if(testpoly.y[i]==maxy) { return 1 ; }
	  if(testpoly.y[i]==miny) { return 0 ; }
	}
      
      for(i=0;i<maxxindex;i++)
	{
	  if(testpoly.y[i]==maxy) { return 1 ; }
	  if(testpoly.y[i]==miny) { return 0 ; } 
	}
      
      printf("(2) failed to determine clockwise-ness!\n");
      return 0;  
    }
  
  else
    {
      
      
      
      
      
      leftvertex = minxindex;
      reset = 0;
      while(
	    (testpoly.x[leftvertex]==testpoly.x[minxindex]) &&
	    (testpoly.y[leftvertex]==testpoly.y[minxindex])
	    )
	{
	  leftvertex = leftvertex - 1;
	  if(leftvertex<0) 
	    {
	      leftvertex = n-1; 
	      reset=reset+1; 
	      if(reset==2)
		{
		  printf("(1) could not compute cross product\n");
		  return 0; 
		}
	    }
	}
      
      
      rightvertex = minxindex;
      reset = 0;
      while(
	    (testpoly.x[rightvertex]==testpoly.x[minxindex]) &&
	    (testpoly.y[rightvertex]==testpoly.y[minxindex])
	    )
	{
	  rightvertex = rightvertex + 1;
	  if(rightvertex==n) 
	    {
	      rightvertex = 0; 
	      reset=reset+1; 
	      if(reset==2)
		{
		  printf("(2) could not compute cross product\n");
		  return 0;  
		}
	    }
	}
      
      
      
      
      
      z  = 
	(testpoly.x[minxindex]   - testpoly.x[leftvertex]) * 
	(testpoly.y[rightvertex] - testpoly.y[minxindex]);
      
      z = z -
	(testpoly.y[minxindex]   - testpoly.y[leftvertex]) * 
	(testpoly.x[rightvertex] - testpoly.x[minxindex]);
      
      
      if(z<0)
	{
	  
	  return 0;
	}
      else if (z>0)
	{
	  
	  return 1;
	}
      else
	{
	  
	  return 0; 
	}
      
    }
}





int SH_PointInsidePoly(double px,double py,double * x,double * y,int numb)
{
  int numInts, i, j, k, incr;
  double nx, ny;
  
  numInts = 0;
  for(i=0; i<numb; i++)
    {
      j = (i + 1) % numb;
      if((y[i] < py) && (py < y[j]))
	{
	  if((x[i] > px) || (x[j] > px))
            {
	      ny = (y[j] - py) / (y[j] - y[i]);
	      nx = x[j] - ((x[j] - x[i]) * ny);
	      if(nx > px)
		{
		  ++numInts;
		}
            }
	}
      else if((y[j] < py) && (py < y[i]))
	{
	  if((x[i] > px) || (x[j] > px))
            {
	      ny = (y[i] - py) / (y[i] - y[j]);
	      nx = x[i] - ((x[i] - x[j]) * ny);
	      if(nx > px)
		{
		  ++numInts;
		}
            }
	}
      else if((py == y[i]) && (px < x[i]) && (py != y[j]))
	{
	  if(((x[j] <= px) && (x[i] > px)) ||
	     ((x[j] >= px) && (x[i] < px)) ||
	     ((x[j] >= px) && (x[i] > px)))
            {
	      for(incr = 1; incr < numb; incr++)
		{
		  
		  k = (i + numb - incr) % numb;
		  if(y[k] != py)
		    break;
		}
	      if((y[k] < py) && (py < y[j]))
		{
		  ++numInts;
		}
	      else if((y[j] < py) && (py < y[k]))
		{
		  ++numInts;
		}
            }
	}
    }
  j = (numInts % 2);
  return(j);
}



int SH_PointInAreal(double px,double py,double * x,double * y,
		    int startindex, int stopindex, int include_edge)
{
  int IsInside;
  int numb,i,j;
  double mindist;
  extern double PointToLineDist2D(double xj,double yj,double xk,double yk,double xl,double yl);
  
  if(include_edge==0)
  {
    

    j = startindex;
    for(i=startindex+1; i<=stopindex; i++)
	{ 
	  mindist = PointToLineDist2D(px,py,x[j],y[j],x[i],y[i]);
	  if(mindist < 0.00000001)
	  {
	    return 0;
	  }
	  j = j + 1;
	}  
  }


  numb = stopindex - startindex + 1;
  
  IsInside = SH_PointInsidePoly(px,py,&x[startindex], &y[startindex], numb);

  if(IsInside>=1)
  {
    return IsInside;  
  }

  if(IsInside < 1)
  {
    j = startindex;
    for(i=startindex+1; i<=stopindex; i++)
	{ 
	  mindist = PointToLineDist2D(px,py,x[j],y[j],x[i],y[i]);
	  if(mindist < 0.00000001)
	  {
	    return 1;
	  }
	  j = j + 1;
	}  
  }  


  return IsInside;
}



int PartsInside(TimSHPObject * psObject,int hole, int parent)
{
  
  int i;
  int holestartindex,holeendindex;
  int parentstartindex,parentendindex;
  
  
  if(hole==parent)
    {
      return 0;
    }
  
  holestartindex = psObject->panPartStart[hole];
  
  if(hole==(psObject->nParts-1))
    {
      holeendindex = psObject->nVertices-1;
    }
  else
    {
      holeendindex = psObject->panPartStart[hole+1] - 1;
    }
  
  
  
  parentstartindex = psObject->panPartStart[parent];
  
  if(parent==(psObject->nParts-1))
    {
      parentendindex = psObject->nVertices-1;
    }
  else
    {
      parentendindex = psObject->panPartStart[parent+1] - 1;
    }
  
  
  
 


  
  for(i=holestartindex;   i<=holeendindex;  i++)  
    {
      if(
	 SH_PointInAreal(psObject->padfX[i],psObject->padfY[i],
			 psObject->padfX,psObject->padfY,
			 parentstartindex,parentendindex,1)==1
	 )
	  {
	  return 1;
	  }
    }
  
  return 0;
}



char *ParseShapeType(int type)
{
  
  if(type==0)       {return "Null (0)"         ;}
  else if(type==1)  {return "Point (1)"        ;}
  else if(type==3)  {return "PolyLine (3)"     ;}
  else if(type==5)  {return "Polygon (5)"      ;}
  else if(type==8)  {return "MultiPoint (8)"   ;}
  else if(type==11) {return "PointZ (11)"      ;}
  else if(type==13) {return "PolyLineZ (13)"   ;}
  else if(type==15) {return "PolygonZ (15)"    ;}
  else if(type==18) {return "MultiPointZ (18)" ;}
  else if(type==21) {return "PointM (21)"      ;}
  else if(type==23) {return "PolyLineM (23)"   ;}
  else if(type==25) {return "PolygonM (25)"    ;}
  else if(type==28) {return "MultiPointM (28)" ;}
  else if(type==31) {return "MultiPatch (31)"  ;}
  else
    {
      printf("error parsing shape type %d\n",type);
      return "error - see output window";
    }
}


void AddBadShapeType(int type,char *shapename1)
{
  char shapename[1000];

  
  if((ATTRIBUTION_TYPE!=7)&&(ATTRIBUTION_TYPE!=8))
    {
      return;
    }
  
  
  if(strlen(specialAfilename)>0)
    {
      sprintf(shapename,"%s",specialAfilename);
    }
  else
    {
      sprintf(shapename,"%s",shapename1);
    }
  
  
  fprintf(badshapetype,"%s\n    Shape type \"%s\" is not valid for MGCP\n",
	  shapename,ParseShapeType(type));
  
}





void AddBadHole(int record_num, int part_num, char *shapename1, int type)
{
  char shapename[1000];
  
  if(strlen(specialAfilename)>0)
    {
      sprintf(shapename,"%s",specialAfilename);
    }
  else
    {
      sprintf(shapename,"%s",shapename1);
    }
  
  
  if(type==0)
    {
      
      fprintf(badholetxtout,"%s\n    Error:  Found suspected hole in record %d (counterclockwise vertices)\n\
But could not find an object this is a hole of for this record.  (Part %d).\n",
	      shapename,record_num,part_num);
    }
  else if(type==1)
    {
      
      fprintf(badholetxtout,"%s\n    Error:  Found suspected hole in record %d\n\
But could not find an object this is a hole of for this record.  (Hole #%d).\n",
	      shapename,record_num,part_num);
    }
  else if(type==2)
    {
      
      fprintf(badholetxtout,"%s\n    Error:  Found suspected hole in record %d\n\
But could not find an object this is a hole of for this record.\n",
	      shapename,record_num);
    }
  else if(type==3)
    {
      
      fprintf(badholetxtout,"%s\n    Error:  Found suspected hole in record %d\n\
But could not find an object this is a hole of for this record.  (Part #%d).\n",
	      shapename,record_num,part_num);
    }
}











void MakeInnerPtrs(TimSHPObject * psObject, int record_num, char *shapename, int verbose)
{
  int thispart,thispart2;
  int startindex,endindex;
  int i,j,badcount;
  
  if(rings_allocced<psObject->nParts)
    {
      if(rings_allocced>0)
	{
	  free(INNERRINGS);
	}
      
      INNERRINGS = (short int *)malloc(sizeof(short int)*psObject->nParts);
      if(INNERRINGS==NULL)
	{
	  printf("inner rings %d: out of memory!\n",psObject->nParts);
	  exit(-1);
	}
      
      rings_allocced = psObject->nParts;
    }
  
  
  if(psObject->nParts==1)
    {
      INNERRINGS[0] = 1;  
      return;
    }
  
  
  for( thispart = 0; thispart < psObject->nParts; thispart++ )
    {
      INNERRINGS[thispart] = 0;
    }
  
  
  
  
  
  
  
  
  for( thispart = 0; thispart < psObject->nParts; thispart++ )
    {
      startindex = psObject->panPartStart[thispart];
      
      if(thispart==(psObject->nParts-1))
	{
	  endindex = psObject->nVertices-1;
	}
      else
	{
	  endindex = psObject->panPartStart[thispart+1] - 1;
	}
      
      
      
      if(numtestpolyverts<(endindex-startindex+1))
	{
          if(numtestpolyverts>0)
	    {
	      free(testpoly.x);
	      free(testpoly.y);
	    }
	  
	  testpoly.x = (double *)malloc( SzD*(endindex-startindex+1000));
	  testpoly.y = (double *)malloc( SzD*(endindex-startindex+1000));
	  numtestpolyverts = endindex-startindex+1000;
	}
      
      
      for(i=startindex,j=0;   i<=endindex;  i++,j++)  
	{
	  testpoly.x[j] = psObject->padfX[i];
	  testpoly.y[j] = psObject->padfY[i];
	}
      
      if(TestCounterClockwise(endindex-startindex+1)==0)
	{
	  INNERRINGS[thispart] = thispart + 1;
	}
 
    }
  
   
  
  
  
  
  
  for( thispart = 0; thispart < psObject->nParts; thispart++ )
    {
      
      if(INNERRINGS[thispart]==0)
	{
	  
	  
	  for(thispart2 = 0; thispart2 < psObject->nParts; thispart2++ )
	    {
	      if(INNERRINGS[thispart2]>0) 
		{
		  if(PartsInside(psObject,thispart,thispart2))
		    {
		      INNERRINGS[thispart] = (-1) * (thispart2+1);  
		      break;
		    }	  
		}
	    }
	}
    }


  

  
     badcount = 0;

	 for( thispart = 0; thispart < psObject->nParts; thispart++ )
    {
 
      if(INNERRINGS[thispart]==0)
	{		  
	  badcount = badcount + 1;
	  INNERRINGS[thispart] = thispart + 1;  
	  	  
	  if(verbose==1)
	  {
	    AddBadHole(record_num,thispart,shapename,0);
	  }
	}

    }
  
  if((badcount>0)&&(verbose==1))
  {
	  printf("  %d (%d) bad holes found for fid %d (total parts)\n",
		  badcount,psObject->nParts,record_num);
  }

}




void Record_LL_Mapping(int GFID_index,int longindex, int FID)
{
  static int lastindex=-1;
  static int badcount=0;


  

  if((GFID_index<0)&&(longindex<0))
    {
      
      lastindex = -1;
      return;
    }


  if(lastindex<0)
    {
      lastindex = GFID_index;
    }
  else if(GFID_index!=(lastindex+1))
    {
      printf("Record_LL error: got %d and %d FID %d\n",GFID_index,lastindex,FID);
      badcount = badcount + 1;
	  if(badcount>100)
	  {
		  exit(-1);
	  }
    }
  else
    {
      lastindex = GFID_index;
	  
    }
  
  fwrite(&longindex,  SzI,1,llmapbin);
  fwrite(&FID,  SzI,1,fidmapbin);

}


void AddNullShape(int FID, int type, int numverts, int part_num)
{
  struct SH_BadAttr *temp;
  int found;
  
  found = 0;
  temp  = badNULLroot;
  
  temp = (struct SH_BadAttr *) malloc(sizeof(struct SH_BadAttr));
  if(temp==NULL){printf("temp6: unable to malloc\n"); exit(-1);}
  temp->code = FID;
  temp->ENUM = NULL;
  temp->next = badNULLroot;

  if(type==1)
  {
    temp->numfound = -999999;
  }
  else
  {
    temp->numfound = numverts;
	temp->firstfound = part_num;
  }

  badNULLroot = temp;
  
  
  SH_Null_Shapes = SH_Null_Shapes  + 1;
}

void ShapeWriteArealLinear(TimSHPObject	*psSHP,int thispart, int threeD, 
			   int areallinear, 
			   int shortindex, int longindex, int featureid, int writepart)
{
  
  
  
  
  int startindex,endindex,i;
  double zcoord;
  int num_nodes;
  int ishole,do_record=0;
  int GFID_index;
  extern void ReSetArealFile();
  extern void ReSetLinearFile();
  extern FILE *multipartlines;
  extern FILE *multipartareas;
  static int oldfeatureid = -123;


  if(writepart==-999)
  {
	
	oldfeatureid = -123;
	return;
  }


  GFID_index = gifd_ids[featureid];


  if(featureid!=oldfeatureid)
    {
      
      
      oldfeatureid = featureid;
	  do_record = 1;
      
      if(areallinear==1)
	{
	  if(TestNumArealNodes>EAREALNODELIMIT)
	    {
	      
	      ReSetArealFile();
	      TestNumArealNodes = 0;
	      SH_Areals_Prev = SH_Areals_Done;
	    }
	}
      else
	{
	  if(TestNumLinearNodes>ELINEARNODELIMIT)
	    {
	      
	      
	      ReSetLinearFile();
	      TestNumLinearNodes = 0;
	      SH_Linears_Prev = SH_Linears_Done;
	    }
	}
    }
  else
  {
	  do_record = 0;
  }
  
  
  
  
  
  startindex = psSHP->panPartStart[thispart];
  
  if(thispart==(psSHP->nParts-1))
    {
      endindex = psSHP->nVertices-1;
    }
  else
    {
      endindex = psSHP->panPartStart[thispart+1] - 1;
    }
  
  
  if(areallinear==1) 
    {
      ishole = INNERRINGS[thispart];
      
      if(ishole>0) 
	{
	  ishole = 0;
	}
      else if(ishole < 0) 
	{
		  ishole = 1;
	}
      else
	{
	  printf("\n\nserious error: got ishole 0 for %d\n\n",featureid);
	  ishole = 0;
	}
    }
  
  
 
  
  
  if(SHAPEDEBUG==1)
    {
      if(areallinear==0)
	{
	  printf("Linear start index %d end index %d\n",startindex,endindex);
	}
      else
	{
	  printf("Areal start index %d end index %d\n",startindex,endindex);
	}
      
      printf("Vertices of part %d:\n",thispart);
    }
  


  
  if(areallinear==1)  
    {      
      num_nodes = endindex - startindex + 1;

      if(num_nodes<3)
	  {
        if(thispart>0)
		{
          printf("Error: found part %d of area feature with FID %d with only %d vertices\n",
			  thispart,featureid,num_nodes);
		}
		else
		{
          printf("Error: found area feature with FID %d with only %d vertices\n",featureid,num_nodes);
		}

        AddNullShape(featureid,0,num_nodes,thispart);

        if((ishole==0)&&(do_record==1))
		{ 
          Record_LL_Mapping(GFID_index,longindex,featureid);
		} 

	  }
	  else
	  {
        fwrite(&featureid,  SzI,1,arealbin);
        fwrite(&ishole,     SzI,1,arealbin);
        fwrite(&longindex,  SzI,1,arealbin);
        fwrite(&shortindex, SzI,1,arealbin);
        fwrite(&GFID_index, SzI,1,arealbin);
        fwrite(&num_nodes,  SzI,1,arealbin);  

        

        if((ishole==0)&&(do_record==1))
		{ 
          Record_LL_Mapping(GFID_index,longindex,featureid);
		} 
 
	  
        for(i=startindex;i<=endindex;i++)
		{ 
	      if((threeD==1)&&(NoZ_Values==0))
		  { 
	        zcoord = psSHP->padfZ[i];
	        num3area = num3area + 1;
		  } 
	      else 
		  { 
	        zcoord = MY2DSENTINEL;
	        num2area = num2area + 1;
		  } 
	  
	      fwrite(&psSHP->padfX[i],SzD,1,arealbin);
	      fwrite(&psSHP->padfY[i],SzD,1,arealbin);
	      fwrite(&zcoord,SzD,1,arealbin);
	  
	      NumArealNodes++;
	      TestNumArealNodes++;
	  
	      sh_testxyglobal(psSHP->padfX[i],psSHP->padfY[i],zcoord);
		} 


        if(writepart==1)
		{ 
	      fwrite(&featureid,  SzI,1,multipartareas);
	      fwrite(&longindex,  SzI,1,multipartareas);
	      fwrite(&shortindex, SzI,1,multipartareas);
	      fwrite(&GFID_index, SzI,1,multipartareas);
	      fwrite(&num_nodes,  SzI,1,multipartareas);  
	  
	      for(i=startindex;i<=endindex;i++)
		  { 
	        if((threeD==1)&&(NoZ_Values==0)){zcoord = psSHP->padfZ[i];}
	        else {zcoord = MY2DSENTINEL;}
	      
	        fwrite(&psSHP->padfX[i],SzD,1,multipartareas);
	        fwrite(&psSHP->padfY[i],SzD,1,multipartareas);
	        fwrite(&zcoord,SzD,1,multipartareas);
		  } 
		} 
	  } 
  }
  else  
    {
      num_nodes = endindex - startindex + 1;
  

      fwrite(&featureid, SzI,1,roadnetbin);
      fwrite(&longindex, SzI,1,roadnetbin);
      fwrite(&shortindex,SzI,1,roadnetbin);
      fwrite(&GFID_index,SzI,1,roadnetbin);
      fwrite(&num_nodes, SzI,1,roadnetbin);
      
	  if(thispart==0)
	  {
        Record_LL_Mapping(GFID_index,longindex,featureid);
	  }
      
      for(i=startindex;i<=endindex;i++)
	{
	  if((threeD==1)&&(NoZ_Values==0))
	    {
	      zcoord = psSHP->padfZ[i];
	      num3line = num3line + 1;
	    }
	  else 
	    {
	      zcoord = MY2DSENTINEL;
	      num2line = num2line + 1;
	    }
	
	  
	  fwrite(&psSHP->padfX[i],SzD,1,roadnetbin);
	  fwrite(&psSHP->padfY[i],SzD,1,roadnetbin);
	  fwrite(&zcoord,         SzD,1,roadnetbin);
	  
	  NumLinearNodes++;
	  TestNumLinearNodes++;
	  
	  sh_testxyglobal(psSHP->padfX[i],psSHP->padfY[i],zcoord);
	}
      
      
      
      if(writepart==1)
	{
	  fwrite(&featureid, SzI,1,multipartlines);
	  fwrite(&longindex, SzI,1,multipartlines);
	  fwrite(&shortindex,SzI,1,multipartlines);
	  fwrite(&GFID_index,SzI,1,multipartlines);
	  fwrite(&num_nodes, SzI,1,multipartlines);
	  
	  
	  for(i=startindex;i<=endindex;i++)
	    {
	      if((threeD==1)&&(NoZ_Values==0)){zcoord = psSHP->padfZ[i];}
	      else {zcoord = MY2DSENTINEL;}
	      
	      fwrite(&psSHP->padfX[i],SzD,1,multipartlines);
	      fwrite(&psSHP->padfY[i],SzD,1,multipartlines);
	      fwrite(&zcoord,         SzD,1,multipartlines);
	    }
	}
    }
}



void ShapeWritePoint(TimSHPObject *psSHP,int thispoint, int threeD,
		     int shortindex, int longindex, int featureid, int writepartfile)
{
  double zcoord;
  int numverts = -1, do_record = 0;  
  int GFID_index;
  static int oldfeatureid = -123;
  extern FILE *multipartpoints;


  
  


  if(writepartfile==-999)
  {
	
	oldfeatureid = -123;
	return;
  }


  GFID_index = gifd_ids[featureid];

  if(featureid!=oldfeatureid)
  {      
    oldfeatureid = featureid;
    do_record = 1;
  }


  
  
  if(SHAPEDEBUG==1)
    {
      if((threeD==1)&&(NoZ_Values==0))
	{
	  printf("Write out point %lf %lf %lf\n",
		 psSHP->padfX[thispoint],psSHP->padfY[thispoint],psSHP->padfZ[thispoint]);
	}
      else
	{
	  printf("Write out point %lf %lf %lf\n",
		 psSHP->padfX[thispoint],psSHP->padfY[thispoint],MY2DSENTINEL);
	}
    }
  
  
  if((threeD==1)&&(NoZ_Values==0))
    {
      zcoord = psSHP->padfZ[thispoint];
      num3point = num3point + 1;
    }
  else
    {
      zcoord = MY2DSENTINEL;
      num2point = num2point + 1;
    }
  
 
  
  fwrite(&featureid,   SzI,1,modelbin);
  fwrite(&longindex,   SzI,1,modelbin);
  fwrite(&shortindex,  SzI,1,modelbin);      
  fwrite(&GFID_index,  SzI,1,modelbin);

  if(do_record==1)
  {
    Record_LL_Mapping(GFID_index,longindex,featureid);
  }

  fwrite(&numverts,               SzI,1,modelbin);
  fwrite(&psSHP->padfX[thispoint],SzD,1,modelbin);
  fwrite(&psSHP->padfY[thispoint],SzD,1,modelbin);
  fwrite(&zcoord,                 SzD,1,modelbin);
  
  NumPointNodes++;
  
  sh_testxyglobal(psSHP->padfX[thispoint],psSHP->padfY[thispoint],zcoord);

  if(writepartfile==1)
    {
      
      
      fwrite(&featureid,   SzI,1,multipartpoints);
      fwrite(&longindex,   SzI,1,multipartpoints);
      fwrite(&shortindex,  SzI,1,multipartpoints);      
      fwrite(&GFID_index,  SzI,1,multipartpoints);
      
      fwrite(&psSHP->padfX[thispoint],SzD,1,multipartpoints);
      fwrite(&psSHP->padfY[thispoint],SzD,1,multipartpoints);
      fwrite(&zcoord,                 SzD,1,multipartpoints);
    }
  
}




int IsObjid(char possiblecode[])
{  
  char newcode[1000];
  int i;

  sprintf(newcode,"%s",possiblecode);
 
  for(i=0;i<(int)strlen(newcode);i++)
   {
      newcode[i] = toupper(newcode[i]);      
   }

  if(!strcmp(newcode,"OBJID"))	
  {
     return 1;
  }
  if(!strcmp(newcode,"OBJECTID"))	
  {
     return 1;
  }
  if(!strcmp(newcode,"ID"))	
  {
     return 1;
  }

  return 0;
}


int IsHgt(char possiblecode[])
{  
  char newcode[1000];
  int i;

  sprintf(newcode,"%s",possiblecode);
 
  for(i=0;i<(int)strlen(newcode);i++)
   {
      newcode[i] = toupper(newcode[i]);      
   }

  if((ATTRTYPE_D4()))
    {
      if(!strcmp(newcode,"HGT"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_FACC()))
    {
      if(!strcmp(newcode,"HGT"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_VMAP()))
    {
      if(!strcmp(newcode,"HGT"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_MGCP3())||(ATTRTYPE_MGCP4()))
    {
      if(!strcmp(newcode,"HGT"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_UFD2()))
    {
      if(!strcmp(newcode,"HGT"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_UFD1()))
    {
      if(!strcmp(newcode,"HGT"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_UFD3()))
    {
      if(!strcmp(newcode,"HGT"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_ANY_TDS()))
    {
      if(!strcmp(newcode,"HGT"))
	  { 
	    return 1;
	  }
    }
  else if((ATTRTYPE_NFDD()))
    {
      if(!strcmp(newcode,"HGT"))
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_DFDD()))
    {
      if(!strcmp(newcode,"HGT"))
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_SAC()))
    {
      if(!strcmp(newcode,"HGT"))
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_ANY_GGDM()))
    {
      if(!strcmp(newcode,"HGT"))
	{
	  return 1;
	}
    }
  else
    {
      printf("Bad attr type %d to IsHGT\n",ATTRIBUTION_TYPE);
      exit(1);
    }
  
  return 0;
}






int IsLen(char possiblecode[])
{  
  char newcode[1000];
  int i;

  sprintf(newcode,"%s",possiblecode);
 
  for(i=0;i<(int)strlen(newcode);i++)
   {
      newcode[i] = toupper(newcode[i]);      
   }

  if((ATTRTYPE_D4()))
    {
      if(!strcmp(newcode,"LEN_"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_FACC()))
    {
      if(!strcmp(newcode,"LEN"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_VMAP()))
    {
      if(!strcmp(newcode,"LEN"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_MGCP3())||(ATTRTYPE_MGCP4()))
    {
      if(!strcmp(newcode,"LEN"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_UFD2()))
    {
      if(!strcmp(newcode,"LEN"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_UFD1()))
    {
      if(!strcmp(newcode,"LEN"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_UFD3()))
    {
      if(!strcmp(newcode,"LEN"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_ANY_TDS()))
    {
      if(!strcmp(newcode,"LZN"))
	  { 
	    return 1;
	  }
    }
  else if((ATTRTYPE_NFDD()))
    {
      if(!strcmp(newcode,"LZN"))
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_DFDD()))
    {
      if(!strcmp(newcode,"LEN"))
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_SAC()))
    {
      if(!strcmp(newcode,"LEN"))
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_ANY_GGDM()))
    {
      if(!strcmp(newcode,"LZN"))
	{
	  return 1;
	}
    }
  else
    {
      printf("Bad attr type %d to IsLen\n",ATTRIBUTION_TYPE);
      exit(1);
    }
  
  return 0;
}



int IsNam(char possiblecode[])
{  
  char newcode[1000];
  int i;

  sprintf(newcode,"%s",possiblecode);
 
  for(i=0;i<(int)strlen(newcode);i++)
   {
      newcode[i] = toupper(newcode[i]);      
   }

  if((ATTRTYPE_D4()))
    {
      if(!strcmp(newcode,"NAM"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_FACC()))
    {
      if(!strcmp(newcode,"NAM"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_VMAP()))
    {
      if(!strcmp(newcode,"NAM"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_MGCP3())||(ATTRTYPE_MGCP4()))
    {
      if(!strcmp(newcode,"NAM"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_UFD2()))
    {
      if(!strcmp(newcode,"NAM"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_UFD1()))
    {
      if(!strcmp(newcode,"NAM"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_UFD3()))
    {
      if(!strcmp(newcode,"NAM"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_ANY_TDS()))
    {
      if(!strcmp(newcode,"ZI005_FNA"))
	  { 
	    return 1;
	  }
    }
  else if((ATTRTYPE_NFDD()))
    {
	  return 0;
    }
  else if((ATTRTYPE_DFDD()))
    {
      if(!strcmp(newcode,"NAM"))
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_SAC()))
    {
	  return 0;
    }
  else if((ATTRTYPE_ANY_GGDM()))
    {
      if(!strcmp(newcode,"ZI005_FNA"))
	{
	  return 1;
	}
    }
  else
    {
      printf("Bad attr type %d to IsNam\n",ATTRIBUTION_TYPE);
      exit(1);
    }
  
  return 0;
}




















int IsZv2(char possiblecode[])
{  
  char newcode[1000];
  int i;
  
  sprintf(newcode,"%s",possiblecode);
  
  for(i=0;i<(int)strlen(newcode);i++)
    {
      newcode[i] = toupper(newcode[i]);      
    }
  
  if((ATTRTYPE_D4()))
    {
      if(!strcmp(newcode,"ZV2"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_FACC()))
    {
      if(!strcmp(newcode,"ZV2"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_VMAP()))
    {
      if(!strcmp(newcode,"ZV2"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_MGCP3())||(ATTRTYPE_MGCP4()))
    {
      return 0;
    }
  else if((ATTRTYPE_UFD2()))
    {
      if(!strcmp(newcode,"ZV2"))
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_UFD1()))
    {
      if(!strcmp(newcode,"ZV2"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_UFD3()))
    {
      if(!strcmp(newcode,"ZV2"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_ANY_TDS()))
    {
      if(!strcmp(newcode,"ZVH"))
	  { 
	   return 1;
	  }
    }
  else if((ATTRTYPE_NFDD()))
    {
      if(!strcmp(newcode,"ZVH"))
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_DFDD()))
    {
      if(!strcmp(newcode,"ZVH"))
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_SAC()))
    {
      if(!strcmp(newcode,"ZV7"))
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_ANY_GGDM()))
    {
      if(!strcmp(newcode,"ZVH"))
	{
	  return 1;
	}
    }
  else
    {
      printf("Bad attr type %d to IsZv2\n",ATTRIBUTION_TYPE);
      exit(1);
    }
  
  return 0;
}



int IsArea(char possiblecode[])
{  
  char newcode[1000];
  int i;
  
  sprintf(newcode,"%s",possiblecode);
  
  for(i=0;i<(int)strlen(newcode);i++)
    {
      newcode[i] = toupper(newcode[i]);      
    }
  
  if((ATTRTYPE_D4()))
    {
      if(!strcmp(newcode,"ARE_"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_FACC()))
    {
      if(!strcmp(newcode,"ARE"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_VMAP()))
    {
      if(!strcmp(newcode,"ARA"))	
	{
	  return 1;
	}
    }
  else if(ATTRTYPE_MGCP3())
    {
      if(!strcmp(newcode,"ARA"))	
	{
	  return 1;
	}
    }
  else if(ATTRTYPE_MGCP4())
    {
	  return 0;
    }
  else if((ATTRTYPE_UFD2()))
    {
      return 0;
    }
  else if((ATTRTYPE_UFD1()))
    {
      return 0;
    }
  else if((ATTRTYPE_UFD3()))
    {
      return 0;
    }
  else if((ATTRTYPE_ANY_TDS()))
    {
      if(!strcmp(newcode,"ARA"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_NFDD()))
    {
      if(!strcmp(newcode,"ARA"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_DFDD()))
    {
      if(!strcmp(newcode,"ARA"))	
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_SAC()))
    {
      if(!strcmp(newcode,"ARA"))
	{
	  return 1;
	}
    }
  else if((ATTRTYPE_ANY_GGDM()))
    {
      if(!strcmp(newcode,"ARA"))	
	{
	  return 1;
	}
    }
  else
    {
      printf("Bad attr type %d to IsArea\n",ATTRIBUTION_TYPE);
      exit(1);
    }
  
  return 0;
}




int IsGFID(char possiblecode[])
{
  
  char newcode[1000];
  int i;
  
  if(HAS_ID[ATTRIBUTION_TYPE]==0) 
  {
    return 0;
  }

  sprintf(newcode,"%s",possiblecode);
  
  

  for(i=0;i<(int)strlen(newcode);i++)
    {
      newcode[i] = toupper(newcode[i]);      
    }
  
  if((ATTRTYPE_D4()))
    {
      if(!strcmp(newcode,"GFID"))
	  {
	   return 1;
	  }
    }
  else if((ATTRTYPE_FACC()))
    {
      if(!strcmp(newcode,"FLDBID"))
	  {
	   return 1;
	  }
    }
  else if((ATTRTYPE_VMAP()))
    {
      return 0;
    }
  else if((ATTRTYPE_MGCP3())||(ATTRTYPE_MGCP4()))
    {
      if(!strcmp(newcode,"UID"))
	  {
	   return 1;
	  }
    }
  else if((ATTRTYPE_UFD2()))
    {
      if(!strcmp(newcode,"GFID"))
	  {
	   return 1;
	  }
    }
  else if((ATTRTYPE_UFD1()))
    {
      if(!strcmp(newcode,"GFID"))
	  {
	   return 1;
	  }
    }
  else if((ATTRTYPE_UFD3()))
    {
      if(!strcmp(newcode,"GFID"))
	  {
	   return 1;
	  }
    }
  else if((ATTRTYPE_ANY_TDS()))
    {
      if(!strcmp(newcode,"UFI"))
	  {
	   return 1;
	  }
    }
  else if((ATTRTYPE_NFDD()))
    {
      if(!strcmp(newcode,"UFI"))
	  {
	   return 1;
	  }
    }
  else if((ATTRTYPE_DFDD()))
    {
      if(!strcmp(newcode,"UID"))
	  {
	   return 1;
	  }
    }
  else if((ATTRTYPE_SAC()))
    {
      if(!strcmp(newcode,"UUID_1"))
	  {
	   return 1;
	  }
    }
  else if((ATTRTYPE_ANY_GGDM()))
    {
      if(!strcmp(newcode,"UFI"))
	  {
	   return 1;
	  }
    }
  else
    {
      printf("Bad attr type %d to IsGF\n",ATTRIBUTION_TYPE);
      exit(1);
    }
  
  return 0;
}



int PossibleOBJECTID(char possiblecode[])
{
  
  char newcode[1000];
  int i;
  
  sprintf(newcode,"%s",possiblecode);
  
  
  for(i=0;i<(int)strlen(newcode);i++)
    {
      newcode[i] = toupper(newcode[i]);      
    }
  
  if(!strcmp(newcode,"OBJECTID"))
    {
      return 1;
    }
  return 0;
}




int LongCode(char possiblecode[])
{
  
  if(!strcmp(possiblecode,"OBJECTID"))	
    {
      return 1;
    }
  
  if(IsGFID(possiblecode)==1)
    {
      return 1;
    }
  
  if(IsArea(possiblecode)==1)
    {
      return 1;
    }
  
  if(IsHgt(possiblecode)==1)
    {
      return 1;
    }

  if(IsLen(possiblecode)==1)
    {
      return 1;
    }

  if(IsNam(possiblecode)==1)
    {
      return 1;
    }

  if(IsZv2(possiblecode)==1)
    {
      return 1;
    }


  return 0;
}



int PossibleFCODE(char possiblecode[])
{
  
  char newcode[1000];
  int i;
  
  sprintf(newcode,"%s",possiblecode);
  
  
  for(i=0;i<(int)strlen(newcode);i++)
    {
      newcode[i] = toupper(newcode[i]);      
    }
  
  

  if(!strcmp(newcode,"F_CODE"))
    {
      return 1;
    }
  if(!strcmp(newcode,"FCODE"))
    {
      return 1;
    }
  if(!strcmp(newcode,"FEATURE_AT"))
    {
      return 1;
    }
  if(!strcmp(newcode,"FEATURE"))
    {
      return 1;
    }
  if(!strcmp(newcode,"FEATURE_NA"))
    {
      return 1;
    }
  if(!strcmp(newcode,"FACC"))
    {
      return 1;
    }
  if(!strcmp(newcode,"FACC_CODE"))
    {
      return 1;
    }

  
  return 0;
}




int ConvertAttrCode(char *oldcode)
{
  int i;
  extern char **gifd_attr_codes;
  extern int GIFD_ATTR_NUM;
  extern int IGNORE_ATTR_NUM;
  extern char **IGNORE_ATTR;
  extern int REPLACE_ATTR_NUM;
  extern char **REPLACE_LHS;
  extern char **REPLACE_RHS;
  extern int METATYPE;
  int metafound;
  char oldcodetest[1000];
  
  extern int num_user_meta;
  extern int *MetaUserValue;
  extern char **MetaUser;
  extern int MetaMappingPossible(int attr_type_in);


  char *MetaESRI[num_meta]=
  {
    "ACE",
    "ACE_EVAL_M",
    "ALE",
    "ALE_EVAL_M",
    "COMMENTS",
    "COMM_CPYRT",
    "COMM_LIC_T",
    "CREATION_D",
    "COMPLETENE",
    "OPERATOR",
    "ORIG_SOURC",
    "ORIG_SOU_1",
    "ORIGINATIN",
    "ORIGINATOR",
    "RSTRN_DCLS",
    "RSTRN_DECL",
    "RSTRN_DSEM",
    "RSTRN_DS_1",
    "RSTRN_FORE",
    "RSTRN_RELE",
    "SCALE",
    "SEC_CD_CNT",
    "SEC_CLASS",
    "SEC_CLASS_",
    "SEC_CLS_AU",
    "SEC_CLS__1",
    "SEC_CLS__2",
    "SPEC_ID",
    "UPDATE_SOU",
    "UPDATE_S_1",
    "UPDATE_S_2",
    "Z_VALUE_TY"
  };
  
  char *MetaINGR[num_meta]=
  {
    "ACE",
    "ACE_EVAL_M",
    "ALE",
    "ALE_EVAL_M",
    "COMMENTS",
    "COMM_CPYRT",
    "COMM_LIC_T",
    "CREATION_D",
    "COMPLETENE",
    "OPERATOR",
    "ORIG_SOURC",
    "ORIG_SOUR1",
    "ORIGINATIN",
    "ORIGINATOR",
    "RSTRN_DCLS",
    "RSTRN_DECL",
    "RSTRN_DSEM",
    "RSTRN_DSE1",
    "RSTRN_FORE",
    "RSTRN_RELE",
    "SCALE",
    "SEC_CD_CNT",
    "SEC_CLASS",
    "SEC_CLASS_",
    "SEC_CLS_AU",
    "SEC_CLS_A1",
    "SEC_CLS_A2",
    "SPEC_ID",
    "UPDATE_SOU",
    "UPDATE_SO1",
    "UPDATE_SO2",
    "Z_VALUE_TY"
  };
  
  
  
  char *MetaNGA[num_meta]=
  {
    "ACE",
    "ACE_EVAL",
    "ALE",
    "ALE_EVAL",
    "COMMENTS",
    "CPYRT_NOTE",
    "TIER_NOTE",
    "CREAT_DATE",
    "COMPLETENE",
    "OPERATOR",
    "SRC_DATE",
    "SRC_INFO",
    "SRC_NAME",
    "ORIG_AGNCY",
    "RSTRN_DCLS",
    "RSTRN_DECL",
    "RSTRN_IC",
    "RSTRN_DSEM",
    "RSTRN_FORE",
    "RSTRN_RELE",
    "SCALE_FAC",
    "SEC_CD_CNT",
    "SEC_CLASS",
    "SEC_S_ID",
    "SEC_AUTH_D",
    "SEC_AUTH_M",
    "SEC_AUTH",
    "SPEC_ID",
    "UPD_NAME",
    "UPD_DATE",
    "UPD_INFO",
    "ZVAL_TYPE"
  };
  




  


  




  

  



  sprintf(oldcodetest,"%s",oldcode);

  
  for(i=0;i<(int)strlen(oldcodetest);i++)
    {
      oldcodetest[i] = toupper(oldcodetest[i]);      
    }



  if((ATTRTYPE_MGCP3())||(ATTRTYPE_MGCP4()))
    {
      if(!strcmp(oldcodetest,"GEOM"))
	{
	  return -100;
	}
    }


  if(IGNORE_ATTR_NUM>0)
  {
    for(i=0;i<IGNORE_ATTR_NUM;i++)
	{
      printf("attr to ignore: %s\n",IGNORE_ATTR[i]);
	  if(!strcmp(oldcodetest,IGNORE_ATTR[i]))
	  {
        printf("found this one\n");
		return -100;
	  }
	}
  }


  if(REPLACE_ATTR_NUM>0)
  {
    for(i=0;i<REPLACE_ATTR_NUM;i++)
	{
      if(!strcmp(oldcodetest,REPLACE_LHS[i]))
	  {
        printf("replacing %s with %s\n",oldcodetest,REPLACE_RHS[i]);
		sprintf(oldcodetest,"%s",REPLACE_RHS[i]);
	  }
	}
  }


  if(
     (ATTRIBUTION_TYPE!=7) &&
     (ATTRIBUTION_TYPE!=8) &&
     (ATTRIBUTION_TYPE!=15) &&
     (ATTRIBUTION_TYPE!=16) &&
     (ATTRIBUTION_TYPE!=17) &&
     (ATTRIBUTION_TYPE!=18) &&  
     (ATTRIBUTION_TYPE!=19) &&
     (ATTRIBUTION_TYPE!=20) &&
     (ATTRIBUTION_TYPE!=21) &&
     (ATTRIBUTION_TYPE!=22) &&
     (ATTRIBUTION_TYPE!=23) &&
     (ATTRIBUTION_TYPE!=24) &&
     (ATTRIBUTION_TYPE!=25) &&
     (ATTRIBUTION_TYPE!=26) &&
     (ATTRIBUTION_TYPE!=27) &&
     (ATTRIBUTION_TYPE!=28) &&
     (ATTRIBUTION_TYPE!=29) &&
     (ATTRIBUTION_TYPE!=30) &&
     (ATTRIBUTION_TYPE!=31) &&
     (ATTRIBUTION_TYPE!=32) &&
     (ATTRIBUTION_TYPE!=33) &&
     (ATTRIBUTION_TYPE!=34) &&
     (ATTRIBUTION_TYPE!=35) &&
     (ATTRIBUTION_TYPE!=36) &&
     (ATTRIBUTION_TYPE!=37) &&
     (ATTRIBUTION_TYPE!=38)
     )
    {

      if(METATYPE==5)
	{
	  metafound = 0;
	  for(i=0;i<num_user_meta;i++)
	    {	  
	      if(!strcmp(MetaUser[i],oldcodetest))
		{
		  return MetaUserValue[i];
		}
	    }
	}
      else
	{  
	  
	  
	  metafound = 0;
	  for(i=0;i<num_meta;i++)
	    {
          if(MetaMappingPossible(ATTRIBUTION_TYPE)==0)
		  {  
            
		  } 
	      else if((METATYPE==0)||(METATYPE==1))
		{
		  if(!strcmp(MetaNGA[i],oldcodetest))
		    {
		      sprintf(oldcodetest,"%s",MetaLeft[i]);
		      metafound = 1;
		    }
		}	  
	      else if(METATYPE==2)
		{
		  if(!strcmp(MetaESRI[i],oldcodetest))
		    {
		      sprintf(oldcodetest,"%s",MetaLeft[i]);
		      metafound = 1;
		    }
		}
	      else if(METATYPE==3)
		{
		  if(!strcmp(MetaINGR[i],oldcodetest))
		    {
		      sprintf(oldcodetest,"%s",MetaLeft[i]);
		      metafound = 1;
		    }
		}
		  else
		  {
			  printf("bad metatype %d\n",METATYPE);
		  }
	      
	      	      
	      if(metafound==1)
		{
		  for(i=0;i<GIFD_ATTR_NUM;i++)
		    {
		      if(!strcmp(gifd_attr_codes[i],oldcodetest))
			{
			  return i;
			}
		    }
		}
	    }
	}
      
      if((metafound==1)&&(ATTRIBUTION_TYPE!=8))
	{
	  printf("metadata problem on %s MT %d AT %d\n",oldcodetest,METATYPE,ATTRIBUTION_TYPE);
	  return -100;
	}
    }
  
  
  
  
 
  
  
  for(i=0;i<GIFD_ATTR_NUM;i++)
    {
      
      
      if(!strcmp(gifd_attr_codes[i],oldcodetest))
	{
	  return i;
	}
    }
  
  return -100;
}



void MakeGunkTxt()
{
  
  
	 
  struct SH_BadCodes  * current, *next;
  int maxlen1,maxlen2,space1,total;
  extern int getspace(int total);
  extern char *MakePlural(int num);

  

  current = Gunkcoderoot;
  while(current!=NULL)
    {
      fprintf(badGunktxtout,"   \"%s\"\n",
	      current->code);
      
      next = current->next;
      free(current->code);
      free(current);
      current = next;
    }
  Gunkcoderoot = NULL;
  


  

  maxlen1 = 0;
  maxlen2 = 0;
  total   = 0;
  current = Gblankroot;
  while(current!=NULL)
  {
	  if((int)strlen(current->code)>maxlen1)
	  {
		  maxlen1 = strlen(current->code);
	  }
	  if(current->num>maxlen2)
	  {
		  maxlen2 = current->num;
	  }
	  total = total + current->num;
      current = current->next;
  }

  space1 = getspace(maxlen2);

  if(total==0)
  {
	  if(Gblankroot!=NULL)
	  {
		  printf("error: got total 0 but non-null GBR\n");
		  Gblankroot = NULL;
	  }
	  return;
  }

  
  current = Gblankroot;
  while(current!=NULL)
    {
      fprintf(Gblanktxtout,"Attribute: %*s has %*d total blank value%s\n",
	      maxlen1,current->code,space1,current->num,MakePlural(current->num));
      
      next = current->next;
      free(current->code);
      free(current);
      current = next;
    }
  Gblankroot = NULL;
  


}



void AddNoFCODE(char *filename1)
{
  struct SH_BadCodes *temp;
  char filename[1000];
  
  if((ATTRIBUTION_TYPE!=7)&&(ATTRIBUTION_TYPE!=8))
  {
	
	return;
  }

  if(strlen(specialAfilename)>0)
   {
     sprintf(filename,"%s",specialAfilename);
   }
   else
   {
	 sprintf(filename,"%s",filename1);
   }


    

  temp = (struct SH_BadCodes *) malloc(sizeof(struct SH_BadCodes));
  if(temp==NULL){printf("temp8: unable to malloc\n"); exit(-1);}
  
  temp->code = (char *) malloc(strlen(filename)+5);
  if(temp->code==NULL){printf("temp9: unable to malloc\n"); exit(-1);}
  sprintf(temp->code,"%s",filename);
  
  temp->message = NULL;
  temp->FIDs    = NULL;      
  temp->next    = nofcoderoot;

  nofcoderoot = temp;
}



void AddBadFilename(char *filename1)
{
  struct SH_BadCodes *temp;
  char filename[1000];

   if(strlen(specialAfilename)>0)
   {
     sprintf(filename,"%s",specialAfilename);
   }
   else
   {
	 sprintf(filename,"%s",filename1);
   }



  

  temp = (struct SH_BadCodes *) malloc(sizeof(struct SH_BadCodes));
  if(temp==NULL){printf("temp8: unable to malloc\n"); exit(-1);}
  
  temp->code = (char *) malloc(strlen(filename)+5);
  if(temp->code==NULL){printf("temp9: unable to malloc\n"); exit(-1);}
  sprintf(temp->code,"%s",filename);
  
  temp->message      = NULL;
  temp->FIDs         = NULL;      
  temp->next         = badfnameroot;
  badfnameroot       = temp;
}






void AddUnkAttr(char *badcode)
{
  
  
  
  struct SH_BadCodes *temp,*prev, *temp2;
  
  
  if(ATTRTYPE_SAC())
  {
	if( (!strcmp(badcode,"SS_ID")) || (!strcmp(badcode,"LAT")) || (!strcmp(badcode,"LONG")) )
	{
	  
	  return;
	}
  }



  
  
  temp  = unkcoderoot;
  
  while(temp!=NULL)
    {
      if(!strcmp(temp->code,badcode))
	{
	  return; 
	}
      temp = temp->next;
    }
  
  
  temp = (struct SH_BadCodes *) malloc(sizeof(struct SH_BadCodes));
  if(temp==NULL){printf("temp8: unable to malloc\n"); exit(-1);}
  
  temp->code = (char *) malloc(strlen(badcode)+5);
  if(temp->code==NULL){printf("temp9: unable to malloc\n"); exit(-1);}
  sprintf(temp->code,"%s",badcode);
  
  temp->message = NULL;
  temp->FIDs    = NULL;      
  temp->next    = NULL;

  if(unkcoderoot==NULL)
    {
      unkcoderoot = temp;
    }
  else
    {
      temp2 = unkcoderoot;
      while(temp2->next!=NULL)
	{
	  temp2 = temp2->next;
	}
      temp2->next = temp;      
    }



  
  

  temp  = Gunkcoderoot;
  
  while(temp!=NULL)
    {
      if(!strcmp(temp->code,badcode))
	{
	  return; 
	}
      temp = temp->next;
    }
 

  

  temp = Gunkcoderoot;
  prev = NULL;
  
  while(temp!=NULL)
    {    
#if(USE_DOS==1)
      {
        if(_stricmp(temp->code,badcode)>=0) 
	  {
	    break;
	  }
      }
#else
      {
        if(strcasecmp(temp->code,badcode)>=0) 
	  {
	    break;
	  }
      }
#endif
      prev = temp;
      temp = temp->next;
    }
  
  
  temp = (struct SH_BadCodes *) malloc(sizeof(struct SH_BadCodes));
  if(temp==NULL){printf("temp8: unable to malloc\n"); exit(-1);}
  
  temp->code = (char *) malloc(strlen(badcode)+5);
  if(temp->code==NULL){printf("temp9: unable to malloc\n"); exit(-1);}
  sprintf(temp->code,"%s",badcode);
  
  temp->message = NULL;
  temp->FIDs    = NULL;      

  if(prev==NULL)
    {
      

      if(Gunkcoderoot==NULL)
	{
	  temp->next = NULL;
	}
      else
	{
	  temp->next = Gunkcoderoot;
	}
      Gunkcoderoot = temp;
    }
  else
    {
      temp->next    = prev->next;
      prev->next    = temp;
    }


  if(Gunkcoderoot==NULL)
    {
      Gunkcoderoot = temp;
    }
}



void AddBadClass(char *badcode, char *expectedcode, int FID)
{
  
  
  
  struct SH_BadCodes *temp;
  struct SH_FIDs *newtemp;
  
  int found;
  int foundit=0;


  found = 0;
  temp  = badcoderoot;

  while(temp!=NULL)
    {
      if(!strcmp(temp->code,badcode))
	{
	  found = 1;
	  
	  
	  
	  
	  newtemp = temp->FIDs;
	  foundit = 0;
	  while(newtemp!=NULL)
	    {
	      if(newtemp->FID == FID)
		{
		  foundit = 1;
		  break;
		}
	      newtemp=newtemp->next;
	    }



	  if((foundit==0)||(FID==-999))  
	    {
	      temp->num = temp->num + 1;
	      
	      
	      newtemp       = (struct SH_FIDs *) malloc (sizeof(struct SH_FIDs));
	      newtemp->FID  = FID;
	      newtemp->next = temp->FIDs;
	      temp->FIDs = newtemp;
	    }
	  break;
	}
      temp = temp->next;
    }
  
   
  
  if(found==0)
    {
      
      temp = (struct SH_BadCodes *) malloc(sizeof(struct SH_BadCodes));
      if(temp==NULL){printf("temp8: unable to malloc\n"); exit(-1);}
      
      temp->code = (char *) malloc(strlen(badcode)+5);
      if(temp->code==NULL){printf("temp9: unable to malloc\n"); exit(-1);}
      sprintf(temp->code,"%s",badcode);
      
      
      temp->message = (char *) malloc(500);
      if(temp->message==NULL){printf("temp9: unable to malloc\n"); exit(-1);}
      
      
      temp->num = 1;
      
      
      temp->FIDs = (struct SH_FIDs *) malloc (sizeof(struct SH_FIDs));
      temp->FIDs->FID = FID;
      temp->FIDs->next = NULL;
      
      
      
      temp->next = badcoderoot;
      badcoderoot = temp;
      
      if(!strcmp(expectedcode,"*****"))
	 {

	  if(verboseout==1)
	    {
	      printf("   Error:  Bad FCODE %s in data\n",badcode);
	    }
	  
	  if(
	     (!strcmp(badcode,"BB040")) ||
	     (!strcmp(badcode,"BH095")) 
	     )
	    {
	      sprintf(temp->message,"   Bad FCODE %s in data.  Using assumed FCODE %s instead.",badcode,expectedcode);
	    }
	  else if(strlen(badcode)==0)
	    {
	      sprintf(temp->message,"   NULL FCODE found in data:");
	    }
	  else if(!strcmp(badcode,"NO FCODE FOUNDzzzSentinel"))
	    {
	      sprintf(temp->message,"   No FCODE found for some data:");
	    }
	  else
	    {
	      sprintf(temp->message,"   Bad FCODE %s in data:",badcode);
	    }
	  
	  if(verboseout==1)
	    {
	      printf("%s\n",temp->message);
	    }
	}
      else
	{

	  if(verboseout==1)
	    {
	      printf("   Error:  Bad FCODE %s in data (expected %s)",badcode,expectedcode);
	    }
	  if(
	     (!strcmp(badcode,"BB040")) ||
	     (!strcmp(badcode,"BH095")) 
	     )
	    {
	      sprintf(temp->message,"   Bad FCODE %s in data.  Using assumed FCODE %s instead",badcode,expectedcode);
	    }
	  else if(!strncmp(badcode,"F_CODE/FCSubType",16))
	  { 
	    sprintf(temp->message,"   Bad %s in data (expected %s)",badcode,expectedcode);
	  }
	  else
	  {
	    sprintf(temp->message,"   Bad FCODE %s in data (expected %s)",badcode,expectedcode);
	  }
	}
    }
}





int ConvertClassCode(char *oldcode, int FID)
{
  int i;
  extern int GIFD_CLASS_NUM;
  extern char **gifd_class_codes;
  
  
  for(i=0;i<GIFD_CLASS_NUM;i++)
    {
      if(!strcmp(oldcode,gifd_class_codes[i]))
	{
	  return i;
	}
 
    }
  
  
  AddBadClass(oldcode,"*****",FID);
  return -100;
}





void AddBadType(int badattr, char *expect_type, char *got_type)
{
  
  
  
  struct SH_BadAttr *temp;
  int i,j,found,num_enum,thisindex,len;
  extern char **gifd_enum_codes;
  extern char **gifd_attr_codes;
  extern int *gifd_attr_enum_count;
  extern int *gifd_attr_enum_start;


  found = 0;
  temp  = badtyperoot;
  
  if(
	  ((ATTRTYPE_SAC())) &&
      ((gifd_attr_enum_count[badattr]>0)&&(!strcmp(expect_type,"Short Integer")))
	)
  {
    
	  if(!strcmp(got_type,"String"))
	  {
	    return;
	  }
  }

  if((gifd_attr_enum_count[badattr]>0)&&(!strcmp(expect_type,"Short Integer")))
  {
    

    num_enum = gifd_attr_enum_count[badattr];
  
   

   for(i=0;i<num_enum;i++)
   {
      thisindex = gifd_attr_enum_start[badattr]+i;

	  len = strlen(gifd_enum_codes[thisindex]);
	  for(j=0;j<len;j++)
	  {
        if(
			(gifd_enum_codes[thisindex][j]<48) ||
			(gifd_enum_codes[thisindex][j]>57)
		  )
		{
          
          if((gifd_enum_codes[thisindex][j]=='-')&&(j==0)&&(len>1))
		  {
			if(gifd_enum_codes[thisindex][1]!='0')
			{
              
              continue;
			}
		  }
		  
		  return;
		}
	  }
    }
  }

  



  while(temp!=NULL)
    {
      if(temp->code==badattr)
	{
	  if(!strcmp(expect_type,temp->ENUM))
	    {
	      if(!strcmp(got_type,temp->goodenum))
		{	      
		  found = 1;
		}
	    }
	}
      temp = temp->next;
    }
  
  
  
  if(found==0)
    {
      temp = (struct SH_BadAttr *) malloc(sizeof(struct SH_BadAttr));
      if(temp==NULL){printf("temp1: unable to malloc\n"); exit(-1);}
      temp->code = badattr;
      
      temp->ENUM = (char *) malloc(strlen(expect_type)+5);
      if(temp->ENUM==NULL){printf("temp2: unable to malloc\n"); exit(-1);}
      sprintf(temp->ENUM,"%s",expect_type);
      
      temp->goodenum = (char *) malloc(strlen(got_type)+5);
      if(temp->goodenum==NULL){printf("temp2: unable to malloc\n"); exit(-1);}
      sprintf(temp->goodenum,"%s",got_type);
      
      temp->next = badtyperoot;
      badtyperoot = temp;
      

      if(verboseout==1)
	{
	  printf("   Error:  For attribute %s, expected type %s, got type %s\n",
		 gifd_attr_codes[badattr],expect_type,got_type);
	}
    }
  
}





void AddBadLen(int badattr, char *expect_len, char *got_len)
{    
  struct SH_BadAttr *temp;
  
  temp = (struct SH_BadAttr *) malloc(sizeof(struct SH_BadAttr));
  if(temp==NULL){printf("temp1: unable to malloc\n"); exit(-1);}
  temp->code = badattr;
  
  temp->ENUM = (char *) malloc(strlen(expect_len)+5);
  if(temp->ENUM==NULL){printf("temp2: unable to malloc\n"); exit(-1);}
  sprintf(temp->ENUM,"%s",expect_len);
  
  temp->goodenum = (char *) malloc(strlen(got_len)+5);
  if(temp->goodenum==NULL){printf("temp2: unable to malloc\n"); exit(-1);}
  sprintf(temp->goodenum,"%s",got_len);
  
  temp->next = badlenroot;
  badlenroot = temp;
    
}





void AddBadEnumType(int badattr, char *filename, char *ENUM, char *goodenum)
{
  
  
  
  struct SH_BadAttr *temp;
  int found;
  extern char **gifd_attr_codes;
  
  found = 0;
  temp  = badenumroot;
  
  while(temp!=NULL)
    {
      if(temp->code==badattr)
	{
	  if(!strcmp(ENUM,temp->ENUM))
	    {
	      if(!strcmp(goodenum,temp->goodenum))
		{	      
		  found = 1;
		}
	    }
	}
      temp = temp->next;
    }
  
  
  if(found==0)
    {
      temp = (struct SH_BadAttr *) malloc(sizeof(struct SH_BadAttr));
      if(temp==NULL){printf("temp3: unable to malloc\n"); exit(-1);}
      temp->code = badattr;
      
      temp->ENUM = (char *) malloc(strlen(ENUM)+5);
      if(temp->ENUM==NULL){printf("temp4: unable to malloc\n"); exit(-1);}
      sprintf(temp->ENUM,"%s",ENUM);
      
      temp->goodenum = (char *) malloc(strlen(goodenum)+5);
      if(temp->goodenum==NULL){printf("temp5: unable to malloc\n"); exit(-1);}
      sprintf(temp->goodenum,"%s",goodenum);
      
      temp->next = badenumroot;
      badenumroot = temp;
      
      
      printf("   Error:  Manipulation of string necessary to map to GIFD:\n\
attribute %s string value %s should be int value %s\n",
	     gifd_attr_codes[badattr],ENUM,goodenum);
    }
  
}



void AddBadCase(int badattr, char *ENUM, int record_num, int type)
{  
  
  
  static struct SH_BadAttr *casetail;
  struct SH_BadAttr *temp;
  int found;
  extern char **gifd_attr_codes;
 

  found = 0;
  temp  = badcaseroot;
  
  
  
  if(type==1)
    {
      while(temp!=NULL)
	{
	  if(temp->code==badattr)
	    {
	      if(!strcmp(ENUM,temp->ENUM))
		{
		  found = 1;
		  break;
		}
	    }
	  temp = temp->next;
	}
    }

  
  if((found==0)||(type==2))
    {
      
      
      temp = (struct SH_BadAttr *) malloc(sizeof(struct SH_BadAttr));

      if(temp==NULL){printf("temp6: unable to malloc\n"); exit(-1);}
      temp->code = badattr;
      if(type==2)
	{
	  temp->numfound = -1;
	}
      else
	{
	  temp->numfound = 1;
	}
      temp->firstfound = record_num;
      temp->ENUM = (char *) malloc(strlen(ENUM)+5);
      if(temp->ENUM==NULL){printf("temp7: unable to malloc\n"); exit(-1);}
      sprintf(temp->ENUM,"%s",ENUM);

      if(type==1)
	{
	  
	  temp->next = badcaseroot;
	  if(badcaseroot==NULL)
	    {
	      casetail    = temp;
	    }
	  badcaseroot = temp;
	}
      else
	{
	  
	  if(badcaseroot==NULL)
	    {
	      temp->next  = NULL;
	      badcaseroot = temp;
	      casetail    = temp;
	    }
	  else
	    {
	      casetail->next = temp;
	      temp->next = NULL;
	      casetail = temp;
	    }
	}

      
      if(verboseout==1)
	{
	  printf("   %d  Bad attr/enum pair attr:%s  enum:%s\n",record_num,gifd_attr_codes[badattr],ENUM);
	}
    }
  else
    {
      temp->numfound = temp->numfound+1;
    }
}



void AddBadAttr(int badattr, char *ENUM, int record_num)
{
  
  
  
  struct SH_BadAttr *temp;
  int found;
  extern char **gifd_attr_codes;
  
  found = 0;
  temp  = badattrroot;
  
  while(temp!=NULL)
    {
      if(temp->code==badattr)
	{
	  if(!strcmp(ENUM,temp->ENUM))
	    {
	      found = 1;
	      break;
	    }
	}
      temp = temp->next;
    }
  
  
  if(found==0)
    {
      temp = (struct SH_BadAttr *) malloc(sizeof(struct SH_BadAttr));
      if(temp==NULL){printf("temp6: unable to malloc\n"); exit(-1);}
      temp->code = badattr;
      temp->numfound = 1;
      temp->firstfound = record_num;
      temp->ENUM = (char *) malloc(strlen(ENUM)+5);
      if(temp->ENUM==NULL){printf("temp7: unable to malloc\n"); exit(-1);}
      sprintf(temp->ENUM,"%s",ENUM);
      temp->next = badattrroot;
      badattrroot = temp;
      
      
      if(verboseout==1)
	{
	  printf("   %d  Bad attr/enum pair attr:%s  enum:%s\n",record_num,gifd_attr_codes[badattr],ENUM);
	}
    }
  else
    {
      temp->numfound = temp->numfound+1;
    }
}







int GetNewEnum(int attr_code,char *oldenum, int report_if_bad, int record_num)
{
  int num_enum,i,ii,thisindex,insertindex,len,thisint;
  char caseinsen[1000],testcaseinsen1[1000],testcaseinsen2[1000],tester[100];
  extern char **gifd_enum_codes;
  extern char **gifd_enum_names;
  extern char **gifd_attr_codes;
  extern int *gifd_attr_enum_count;
  extern int *gifd_attr_enum_start;
  
  
  
  
  
  
  if(oldenum[0]=='\0')
    {
      
      return -100;
    }
  
  
  num_enum = gifd_attr_enum_count[attr_code];
  
  for(i=0;i<num_enum;i++)
    {
      thisindex = gifd_attr_enum_start[attr_code]+i;
      
      if(
	 (!strcmp(oldenum,gifd_enum_codes[thisindex])) ||  
	 (!strcmp(oldenum,gifd_enum_names[thisindex]))     
	 )
	{
	  return i;
	}
      
    }
  
  


  if((ATTRTYPE_SAC()))
  {

	if(!strcmp(gifd_attr_codes[attr_code],"CLASS"))
	{
	  

      tester[0] = '\0';

	  if(!strcmp(oldenum,"U"))
	  {
		sprintf(tester,"U (UNCLASS)");
	  }
	  else if(!strcmp(oldenum,"S"))
	  {
		sprintf(tester,"S (SECRET)");
	  }

	  if(strlen(tester)>5)
	  {
        for(i=0;i<num_enum;i++)
		{  
          thisindex = gifd_attr_enum_start[attr_code]+i;
      
          if(!strcmp(tester,gifd_enum_names[thisindex]))
		  { 
	        return i;
		  }  
		}  
	  } 
	}


    

	
    len = strlen(oldenum);
	insertindex = 0;




	for(i=strlen(gifd_attr_codes[attr_code]);i<len;i++)
	{
      if(oldenum[i]=='_')
	  {
        tester[insertindex] = '\0';
		insertindex = -1;
		break;
	  }
	  if(insertindex>4)
	  {
        break;
	  }
      if((oldenum[i]>='0')&&(oldenum[i]<='9'))
	  {
        tester[insertindex] = oldenum[i];
		insertindex = insertindex + 1;
	  }
	  else
	  {
        break;
	  }
	}


	if(insertindex==-1)
	{
      
      
	  sscanf(tester,"%d",&thisint);
	  sprintf(tester,"%d",thisint);
      
	}
	else
	{
      tester[insertindex] = '\0';
       
	}


	if(insertindex==-1)
	{
      for(i=0;i<num_enum;i++)
	  { 
        thisindex = gifd_attr_enum_start[attr_code]+i;
      
        if(!strcmp(tester,gifd_enum_codes[thisindex]))
		{ 
	      return i;
		}  
	  } 
	} 
  }






  
  
  
  sprintf(caseinsen,"%s",oldenum);
  for(i=0;i<(int)strlen(caseinsen);i++)
    {
      caseinsen[i] = timtoupper(caseinsen[i]);
    }
  
  num_enum = gifd_attr_enum_count[attr_code];
  
  for(i=0;i<num_enum;i++)
    {
      thisindex = gifd_attr_enum_start[attr_code]+i;
      
      
      sprintf(testcaseinsen1,"%s",gifd_enum_codes[thisindex]);
      for(ii=0;ii<(int)strlen(testcaseinsen1);ii++)
	{
	  testcaseinsen1[ii] = timtoupper(testcaseinsen1[ii]);
	}
      
      sprintf(testcaseinsen2,"%s",gifd_enum_names[thisindex]);
      for(ii=0;ii<(int)strlen(testcaseinsen2);ii++)
	{
	  testcaseinsen2[ii] = timtoupper(testcaseinsen2[ii]);
	}
      
      
      
      
      if(
	 (!strcmp(caseinsen,testcaseinsen1)) || 
	 (!strcmp(caseinsen,testcaseinsen2))    
	 )
	{	  
	  AddBadCase(attr_code,oldenum,record_num,1);
	  
	  return i;	  
	}
    }
  
  
  
  if(report_if_bad)
    {
      AddBadAttr(attr_code, oldenum, record_num);
    }
  
  
  return -100;
}









int SH_DupeAttribute(struct sh_long_attr_list SAC_LONG[],int addindex)
{
  int i;
  
  for(i=0;i<addindex;i++)
    {
      if(SAC_LONG[i].attr_code != SAC_LONG[addindex].attr_code) 
	{continue;}
      if (SAC_LONG[i].unit_code != SAC_LONG[addindex].unit_code)  
	{continue;}     
      if (SAC_LONG[i].geomtype != SAC_LONG[addindex].geomtype)  
	{continue;}     
      
      if (SAC_LONG[i].geomtype==0)
	{
	  if (SAC_LONG[i].Dvalue != SAC_LONG[addindex].Dvalue)   
	    {continue;}
	  
	}  
      else if (SAC_LONG[i].geomtype==1)
	{            
	  if (SAC_LONG[i].Dvalue != SAC_LONG[addindex].Dvalue)   
	    {continue;}              
	}
      else if (SAC_LONG[i].geomtype==2)
	{
	  if((SAC_LONG[i].Cvalue!=NULL)&&(SAC_LONG[addindex].Cvalue!=NULL))
	    {
	      if (strcmp(SAC_LONG[i].Cvalue,SAC_LONG[addindex].Cvalue)) 
		{continue;}
	    }
	  else if((SAC_LONG[i].Cvalue==NULL)&&(SAC_LONG[addindex].Cvalue!=NULL))
	    {
	      continue;
	    }
	  else if((SAC_LONG[i].Cvalue!=NULL)&&(SAC_LONG[addindex].Cvalue==NULL))
	    {
	      continue;
	    }
	}
      else if (SAC_LONG[i].geomtype==3)
	{            
	  if (SAC_LONG[i].Dvalue != SAC_LONG[addindex].Dvalue)   
	    {continue;}              
	  
	}
      else
	{
	  printf("shdupe: bad val %d\n",SAC_LONG[i].geomtype);
	}

      return 1;  
    }
  
  return 0; 
}







void SH_AddShortAttribute(struct sh_short_attr_list SAC_SHORT[],int addindex,int attr_code)
{
  
  attr_code = attr_code + 1;
  
  SAC_SHORT[addindex].attr_code    = attr_code;  
  SAC_SHORT[addindex].lod_stuff    = NULL;
  SAC_SHORT[addindex].nam_stuff    = NULL;
}


int Around3276(double dval)
{
  if((dval>=32760)&&(dval<=32769))
  {
    return 1;
  }

  if((dval>=-32769)&&(dval<=-32760))
  {
    return 1;
  }

  return 0;
}


int SH_AddLongAttribute(
			struct sh_long_attr_list SAC_LONG[],int addindex,int attr_code, 
			unsigned char unit_code, unsigned char scale_code, unsigned char SEDRIStype, 
			int Ivalue, double Dvalue, char Cvalue[])
{
  extern int TruncImport,GIFD_ATTR_NUM;
  extern char **gifd_attr_codes;

  attr_code = attr_code + 1;


  SAC_LONG[addindex].attr_code  = attr_code;
  SAC_LONG[addindex].unit_code  = unit_code;
  SAC_LONG[addindex].scale_code = scale_code;
  SAC_LONG[addindex].SEDRIStype = SEDRIStype;
  SAC_LONG[addindex].Cvalue = NULL;
  
  
  if(SEDRIStype==TIM_INTEGER)
    {
      SAC_LONG[addindex].geomtype = 0;  
    }
  else if(SEDRIStype==TIM_DOUBLE)
    {
      SAC_LONG[addindex].geomtype = 1;  

	  if((attr_code>=1)&&(attr_code<=GIFD_ATTR_NUM))  
	  {

	    if(
			(!strcmp(gifd_attr_codes[attr_code-1],"LEN")) ||
            (!strcmp(gifd_attr_codes[attr_code-1],"LEN_"))
		  )
		{
          if( (ATTRTYPE_ANY_MGCP()) || (ATTRTYPE_SAC()) || (ATTRTYPE_VMAP()) )
		  {
            
		  }
		  else
		  {
			

	        if((TruncImport==1)&&(Around3276(Dvalue)==0))
			{
              Dvalue = TruncateToNdigits(Dvalue,1);
			}
	        else if((TruncImport==2)&&(Around3276(Dvalue)==0))
			{
              Dvalue = (int)Dvalue;
			}
		  }
		}
	    if(!strcmp(gifd_attr_codes[attr_code-1],"LZN"))
		{
	      if((TruncImport==1)&&(Around3276(Dvalue)==0))
		  {
            Dvalue = TruncateToNdigits(Dvalue,1);
		  }
	      else if((TruncImport==2)&&(Around3276(Dvalue)==0))
		  {
            Dvalue = (int)Dvalue;
		  }
		}
	    else if(!strcmp(gifd_attr_codes[attr_code-1],"AOO"))
		{
		  if(
			  (Dvalue<0.0) ||
			  (  (ATTRTYPE_VMAP()) && (Dvalue>359.0) )  ||
			  (  (ATTRTYPE_MGCP4()) && ( (Dvalue>179.9) && (Dvalue<180.0) ) ) ||
			  (Dvalue>360.0)
			)
		  {
            
		  }
		  else
		  {
	        if((TruncImport==1)&&(Around3276(Dvalue)==0))
			{
              Dvalue = TruncateToNdigits(Dvalue,1);
			}
	        else if((TruncImport==2)&&(Around3276(Dvalue)==0))
			{
              Dvalue = (int)Dvalue;
			}
		  }
		}
	  }
    }
  else if(SEDRIStype==TIM_STRING)
    {
      SAC_LONG[addindex].geomtype = 2;  
    }
  else if(SEDRIStype==TIM_ENUMERANT)
    {
      SAC_LONG[addindex].geomtype = 3;  
    }
  else
    {
      printf("sh_add_long:  unknown type %d\n",SEDRIStype);
    }
  
  
  if(
     (SAC_LONG[addindex].geomtype==0) ||   
     (SAC_LONG[addindex].geomtype==3)    
     )
    {
      SAC_LONG[addindex].Dvalue = (double)Ivalue;
    }
  else if(SAC_LONG[addindex].geomtype==1) 
    {
      SAC_LONG[addindex].Dvalue = Dvalue;
    }
  else if(SAC_LONG[addindex].geomtype==2) 
    {
      if(Cvalue[0]!='\0')
	{
	  SAC_LONG[addindex].Cvalue =  (char *) malloc(strlen(Cvalue)+2);
	}
      else
	{
	  SAC_LONG[addindex].Cvalue =  (char *) malloc(2);
	}


  if(SAC_LONG[addindex].Cvalue==NULL)
	{printf("AddLong: out of memory!\n"); exit(-1);}
      
      sprintf(SAC_LONG[addindex].Cvalue,"%s",Cvalue);
    }

  return !SH_DupeAttribute(SAC_LONG,addindex);
}




char * SH_BuildString(int type, int scc, int numsac, struct sh_long_attr_list SAC_LONG[])
{
  static char temp [10000];
  char temp2[5000];
  int i;


  sprintf(temp,"%d %d %d ",type,scc,numsac);


  for(i=0;i<numsac;i++)
    {
      
      if(SAC_LONG[i].attr_code==-1)
	{
	  sprintf(temp2,"%d %d %s \n",
		  SAC_LONG[i].attr_code,
		  (int)strlen(SAC_LONG[i].lod_stuff),
		  SAC_LONG[i].lod_stuff);
	  
	  strcat(temp,temp2);
	}
      else if(SAC_LONG[i].attr_code==-2)
	{
	  sprintf(temp2,"%d %d %s \n",
		  SAC_LONG[i].attr_code,
		  (int)strlen(SAC_LONG[i].nam_stuff),
		  SAC_LONG[i].nam_stuff);
	  
	  strcat(temp,temp2);
	}
      else
	{	  
	  sprintf(temp2,"%d %d %d %d %d ",SAC_LONG[i].attr_code,
		  (int)SAC_LONG[i].unit_code,
		  (int)SAC_LONG[i].scale_code,
		  (int)SAC_LONG[i].SEDRIStype,
		  (int)SAC_LONG[i].geomtype);
	  
	  strcat(temp,temp2);
	  
	  
	  if(SAC_LONG[i].geomtype==0)
	    {
	      sprintf(temp2,"%d ",(int)SAC_LONG[i].Dvalue);
	      
	      strcat (temp ,temp2);
	    }
	  else if(SAC_LONG[i].geomtype==1)
	    {
	      sprintf(temp2,"%.8lf ",SAC_LONG[i].Dvalue);
	      strcat (temp ,temp2);
	    }
	  else if(SAC_LONG[i].geomtype==2)
	    {
	      sprintf(temp2,"%s ",SAC_LONG[i].Cvalue);
	      strcat (temp ,temp2);
	    }
	  else if(SAC_LONG[i].geomtype==3)
	    {
	      sprintf(temp2,"%d ",(int)SAC_LONG[i].Dvalue);
	      
	      strcat (temp ,temp2);
	    }
	  else if(SAC_LONG[i].geomtype==4)
	    {
	      sprintf(temp2,"%d ",(int)SAC_LONG[i].Dvalue);
	      
	      strcat (temp ,temp2);
	    }
	  else
	    {
	      printf("bad geom type in buildstring %d\n",SAC_LONG[i].geomtype);
	    }
	}
    }
  return (char *)temp;
}




void TestUppercase(int geomtype,int class_code,int attr_code,char *Cvalue, int record_num)
{
  int i,len,badval=0;
  char thisclass[100],thisattr[100],thisgeom[100];
#if(USE_UFD==1)
  extern int UFD1ALLCAPSLEN;
  extern char *ufd_allcaps_fcodes[];
  extern char *ufd_allcaps_geoms[];
  extern char *ufd_allcaps_attrs[];
#endif

  extern char *GetShortGeomName(int geom);
  

  

  if(Cvalue==NULL)
    {
      return;
    }
  
  if((geomtype!=C_POFE)&&(geomtype!=C_LINE)&&(geomtype!=C_AREA))
    {
      return;
    }


  len = strlen(Cvalue);
  
  for(i=0;i<len;i++)
    {
      if(islower(Cvalue[i]))
	{
	  badval = 1;
	  break;
	}
    }

  if(badval==0)
    {
      return;
    }


  



  sprintf(thisclass,"%s",GetECCCode(class_code));
  sprintf(thisattr ,"%s",GetEACCode(attr_code));
  if(geomtype==C_POFE)
    {
      sprintf(thisgeom,"P");
    }
  else if(geomtype==C_LINE)
    {
      sprintf(thisgeom,"L");
    }
  else if(geomtype==C_AREA)
    {
      sprintf(thisgeom,"A");
    }
  
#if(USE_UFD==1)  
  for(i=0;i<UFD1ALLCAPSLEN;i++)
    {
      if(
	 (!strcmp(thisclass,ufd_allcaps_fcodes[i])) &&
	 (!strcmp(thisattr ,ufd_allcaps_attrs [i])) &&
	 (!strcmp(thisgeom, ufd_allcaps_geoms [i]))
	 )
	{
	  

	  AddBadCase(attr_code-1,Cvalue,record_num,2);
	  
	  return;
	}
  }
#endif
  
}


int SH_FindSCC_LONG(int type, int scc, int numsac, struct sh_long_attr_list SAC_LONG[], int record_num)
{
  int SzN = sizeof(struct SH_SccNode),i;
  static int pass=0;
  char *Str_Id;
  statusEnum status;
  int foundindex,thiseqc;
  struct SH_SccNode *NEW_ENTRY;
  
  if(scc!=-100)
    {
      scc = scc + 1;
    }
  
  Str_Id = SH_BuildString(type,scc,numsac,SAC_LONG);
  
  pass++;
  
  
  
  NEW_ENTRY = (struct SH_SccNode *) malloc(SzN);
  if(NEW_ENTRY==NULL){printf("FindSCC_LONG: out of allocation memory\n"); exit(-1);}
  
  NEW_ENTRY->scc       = scc;
  NEW_ENTRY->numsac    = numsac;
  NEW_ENTRY->type      = type;
  NEW_ENTRY->next      = NULL;
  NEW_ENTRY->prev      = NULL;
  
  
  if(numsac==0)
    {
      NEW_ENTRY->sac = NULL;
    }
  else
    {
      NEW_ENTRY->sac = (struct sh_long_attr_list *) malloc(sizeof(struct sh_long_attr_list)*numsac);
      if(NEW_ENTRY->sac==NULL){printf("FindSCC_LONG: out of allocation memory\n"); exit(-1);}
    }
  
  for(i=0;i<numsac;i++)
    {

      
      if(
	 (SAC_LONG[i].geomtype==2)                        && 
	 (SAC_LONG[i].attr_code>=0)                       &&
	 ((ATTRTYPE_UFD1())))
	{
	  if(
	     (!strcmp(GetEACCode(SAC_LONG[i].attr_code),"TXT")) ||
	     (!strcmp(GetEACCode(SAC_LONG[i].attr_code),"NAM")) ||
	     (!strcmp(GetEACCode(SAC_LONG[i].attr_code),"NM3")) ||
	     (!strcmp(GetEACCode(SAC_LONG[i].attr_code),"NM4")) ||
	     (!strcmp(GetEACCode(SAC_LONG[i].attr_code),"IKO")) ||
	     (!strcmp(GetEACCode(SAC_LONG[i].attr_code),"VDR"))
	     )
	    {
	      TestUppercase(type,scc,SAC_LONG[i].attr_code,SAC_LONG[i].Cvalue,record_num);
	    }
	}


	  
	   
      if(ATTRTYPE_ANY_TDS())
	  {
	    

        if(0)
		{
	      if(SAC_LONG[i].geomtype==3) 
		  { 
		    if(type==1) 
			{ 
			  if(!strcmp(GetECCCode(scc),"ZI031"))
			  { 
		        if(!strcmp(GetEACCode(SAC_LONG[i].attr_code),"EQC"))
				{ 
			      thiseqc = (int)SAC_LONG[i].Dvalue;

			      printf("Found EQC value %d\n",thiseqc);

			      if((thiseqc>=0)&&(thiseqc<=7))
				  { 
                    scale_found[thiseqc] = 1;
				  } 
			      else
				  { 
				    printf("error:  got bad EQC in SU: %d\n",thiseqc);
				  } 
				} 
			  } 
			} 
		  } 
		} 
	  }
      NEW_ENTRY->sac[i].attr_code  = SAC_LONG[i].attr_code;
      NEW_ENTRY->sac[i].unit_code  = SAC_LONG[i].unit_code;
      NEW_ENTRY->sac[i].scale_code = SAC_LONG[i].scale_code;
      NEW_ENTRY->sac[i].SEDRIStype = SAC_LONG[i].SEDRIStype;
      NEW_ENTRY->sac[i].geomtype   = SAC_LONG[i].geomtype;
      NEW_ENTRY->sac[i].lod_stuff = NULL;
      NEW_ENTRY->sac[i].nam_stuff = NULL;
      
      
      if(NEW_ENTRY->sac[i].attr_code==-1)
	{
	  if(SAC_LONG[i].lod_stuff!=NULL) 
	    {
	      
	      NEW_ENTRY->sac[i].lod_stuff = (char *) malloc(strlen(SAC_LONG[i].lod_stuff)+2);
	      if(NEW_ENTRY->sac[i].lod_stuff==NULL)
		{printf("FindSCC_LONG: out of allocation memory\n"); exit(-1);}	    
	      strcpy(NEW_ENTRY->sac[i].lod_stuff,SAC_LONG[i].lod_stuff);
	    }
	}
      else if(NEW_ENTRY->sac[i].attr_code==-2)
	{
	  if(SAC_LONG[i].nam_stuff!=NULL) 
	    {
	      
	      NEW_ENTRY->sac[i].nam_stuff = (char *) malloc(strlen(SAC_LONG[i].nam_stuff)+2);
	      if(NEW_ENTRY->sac[i].nam_stuff==NULL)
		{printf("FindSCC_LONG: out of allocation memory\n"); exit(-1);}	    
	      strcpy(NEW_ENTRY->sac[i].nam_stuff,SAC_LONG[i].nam_stuff);
	    }
	}
      else if(NEW_ENTRY->sac[i].geomtype==0)
	{
	  NEW_ENTRY->sac[i].Dvalue     = SAC_LONG[i].Dvalue;
	  
	}
      else if(NEW_ENTRY->sac[i].geomtype==1)
	{
	  NEW_ENTRY->sac[i].Dvalue     = SAC_LONG[i].Dvalue;
	}
      else if(NEW_ENTRY->sac[i].geomtype==2)
	{
	  if(SAC_LONG[i].Cvalue[0]!='\0')
	    {
	      NEW_ENTRY->sac[i].Cvalue = (char *)malloc(strlen(SAC_LONG[i].Cvalue)+2);
	      if(NEW_ENTRY->sac[i].Cvalue==NULL){printf("place 2 out of mem\n"); exit(-1);}
	    }
	  else
	    {
	      NEW_ENTRY->sac[i].Cvalue = (char *)malloc(2);
	      if(NEW_ENTRY->sac[i].Cvalue==NULL){printf("place 1 out of mem\n"); exit(-1);}
	    }
	  
	  if(NEW_ENTRY->sac[i].Cvalue==NULL)
	    {printf("FindLong: out of memory!\n"); exit(-1);}
	  
	  sprintf(NEW_ENTRY->sac[i].Cvalue,"%s",SAC_LONG[i].Cvalue);
	}
      else if(NEW_ENTRY->sac[i].geomtype==3)
	{
	  NEW_ENTRY->sac[i].Dvalue     = SAC_LONG[i].Dvalue;
	  
	}
      else if(NEW_ENTRY->sac[i].geomtype==4)
	{
	  NEW_ENTRY->sac[i].Dvalue     = SAC_LONG[i].Dvalue;
	  
	}
    }
  
  
  if ((status = SH_find(&SH_root, Str_Id,&foundindex)) == STATUS_KEY_FOUND) 
    {
      
      
      if(numsac>0)
	{
	  for(i=0;i<numsac;i++)
	    {
	      if(NEW_ENTRY->sac[i].geomtype==2)
		{
		  free(NEW_ENTRY->sac[i].Cvalue);
		  NEW_ENTRY->sac[i].Cvalue = NULL;
		}
	      if(SAC_LONG[i].lod_stuff!=NULL)
		{
		  free(NEW_ENTRY->sac[i].lod_stuff);
		  NEW_ENTRY->sac[i].lod_stuff = NULL;
		}
	      if(SAC_LONG[i].nam_stuff!=NULL)
		{
		  free(NEW_ENTRY->sac[i].nam_stuff);
		  NEW_ENTRY->sac[i].nam_stuff = NULL;
		}
	    }
	  free(NEW_ENTRY->sac);
	  NEW_ENTRY->sac = NULL;
	}
      free(NEW_ENTRY);
      
      
      return foundindex;
    }
  else
    {
      status = SH_insert(&SH_root, Str_Id,scc_long_items,NEW_ENTRY);
      if (status  == STATUS_DUPLICATE_KEY) 
	{
	  printf("this shouldnt have happened\n"); 
	  exit(-1);
	}
      else if (status  == STATUS_MEM_EXHAUSTED) 
	{
	  printf("insert tree:  out of memory\n"); 
	  exit(-1);
	}
      
      scc_long_items++;
      
      return (scc_long_items-1);
    }
}




int SH_FindSCC_SHORT(int type, int scc, int numsac, struct sh_short_attr_list SAC_SHORT[], int record_num)
{
  int SzN = sizeof(struct SH_SccNodeSH),i;
  struct SH_SccNodeSH * current;
  struct SH_SccNodeSH * last;
  int index=0,bad;
  
  
  
  
  
  
  if(scc!=-100)
    {
      scc = scc + 1;
    }
  


  if(scc_short_items==0)
    {
      SH_SHORT_LIST = (struct SH_SccNodeSH *) malloc(SzN);
      if(SH_SHORT_LIST==NULL){printf("FindSCC_SHORT: out of allocation memory\n"); exit(-1);}
      
      SH_SHORT_LIST->scc    = scc;
      SH_SHORT_LIST->numsac = numsac;
      SH_SHORT_LIST->type   = type;
      SH_SHORT_LIST->next   = NULL;
      
      
      SH_SHORT_LIST->sac = (struct sh_short_attr_list *) malloc(sizeof(struct sh_short_attr_list)*numsac);
      if(SH_SHORT_LIST->sac==NULL){printf("FindSCC_SHORT: out of allocation memory\n"); exit(-1);}
      
      for(i=0;i<numsac;i++)
	{

	  SH_SHORT_LIST->sac[i].attr_code = SAC_SHORT[i].attr_code;

	  
	  if(SAC_SHORT[i].lod_stuff!=NULL)
	    {
	      SH_SHORT_LIST->sac[i].lod_stuff = (char *) malloc(strlen(SAC_SHORT[i].lod_stuff)+2);
	      if(SH_SHORT_LIST->sac[i].lod_stuff==NULL)
		{printf("FindSCC_SHORT: out of allocation memory\n"); exit(-1);}	    
	      strcpy(SH_SHORT_LIST->sac[i].lod_stuff,SAC_SHORT[i].lod_stuff);
	    }
	  else
	    {
	      SH_SHORT_LIST->sac[i].lod_stuff = NULL;
	    }


	  if(SAC_SHORT[i].nam_stuff!=NULL)
	    {

	      SH_SHORT_LIST->sac[i].nam_stuff = (char *) malloc(strlen(SAC_SHORT[i].nam_stuff)+2);
	      if(SH_SHORT_LIST->sac[i].nam_stuff==NULL)
		{printf("FindSCC_SHORT: out of allocation memory\n"); exit(-1);}	    
	      strcpy(SH_SHORT_LIST->sac[i].nam_stuff,SAC_SHORT[i].nam_stuff);
	    }
	  else
	    {
	      SH_SHORT_LIST->sac[i].nam_stuff = NULL;
	    }
	}
      
      scc_short_items++;
      return (scc_short_items-1);
    }
  else   
    {
      current = SH_SHORT_LIST;
      while(current!=NULL)
	{
	  if(
	     (current->numsac==numsac)&&
	     (current->scc   ==scc)   &&
	     (current->type  ==type)  
	     )
	    {
	      
	      bad = 0;
	      for(i=0;i<numsac;i++)
		{
		  if(SAC_SHORT[i].attr_code==-1)
		    {
		      if(strcmp(current->sac[i].lod_stuff,SAC_SHORT[i].lod_stuff))
			{
			  bad=1;
			  break;
			}
		    }

		  if(SAC_SHORT[i].attr_code==-2)
		    {
		      if(strcmp(current->sac[i].nam_stuff,SAC_SHORT[i].nam_stuff))
			{
			  bad=1;
			  break;
			}
		    }
		}
	      
	      if(bad==0)
		{
		  return index;
		}
	      
	    }
	  
	  index++;
	  last = current;
	  current = current-> next;
	}
      
      
      
      current = (struct SH_SccNodeSH *) malloc(SzN);
      if(current==NULL){printf("FindSCC_SHORT: out of allocation memory\n"); exit(-1);}
      
      current->scc   = scc;
      current->numsac= numsac;
      current->type  =  type;
      
      current->sac = (struct sh_short_attr_list *) malloc(sizeof(struct sh_short_attr_list)*numsac);
      if(current->sac==NULL){printf("FindSCC_SHORT: out of allocation memory\n"); exit(-1);}
      
      for(i=0;i<numsac;i++)
	{
	  current->sac[i].attr_code = SAC_SHORT[i].attr_code;
	  
	  if(SAC_SHORT[i].lod_stuff!=NULL)
	    {
	      current->sac[i].lod_stuff = (char *) malloc(strlen(SAC_SHORT[i].lod_stuff)+2);
	      if(current->sac[i].lod_stuff==NULL)
		{printf("FindSCC_SHORT: out of allocation memory\n"); exit(-1);}	    
	      strcpy(current->sac[i].lod_stuff,SAC_SHORT[i].lod_stuff);
	    }
	  else
	    {
	      current->sac[i].lod_stuff = NULL;
	    }

	  if(SAC_SHORT[i].nam_stuff!=NULL)
	    {
	      current->sac[i].nam_stuff = (char *) malloc(strlen(SAC_SHORT[i].nam_stuff)+2);
	      if(current->sac[i].nam_stuff==NULL)
		{printf("FindSCC_SHORT: out of allocation memory\n"); exit(-1);}	    
	      strcpy(current->sac[i].nam_stuff,SAC_SHORT[i].nam_stuff);
	    }
	  else
	    {
	      current->sac[i].nam_stuff = NULL;
	    }
	}
      
      
      current->next = NULL;
      last->next = current;
      scc_short_items++;
      return(index);
    }
}



void WriteNFI(char *NFI,char * NFN, char *NAM, int classcode, int geomtype)
{
  extern FILE *nfnfile;
  int i,len;

  

  len = strlen(NAM);
  for(i=0;i<len;i++)
  {
	if(NAM[i]==10)
	{
      printf("Replacing newline character %d with \" \" in NAM\n",NAM[i]);
	  NAM[i] = 32;
	}
	else if(NAM[i]==13)
	{
      printf("Replacing carriage return character %d with \" \" in NAM\n",NAM[i]);
	  NAM[i] = 32;
	}
    else if((NAM[i]>=0)&&(NAM[i]<32))
	{
      printf("Replacing non-printing character %d with \" \" in NAM\n",NAM[i]);
	  NAM[i] = 32;
	}
  }

  fprintf(nfnfile,"\"%s\" \"%d\" %s **!!!!** %s **!!!!** %s\n",GetECCLabel(classcode),geomtype,NFI,NFN,NAM);
}


int IsGoodNF(char *inval)
{
  int i,len;
  extern int IsNumber(int num);

  len = strlen(inval);


  if(len<7) 
  {
    return 0;
  }

  if(!strcmp(inval,"\"-999999\"")) 
  {
    return 0;
  }

  if(!strcmp(inval,"\"-999999.0\"")) 
  {
    return 0;
  }

  if(inval[0]!='"')
  {
    return 0;
  }

  if(IsNumber(inval[1])==0)
  {
    if(inval[1]!='-')
	{
      return 0;
	}
  }

  for(i=2;i<len-1;i++)
  {
    if(IsNumber(inval[i])==0)
	{
      return 0;
	}
  }

  return 1;
}




void NFIWrapper(char *saveNFI, char *saveNFN, char *saveNAM, int classcode, int geomtype)
{
  int i,len,goodnfn=0;
  static int lastclass = -78, lastgeom = -98,numdupe=0;
  static char lastNFI[300]={"a"}, lastNFN[300]={"a"}, lastNAM[300]={"a"};
  extern char *GetShortGeomName(int geom);
  extern char **gifd_class_names;
  extern int NAM_HTML_LIMIT;
  extern FILE *savenames;


  if(ATTRTYPE_ANY_TDS())
  {
    saveNFI = "\"11111111111111\"";
  }

  if((classcode==123456789)&&(geomtype==123456789))
  {
	
    fprintf(savenames," %d\n",numdupe + 1);
    numdupe = 0;
    return;
  }

  if(classcode<1)
  {
    return;
  }

  if(strlen(saveNAM)>0)
  {

    

	if(numsavednames<NAM_HTML_LIMIT)
	{
      if( (!strcmp(lastNAM,saveNAM)) && (lastclass==classcode) && (lastgeom==geomtype) )
	  {
        
		numdupe = numdupe + 1;
	  }
	  else
	  {
        if(numsavednames>0)
		{
		  
		  fprintf(savenames," %d\n",numdupe + 1);
		  numdupe = 0;
		}

	    numsavednames = numsavednames + 1;

	    fprintf(savenames,"%s (%s): ",gifd_class_names[classcode-1],GetShortGeomName(geomtype));

        len = strlen(saveNAM);
        for(i=0;i<len;i++)
		{ 

	      if(saveNAM[i]==10)
		  {  
		    fprintf(savenames,"!!newline character!!");
		  } 
	      else if(saveNAM[i]==13)
		  {  
		    fprintf(savenames,"!!carriage return character!!");
		  }  
          else if((saveNAM[i]>=0)&&(saveNAM[i]<32))
		  { 
		    fprintf(savenames,"!!non-printing character!!");
		  } 
		  else
		  { 
		    fprintf(savenames,"%c",saveNAM[i]);
		  } 
		} 
	  }
      
	}
  }



  if(strlen(lastNFI)>2)
  {
    if(
		(!strcmp(lastNFI,saveNFI))                 &&
		(!strcmp(lastNFN,saveNFN))                 &&
		(!strcmp(lastNAM,saveNAM))                 &&
		(lastclass==classcode)                     &&
		((lastgeom==geomtype)&&(lastgeom!=C_POFE))    
	  )
	{
      return;
	}
  }





  lastclass = classcode;
  lastgeom = geomtype;

  sprintf(lastNFI,"%s",saveNFI);
  sprintf(lastNFN,"%s",saveNFN);
  sprintf(lastNAM,"%s",saveNAM);


  if( 
	  (saveNFI[0]!='\0') && 
	  (saveNFN[0]!='\0') && 
	  (saveNAM[0]!='\0') )
  {

	
	if(ATTRTYPE_MGCP4()==1)
	{
	  goodnfn = 1; 
	}
    else
	{
	  goodnfn = IsGoodNF(saveNFN);
	}


	if(

		

		(goodnfn==1)                &&

		(IsGoodNF(saveNFI))         &&

	    (strcmp(saveNAM,"\"N/A\"")) &&
	    (strcmp(saveNAM,"\"N_A\"")) &&
	    (strcmp(saveNAM,"\"UNK\"")) &&
	    (strcmp(saveNAM,"\"n/a\"")) &&
	    (strcmp(saveNAM,"\"n_a\"")) &&
	    (strcmp(saveNAM,"\"unk\"")) &&
	    (strcmp(saveNAM,"\"NOT APPLICABLE\"")) &&
	    (strcmp(saveNFN,"\"not applicable\"")) &&
	    (strcmp(saveNAM,"\"not applicable\"")) &&
	    (strcmp(saveNAM,"\"UNKNOWN\"")) &&
	    (strcmp(saveNAM,"\"unknown\""))
	  )
	{ 
       WriteNFI(saveNFI,saveNFN,saveNAM,classcode,geomtype);
	} 
  } 
}







void SH_PrintListChunk(int done, int numtables, char *filename, char *tablename)
{
  struct SH_SccNode   * current;
  struct SH_SccNodeSH * current2;
  int i,j,namelen,totalsac,templen=0,thisgeomtype;
  int thisattrcode,writeval;
  int Ivalue;
  char dummy[10];



  static  FILE *codesbin,*codesbin2;
  
  if(done==1) 
    {      
      if(codesbin!=NULL)
	{
	  fclose(codesbin);
	  codesbin = NULL;
	}
      if(codesbin2!=NULL)
	{
	  fclose(codesbin2);
	  codesbin2 = NULL;
	}
      return;
    }
  
  
 
  
  
  
  
  
  
  if(codesbin==NULL)
    {
      codesbin = fopen(codesoutfullbin,"wb");
      
      if(codesbin==NULL)
	{
	  printf("couldnt open %s\n",codesoutfullbin);
	  exit(-1);
	}
    }
  
  
  
  for(j=0;j<scc_long_items;j++)
    {
      if(ABORT_EXTRACT==1)
	{
	  return;
	}
      
      if(j%250==0)
	{
	  update_shape_import(filename,tablename,numtables,-1,-1,
			      SH_Points_Done,SH_Linears_Done,SH_Areals_Done,gridpointsread,
			      0,1,j,scc_long_items,SH_bad_objects, SH_BadCoords,
			      SH_Null_Shapes,SH_Zero_Shapes,SH_Bad_DBF);
	}
      
      
      current = SH_FULL_PTRS[j]->rec.node;
      
      fwrite(&current->scc,    SzI,1,codesbin);
      fwrite(&current->type,   SzI,1,codesbin);
      
      totalsac = current->numsac;
      fwrite(&totalsac, SzI,1,codesbin);

      for(i=0;i<current->numsac;i++)
	{
	  
	  
	  if(current->sac[i].attr_code==-1)
	    {
	      thisattrcode = (int)current->sac[i].attr_code;
	      fwrite(&thisattrcode,   SzI,1,codesbin);
	      
	      namelen = strlen(current->sac[i].lod_stuff);
	      
	      fwrite(&namelen,     SzI,1,codesbin);
	      fwrite(&current->sac[i].lod_stuff[0],  1,namelen,codesbin);
	    }
	  else if(current->sac[i].attr_code==-2)
	    {
	      thisattrcode = (int)current->sac[i].attr_code;
	      fwrite(&thisattrcode,   SzI,1,codesbin);
	      
	      namelen = strlen(current->sac[i].nam_stuff);
	      
	      fwrite(&namelen,     SzI,1,codesbin);
	      fwrite(&current->sac[i].nam_stuff[0],  1,namelen,codesbin);
	    }
	  else if(current->sac[i].attr_code==-3)
	    {
	      thisattrcode = (int)current->sac[i].attr_code;
	      fwrite(&thisattrcode,   SzI,1,codesbin);
	      
	      namelen = strlen(current->sac[i].Cvalue);
	      
	      fwrite(&namelen,     SzI,1,codesbin);
	      fwrite(&current->sac[i].Cvalue[0],  1,namelen,codesbin);
	    }
	  else
	    {
	      
	      if(current->sac[i].attr_code<0)
		  { 
		    printf("Error!  neg code %d (%d)\n",current->sac[i].attr_code,i);
            current->sac[i].attr_code = 1; 
		  } 

	      thisattrcode = (int)current->sac[i].attr_code;
	      fwrite(&thisattrcode,  SzI,1,codesbin);
	         
	      
	      Ivalue = (int)current->sac[i].unit_code;
	      if(Ivalue==TIM_UNITLESS)
		  { 
		    writeval = EUC_UNITLESS;
		  } 
	      else if(Ivalue==TIM_METRE)
		  { 
		    writeval = EUC_METRE;
		  } 
	      else
		  { 
		    printf("bad units %d\n",Ivalue);
		  } 
	      
	      fwrite(&writeval,  SzI,1,codesbin);
	      
	      
	      Ivalue = (int)current->sac[i].scale_code;
	      if(Ivalue==TIM_UNI)
		  { 
		    writeval = ESC_UNI;
		  } 
	      else
		  { 
		    printf("bad scale %d\n",Ivalue);
		  } 
	      
	      fwrite(&writeval, SzI,1,codesbin);
	      
	      
	      Ivalue = (int)current->sac[i].SEDRIStype;
	      if(Ivalue==TIM_INTEGER)  {writeval = EDCS_AVT_INTEGER;}
	      else if(Ivalue==TIM_DOUBLE)   {writeval = EDCS_AVT_REAL;}
	      else if(Ivalue==TIM_ENUMERANT){writeval = EDCS_AVT_ENUMERATION;}
	      else if(Ivalue==TIM_STRING)   {writeval = EDCS_AVT_STRING;}
	      else {printf("bad sed type %d\n",Ivalue);}
	      
	      fwrite(&writeval, SzI,1,codesbin);
	      
	      
	      thisgeomtype = (int)current->sac[i].geomtype;
	      fwrite(&thisgeomtype,   SzI,1,codesbin);
	      
	      if(current->sac[i].geomtype==0)
		{
		  
		  writeval = (int)current->sac[i].Dvalue;
		  fwrite(&writeval,   SzI,1,codesbin);
		}
	      else if(current->sac[i].geomtype==1)
		{
		  
		  fwrite(&current->sac[i].Dvalue,   SzD,1,codesbin);
		}
	      else if(current->sac[i].geomtype==2)
		{
		  
		  namelen = strlen(current->sac[i].Cvalue);
		  fwrite(&namelen,   1,SzI,codesbin);
		  fwrite(&current->sac[i].Cvalue[0],   1,namelen,codesbin);
		}
	      else if(current->sac[i].geomtype==3)
		{
		  
		  writeval = (int)current->sac[i].Dvalue;
		  fwrite(&writeval,   SzI,1,codesbin);
		}
	      else
		{
		  printf("write_long: unexpected geom type %d\n",current->sac[i].geomtype);
		}
	    }
	}


    current = current-> next;
  }
  
 
   
  
  
  if(codesbin2==NULL)
    {
      codesbin2 = fopen(codesoutshortbin,"wb");
      if(codesbin2==NULL)
	{
	  printf("couldnt open %s\n",codesoutshortbin);
	  exit(-1);
	}
    }
  
  current2 = SH_SHORT_LIST;
  while(current2!=NULL)
    {
      fwrite(&current2->scc,   SzI,1,codesbin2);
      totalsac = current2->numsac;
      fwrite(&totalsac,SzI,1,codesbin2);
      fwrite(&current2->type,SzI,1,codesbin2);
      
      
      for(i=0;i<current2->numsac;i++)
	{
	  thisattrcode = (int)current2->sac[i].attr_code;	  
	  fwrite(&thisattrcode,SzI,1,codesbin2);
	  
	  if(current2->sac[i].attr_code==-1)
	    {
	      templen = strlen(current2->sac[i].lod_stuff);
	      fwrite(&templen,SzI,1,codesbin2);
	      fwrite(&current2->sac[i].lod_stuff[0],templen,1,codesbin2);
	    }
	  if(current2->sac[i].attr_code==-2)
	    {
	      templen = strlen(current2->sac[i].nam_stuff);
	      fwrite(&templen,SzI,1,codesbin2);
	      fwrite(&current2->sac[i].nam_stuff[0],templen,1,codesbin2);
	    }
	  if(current2->sac[i].attr_code==-3)
	    {
		  sprintf(dummy,"AAAAA\n");
	      templen = strlen(dummy);
	      fwrite(&templen,SzI,1,codesbin2);
	      fwrite(&dummy[0],templen,1,codesbin2);
	    }
	}      
      current2 = current2-> next;
    }
}






void FreeFIDList(struct SH_FIDs * curr)
{
  struct SH_FIDs *Cnext;
  
  
  while(curr!=NULL)
    {
      Cnext = curr->next;
      
      free(curr);
      curr = Cnext;
    }
  
}


char *GetNFI()
{
  if(ATTRTYPE_ANY_TDS()||ATTRTYPE_ANY_GGDM())
  {
    return "~~Q~~";
  }
  
  return "NFI";
}

char *GetNFN()
{
  if(ATTRTYPE_ANY_TDS())
  {
    return "ZI005_NFN";
  }
  
  return "NFN";
}



void GetShortName(char shortname[],char *shape_to_import)
{
  
  
  int lastfound,i,j;
  char target;
  
  
  if((USE_DOS==1)&&(SLASHTYPE==DOS_TYPE))
    {
      target = '\\';
    }
  else
    {
      target = '/';
    }
  
  
  lastfound = 0;
  
  for(i=0;i<(int)strlen(shape_to_import);i++)
    {
      if(shape_to_import[i]==target)
	{
	  lastfound = i;
	}
    }
  
  if(lastfound==0)
    {
      sprintf(shortname,"%s",shape_to_import);
      return;
    }
  
  
  for(i=lastfound+1,j=0; i<(int)strlen(shape_to_import); i++,j++)
    {
      shortname[j] = shape_to_import[i];
      if((shortname[j]==10)||(shortname[j]==13))
	{
	  shortname[j]   = '\0';
	  shortname[j+1] = '\0';
	  break;
	}
    }  
  
  shortname[j] = '\0';
}




void SH_FreeLists(char *sentinel,char *shapename)
{
  struct SH_SccNodeSH * current2;
  struct SH_SccNodeSH * next2;
  struct SH_BadCodes  * current, *next;
  struct SH_BadAttr   * Ccurrent, *Cnext;
  extern char **gifd_attr_codes;
  int i;
  char shortname[1000];
  

  if(strcmp(sentinel,"!@#$%^&*()"))  
  {
    

   current2 = SH_SHORT_LIST;		     
  
   while(current2!=NULL)
    {
      next2 = current2->next;
      
      for(i=0;i<current2->numsac;i++)
	{
	  if(current2->sac[i].lod_stuff!=NULL)
	    {
	      if(current2->sac[i].attr_code==-1)
		{
		  free(current2->sac[i].lod_stuff);
		}
	      else
		{
		  printf("\n\ninternal error: got lod not null when attr_code was not -1\n\n");
		  printf("%s and %d\n",current2->sac[i].lod_stuff,(int)current2->sac[i].attr_code);
		}
	    }
	  if(current2->sac[i].nam_stuff!=NULL)
	    {
	      if(current2->sac[i].attr_code==-2)
		{
		  free(current2->sac[i].nam_stuff);
		}
	      else
		{
		  printf("\n\ninternal error: got nam not null when attr_code was not -2\n\n");
		  printf("%s and %d\n",current2->sac[i].nam_stuff,(int)current2->sac[i].attr_code);
		}
	    }
	}
      
      if(current2->sac!=NULL)
	{
	  free(current2->sac);
	}
      free(current2);
      current2 = next2;
    }
   SH_SHORT_LIST   = NULL;
   scc_short_items = 0;
  }
  
  


  if(badcoderoot!=NULL)
    {
      if(strlen(specialAfilename)>0)
	{
	  fprintf(badfcodeout,"\n\nInstances of bad FCODE values in:\n  %s:\n",specialAfilename);
	}
      else
	{
	  fprintf(badfcodeout,"\n\nInstances of bad FCODE values in:\n  %s:\n",shapename);
	}
    }
  current = badcoderoot;
  while(current!=NULL)
    {
      fprintf(badfcodeout,"%s\n",current->message);
      fprintf(badfcodeout,"    %d instances\n",current->num);
      
      FreeFIDList(current->FIDs);
      
      
      next = current->next;
      if(current->code!=NULL)
	{
	  free(current->code);
	}
      if(current->message!=NULL)
	{
	  free(current->message);
	}
      
      free(current);
      current = next;
    }
  badcoderoot = NULL;
  
  
  
  
  
  GetShortName(shortname,shapename);
  
  
  
  
  
  if(badNULLroot!=NULL)
    {
      fprintf(nullshptxtout,
	      "\n\nInstances of NULL features found in:\n  %s:\n",shapename);
    }
  Ccurrent = badNULLroot;
  while(Ccurrent!=NULL)
    {
	  if(Ccurrent->numfound==-999999)
	  {
        fprintf(nullshptxtout,"   FID %d is a NULL feature\n",
	      Ccurrent->code);
      }
	  else
	  {
        if(Ccurrent->firstfound>=0)
		{
          fprintf(nullshptxtout,"   FID %d (part %d) is a part of a multi-part area feature with only %d vertices\n",
	        Ccurrent->code,Ccurrent->firstfound,Ccurrent->numfound);
		}
		else
		{
          fprintf(nullshptxtout,"   FID %d is a part of an area feature with only %d vertices\n",
	        Ccurrent->code,Ccurrent->numfound);
		}
      }
      
      Cnext = Ccurrent->next;
      if(Ccurrent->ENUM!=NULL)
	{
	  free(Ccurrent->ENUM);
	}
      free(Ccurrent);
      Ccurrent = Cnext;
    }
  badNULLroot = NULL;
  
  


  
  if(unkcoderoot!=NULL)
    {
      fprintf(badunktxtout,
	      "\n\nColumn names in %s that were ignored due to not being recognized:\n",shapename);
    }
  current = unkcoderoot;
  while(current!=NULL)
    {
    fprintf(badunktxtout,"   \"%s\"\n",
	      current->code);
      
      next = current->next;
      free(current->code);
      free(current);
      current = next;
    }
  unkcoderoot = NULL;
  
  
  

  current = badfnameroot;
  while(current!=NULL)
    {
      fprintf(badfilename,"\"%s\"\n",
	      current->code);
      
      next = current->next;
      free(current->code);
      free(current);
      current = next;
    }
  badfnameroot = NULL;
  
  

  current = nofcoderoot;
  while(current!=NULL)
    {
      fprintf(nofcode,"\"%s\"\n",
	      current->code);
      
      next = current->next;
      free(current->code);
      free(current);
      current = next;
    }
  nofcoderoot = NULL;
  
  


  
  
  if(badCoordroot!=NULL)
    {
	  if(strlen(specialAfilename)>0)
	  {
       fprintf(badcoordout,
	      "\n\nInstances of invalid coordinates found in:\n  %s:\n",specialAfilename);
	  }
	  else
	  {
      fprintf(badcoordout,
	      "\n\nInstances of invalid coordinates found in:\n  %s:\n",shapename);
	  }

     }
  Ccurrent = badCoordroot;
  while(Ccurrent!=NULL)
    {
      fprintf(badcoordout,"   FID %d has invalid coordinates\n",
	      Ccurrent->code);
      
      
      Cnext = Ccurrent->next;
      if(Ccurrent->ENUM!=NULL)
	{
	  free(Ccurrent->ENUM);
	}
      free(Ccurrent);
      Ccurrent = Cnext;
    }
  badCoordroot = NULL;
  
  
  
  
  
  
  
  
  if(badattrroot!=NULL)
    {
      fprintf(badattrtxtout,"\n\nInstances of attributes with invalid pick-list values found in:\n  %s:\n",shapename);
    }
  Ccurrent = badattrroot;
  while(Ccurrent!=NULL)
    {
      fprintf(badattrtxtout,"   %d instances of %s with invalid value: \"%s\"\n",
	      Ccurrent->numfound,
	      gifd_attr_codes[Ccurrent->code],
	      Ccurrent->ENUM);
      
      fprintf(badattrtxtout,"      The first such instance is record number %d\n",Ccurrent->firstfound);
            
      Cnext = Ccurrent->next;
      if(Ccurrent->ENUM!=NULL)
	{
	  free(Ccurrent->ENUM);
	}
      free(Ccurrent);
      Ccurrent = Cnext;
    }
  badattrroot = NULL;
  
  
  
  
  
  
  
  if(badcaseroot!=NULL)
    {
      fprintf(badcasetxtout,"\n\nInstances of attributes with invalid case values found in:\n  %s:\n",shapename);
    }
  Ccurrent = badcaseroot;
  while(Ccurrent!=NULL)
    {
      if(Ccurrent->numfound<0)
	{
	  
	  fprintf(badcasetxtout,"   Non-Uppercase string %s found for attribute %s, record %d\n", 
		  Ccurrent->ENUM,
		  gifd_attr_codes[Ccurrent->code],
		  Ccurrent->firstfound);
	}
      else
	{
	  
	  if(strlen(Ccurrent->ENUM)>50)
	    {
	      fprintf(badcasetxtout,"   %d pick-list instances of %s with non case matching value:\n       \"%s\"\n",
		      Ccurrent->numfound,
		      gifd_attr_codes[Ccurrent->code],
		      Ccurrent->ENUM);
	    }
	  else
	    {
	      fprintf(badcasetxtout,"   %d pick-list instances of %s with non case matching value: \"%s\"\n",
		      Ccurrent->numfound,
		      gifd_attr_codes[Ccurrent->code],
		      Ccurrent->ENUM);
	    }
	  fprintf(badcasetxtout,"      The first such instance is record number %d\n",Ccurrent->firstfound);
	}

      
      Cnext = Ccurrent->next;
      if(Ccurrent->ENUM!=NULL)
	{
	  free(Ccurrent->ENUM);
	}
      free(Ccurrent);
      Ccurrent = Cnext;
    }
  badcaseroot = NULL;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  Ccurrent = badenumroot;
  while(Ccurrent!=NULL)
    {
      Cnext = Ccurrent->next;
      if(Ccurrent->ENUM!=NULL)
	{
	  free(Ccurrent->ENUM);
	}
      if(Ccurrent->goodenum!=NULL)
	{
	  free(Ccurrent->goodenum);
	}
      free(Ccurrent);
      Ccurrent = Cnext;
    }
  badenumroot = NULL;
  


  if(badtyperoot!=NULL)
    {
      fprintf(badtypeout,"\n\nAttributes with invalid data types found in:\n  %s:\n",shapename);
    }  
  Ccurrent = badtyperoot;
  while(Ccurrent!=NULL)
    {
      Cnext = Ccurrent->next;
      
      fprintf(badtypeout,"   Attribute %s:  expected %s, got %s\n",
	      gifd_attr_codes[Ccurrent->code],
	      Ccurrent->ENUM,
	      Ccurrent->goodenum);
      
      
      if(Ccurrent->ENUM!=NULL)
	{
	  free(Ccurrent->ENUM);
	}
      if(Ccurrent->goodenum!=NULL)
	{
	  free(Ccurrent->goodenum);
	}
      free(Ccurrent);
      Ccurrent = Cnext;
    }
  badtyperoot = NULL;
  



  if(badlenroot!=NULL)
    {
      fprintf(badlenout,"\n\nAttributes with incorrect lengths found in:\n  %s:\n",shapename);
    }  
  Ccurrent = badlenroot;
  while(Ccurrent!=NULL)
    {
      Cnext = Ccurrent->next;
      
	  if(Ccurrent->code==-999)
	  {
        fprintf(badlenout,"   Attribute FCODE:  expected %s, found %s\n",
	      Ccurrent->ENUM,
	      Ccurrent->goodenum);
	  }
	  else
	  {
        fprintf(badlenout,"   Attribute %s:  expected %s, found %s\n",
	      gifd_attr_codes[Ccurrent->code],
	      Ccurrent->ENUM,
	      Ccurrent->goodenum);
      }

      
      if(Ccurrent->ENUM!=NULL)
	{
	  free(Ccurrent->ENUM);
	}
      if(Ccurrent->goodenum!=NULL)
	{
	  free(Ccurrent->goodenum);
	}
      free(Ccurrent);
      Ccurrent = Cnext;
    }
  badlenroot = NULL;


}






int ClipTestArealLinear(TimSHPObject *psSHP,int thispart, int FID,char *shape_to_import)
{
  int startindex,endindex,i;
  
  
  
  startindex = psSHP->panPartStart[thispart];
  
  if(thispart==(psSHP->nParts-1))
    {
      endindex = psSHP->nVertices-1;
    }
  else
    {
      endindex = psSHP->panPartStart[thispart+1] - 1;
    }
  
  
  
  for(i=startindex;i<=endindex;i++)
    {
	  if(
		  (i==endindex)                                      &&
		  (endindex!=startindex)                             &&
		  (psSHP->padfX[startindex]==psSHP->padfX[endindex]) &&
		  (psSHP->padfY[startindex]==psSHP->padfY[endindex])
		  )
	  {
		  
		  break;
	  }

      if(TestGeodetic(psSHP->padfX[i],psSHP->padfY[i],FID,shape_to_import)==0)
	  {
	    return -1;
	  } 
    }
  
  if(CLIPEXTRACT==1)
    {
      for(i=startindex;i<=endindex;i++)
	{
	  if((psSHP->padfX[i]>=CLIPLLX) && 
	     (psSHP->padfY[i]>=CLIPLLY) && 
	     (psSHP->padfX[i]<=CLIPURX) && 
	     (psSHP->padfY[i]<=CLIPURY))
	    {
	      return 1;
	    }
	}
    }
  else
    {
      return 0;
    }
  
  
  
  
  return 0; 
}





int ClipTest(int record_num, TimSHPHandle hSHP, char *shape_to_import, char *fcode)
{
  
  
  
  TimSHPObject	*psSHP;
  int j,foundgood,result;


  psSHP = TimSHPReadObject( hSHP, record_num );


  switch(psSHP->nTimSHPType)
    {

    case TimSHPT_NULL:  
      printf("null feature found.  FID %d  Ignoring\n",record_num);
      AddNullShape(record_num,1,0,0);
      TimSHPDestroyObject( psSHP );
      return 0;



    case TimSHPT_POINTM:
    case TimSHPT_POINTZ:
    case TimSHPT_POINT:      

      if(TestGeodetic(psSHP->padfX[0],psSHP->padfY[0],record_num,shape_to_import)==0)
	{
	  return 0;
	}

      if(CLIPEXTRACT==0)
	{
	  TimSHPDestroyObject( psSHP );
	  return 1;
	}


      if(CLIPEXTRACT==1)
	{
	  if((psSHP->padfX[0]>=CLIPLLX) && 
	     (psSHP->padfY[0]>=CLIPLLY) && 
	     (psSHP->padfX[0]<=CLIPURX) && 
	     (psSHP->padfY[0]<=CLIPURY))
	    {
	      TimSHPDestroyObject( psSHP );
	      return 1;
	    }
	}
      
      
      TimSHPDestroyObject( psSHP );
      return 0;
      break;
      
      
    case TimSHPT_MULTIPOINTZ: 
    case TimSHPT_MULTIPOINT:   
    case TimSHPT_MULTIPOINTM: 
     
    

      for(j=0;j<psSHP->nVertices;j++)
	{
	  if(TestGeodetic(psSHP->padfX[j],psSHP->padfY[j],record_num,shape_to_import)==0)
	    {
	      return 0;
	    } 
	}
      
      if(CLIPEXTRACT==0)
	{
	  TimSHPDestroyObject( psSHP );
	  return 1;
	}
      
      if(CLIPEXTRACT==1)
	{
	  for(j=0;j<psSHP->nVertices;j++)
	    {
	      if((psSHP->padfX[j]>=CLIPLLX) && 
		 (psSHP->padfY[j]>=CLIPLLY) &&
		 (psSHP->padfX[j]<=CLIPURX) && 
		 (psSHP->padfY[j]<=CLIPURY))
		{
		  TimSHPDestroyObject( psSHP );
		  return 1;
		}
	    }
	}
      
      
      
      
      TimSHPDestroyObject( psSHP );
      return 0;
      
      break;
      
      
      
    case TimSHPT_ARCZ:        
    case TimSHPT_ARC:        
    case TimSHPT_ARCM:  
      
	if(psSHP->nParts==0)
	{
	  printf("detected linear with 0 parts!\n");
	  if(strcmp(fcode,"*****"))
	  {
        fprintf(badshapeout,"Line feature detected with 0 parts (%s).  FID %d\n  Shapefile: %s\n",
	      fcode,record_num,specialAfilename); 
	  }
	  else
	  {
        fprintf(badshapeout,"Line feature detected with 0 parts.  FID %d\n  Shapefile: %s\n",
	      record_num,specialAfilename); 
	  }

 	  SH_Zero_Shapes = SH_Zero_Shapes + 1;
      TimSHPDestroyObject( psSHP );
	  return 0;
	}
    else
	{
	  foundgood = 0;
	  for(j=0;j<psSHP->nParts;j++)
	    {
	      
	      result = ClipTestArealLinear(psSHP,j,record_num,shape_to_import);
	      if(result==-1)
		{
		  
		  TimSHPDestroyObject( psSHP );
		  return 0;
		}
	      else if(result==1)
		{
		  
		  foundgood = 1;
		}
	    }
	  
	  if((foundgood==1)||(CLIPEXTRACT==0))
	    {
	      TimSHPDestroyObject( psSHP );
	      return 1;
	    }
	}
      
      TimSHPDestroyObject( psSHP );
      return 0;
      
      break;
      
      
      
    case TimSHPT_MULTIPATCH: 
    case TimSHPT_POLYGONZ: 
    case TimSHPT_POLYGON:       
    case TimSHPT_POLYGONM: 
      
    if(psSHP->nParts==0)
	{
	  printf("detected area with 0 parts!\n");

	  if(strcmp(fcode,"*****"))
	  {
	    fprintf(badshapeout,"Area feature detected with 0 parts (%s).  FID %d\n  Shapefile: %s\n\n",
	      fcode,record_num,specialAfilename); 
	  }
	  else
	  {
	    fprintf(badshapeout,"Area feature detected with 0 parts.  FID %d\n  Shapefile: %s\n\n",
	      record_num,specialAfilename); 
	  }

	  SH_Zero_Shapes = SH_Zero_Shapes + 1;
      TimSHPDestroyObject( psSHP );
	  return 0;
	}
    else
	{
	  foundgood = 0;
	  for(j=0;j<psSHP->nParts;j++)
	    {
	      result = ClipTestArealLinear(psSHP,j,record_num,shape_to_import);
	      if(result==-1)
		{
		  
		  TimSHPDestroyObject( psSHP );
		  return 0;
		}
	      else if(result==1)
		{
		  
		  foundgood = 1;
		}
	    }
	  
	  if((foundgood==1)||(CLIPEXTRACT==0))
	    {
	      TimSHPDestroyObject( psSHP );
	      return 1;
	    }
	}
      TimSHPDestroyObject( psSHP );
      return 0;
    }
  
  TimSHPDestroyObject( psSHP );
  printf("should not be here clip\n");
  return 0;
}




FILE *Get1File(int attr_type)
{
  if(attr_type==LONG_ATTR_ID)
    {
      return id1bin;
    }
  else if(attr_type==LONG_ATTR_AREA)
    {
      return area1bin;
    }
  else if(attr_type==LONG_ATTR_HGT)
    {
      return hgt1bin;
    }
  else if(attr_type==LONG_ATTR_LEN)
    {
      return len1bin;
    }
  else if(attr_type==LONG_ATTR_NAM)
    {
      return nam1bin;
    }
  else if(attr_type==LONG_ATTR_ZV2)
    {
      return zv1bin;
    }
  else
    {
      printf("bad flag %d to Get1File\n",attr_type);
      return NULL;
    }
}


FILE *Get2File(int attr_type)
{
  if(attr_type==LONG_ATTR_ID)
    {
      return id2bin;	
    }
  else if(attr_type==LONG_ATTR_AREA)
    {
      return area2bin;
    }
  else if(attr_type==LONG_ATTR_HGT)
    {
      return hgt2bin;
    }
  else if(attr_type==LONG_ATTR_LEN)
    {
      return len2bin;
    }
  else if(attr_type==LONG_ATTR_NAM)
    {
      return nam2bin;
    }
  else if(attr_type==LONG_ATTR_ZV2)
    {
      return zv2bin;
    }
  else
    {
      printf("bad flag %d to Get2File\n",attr_type);
      return NULL;
    }
}


void WriteGFID(int datafound,char *charval, int Ival, double Dval,
	       int datatype, int attr_type)
{
  FILE *file_1,*file_2;
  long int fileposn;
  short int writelen;
  char thiscode[1000];
  int writeout=1;
  extern int TruncImport;


  if(datatype==D_TYPE)
  {
	

    if((ATTRTYPE_ANY_TDS()>0)||(ATTRTYPE_ANY_GGDM()>0))
	{
	  if((attr_type==LONG_ATTR_HGT)||(attr_type==LONG_ATTR_LEN)||(attr_type==LONG_ATTR_ZV2))
	  {
        if((TruncImport==1)&&(Around3276(Dval)==0))
		{ 
          Dval = TruncateToNdigits(Dval,1);
		} 
	    else if((TruncImport==2)&&(Around3276(Dval)==0))
		{ 
          Dval = (int)Dval;
		} 
	  } 
	} 
  }


  if((datafound==0)&&(attr_type==LONG_ATTR_ID))
    {
      if(HAS_ID[ATTRIBUTION_TYPE]==0)
	{
	  writeout = 0;
	}
      else
	{
	  sprintf(thiscode,"No %s found",GetFrontPart());
	  datatype = C_TYPE;
	}
    }


  else if((attr_type==LONG_ATTR_ID)||(datatype==C_TYPE))
    {
    sprintf(thiscode,"%s",charval);
    }


  if(writeout==1)
    {	
      file_1 = Get1File(attr_type);
      file_2 = Get2File(attr_type);
      
      if(file_1==NULL)
	{
	  printf("Error: Null file1 for %d\n",attr_type);
	  return;
	}
      if(file_2==NULL)
	{
	  printf("Error: Null file2 for %d\n",attr_type);
	  return;
	}
      
      if(datatype==NOTYPE)
	{
	  writelen = 0; 
	  fileposn = -1;
	  fwrite(&writelen,  1,sizeof(short int),file_1);
	  fwrite(&fileposn,  1,SzL,file_1); 
	}
      else if(datatype==C_TYPE)
 	{
	  writelen = (short int)strlen(thiscode);
	  fileposn = ftell(file_2);
	  fwrite(&writelen,    1,sizeof(short int),file_1);
	  fwrite(&fileposn,    1,SzL,file_1); 
	  fwrite(&thiscode[0], 1,writelen,file_2);
	}
      else if(datatype==I_TYPE)
	{
	  writelen = -1;
	  fileposn = ftell(file_2);
	  fwrite(&writelen, 1,sizeof(short int),file_1);
	  fwrite(&fileposn, 1,SzL,file_1); 
	  fwrite(&Ival,     1,SzI,file_2);
	}
      else if(datatype==D_TYPE)
	{
	  writelen = -2;
	  fileposn = ftell(file_2);
	  fwrite(&writelen, 1,sizeof(short int),file_1);
	  fwrite(&fileposn, 1,SzL,file_1); 
	  fwrite(&Dval,     1,SzD,file_2);
	}
	  else
	  {
		  printf("WD: got bad data type %d\n",datatype);
	  }
    }
  
  
  if(attr_type==LONG_ATTR_ID)
    {
	  

      global_gifd_id = global_gifd_id + 1;

    }  
}	


int GetClassLevelStrings(int testclass,char retval1[],char retval2[],char retval3[])
{
  static char attrname[30],codename[10],valuename[100];
  int level;



       if(testclass==1) {level = 0; sprintf(attrname,"CLASS");      sprintf(codename,"1" );  sprintf(valuename,"U (UNCLASS)");                     }
  else if(testclass==2) {level = 0; sprintf(attrname,"SEC_CLASS");  sprintf(codename,"U" );  sprintf(valuename,"Unclassified");                    }
  else if(testclass==3) {level = 0; sprintf(attrname,"SEC_CLASS");  sprintf(codename,"08");  sprintf(valuename,"NATO Unclassified");               }
  else if(testclass==4) {level = 0; sprintf(attrname,"ZSAX_RS0" );  sprintf(codename,"U" );  sprintf(valuename,"UNCLASSIFIED");                    }
  else if(testclass==5) {level = 0; sprintf(attrname,"SEC"      );  sprintf(codename,"5" );  sprintf(valuename,"US Unclassified");                 }
  else if(testclass==6) {level = 0; sprintf(attrname,"SEC"      );  sprintf(codename,"23");  sprintf(valuename,"NATO Unclassified");               }
  else if(testclass==7) {level = 0; sprintf(attrname,"TREX"     );  sprintf(codename,"XML"); sprintf(valuename,"unclassified");                    }

  else if(testclass==8) {level = 1; sprintf(attrname,"SEC"      );  sprintf(codename,"22");  sprintf(valuename,"US For Official Use Only");        }

  else if(testclass==9) {level = 1; sprintf(attrname,"SEC_CLASS");  sprintf(codename,"07");  sprintf(valuename,"NATO Restricted");                 }
  else if(testclass==10){level = 1; sprintf(attrname,"ZSAX_RS0" );  sprintf(codename,"R" );  sprintf(valuename,"RESTRICTED");                      }
  else if(testclass==11){level = 1; sprintf(attrname,"SEC"      );  sprintf(codename,"10");  sprintf(valuename,"NATO Restricted (NR)");           }
  else if(testclass==12){level = 1; sprintf(attrname,"SEC"      );  sprintf(codename,"14");  sprintf(valuename,"UK Restricted");                   }
  else if(testclass==13){level = 1; sprintf(attrname,"SEC"      );  sprintf(codename,"4" );  sprintf(valuename,"US Restricted");                   }
  else if(testclass==14){level = 1; sprintf(attrname,"TREX"     );  sprintf(codename,"XML"); sprintf(valuename,"restricted");                   }


  else if(testclass==15){level = 2; sprintf(attrname,"SEC_CLASS");  sprintf(codename,"C" );  sprintf(valuename,"Confidential");                    }
  else if(testclass==16){level = 2; sprintf(attrname,"SEC_CLASS");  sprintf(codename,"06");  sprintf(valuename,"NATO Confidential");               }
  else if(testclass==17){level = 2; sprintf(attrname,"SEC_CLASS");  sprintf(codename,"11");  sprintf(valuename,"Confidential Atomal");             }
  else if(testclass==18){level = 2; sprintf(attrname,"ZSAX_RS0" );  sprintf(codename,"C" );  sprintf(valuename,"CONFIDENTIAL");                    }
  else if(testclass==19){level = 2; sprintf(attrname,"SEC"      );  sprintf(codename,"13");  sprintf(valuename,"UK Confidential");                 }
  else if(testclass==20){level = 2; sprintf(attrname,"SEC"      );  sprintf(codename,"3" );  sprintf(valuename,"US Confidential");                 }
  else if(testclass==21){level = 2; sprintf(attrname,"SEC"      );  sprintf(codename,"9" );  sprintf(valuename,"NATO Confidential (NC)");          }
  else if(testclass==22){level = 2; sprintf(attrname,"SEC"      );  sprintf(codename,"21");  sprintf(valuename,"NATO Confidential Atomal (NCA)");  }
  else if(testclass==23){level = 2; sprintf(attrname,"TREX"     );  sprintf(codename,"XML"); sprintf(valuename,"confidential");                   }



  
  else if(testclass==24){level = 3; sprintf(attrname,"CLASS");      sprintf(codename,"0" );  sprintf(valuename,"S (SECRET)");                      }
  else if(testclass==25){level = 3; sprintf(attrname,"CLASS");      sprintf(codename,"0" );  sprintf(valuename,"S (SECRET)");                      }



  else if(testclass==26){level = 3; sprintf(attrname,"SEC_CLASS");  sprintf(codename,"S" );  sprintf(valuename,"Secret");                          }
  else if(testclass==27){level = 3; sprintf(attrname,"SEC_CLASS");  sprintf(codename,"03");  sprintf(valuename,"NATO Secret");                     }
  else if(testclass==28){level = 3; sprintf(attrname,"SEC_CLASS");  sprintf(codename,"04");  sprintf(valuename,"NATO Secret-Savate");              }
  else if(testclass==29){level = 3; sprintf(attrname,"SEC_CLASS");  sprintf(codename,"05");  sprintf(valuename,"NATO Secret-Avicula");             }
  else if(testclass==30){level = 3; sprintf(attrname,"SEC_CLASS");  sprintf(codename,"10");  sprintf(valuename,"Secret Atomal");                   }
  else if(testclass==31){level = 3; sprintf(attrname,"ZSAX_RS0" );  sprintf(codename,"S" );  sprintf(valuename,"SECRET");                          }
  else if(testclass==32){level = 3; sprintf(attrname,"SEC"      );  sprintf(codename,"2" );  sprintf(valuename,"US Secret");                       }
  else if(testclass==33){level = 3; sprintf(attrname,"SEC"      );  sprintf(codename,"12");  sprintf(valuename,"UK Secret");                       }
  else if(testclass==34){level = 3; sprintf(attrname,"SEC"      );  sprintf(codename,"8" );  sprintf(valuename,"NATO Secret (NS)");                }
  else if(testclass==35){level = 3; sprintf(attrname,"SEC"      );  sprintf(codename,"18");  sprintf(valuename,"NATO Secret Savate");              }
  else if(testclass==36){level = 3; sprintf(attrname,"SEC"      );  sprintf(codename,"19");  sprintf(valuename,"NATO Secret Avicula");             }
  else if(testclass==37){level = 3; sprintf(attrname,"SEC"      );  sprintf(codename,"20");  sprintf(valuename,"NATO Secret Atomal (NSA)");        }
  else if(testclass==38){level = 3; sprintf(attrname,"TREX"     );  sprintf(codename,"XML"); sprintf(valuename,"secret");                   }

  else if(testclass==39){level = 4; sprintf(attrname,"SEC_CLASS");  sprintf(codename,"TS");  sprintf(valuename,"Top Secret");                          }
  else if(testclass==40){level = 4; sprintf(attrname,"SEC_CLASS");  sprintf(codename,"01");  sprintf(valuename,"COSMIC Top Secret-Bohemia");       }
  else if(testclass==41){level = 4; sprintf(attrname,"SEC_CLASS");  sprintf(codename,"02");  sprintf(valuename,"COSMIC Top Secret-Balk");          }
  else if(testclass==42){level = 4; sprintf(attrname,"SEC_CLASS");  sprintf(codename,"09");  sprintf(valuename,"COSMIC Top Secret Atom");          }
  else if(testclass==43){level = 4; sprintf(attrname,"ZSAX_RS0" );  sprintf(codename,"TS");  sprintf(valuename,"TOP SECRET");                      }
  else if(testclass==44){level = 4; sprintf(attrname,"SEC"      );  sprintf(codename,"1" );  sprintf(valuename,"US Top Secret");                   }
  else if(testclass==45){level = 4; sprintf(attrname,"SEC"      );  sprintf(codename,"6" );  sprintf(valuename,"COSMIC Top Secret (CTS)");         }
  else if(testclass==46){level = 4; sprintf(attrname,"SEC"      );  sprintf(codename,"7" );  sprintf(valuename,"FOCAL Top Secret (FTS)");          }
  else if(testclass==47){level = 4; sprintf(attrname,"SEC"      );  sprintf(codename,"11");  sprintf(valuename,"UK Top Secret");                   }
  else if(testclass==48){level = 4; sprintf(attrname,"SEC"      );  sprintf(codename,"15");  sprintf(valuename,"COSMIC Top Secret (CTS) Bohemia"); }
  else if(testclass==49){level = 4; sprintf(attrname,"SEC"      );  sprintf(codename,"16");  sprintf(valuename,"COSMIC Top Secret (CTS) Balk");    }
  else if(testclass==50){level = 4; sprintf(attrname,"SEC"      );  sprintf(codename,"17");  sprintf(valuename,"COSMIC Top Secret Atomal (CTSA)"); }
  else if(testclass==51){level = 4; sprintf(attrname,"TREX"     );  sprintf(codename,"XML"); sprintf(valuename,"topSecret");                   }

  else
  {
    printf("Error in GCLS: unrecognized code %d\n",testclass);
    sprintf(attrname,"Error");  
    sprintf(codename,"Unrecognized code");
    sprintf(valuename,"%d",testclass);
	level = 5;
  }

  sprintf(retval1,"%s",attrname);
  sprintf(retval2,"%s",codename);
  sprintf(retval3,"%s",valuename);
  return level;
}


int SetClassLevel(char columnname[],char Incolumnvalue[],char filename[],char tablename[])
{
  char columnvalue[1000],columnvalue2[1000];
  int testclass,len,i,insertindex;
  extern int ClassLevel;
  extern char SaveClassTable [1000];
  extern char SaveClassValue [1000];
  


  
  sprintf(columnvalue2,"%s",Incolumnvalue);

  insertindex = 0;
  len = strlen(columnvalue2);
  for(i=0;i<len;i++)
  {
    if(columnvalue2[i]!='"')
	{
      columnvalue[insertindex] = timtoupper(columnvalue2[i]);  
      insertindex = insertindex + 1;
	}
  }

  columnvalue[insertindex] = '\0';



  if(columnvalue[0] == '\0')
    {
      return 0;
    }
  
  if(!strcmp(columnvalue,"UNK"))
    {
      return 0;
    }

  testclass = -10000;




  



  

  if(CREATING_TREX==1)
  {
	
	if(strcmp(columnname,"TREX"))
	{
	  return 0;
	}
  }
  else
  {
    if(ConvertAttrCode(columnname)<0)
	{ 
	  return 0;
	} 
  }




  if(!strcmp(columnname,"CLASS")     && ( (!strcmp(columnvalue,"1"))  || (!strcmp(columnvalue,"U (UNCLASS)")) || (!strcmp(columnvalue,"U"))   ))                     {testclass = 1;}
  if(!strcmp(columnname,"SEC_CLASS") && ( (!strcmp(columnvalue,"U" )) || (!strcmp(columnvalue,"Unclassified"))))                    {testclass = 2;}
  if(!strcmp(columnname,"SEC_CLASS") && ( (!strcmp(columnvalue,"08")) || (!strcmp(columnvalue,"NATO Unclassified"))))               {testclass = 3;}
  if(!strcmp(columnname,"ZSAX_RS0" ) && ( (!strcmp(columnvalue,"U" )) || (!strcmp(columnvalue,"UNCLASSIFIED"))))                    {testclass = 4;}
  if(!strcmp(columnname,"SEC"      ) && ( (!strcmp(columnvalue,"5" )) || (!strcmp(columnvalue,"US Unclassified"))))                 {testclass = 5;}
  if(!strcmp(columnname,"SEC"      ) && ( (!strcmp(columnvalue,"23")) || (!strcmp(columnvalue,"NATO Unclassified"))))               {testclass = 6;}
  if(!strcmp(columnname,"TREX")      && ( (!strcmp(Incolumnvalue,"unclassified"))))                                                 {testclass = 7;}


  if(!strcmp(columnname,"SEC"      ) && ( (!strcmp(columnvalue,"22")) || (!strcmp(columnvalue,"US For Official Use Only"))))        {testclass = 8;}


  if(!strcmp(columnname,"SEC_CLASS") && ( (!strcmp(columnvalue,"07")) || (!strcmp(columnvalue,"NATO Restricted"))))                 {testclass = 9;}
  if(!strcmp(columnname,"ZSAX_RS0" ) && ( (!strcmp(columnvalue,"R" )) || (!strcmp(columnvalue,"RESTRICTED"))))                      {testclass = 10;}
  if(!strcmp(columnname,"SEC"      ) && ( (!strcmp(columnvalue,"10")) || (!strcmp(columnvalue,"NATO Restricted (NR)"))))            {testclass = 11;}
  if(!strcmp(columnname,"SEC"      ) && ( (!strcmp(columnvalue,"14")) || (!strcmp(columnvalue,"UK Restricted"))))                   {testclass = 12;}
  if(!strcmp(columnname,"SEC"      ) && ( (!strcmp(columnvalue,"4" )) || (!strcmp(columnvalue,"US Restricted"))))                   {testclass = 13;}
  if(!strcmp(columnname,"TREX")      && ( (!strcmp(Incolumnvalue,"restricted"))))                                                   {testclass = 14;}


  if(!strcmp(columnname,"SEC_CLASS") && ( (!strcmp(columnvalue,"C" )) || (!strcmp(columnvalue,"Confidential"))))                    {testclass = 15;}
  if(!strcmp(columnname,"SEC_CLASS") && ( (!strcmp(columnvalue,"06")) || (!strcmp(columnvalue,"NATO Confidential"))))               {testclass = 16;}
  if(!strcmp(columnname,"SEC_CLASS") && ( (!strcmp(columnvalue,"11")) || (!strcmp(columnvalue,"Confidential Atomal"))))             {testclass = 17;}
  if(!strcmp(columnname,"ZSAX_RS0" ) && ( (!strcmp(columnvalue,"C" )) || (!strcmp(columnvalue,"CONFIDENTIAL"))))                    {testclass = 18;}
  if(!strcmp(columnname,"SEC"      ) && ( (!strcmp(columnvalue,"13")) || (!strcmp(columnvalue,"UK Confidential"))))                 {testclass = 19;}
  if(!strcmp(columnname,"SEC"      ) && ( (!strcmp(columnvalue,"3" )) || (!strcmp(columnvalue,"US Confidential"))))                 {testclass = 20;}
  if(!strcmp(columnname,"SEC"      ) && ( (!strcmp(columnvalue,"9" )) || (!strcmp(columnvalue,"NATO Confidential (NC)"))))          {testclass = 21;}
  if(!strcmp(columnname,"SEC"      ) && ( (!strcmp(columnvalue,"21")) || (!strcmp(columnvalue,"NATO Confidential Atomal (NCA)"))))  {testclass = 22;}
  if(!strcmp(columnname,"TREX")      && ( (!strcmp(Incolumnvalue,"confidential"))))                                                 {testclass = 23;}


  if(!strcmp(columnname,"CLASS")     && ( (!strcmp(columnvalue,"0"))  || (!strcmp(columnvalue,"S")) || (!strcmp(columnvalue,"S (SECRET)")) ))    {testclass = 24;}
  if(!strcmp(columnname,"CLASS")     && ( (!strcmp(columnvalue,"0"))  || (!strcmp(columnvalue,"S (SECRET)"))))                      {testclass = 25;}
  if(!strcmp(columnname,"SEC_CLASS") && ( (!strcmp(columnvalue,"S" )) || (!strcmp(columnvalue,"Secret"))))                          {testclass = 26;}
  if(!strcmp(columnname,"SEC_CLASS") && ( (!strcmp(columnvalue,"03")) || (!strcmp(columnvalue,"NATO Secret"))))                     {testclass = 27;}
  if(!strcmp(columnname,"SEC_CLASS") && ( (!strcmp(columnvalue,"04")) || (!strcmp(columnvalue,"NATO Secret-Savate"))))              {testclass = 28;}
  if(!strcmp(columnname,"SEC_CLASS") && ( (!strcmp(columnvalue,"05")) || (!strcmp(columnvalue,"NATO Secret-Avicula"))))             {testclass = 29;}
  if(!strcmp(columnname,"SEC_CLASS") && ( (!strcmp(columnvalue,"10")) || (!strcmp(columnvalue,"Secret Atomal"))))                   {testclass = 30;}
  if(!strcmp(columnname,"ZSAX_RS0" ) && ( (!strcmp(columnvalue,"S" )) || (!strcmp(columnvalue,"SECRET"))))                          {testclass = 31;}
  if(!strcmp(columnname,"SEC"      ) && ( (!strcmp(columnvalue,"2" )) || (!strcmp(columnvalue,"US Secret"))))                       {testclass = 32;}
  if(!strcmp(columnname,"SEC"      ) && ( (!strcmp(columnvalue,"12")) || (!strcmp(columnvalue,"UK Secret"))))                       {testclass = 33;}
  if(!strcmp(columnname,"SEC"      ) && ( (!strcmp(columnvalue,"8" )) || (!strcmp(columnvalue,"NATO Secret (NS)"))))                {testclass = 34;}
  if(!strcmp(columnname,"SEC"      ) && ( (!strcmp(columnvalue,"18")) || (!strcmp(columnvalue,"NATO Secret Savate"))))              {testclass = 35;}
  if(!strcmp(columnname,"SEC"      ) && ( (!strcmp(columnvalue,"19")) || (!strcmp(columnvalue,"NATO Secret Avicula"))))             {testclass = 36;}
  if(!strcmp(columnname,"SEC"      ) && ( (!strcmp(columnvalue,"20")) || (!strcmp(columnvalue,"NATO Secret Atomal (NSA)"))))        {testclass = 37;}
  if(!strcmp(columnname,"TREX")      && ( (!strcmp(Incolumnvalue,"secret"))))                                                       {testclass = 38;}


  if(!strcmp(columnname,"SEC_CLASS") && ( (!strcmp(columnvalue,"TS")) || (!strcmp(columnvalue,"Top Secret"))))                      {testclass = 39;}
  if(!strcmp(columnname,"SEC_CLASS") && ( (!strcmp(columnvalue,"01")) || (!strcmp(columnvalue,"COSMIC Top Secret-Bohemia"))))       {testclass = 40;}
  if(!strcmp(columnname,"SEC_CLASS") && ( (!strcmp(columnvalue,"02")) || (!strcmp(columnvalue,"COSMIC Top Secret-Balk"))))          {testclass = 41;}
  if(!strcmp(columnname,"SEC_CLASS") && ( (!strcmp(columnvalue,"09")) || (!strcmp(columnvalue,"COSMIC Top Secret Atom"))))          {testclass = 42;}
  if(!strcmp(columnname,"ZSAX_RS0" ) && ( (!strcmp(columnvalue,"TS")) || (!strcmp(columnvalue,"TOP SECRET"))))                      {testclass = 43;}
  if(!strcmp(columnname,"SEC"      ) && ( (!strcmp(columnvalue,"1" )) || (!strcmp(columnvalue,"US Top Secret"))))                   {testclass = 44;}
  if(!strcmp(columnname,"SEC"      ) && ( (!strcmp(columnvalue,"6" )) || (!strcmp(columnvalue,"COSMIC Top Secret (CTS)"))))         {testclass = 45;}
  if(!strcmp(columnname,"SEC"      ) && ( (!strcmp(columnvalue,"7" )) || (!strcmp(columnvalue,"FOCAL Top Secret (FTS)"))))          {testclass = 46;}
  if(!strcmp(columnname,"SEC"      ) && ( (!strcmp(columnvalue,"11")) || (!strcmp(columnvalue,"UK Top Secret"))))                   {testclass = 47;}
  if(!strcmp(columnname,"SEC"      ) && ( (!strcmp(columnvalue,"15")) || (!strcmp(columnvalue,"COSMIC Top Secret (CTS) Bohemia")))) {testclass = 48;}
  if(!strcmp(columnname,"SEC"      ) && ( (!strcmp(columnvalue,"16")) || (!strcmp(columnvalue,"COSMIC Top Secret (CTS) Balk"))))    {testclass = 49;}
  if(!strcmp(columnname,"SEC"      ) && ( (!strcmp(columnvalue,"17")) || (!strcmp(columnvalue,"COSMIC Top Secret Atomal (CTSA)")))) {testclass = 50;}
  if(!strcmp(columnname,"TREX")      && ( (!strcmp(Incolumnvalue,"topSecret"))))                                                    {testclass = 51;}



  if(testclass > ClassLevel)
    {
	  printf("Setting class level to %d\n",testclass);

	  

      sprintf(columnvalue2,"%s",Incolumnvalue);

      insertindex = 0;
      len = strlen(columnvalue2);
      for(i=0;i<len;i++)
	  { 
        if(columnvalue2[i]!='"')
		{ 
          columnvalue[insertindex] = columnvalue2[i];  
          insertindex = insertindex + 1;
		} 
	  } 

      columnvalue[insertindex] = '\0';


	  if(tablename==NULL)
	  {
	    sprintf(SaveClassTable,"%s",filename);
	    sprintf(SaveClassValue,"%s",columnvalue);
	  }
	  else
	  {
	    sprintf(SaveClassTable,"%s:%s",filename,tablename);
	    sprintf(SaveClassValue,"%s",columnvalue);
	  }
      ClassLevel = testclass;
    }

  return 0;
}






#define UTF8_INVALID_BYTE_ERROR                  0
#define UTF8_UNEXPECTED_CONTINUTATION_BYTE_ERROR 1
#define UTF8_UNEXPECTED_ASCII_BYTE_ERROR         2
#define UTF8_UNEXPECTED_START_BYTE_ERROR         3
#define UTF8_TOOMANYBYTES_ERROR                  4
#define UTF8_OVERLONG_ERROR                      5
#define UTF8_ENDWITHOUTCONTINUATION_ERROR        6
#define UTF8_CODEPOINT1_ERROR                    7
#define UTF8_CODEPOINT2_ERROR                    8
#define UTF8_CODEPOINT3_ERROR                    9
#define UTF8_CODEPOINT4_ERROR                    10
#define UTF8_ValidInvalid_ERROR                  11


char *UTF8errors[] = {
    "invalid byte (C0, C1, or F5-FF)",
    "unexpected continuation byte; ASCII or start byte expected",
    "unexpected ASCII byte; continuation byte expected",
    "unexpected start byte; continuation byte expected",
    "too many bytes in UTF character: a maximum of 4 are allowed",
    "overlong sequence",
	"unexpected end of string; continuation byte expected",
    "invalid codepoint (codepoint >= U+110000)",
    "invalid codepoint (codepoint >= U+fdd0 AND <=U+fdef)",
    "invalid codepoint (last 2 codepoints of each plane {FFFE and FFFF} are invalid)",
    "invalid codepoint (surrogate pair values (U+d800 to U+dfff) are invalid)",
	"Valid UTF-8, but not on MGCP TRD4 accepted list"
};


void UTF2_Error(int errindex,const unsigned char *instring,int record_num,char *attr_name,
			   char *shape_to_import,int err_location)
{
  int i;
  extern FILE *utfout;

  if(utfout==NULL)
  {
    printf("UTF error while reading XML: %s\n",instring);
	return;
  }

  fprintf(utfout,"UTF-8 encoding anomaly for file/table: %s:\n",shape_to_import);
  fprintf(utfout," Record %d, attribute %s\n",record_num,attr_name);
  fprintf(utfout," Details: %s\n",UTF8errors[errindex]);

  if(errindex==4)
  {
    fprintf(utfout,"  Invalid number of bytes in single sequence: %d\n",err_location);
  }
  else if((errindex>=7)&&(errindex<=11))
  {
	
    fprintf(utfout,"  Invalid codepoint: U+%08X\n",err_location);
  }

  if(errindex<6)
  {
    fprintf(utfout," Hexadecimal encoding of the invalid attribute value (with ** surrounding the first problem byte):");
  }
  else
  {
    fprintf(utfout," Hexadecimal encoding of the invalid attribute value:");
  }

  for(i=0;i<(int)strlen((char *)instring);i++)
  {
	if(i%20==0)
	{
      fprintf(utfout,"\n   ");
	}

    if((i==err_location)&&(errindex<6))
	{
      fprintf(utfout,"**%02X** ",(unsigned char)instring[i]);
	}
	else
	{
      fprintf(utfout,"%02X ",(unsigned char)instring[i]);
	}
  }

  fprintf(utfout,"\n\n");

}



int msz(unsigned char value) 
{
  int r = 0;

  

  if (value == 0xff)
  {
    return -1;
  }

  value = ~value;
    
  while (value >>= 1)
  {
    r++;
  }

  return r;
}



int valid_codepoint2(unsigned int cp) 
{
  
 
  if(cp >= 0x110000)
  {
    return 0;
  }

  if( (cp>=0xfdd0) && (cp<=0xfdef) )
  {
    return 0;
  }

  if( (cp & 0xfffe) == 0xfffe )
  {
    return 0;
  }

  if( (cp & 0xfffff800) == 0xd800 ) 
  {
	return 0;
  }

  return 1;
}


int BadCodePointMGCP4(unsigned int cp,char *attr_name)
{
  int i,start;
  extern int StringCaseInsensitiveMatch(char * a, char *b);
 
  start = 1;

  if(StringCaseInsensitiveMatch(attr_name,"CCN"))
  {
	start = 0;
  }

  for(i=start;i<MGCP_UTF8_WHITELIST_NUM;i++)
  {
    if(cp==MGCP_UTF8_Whitelist[i])
	{
	  return 0; 
	}
  }
  return 1; 
}


int valid_codepoint(unsigned int cp,const unsigned char *instring,int record_num,char *attr_name,
			   char *shape_to_import,int err_location) 
{
  

  if(cp >= 0x110000)
  {
    

	UTF2_Error(UTF8_CODEPOINT1_ERROR,instring,record_num,attr_name,shape_to_import,cp);
    return 0;
  }

  if( (cp>=0xfdd0) && (cp<=0xfdef) )
  {
    

	UTF2_Error(UTF8_CODEPOINT2_ERROR,instring,record_num,attr_name,shape_to_import,cp);
    return 0;
  }

  if( (cp & 0xfffe) == 0xfffe )
  {
    

	UTF2_Error(UTF8_CODEPOINT3_ERROR,instring,record_num,attr_name,shape_to_import,cp);
    return 0;
  }

  if( (cp & 0xfffff800) == 0xd800 ) 
  {
    

	UTF2_Error(UTF8_CODEPOINT4_ERROR,instring,record_num,attr_name,shape_to_import,cp);
	return 0;
  }


  if(ATTRTYPE_MGCP4())
  {
	if(BadCodePointMGCP4(cp,attr_name))
	{
	  
	  UTF2_Error(UTF8_ValidInvalid_ERROR,instring,record_num,attr_name,shape_to_import,cp);
	  return 0;
	}
  }

  return 1;
}


int GoodUTF(const unsigned char *instring,int record_num,char *attr_name,char *shape_to_import) 
{
  int i,msz_byte,state=0,cpbytes=0,len;
  unsigned char byte;
  unsigned int cp;
  unsigned int offset = 0;

  len = strlen((char *)instring);

  for(i=0;i<len;i++)
   {
      byte = instring[i];

      msz_byte = msz(byte);

      if ( (byte==0xc0) || (byte==0xc1) ||  ((byte>=0xf5)   )  )
	  {
        UTF2_Error(UTF8_INVALID_BYTE_ERROR,instring,record_num,attr_name,shape_to_import,i);
        return 0;
	  }

      switch (state) 
	  {
        case 0:
           if (msz_byte == 6) 
		   {
              UTF2_Error(UTF8_UNEXPECTED_CONTINUTATION_BYTE_ERROR,instring,record_num,attr_name,shape_to_import,i);
              return 0;
		   }
                
		   if ((msz_byte >= 1) && (msz_byte <= 5)) 
		   {
             state = 6 - msz_byte;
             cp = (byte & ((1 << msz_byte) - 1)) << (state * 6);
             cpbytes = 1;
		   }
           break;

        case 1:
        case 2:
        case 3:
        case 4:
        case 5:

           if (msz_byte == 7) 
		   {
             UTF2_Error(UTF8_UNEXPECTED_ASCII_BYTE_ERROR,instring,record_num,attr_name,shape_to_import,i);
             return 0;
           } 
		   else if (msz_byte >= 1 && msz_byte <= 5) 
		   {
             UTF2_Error(UTF8_UNEXPECTED_START_BYTE_ERROR,instring,record_num,attr_name,shape_to_import,i);
             return 0;
           } 
		   else if (msz_byte==6) 
		   {
              cp |= (byte & 0x3f) << (--state * 6);
              cpbytes++;

              if (!state) 
			  {

				if(cpbytes>4)
				{
                  UTF2_Error(UTF8_TOOMANYBYTES_ERROR,instring,record_num,attr_name,shape_to_import,cpbytes);
                  return 0;
				}

                if (
                     (cp <= 0x80) ||
                     (cp <= 0x800 && cpbytes > 2)   ||
                     (cp <= 0x10000 && cpbytes > 3)
                   ) 
				{
                  UTF2_Error(UTF8_OVERLONG_ERROR,instring,record_num,attr_name,shape_to_import,i);
                  return 0;
				}


                if (!valid_codepoint(cp,instring,record_num,attr_name,shape_to_import,i))
				{
				  
                  

                  return 0;
				}



			  }
		   } 
          break;
	  } 
      offset++;
  } 

  if(state)
  {
    UTF2_Error(UTF8_ENDWITHOUTCONTINUATION_ERROR,instring,record_num,attr_name,shape_to_import,i);
	return 0;
  }

  return 1;

}







unsigned int GoodUTF2(const unsigned char *instring) 
{
  int i,msz_byte,state=0,cpbytes=0,len;
  unsigned char byte;
  unsigned int cp;
  unsigned int offset = 0;

  

  len = strlen((char *)instring);

  for(i=0;i<len;i++)
   {
      byte = instring[i];

      msz_byte = msz(byte);

      if ( (byte==0xc0) || (byte==0xc1) ||  ((byte>=0xf5)  )  ) 
	  {
        return 0;
	  }

      switch (state) 
	  {
        case 0:
           if (msz_byte == 6) 
		   {
              return 0;
		   }
                
		   if ((msz_byte >= 1) && (msz_byte <= 5)) 
		   {
             state = 6 - msz_byte;
             cp = (byte & ((1 << msz_byte) - 1)) << (state * 6);
             cpbytes = 1;
		   }
           break;

        case 1:
        case 2:
        case 3:
        case 4:
        case 5:

           if (msz_byte == 7) 
		   {
             return 0;
           } 
		   else if (msz_byte >= 1 && msz_byte <= 5) 
		   {
              return 0;
           } 
		   else if (msz_byte==6) 
		   {
              cp |= (byte & 0x3f) << (--state * 6);
              cpbytes++;

              if (!state) 
			  {

				if(cpbytes>4)
				{
                  return 0;
				}

                if (
                     (cp <= 0x80) ||
                     (cp <= 0x800 && cpbytes > 2)   ||
                     (cp <= 0x10000 && cpbytes > 3)
                   ) 
				{
                  return 0;
				}


                if (!valid_codepoint2(cp))
				{
                  return 0;
				}
			  }
		   } 
          break;
	  } 
      offset++;

  } 

  if(state)
  {
	return 0;
  }

  return cp;

}







char *MakeUTF(const unsigned char *instring, int record_num, char *attr_name, char *shape_to_import)
{
  static char retval[5000];


  if((VERBOSE_UTF==1)&&(record_num==4))
  {
    printf("\n\n");
    printf("Checking UTF for record %d, attr %s\n",record_num,attr_name);
    printf("...value:  %d\n",GoodUTF(instring,record_num,attr_name,shape_to_import));
  }
  else if((VERBOSE_UTF==0)&&(record_num>=0))
  {
    GoodUTF(instring,record_num,attr_name,shape_to_import);
  }

  sprintf(retval,"%s",instring);
  return retval;
}




void GetFields(TimDBFHandle hDBF,int totalnum)
{
  

  int i,tempI;
  int nWidth,nDecimals;
  int err_width,id_width,ret_width,geom_width;
  int instance_index,mag_index,id_index,cond_index,ret_index,geom_index,err_index;
  TimDBFFieldType	eType[1000]; 
  char title[1000][12];
  char temp[2000];
  int foundmag=0,founderrnum=0,foundinstance=0,foundgeom=0,foundid=0,foundretain=0,foundcondnum=0;

    
  for(i=0;i<totalnum;i++)
    {
      temp_short[i] = 0;  
    }


  for(i=0; i<TimDBFGetFieldCount(hDBF); i++)
    {
      eType[i] = TimDBFGetFieldInfo(hDBF,i,title[i],&nWidth,&nDecimals);
      

      
      for(tempI=0;tempI<(int)strlen(title[i]);tempI++)
	{
	  title[i][tempI] = timtoupper(title[i][tempI]);
	}
      
      if(!strcmp(title[i],"MAGNITUDE"))
	{
	  mag_index = 1;

	  if(eType[i]==FTDouble)
	    {
	      foundmag = 1;
	    }
	}
      if(!strcmp(title[i],"INSTANCE"))
	{
	  instance_index = i;

	  if(eType[i]==FTInteger)
	    {
	      foundinstance = 1;
	    }
	}
      if(!strcmp(title[i],"ERRTYPE"))
	{
	  err_width = nWidth;
	  err_index = i;

	  if(eType[i]==FTString)
	    {
	      founderrnum = 1;
	    }
	}
      if(!strcmp(title[i],"GFID"))
	{
	  id_width = nWidth;
	  id_index = i;

	  if(eType[i]==FTString)
	    {
	      foundid = 1;
	    }
	}
      if(!strcmp(title[i],"FLDBID"))
	{
	  id_width = nWidth;
	  id_index = i;

	  if(eType[i]==FTString)
	    {
	      foundid = 2;
	    }
	}
      if(!strcmp(title[i],"UID"))
	{
	  id_width = nWidth;
	  id_index = i;

	  if(eType[i]==FTString)
	    {
	      foundid = 3;
	    }
	}

      if(!strcmp(title[i],"UFI"))
	{
	  id_width = nWidth;
	  id_index = i;

	  if(eType[i]==FTString)
	    {
	      foundid = 4;
	    }
	}

      if(!strcmp(title[i],"UUID_1"))
	{
	  id_width = nWidth;
	  id_index = i;

	  if(eType[i]==FTString)
	    {
	      foundid = 5;
	    }
	}

      if(!strcmp(title[i],"RETAINIGN"))
	{
	  ret_width = nWidth;
	  ret_index = i;

	  if(eType[i]==FTString)
	    {
	      foundretain = 1;
	    }
	}
      if(!strcmp(title[i],"ORIG_GEOM"))
	{
	  geom_width = nWidth;
	  geom_index = i;

	  if(eType[i]==FTString)
	    {
	      foundgeom = 1;
	    }
	}
      if(!strcmp(title[i],"COND_NUM"))
	{
	  cond_index = i;

	  if(eType[i]==FTInteger)
	    {
	      foundcondnum = 1;
	    }
	}
    }

  
  
  
  if(
     (foundmag==0) ||
     (founderrnum==0) ||
     (foundinstance==0) ||
     (foundgeom==0) ||
     (foundid==0) ||
     (foundretain==0) ||
     (foundcondnum==0) 
     )
    {
      return;
    }


  


  for( i = 0; i < totalnum; i++ )
    {
     
      temp[0] = '\0';
      sprintf(temp,"%s",MakeUTF((unsigned char *)TimDBFReadStringAttribute(hDBF,i,ret_index),-1," "," "));


      if(!strcmp(temp,"IGNORE"))
	{
	  temp[0] = '\0';
	  sprintf(temp,"%s",MakeUTF((unsigned char *)TimDBFReadStringAttribute(hDBF,i,id_index),-1," "," "));
	  

	  if(
	     (strcmp(temp,"N/A"))                             &&
	     (strcmp(temp,"No GFID found"))                                  &&
	     (strcmp(temp,"No FLDBID found"))                                &&
	     (strcmp(temp,"No UID found"))                                   &&
	     (strcmp(temp,"No UFI found"))
	     )
	    {
	      
	      GL_IDs[i]    = (char *)malloc(id_width+5);
	      GL_IDs[i][0] = '\0';
	      sprintf(GL_IDs[i],"%s",MakeUTF((unsigned char *)TimDBFReadStringAttribute(hDBF,i,id_index),-1," "," "));

	      GL_geoms[i]    = (char *)malloc(geom_width+5);
	      GL_geoms[i][0] = '\0';
	      sprintf(GL_geoms[i],"%s",MakeUTF((unsigned char *)TimDBFReadStringAttribute(hDBF,i,geom_index),-1," "," "));

	      GL_errnums[i]    = (char *)malloc(err_width+5);
	      GL_errnums[i][0] = '\0';
	      sprintf(GL_errnums[i],"%s",MakeUTF((unsigned char *)TimDBFReadStringAttribute(hDBF,i,err_index),-1," "," "));

	      GL_magnitudes[i] = TimDBFReadDoubleAttribute(hDBF,i,mag_index);
	      GL_condnums  [i] = TimDBFReadIntegerAttribute(hDBF,i,cond_index);
	      GL_instances [i] = TimDBFReadIntegerAttribute(hDBF,i,instance_index);

	      temp_short[i] = 1;
	    }
	}
    }
}



void TestMGCPFilename(char *shape_to_import, char *inshortname)
{
  int i,len,lastquote=0;
  char possiblefcode[10],shortname[500];
  extern int SilentConvertClassCode(char *oldcode);

    
  if((ATTRIBUTION_TYPE!=7)&&(ATTRIBUTION_TYPE!=8))
  {
    return;
  }


  len = strlen(inshortname);


  if(len>8)
  {
    
	

	for(i=0;i<len;i++)
	{
      if(inshortname[i]==';')
	  {
        lastquote = i;
	  }
	}

	if(lastquote>0)
	{
      sprintf(shortname,"%s",&inshortname[lastquote+1]);
	}
	else
	{
      sprintf(shortname,"%s",inshortname);
	}
  }
  else
  {
    sprintf(shortname,"%s",inshortname);
  }

  len = strlen(shortname);


  if ( 
	  (len!=6) && 
	  (len!=8)    
	  )
    {
      AddBadFilename(shape_to_import);
      return;
    }



  if(
     (shortname[0]!='P') &&
     (shortname[0]!='L') &&
     (shortname[0]!='A')
     )
    {
      AddBadFilename(shape_to_import);
      return;
    }

  for(i=1;i<6;i++)
    {
      possiblefcode[i-1] = shortname[i];
    }
  possiblefcode[5] = '\0';

  
  if(SilentConvertClassCode(possiblefcode)==-100)
    {
      AddBadFilename(shape_to_import);
      return;
    }
  
  if(strlen(shortname)==6)
    {
      return;
    }


  
  
  
  
  if(shortname[6]!='_')
    {
      AddBadFilename(shape_to_import);
      return;
    }

  if((shortname[7]<'1')||(shortname[7]>'9'))
    {
      AddBadFilename(shape_to_import);
      return;
    }
  
}




int EvalValue(int oldval, char *shape_to_import,char attr_name[],int thisintval,double thisrealval,
	       char *thisstrval,int type)
{
  

  extern  int RealClose(double a, double b);
  int Itestval;
  double Dtestval;


  if(ATTRTYPE_MGCP4())
  {
    
    return -100;
  }


  if(!strcmp(attr_name,"BRF"))
    {
      Itestval = -2147483647;
      Dtestval = -2147483647.0;
    }
  else
    {
      Itestval = -32768;
      Dtestval = -32768.0;
    }
 
  if((oldval==-100)||(oldval==-11))
    {
      return oldval;
    }
  
  if(type==1)
    {
      
      if((oldval==-10)&&(thisintval==Itestval))
	{
	  return -11;
	}
      else if((oldval==-1)&&(thisintval!=Itestval))
	{
	  return -11;
	}
      else if((oldval==1)&&(thisintval==Itestval))
	{
	  return -1;
	}
      else if((oldval==1)&&(thisintval!=Itestval))
	{
	  return -10;
	}
      return oldval;
    }
  else if(type==2)
    {
      
      if((oldval==-10)&&(RealClose(thisrealval,Dtestval)==1))
	{
	  return -11;
	}
      else if((oldval==-1)&&(RealClose(thisrealval,Dtestval)==0))
	{
	  return -11;
	}
      else if((oldval==1)&&(RealClose(thisrealval,Dtestval)==1))
	{
	  return -1;
	}
      else if((oldval==1)&&(RealClose(thisrealval,Dtestval)==0))
	{
	  return -10;
	}
      return oldval;
    }
  else if(type==3)
    {
      
      if((oldval==-10)&&(!strcmp(thisstrval,"N/A")))
	{
	  return -11;
	}
      else if((oldval==-1)&&(strcmp(thisstrval,"N/A")))
	{
	  return -11;
	}
      else if((oldval==1)&&(!strcmp(thisstrval,"N/A")))
	{
	  return -1;
	}
      else if((oldval==1)&&(strcmp(thisstrval,"N/A")))
	{
	  return -10;
	}
      return oldval;
    }
  else if(type==4)
    {
      
      if((oldval==-10)&&(!strcmp(thisstrval,"\"N/A\"")))
	{
	  return -11;
	}
      else if((oldval==-1)&&(strcmp(thisstrval,"\"N/A\"")))
	{
	  return -11;
	}
      else if((oldval==1)&&(!strcmp(thisstrval,"\"N/A\"")))
	{
	  return -1;
	}
      else if((oldval==1)&&(strcmp(thisstrval,"\"N/A\"")))
	{
	  return -10;
	}
      return oldval;
    }
  else
    {
      printf("Error: Bad type to EvalValue %d\n",type);
      return oldval;
    }
  
  return oldval;
}



int GetOptional(char *fcode,char *attrcode,int geom)
{
  char targetfcode   [1000];
  char targetattrcode[1000];
  int foundit,i;


  if(ATTRIBUTION_TYPE!=7)  
    {
      return -100;
    }

  

  sprintf(targetfcode,   "%s ",fcode);
  sprintf(targetattrcode," %s",attrcode);

  for(i=0;i<(int)strlen(targetattrcode);i++)
    {
      targetattrcode[i] = toupper(targetattrcode[i]);      
    }
  

  foundit = 0;
  
  if(geom==C_AREA)
    {
      for(i=0;i<MGCP3_A_OPTCOUNT;i++)
	{
	  if(strstr(MGCP3_a_optional[i],"GIFD_D4_metadata"))
	    {
	      if(strstr(MGCP3_a_optional[i],targetattrcode)!=NULL)
		{
		  return 1;
		}
	    }
	  else if(strstr(MGCP3_a_optional[i],targetfcode)!=NULL)
	    {
	      foundit = 1;
	      
	      if(strstr(MGCP3_a_optional[i],targetattrcode)!=NULL)
		{
		  return 1;
		}
	    }
	  else if(foundit==1)
	    {
	      
	      return -100;
	    }
	}
    }
  else if(geom==C_LINE)
    {
      for(i=0;i<MGCP3_L_OPTCOUNT;i++)
	{
	  if(strstr(MGCP3_l_optional[i],"GIFD_D4_metadata"))
	    {
	      if(strstr(MGCP3_l_optional[i],targetattrcode)!=NULL)
		{
		  return 1;
		}
	    }
	  else if(strstr(MGCP3_l_optional[i],targetfcode)!=NULL)
	    {
	      foundit = 1;
	      
	      if(strstr(MGCP3_l_optional[i],targetattrcode)!=NULL)
		{
		  return 1;
		}
	    }
	  else if(foundit==1)
	    {
	      
	      return -100;
	    }
	}
    }
  else if(geom==C_POFE)
    {
      for(i=0;i<MGCP3_P_OPTCOUNT;i++)
	{
	  if(strstr(MGCP3_p_optional[i],"GIFD_D4_metadata"))
	    {
	      if(strstr(MGCP3_p_optional[i],targetattrcode)!=NULL)
		{
		  return 1;
		}
	    }
	  else if(strstr(MGCP3_p_optional[i],targetfcode)!=NULL)
	    {
	      foundit = 1;
	      
	      if(strstr(MGCP3_p_optional[i],targetattrcode)!=NULL)
		{
		  return 1;
		}
	    }
	  else if(foundit==1)
	    {
	      
	      return -100;
	    }
	}
    }
  else
    {
      printf("bad geom %d to GetOptional\n",geom);
      return -100;
    }
  
  
  
  return -100;
}



void TestWidth(int fieldtype,char attrcode[], int width)
{
  int intcode;
  char len1[1000],len2[1000];
  int *lens;
  char **types;
  extern int   MGCP3_attr_lens[];
  extern char *MGCP3_attr_types[];
  extern int   MGCP4_attr_lens[];
  extern char *MGCP4_attr_types[];


  



  intcode = ConvertAttrCode(attrcode);

  if(intcode<0)
    {
      return;
    }


  if(ATTRTYPE_MGCP3())
  {
    lens = MGCP3_attr_lens;
	types = MGCP3_attr_types;
  }
  else if(ATTRTYPE_MGCP4())
  {
    lens = MGCP4_attr_lens;
	types = MGCP4_attr_types;
  }
  else
  {
    printf("Error in TW: %d\n",ATTRIBUTION_TYPE);
	return;
  }



  


  sprintf(len1,"%d",lens[intcode]);
  sprintf(len2,"%d",width);



  
  if(
     (fieldtype==1) && 
     (!strcmp(types[intcode],"String"))  
     )
    {
      if(width!=lens[intcode])
	  {	  
		if((lens[intcode]!=255)||(width!=254))
		{
		  
          sprintf(len1,"%d",lens[intcode]);
	     AddBadLen(intcode,len1,len2);
		}
	  }
    }
  else if( 
	  (fieldtype==2) && 
	  ( (!strcmp(types[intcode],"Integer")) || (!strcmp(types[intcode],"Short Integer")) )
	  )
    {
      if(width!=lens[intcode])
	{
	  AddBadLen(intcode,len1,len2);
	}
    }
  else if(
	  (fieldtype==3) &&
	  (!strcmp(types[intcode],"Real"))
	  )
    {
      if(width!=lens[intcode])
	{
	  AddBadLen(intcode,len1,len2);
	}
    }
  else if(width!=lens[intcode])
    {
	  

	  
    }
  
}


char *MakeCSV(char *instr)
{
  int i,insertindex,len;
  static char outstr[500];

  len = strlen(instr);
  insertindex = 0;

  for(i=0;i<len;i++)
  {
    if(instr[i]!='"')
	{
	  outstr[insertindex] = instr[i];
	  insertindex = insertindex + 1;
	}
	else
	{
	  outstr[insertindex] = instr[i];
	  insertindex = insertindex + 1;

	  outstr[insertindex] = instr[i];
	  insertindex = insertindex + 1;
	}
  }

  outstr[insertindex] = '\0';
  return outstr;
}



char *MakeCSV2(char *instr)
{
  int i,insertindex,len;
  static char outstr[500];

  len = strlen(instr);
  insertindex = 0;

  for(i=0;i<len;i++)
  {
    if(instr[i]!='"')
	{
	  outstr[insertindex] = instr[i];
	  insertindex = insertindex + 1;
	}
	else
	{
	  outstr[insertindex] = instr[i];
	  insertindex = insertindex + 1;

	  outstr[insertindex] = instr[i];
	  insertindex = insertindex + 1;
	}
  }

  outstr[insertindex] = '\0';
  return outstr;
}



int DoBlankAttr()
{
  if(
     (ATTRTYPE_MGCP3())||(ATTRTYPE_MGCP4())  || 
	 (ATTRTYPE_ANY_TDS())
	)
  {
    return 1;
  }

  return 0;
}


void AddBlankAttr(char filename[],char attribute[],int record_num,int datatype)
{
  struct SH_BadCodes *temp,*prev;

  if(DoBlankAttr()==0)
  {
    return;
  }

  if(datatype==0)
	{
	  fprintf(nullattrval,"File %s, column %s, record %d is a blank integer\n",filename,attribute,record_num);
	  fprintf(nullattrcsv,"\"%s\",\"%s\",\"%d\",\"Blank Integer\"\n",MakeCSV(filename),MakeCSV2(attribute),record_num);
	}
  else if(datatype==1)
	{
	  fprintf(nullattrval,"File %s, column %s, record %d is a blank real\n",filename,attribute,record_num);
	  fprintf(nullattrcsv,"\"%s\",\"%s\",\"%d\",\"Blank Real\"\n",MakeCSV(filename),MakeCSV2(attribute),record_num);
	}
  else if(datatype==2)
	{
	  if(ATTRTYPE_TDS4())
	  {
         
         return;
	  }

	  fprintf(nullattrval,"File %s, column %s, record %d is a blank string\n",filename,attribute,record_num);
	  fprintf(nullattrcsv,"\"%s\",\"%s\",\"%d\",\"Blank String\"\n",MakeCSV(filename),MakeCSV2(attribute),record_num);
	}
  else
	{
		printf("bad data type to ABA: %d\n",datatype);
		exit(1);
	}
    
  

  temp  = Gblankroot;
  
  while(temp!=NULL)
    {
      if(!strcmp(temp->code,attribute))
	  {
		temp->num = temp->num + 1;
	    return; 
	  }
      temp = temp->next;
    }
 

  

  temp = Gblankroot;
  prev = NULL;
  
  while(temp!=NULL)
    {    
#if(USE_DOS==1)
      {
        if(_stricmp(temp->code,attribute)>=0) 
	  {
	    break;
	  }
      }
#else
      {
        if(strcasecmp(temp->code,attribute)>=0) 
	  {
	    break;
	  }
      }
#endif
      prev = temp;
      temp = temp->next;
    }
  
  
  temp = (struct SH_BadCodes *) malloc(sizeof(struct SH_BadCodes));
  if(temp==NULL){printf("temp8: unable to malloc\n"); exit(-1);}
  
  temp->code = (char *) malloc(strlen(attribute)+5);
  if(temp->code==NULL){printf("temp9: unable to malloc\n"); exit(-1);}
  sprintf(temp->code,"%s",attribute);
  temp->num = 1;
  temp->message = NULL;
  temp->FIDs    = NULL;      

  if(prev==NULL)
    {
      

      if(Gblankroot==NULL)
	{
	  temp->next = NULL;
	}
      else
	{
	  temp->next = Gblankroot;
	}
      Gblankroot = temp;
    }
  else
    {
      temp->next    = prev->next;
      prev->next    = temp;
    }


  if(Gblankroot==NULL)
    {
      Gblankroot = temp;
    }
}





int GetLongValues(char *filename,char *attrname,TimDBFFieldType etype,TimDBFHandle hDBF, int record_num, int attr_index,
				  char *Cval,int *Ival,double *Dval)
{
  char tempstr[1000];
  int tempint;
  double tempdouble;
  extern int NULLINT;
  
  if(etype==FTString)
    {
      tempstr[0] = '\0';
      sprintf(tempstr,"%s",MakeUTF((unsigned char *)TimDBFReadStringAttribute(hDBF,record_num,attr_index),record_num,attrname,filename));
      
      if(tempstr[0]!='\0')
	{
	  sprintf(Cval,"%s",tempstr);
	  return C_TYPE;
	}
      else
	{
	  
	  sprintf(Cval,"NULL string found");
	  AddBlankAttr(filename,attrname,record_num,2); 
	  return C_TYPE;
	}
    }
  
  else if(etype==FTDouble)
    {		      
      tempdouble = TimDBFReadDoubleAttribute(hDBF,record_num,attr_index);
      if(NULLINT==1)
	{
	  AddBlankAttr(filename,attrname,record_num,1); 
	  return NOTYPE;
	}
      else
	{
	  *Dval = tempdouble;
	  return D_TYPE;
	}
    }
  
  else if(etype==FTInteger)
    {		      
      tempint = TimDBFReadIntegerAttribute(hDBF,record_num,attr_index);
      
      if(NULLINT==1)
	{
	  printf("found null int for long int value\n");
	  AddBlankAttr(filename,attrname,record_num,0); 
	  return NOTYPE;
	}
      else
	{
	  *Ival = tempint;
	  return I_TYPE;
	}
    }
  
  
  return NOTYPE;
  
}



void HandleDoublePickListVal(int attr_code, double thisrealval,int *GEOMTYPE,
							 unsigned char *SEDRIStype, int *retenum, int record_num)
{
  char enumvalue[1000];
  int Ival,newenum;
  double Dval;


  

  Ival = (int)thisrealval;
  Dval = (double)Ival;

  if(Dval!=thisrealval)
  {
	
	*GEOMTYPE = -999;

	sprintf(enumvalue,"%lf",thisrealval);
	AddBadAttr(attr_code, enumvalue, record_num);
 
	return;
  }

  sprintf(enumvalue,"%d",Ival);

  newenum = GetNewEnum(attr_code,
	 				   enumvalue,
				       0,
					   record_num);
			      
  if(newenum>=0)
  {
	
	*GEOMTYPE   = 3;
	*SEDRIStype = TIM_ENUMERANT;
	*retenum    = newenum;
	  
	
	return;
  } 
  else
  {
	 
	 sprintf(enumvalue,"%lf",thisrealval);
	 AddBadAttr(attr_code, enumvalue, record_num);
     *GEOMTYPE = -999;
  }

  *GEOMTYPE = -999;
}






int IsSubtype(char *attr_name)
{
  extern int StringCaseInsensitiveMatch(char * a, char *b);

  if(ATTRTYPE_ANY_GGDM()==1)
  {
    if(StringCaseInsensitiveMatch(attr_name,"fcsubtype"))
	{
      return 1;
	} 
  }

  return 0;
}


void BuildIndices(TimDBFHandle hDBF,int totalnum,int seeitgeom, 
		  char *allshapes, char *shape_to_import, int files_done, 
		  char *fcode, char *shortname, int doattr, TimSHPHandle hSHP)
{
  
  
  
  
  TimDBFFieldType	eType[1000]; 
  unsigned char SEDRIStype;
  char Cvalue[5000],thiscode[5000],savegfid[5000],title[1000][12],SaveAreaC[1000],
    enumvalue[5000],scrubenumvalue[5000],thisstrval[5000],filename[1000],
	SaveZv2C[1000],SaveHgtC[1000],SaveLenC[1000],SaveNamC[1000],
	saveNFN[1000],saveNFI[1000],saveNAM[1000],sav996[500],sav999[500],
	expmessage[300],foundmessage[300];
  int record_num,i,nWidth,nDecimals,sh_sac_short_index=0,sh_sac_long_index=0,
    nfields,new_attr_code,gifd_found,tempI,foundpossibleclass=0,firstbad,
    mgcpfcodefound=0,attr_code[5000],optional_attribute[5000],newenum,zz,len,
    thisintval=0,GEOMTYPE,badfound,Ivalue,class_code,other_class_code,j,k,
    SaveAreaI=0,SaveZv2I=0,area_found,zv2_found,tempcode,attrindex,
	SaveHgtI=0,SaveLenI=0,SaveNamI=0,hgt_found,len_found,nam_found,
	lastindex=0,totalnum2,thisindex,starter;
  double Dvalue,thisrealval=0,SaveAreaD=0.0,SaveZv2D=0.0,tempDval,
	  SaveHgtD=0.0,SaveLenD=0.0,SaveNamD=0.0;
  
  char **thearr;

  struct sh_long_attr_list  SH_SAC_LONG [SH_LISTLEN];   
  struct sh_short_attr_list SH_SAC_SHORT[SH_LISTLEN]; 

  extern int NULLINT;
  extern int *gifd_attr_enum_count;
  extern char **gifd_attr_types;
  extern int SilentGetAttrIndex(char *eac);
  extern int global_trex_shape_layer,gcpindex2_0,gcpindex2_1,gcpindex2_2,gcpindex2_3;


  if(strlen(specialAfilename)>0)
    {
      sprintf(filename,"%s",specialAfilename);
    }
  else
    {
      sprintf(filename,"%s",shape_to_import);
    }
  
  
  if(temp_short!=NULL)
    {
      free(temp_short);
      temp_short = NULL;
    }
  if(temp_long!=NULL)
    {
      free(temp_long);
      temp_long = NULL;
    }
  if(gifd_ids!=NULL)
    {
      free(gifd_ids);
      gifd_ids = NULL;
    }
  
  
  
  
  temp_short = (int *) malloc(sizeof(int) * totalnum);
  if(temp_short==NULL){printf("temp_short: out of mem\n"); exit(-1);}
  
  temp_long  = (int *) malloc(sizeof(int) *totalnum);
  if(temp_long==NULL){printf("temp_long: out of mem\n"); exit(-1);}
  
  gifd_ids  = (int *) malloc(sizeof(int) *totalnum);
  if(gifd_ids==NULL){printf("gifd_ids: out of mem\n"); exit(-1);}
  
  
  

  
  



  for(i=0;i<SH_LISTLEN;i++)
    {
      SH_SAC_LONG [i].lod_stuff = NULL;
      SH_SAC_SHORT[i].lod_stuff = NULL;
      SH_SAC_LONG [i].nam_stuff = NULL;
      SH_SAC_SHORT[i].nam_stuff = NULL;
      SH_SAC_LONG [i].Cvalue    = NULL;
    }
  
  
  
  nfields = TimDBFGetFieldCount(hDBF);
  
  if(doattr==1)
    {  
      for(i=0; i<nfields; i++)
	{
	  eType[i] = TimDBFGetFieldInfo(hDBF,i,title[i],&nWidth,&nDecimals);
	  
	  
	  for(tempI=0;tempI<(int)strlen(title[i]);tempI++)
            {
              title[i][tempI] = timtoupper(title[i][tempI]);
            }
	  
	  
	  
	  
	  if(LongCode(title[i]))
	    {
	      attr_code[i] = -100;
	      
	      
	      
	      tempcode = ConvertAttrCode(title[i]);
	      if(tempcode>=0)
		{
		  
		  badfound = 0;
		  
		  if(eType[i]==FTString)
		    {
		      if(
			 strcmp( gifd_attr_types[tempcode],"Date") &&
			 strcmp( gifd_attr_types[tempcode],"Notgiven") &&
			 strcmp( gifd_attr_types[tempcode],"String") 
			 )
			{
			  AddBadType(tempcode,gifd_attr_types[tempcode],"String");
			  badfound = 1;
			}
		    }
		  else if(eType[i]==FTDouble)
		    {	
		      if(
			 strcmp( gifd_attr_types[tempcode],"Notgiven") &&
			 strcmp( gifd_attr_types[tempcode],"Double") &&
			 strcmp( gifd_attr_types[tempcode],"Real") &&
			 strcmp( gifd_attr_types[tempcode],"Float")
			 )
			{
			  AddBadType(tempcode,gifd_attr_types[tempcode],"Real");
			  badfound = 1;
			}
		    }
		  else if(eType[i]==FTInteger)
		    {
		      if(
			 strcmp( gifd_attr_types[tempcode],"Notgiven")      &&
			 strcmp( gifd_attr_types[tempcode],"Short Integer") &&
			 strcmp( gifd_attr_types[tempcode],"Integer")       &&
			 strcmp( gifd_attr_types[tempcode],"ShortInteger")  &&
			 strcmp( gifd_attr_types[tempcode],"Long Integer")  &&
			 strcmp( gifd_attr_types[tempcode],"LongInteger") 
			 )
			{
			  AddBadType(tempcode,gifd_attr_types[tempcode],"Integer");
			  badfound = 1;
			}
		    }
		  else if(eType[i]==FTSpecial)  
		    {
		      eType[i] = FTString;  
		      
		      if(strcmp( gifd_attr_types[tempcode],"Date"))
			{
			  AddBadType(tempcode,gifd_attr_types[tempcode],"Date");
			  badfound = 1;
			}
		    }
		  

		  if((ATTRTYPE_MGCP3())||(ATTRTYPE_MGCP4()))
		    {
		      if(badfound==0)
			{
			  if(eType[i]==FTString)
			  {
			    TestWidth(1,title[i],nWidth);
			  }
			  else if(eType[i]==FTInteger)
			  {
			    TestWidth(2,title[i],nWidth);
			  }
			  else if(eType[i]==FTDouble)
			  {
			    TestWidth(3,title[i],nWidth);
			  }

			}
		    }


		}
	    }
	  else
	    {
	      attr_code[i] = ConvertAttrCode(title[i]);
	      
	      if(attr_code[i]>=0)
		{
		  
		  
		  badfound = 0;
		  
		  if(eType[i]==FTString)
		    {
		      if(
			 strcmp( gifd_attr_types[attr_code[i]],"Date") &&
			 strcmp( gifd_attr_types[attr_code[i]],"Notgiven") &&
			 strcmp( gifd_attr_types[attr_code[i]],"String") 
			 )
			{
			  AddBadType(attr_code[i],gifd_attr_types[attr_code[i]],"String");
			  badfound = 1;
			}
		    }
		  else if(eType[i]==FTDouble)
		    {	
		      if(
			 strcmp( gifd_attr_types[attr_code[i]],"Notgiven") &&
			 strcmp( gifd_attr_types[attr_code[i]],"Double") &&
			 strcmp( gifd_attr_types[attr_code[i]],"Real") &&
			 strcmp( gifd_attr_types[attr_code[i]],"Float")
			 )
			{
			  AddBadType(attr_code[i],gifd_attr_types[attr_code[i]],"Real");
			  badfound = 1;
			}
		    }
		  else if(eType[i]==FTInteger)
		    {
		      if(
			 strcmp( gifd_attr_types[attr_code[i]],"Notgiven")      &&
			 strcmp( gifd_attr_types[attr_code[i]],"Short Integer") &&
			 strcmp( gifd_attr_types[attr_code[i]],"Integer")       &&
			 strcmp( gifd_attr_types[attr_code[i]],"ShortInteger")  &&
			 strcmp( gifd_attr_types[attr_code[i]],"Long Integer")  &&
			 strcmp( gifd_attr_types[attr_code[i]],"LongInteger") 
			 )
			{
			  AddBadType(attr_code[i],gifd_attr_types[attr_code[i]],"Integer");
			  badfound = 1;
			}
		    }
		  else if(eType[i]==FTSpecial)  
		    {
		      eType[i] = FTString;  
		      
		      if(strcmp( gifd_attr_types[attr_code[i]],"Date"))
			{
			  AddBadType(attr_code[i],gifd_attr_types[attr_code[i]],"Date");
			  badfound = 1;
			}
		    }
		  
		  
		  if((ATTRTYPE_MGCP3())||(ATTRTYPE_MGCP4()))
		    {
		      if(badfound==0)
			{
			  if(eType[i]==FTString)
			  {
			    TestWidth(1,title[i],nWidth);
			  }
			  else if(eType[i]==FTInteger)
			  {
			    TestWidth(2,title[i],nWidth);
			  }
			  else if(eType[i]==FTDouble)
			  {
			    TestWidth(3,title[i],nWidth);
			  }

			}
		    }
		}
	    }
	  
	  
	  if((attr_code[i]>=0)&&(strcmp(fcode,"*****")))
	    {
	      optional_attribute[i] = GetOptional(fcode,title[i],seeitgeom);
	      
	      
	    }
	  else if( (ATTRTYPE_MGCP3()) &&
		       ( (!strcmp(title[i],"HGT")) || (!strcmp(title[i],"ARA")) )
			 )
	  {
        optional_attribute[i] = 1;
	  }
	  else
	  {
        optional_attribute[i] = -100;
	  }
	  
	  
	  if(PossibleFCODE(title[i]))
	    {
	      foundpossibleclass = 1;
	    }
	  else if(
		  (attr_code[i]==-100) &&
		  (LongCode(title[i])==0)
		  )
	    {


		  if(CREATING_TREX==1)
		  {
			if(0) 
			{
              if( (strcmp(fcode,"CA030")) || (!strstr(shortname,"ICESAT_")) ) 
			  {   
	            AddUnkAttr(title[i]);
			  }  
			}
		  }
		  else
		  {
	        AddUnkAttr(title[i]);
		  }
		  
	    }
	  

      if((ATTRTYPE_MGCP3())||(ATTRTYPE_MGCP4()))
	    {
	      if(!strcmp(title[i],"FCODE")) 
		  {
	        mgcpfcodefound = 1;

		    if(nWidth!=5)
			{ 
			  sprintf(Cvalue,"%d",nWidth);
		      AddBadLen(-999 ,"5",Cvalue);
			} 
		  } 
	    }


	  


	} 
    } 



  if(mgcpfcodefound==0)
    {
      AddNoFCODE(shape_to_import);
    }
  
  TestMGCPFilename(shape_to_import,shortname);
  
  
  
  
  if(strcmp(fcode,"*****"))
    { 
      class_code = ConvertClassCode(fcode,-999);
    }
  
  
  

  for(record_num=0; record_num<totalnum;record_num=record_num+5000)
    {
	  i = 0; 

	  switch(eType[i])
		    {
		      case FTString:
		      thisstrval[0] = '\0'; 
		      sprintf(thisstrval,"%s",MakeUTF((unsigned char *)TimDBFReadStringAttribute(hDBF,record_num,i),-1," "," "));
		      break;
		      
		      case FTDouble:
		      thisrealval = TimDBFReadDoubleAttribute(hDBF,record_num,i);
		      break;
		     
		      case FTInteger: 
		      Ivalue = TimDBFReadIntegerAttribute(hDBF,record_num,i);
		      break;

		      case FTLogical:
		      printf("Got unexpected field type in DB table: logical\n");

		      case FTInvalid:
		      printf("Got unexpected field type in DB table: invalid\n");

		      default:
		      printf("Got unexpected field type in DB table %d\n",(int)eType[i]);
		      break;
		    }

	  if(NULLFILE>0)
	  {
		return;
	  }
  }




  for(record_num=0; record_num<totalnum;record_num++)
  {

      
      if(record_num%250==0)
	{
	  update_shape_import(allshapes,shape_to_import, files_done,record_num,totalnum,
			      SH_Points_Done,SH_Linears_Done,SH_Areals_Done,gridpointsread,
			      0,0,0,0,SH_bad_objects, SH_BadCoords,SH_Null_Shapes,SH_Zero_Shapes,SH_Bad_DBF);
	}



      

      if(ClipTest(record_num,hSHP,shape_to_import,fcode)==0)
	{
	  
	  
	  temp_long [record_num] = -1000;
	  temp_short[record_num] = -1000;
	  continue;
	}
      
      
      
      if(!strcmp(fcode,"*****"))
	{
	  
	  class_code = -100;
	}

	other_class_code = -100;



      
      
      SH_SAC_LONG[sh_sac_long_index].lod_stuff = (char *)malloc(strlen(shortname)+20); 
      if(SH_SAC_LONG[sh_sac_long_index].lod_stuff==NULL){printf("out of memory!\n"); exit(-1);}
      
      SH_SAC_SHORT[sh_sac_short_index].lod_stuff = (char *)malloc(strlen(shortname)+20); 
      if(SH_SAC_SHORT[sh_sac_long_index].lod_stuff==NULL){printf("out of memory!\n"); exit(-1);}
      
      if( (!strcmp(fcode,"CA030")) && (strstr(shortname,"ICESAT_")) )
	  {
        sprintf(SH_SAC_LONG [sh_sac_long_index ].lod_stuff,"ICESat Point");
        sprintf(SH_SAC_SHORT[sh_sac_short_index].lod_stuff,"ICESat Point");
		startICESAT = SH_Points_Done;
	  }
	  else if( (!strcmp(fcode,"GB005")) && (strstr(shortname,"LAB_")) )
	  {
        sprintf(SH_SAC_LONG [sh_sac_long_index ].lod_stuff,"LAB");
        sprintf(SH_SAC_SHORT[sh_sac_short_index].lod_stuff,"LAB");
	  }
	  else
	  {
        sprintf(SH_SAC_LONG [sh_sac_long_index ].lod_stuff,"%s",shortname);
        sprintf(SH_SAC_SHORT[sh_sac_short_index].lod_stuff,"%s",shortname);
      }

      SH_SAC_LONG [sh_sac_long_index ].attr_code = -1;
      SH_SAC_SHORT[sh_sac_short_index].attr_code = -1;
      
      sh_sac_short_index++;
      sh_sac_long_index++;
      



      
      if(ABORT_EXTRACT==1)
	{
	  return;
	}
      
      
      
      if(doattr==1)
	{
	  gifd_found = 0; 
	  area_found = NOTYPE;
	  hgt_found  = NOTYPE;
	  len_found  = NOTYPE;
	  nam_found  = NOTYPE;
	  zv2_found  = NOTYPE;
	  
      saveNFI[0] = '\0';
      saveNFN[0] = '\0';
      saveNAM[0] = '\0';

      sprintf(sav996,"ABCPRT");
	  sprintf(sav999,"AAAABBBBRRRRFFFFTTTT");
	  firstbad = 0;


	  if(CREATING_TREX==1)
	  {

         if( (!strcmp(fcode,"CA030")) && (strstr(shortname,"ICESAT_")) )
		 {
		   

           attrindex = SilentGetAttrIndex("TXT");
	  
           SH_SAC_LONG[sh_sac_long_index].attr_code  = attrindex;
           SH_SAC_LONG[sh_sac_long_index].unit_code  = TIM_UNITLESS;
           SH_SAC_LONG[sh_sac_long_index].scale_code = TIM_UNI;
           SH_SAC_LONG[sh_sac_long_index].SEDRIStype = TIM_STRING;
           SH_SAC_LONG[sh_sac_long_index].Cvalue     = NULL;
           SH_SAC_LONG[sh_sac_long_index].lod_stuff  = NULL;
           SH_SAC_LONG[sh_sac_long_index].nam_stuff  = NULL;
           SH_SAC_LONG[sh_sac_long_index].geomtype   = 2;  
           SH_SAC_LONG[sh_sac_long_index].Cvalue     =  (char *) malloc(50);
           sprintf(SH_SAC_LONG[sh_sac_long_index].Cvalue,"%s","\"ICESat Point\"");

           SH_SAC_SHORT[sh_sac_long_index].attr_code = attrindex;
           SH_SAC_SHORT[sh_sac_long_index].lod_stuff = NULL;
           SH_SAC_SHORT[sh_sac_long_index].nam_stuff = NULL;

           sh_sac_short_index++;
           sh_sac_long_index++;
		 }
         if( (!strcmp(fcode,"GB005")) && (strstr(shortname,"LAB_")) )
		 {
		   
		 }
	  }

	  for(i=0; i<nfields; i++)
	    {
	      
		  if(CREATING_TREX==1)
		  {
			
			break;
		  }

	      if(  (!strcmp(title[i],"SEC_CLASS"))  ||  (!strcmp(title[i],"ZSAX_RS0"))  ||  (!strcmp(title[i],"SEC"))  ||  (!strcmp(title[i],"CLASS"))  )
		  { 
		    
		    thiscode[0] = '\0';
		  
		    if(eType[i]==FTString)
		    {
		      sprintf(thiscode,"%s",MakeUTF((unsigned char *)TimDBFReadStringAttribute(hDBF,record_num,i),record_num,title[i],shape_to_import));
		    }
		    else if(eType[i]==FTInteger)
		    {
		      sprintf(thiscode,"%d",TimDBFReadIntegerAttribute(hDBF,record_num,i));
		    }

		    if(SetClassLevel(title[i],thiscode,shape_to_import,NULL)>0)
		    {
		      ABORT_EXTRACT = 1;
		      return;
		    }
		  
		    thiscode[0] = '\0';
		  } 

	      
		  if(IsSubtype(title[i]))
		  {
            if(eType[i]==FTInteger)
		    {
		      sprintf(sav996,"%d",TimDBFReadIntegerAttribute(hDBF,record_num,i));		  
			}
			else
			{
			  if(firstbad==0)
			  {
			    printf("non-integer data type for FCSubType...cannot check FCSubType/F_CODE compliance\n");
				firstbad = 1;
			  }
			}
		  }



	      
	     if(IsGFID(title[i]))
		{
		  if(eType[i]==FTString)
		    {
		      thiscode[0] = '\0';
		      sprintf(thiscode,"%s",MakeUTF((unsigned char *)TimDBFReadStringAttribute(hDBF,record_num,i),record_num,title[i],shape_to_import));
		      
		      if(thiscode[0]=='\0')
			{
			  sprintf(savegfid," Blank %s found ",GetFrontPart());
			}
		      else
			{
			  sprintf(savegfid,"%s",thiscode);
			}
		      gifd_found = 1;
		    }
		  else
		    {
		      printf("Found %s field of type other than string.  Ignoring\n",title[i]);
		    }
		}


	      if(IsArea(title[i]))
		{
		  area_found = GetLongValues(shape_to_import,title[i],eType[i],hDBF,record_num,i,&SaveAreaC[0],&SaveAreaI,&SaveAreaD);
		}
	      if(IsHgt(title[i]))
		{
		  hgt_found  = GetLongValues(shape_to_import,title[i],eType[i],hDBF,record_num,i,&SaveHgtC[0],&SaveHgtI,&SaveHgtD);
		}
	      if(IsLen(title[i]))
		{
		  len_found  = GetLongValues(shape_to_import,title[i],eType[i],hDBF,record_num,i,&SaveLenC[0],&SaveLenI,&SaveLenD);
		}
	      if(IsNam(title[i]))
		{
		  nam_found  = GetLongValues(shape_to_import,title[i],eType[i],hDBF,record_num,i,&SaveNamC[0],&SaveNamI,&SaveNamD);

		  if(DoNFI())
		  {
            if(nam_found==C_TYPE)
			{
              sprintf(saveNAM,"\"%s\"",SaveNamC);
			} 
		  }
		}
	      if(IsZv2(title[i]))
		{
		  zv2_found  = GetLongValues(shape_to_import,title[i],eType[i],hDBF,record_num,i,&SaveZv2C[0],&SaveZv2I,&SaveZv2D);
		}
	      


	      if(PossibleFCODE(title[i]))
		{
		  if(eType[i]==FTString)
		    {
		      thiscode[0] = '\0';
		      sprintf(thiscode,"%s",MakeUTF((unsigned char *)TimDBFReadStringAttribute(hDBF,record_num,i),record_num,title[i],shape_to_import));
		      
		      if(thiscode[0]=='\0')
			{
			  AddBadClass(thiscode,fcode,record_num);
			}
		      
		      else
			{ 
			  for(j=0;j<(int)strlen(thiscode);j++)
			    {
			      thiscode[j] = timtoupper(thiscode[j]);
			    }
			  

			  sprintf(sav999,"%s",thiscode);

			  
			  other_class_code = ConvertClassCode(thiscode,record_num);
			  
			  
			  if(!strcmp(fcode,"*****"))
			    {
			      if((class_code==-100)&&(other_class_code!=-100))
				{
				  
				  class_code = other_class_code;
				}
			    }
			  else
			    {				  
			      
			      if(other_class_code!=class_code)
				{
				  AddBadClass(thiscode,fcode,record_num);
				}
			    }
			}
		    }
		  else
		    {
		      printf("found FCODE of type not string.  Ignoring.\n");
		    }
		}
	      
	      
	      
	      
	      
	      if(attr_code[i]>=0)
		{
		  new_attr_code = attr_code[i];
		  
		  switch(eType[i])
		    {
		      
		    case FTString:
		      
		      
		      
		      thisstrval[0] = '\0'; 
		      sprintf(thisstrval,"%s",MakeUTF((unsigned char *)TimDBFReadStringAttribute(hDBF,record_num,i),-1," "," "));
		      
		      if(strlen(thisstrval)==0)
			{
              AddBlankAttr(filename,title[i],record_num,2); 
			}
		      else
			{
			  optional_attribute[i] = EvalValue(optional_attribute[i],shape_to_import,title[i],thisintval,thisrealval,thisstrval,3); 


			  if(DoNFI())
			  {
                if(!strcmp(title[i],GetNFI()))
				{  
                  sprintf(saveNFI,"\"%s\"",thisstrval);

		         len = strlen(saveNFI);
		         for(zz=0;zz<len;zz++)
				 { 
			       if ((saveNFI[zz]<32)&&(saveNFI[zz]>=0))
				   { 
			         

			         saveNFI[zz] = '!';
				   }  
				 } 


				}



                if(!strcmp(title[i],GetNFN()))
				{  
                  sprintf(saveNFN,"\"%s\"",thisstrval);

		          len = strlen(saveNFN);
		          for(zz=0;zz<len;zz++)
				  {  
			        if ((saveNFN[zz]<32)&&(saveNFN[zz]>=0))
					{ 
			          
			          saveNFN[zz] = '!';
					}   
				  }  

				} 
			  }

			}	
		      
		      
		      		      
		      if(gifd_attr_enum_count[attr_code[i]]==0)
			{    
			  GEOMTYPE = 2;
			  SEDRIStype = TIM_STRING;
			  
			  
			  enumvalue[0] = '\0'; 
			  sprintf(enumvalue,"%s",MakeUTF((unsigned char *)TimDBFReadStringAttribute(hDBF,record_num,i),-1," "," "));
			  
			  if(
			     (enumvalue[0]=='\0')
			     
			     )
			    {
			      GEOMTYPE = -999;
			    }
			}
		      else
			{	
			  
			  enumvalue[0] = '\0'; 
			  sprintf(enumvalue,"%s",MakeUTF((unsigned char *)TimDBFReadStringAttribute(hDBF,record_num,i),-1," "," "));


			  if(enumvalue[0]=='\0')
			    {
			      
			      GEOMTYPE = -999;
			      
			      
			    }
			  else 
			    {
			      
			      newenum = GetNewEnum(attr_code[i],
						   enumvalue,
						   0,
						   record_num);
			      
			      if(newenum>=0)
				{
				  
				  GEOMTYPE = 3;
				  SEDRIStype = TIM_ENUMERANT;
				  
				}
			      else
				{
				  
				  
				  sprintf(scrubenumvalue,"%s",enumvalue);
				  
				  for(j=0;j<(int)strlen(scrubenumvalue);j++)
				    {
				      if(scrubenumvalue[j]!='0')
					{
					  break;
					}
				    }
				  
				  
				  if(j<(int)strlen(scrubenumvalue))
				    {
				      for(k=j; k<(int)strlen(scrubenumvalue);k++)
					{
					  enumvalue[k-j] = scrubenumvalue[k];
					}
				      enumvalue[k-j] = '\0';
				      
				      newenum = GetNewEnum(attr_code[i],
							   enumvalue,
							   1,
							   record_num);			      
				      
				      if(newenum>=0)
					{
					  
					  GEOMTYPE = 3;
					  SEDRIStype = TIM_ENUMERANT;
					  
					  AddBadEnumType(attr_code[i],shape_to_import,scrubenumvalue,enumvalue);
					  
					  
					  
					}
				      else
					{
					  
					  GEOMTYPE = -999;
					}
				    }
				  else
				    {
				      AddBadAttr(attr_code[i],scrubenumvalue,record_num);
				      GEOMTYPE = -999;
				    }
				}
			    }
			}
		      
		      break;
		      
		      
		      
		    case FTDouble:
		      
		      if(gifd_attr_enum_count[attr_code[i]]>0)
			  {
		        thisrealval = TimDBFReadDoubleAttribute(hDBF,record_num,i);

				HandleDoublePickListVal(attr_code[i],thisrealval,&GEOMTYPE,&SEDRIStype,&newenum,record_num);
			  }
			  else
			  {
		        thisrealval = TimDBFReadDoubleAttribute(hDBF,record_num,i);
		        if(NULLINT==1)
				{ 
                  AddBlankAttr(filename,title[i],record_num,1); 	  
 			      GEOMTYPE = -999;
				} 
		        else 
				{
			      optional_attribute[i] = EvalValue(optional_attribute[i],shape_to_import,title[i],thisintval,thisrealval,thisstrval,2); 
			      GEOMTYPE   = 1;  
			      SEDRIStype = TIM_DOUBLE;
				}
			  }
		      
		      break;
		      
		      
		      
		      
		      
		      
		    case FTInteger:
		      
		      
		      
		      Ivalue = TimDBFReadIntegerAttribute(hDBF,record_num,i);
		      thisintval = Ivalue;
		      
		      if(NULLINT==1)
			{
		      AddBlankAttr(filename,title[i],record_num,0); 

			  GEOMTYPE = -999;
			}
		      else if(gifd_attr_enum_count[attr_code[i]]==0)
			{
			  
			  GEOMTYPE = 0; 
			  SEDRIStype = TIM_INTEGER;
			  optional_attribute[i] = EvalValue(optional_attribute[i],shape_to_import,title[i],thisintval,thisrealval,thisstrval,1); 
			}
		      else
			{	
			  optional_attribute[i] = EvalValue(optional_attribute[i],shape_to_import,title[i],thisintval,thisrealval,thisstrval,1); 
			  
			  
			  
			  enumvalue[0] = '\0';
			  sprintf(enumvalue,"%d",TimDBFReadIntegerAttribute(hDBF,record_num,i));
			  
			  newenum = GetNewEnum(attr_code[i],
					       enumvalue,
					       1,
					       record_num);
			  
			  if(newenum>=0)
			    {
			      
			      GEOMTYPE = 3;
			      SEDRIStype = TIM_ENUMERANT;
			    }
			  else
			    {
			      GEOMTYPE = -999;
			      
			    }
			}
		      break;
		    case FTLogical:
		      printf("Got unexpected field type in DB table: logical\n");
		    case FTInvalid:
		      printf("Got unexpected field type in DB table: invalid\n");
		    default:
		      printf("Got unexpected field type in DB table %d\n",(int)eType[i]);
		      break;
		    }
		}
	      else
		{
		  

		  

          if((ATTRTYPE_MGCP3())||(ATTRTYPE_MGCP4()))
		  {
			 if(eType[i]==FTDouble) 
			 {
			   tempDval = TimDBFReadDoubleAttribute(hDBF,record_num,i);

               if( (!strcmp(title[i],"HGT")) || (!strcmp(title[i],"ARA")) )
			   {
                 optional_attribute[i] = EvalValue(optional_attribute[i],shape_to_import,title[i],-999,tempDval,"NULL",2); 
			   }
			 }
		  }

		  GEOMTYPE = -999;  
		}
	      
	      
	      
	      
	      
	      if(GEOMTYPE!=-999)
		{
		  Cvalue[0] = '\0';
		  Ivalue = 0;
		  Dvalue = 0.0;
		  
		  
		  if (GEOMTYPE==0)   
		    {
		      Ivalue = TimDBFReadIntegerAttribute(hDBF,record_num,i);
		    }
		  else if(GEOMTYPE==3) 
		    {
		      Ivalue = newenum;
		    }
		  else if(GEOMTYPE==1)
		    {
		      Dvalue = TimDBFReadDoubleAttribute(hDBF,record_num,i);
		    }
		  else if(GEOMTYPE==2)
		    {
			  if(
				   (!strcmp(title[i],"ZI005_FNA1")) ||  
				   (!strcmp(title[i],"ADR"))        ||  
				   (!strcmp(title[i],"ZI006_MEM"))  ||  
                   (!strcmp(title[i],"FUFI"))           
				)
			  {
                sprintf(Cvalue,"\"Value not imported\"");
			  }
			  else
			  {
		        sprintf(Cvalue,"\"%s\"",MakeUTF((unsigned char *)TimDBFReadStringAttribute(hDBF,record_num,i),record_num,title[i],shape_to_import));
			  }

		      len = strlen(Cvalue);

		      for(zz=0;zz<len;zz++)
			{
			  if ((Cvalue[zz]<32)&&(Cvalue[zz]>=0))
			    {
			      
			      
			      Cvalue[zz] = '!';
			    }
			}
		      
		      
		    }	      	      
		  
		  if(SH_AddLongAttribute (SH_SAC_LONG, sh_sac_long_index,new_attr_code,TIM_UNITLESS,TIM_UNI,SEDRIStype,
					  Ivalue,Dvalue,Cvalue))
		    {
		      SH_AddShortAttribute(SH_SAC_SHORT,sh_sac_short_index,new_attr_code);
		      
		      sh_sac_short_index++;
		      sh_sac_long_index++;
		    }
		}
	    }
	  
	  
	

      NFIWrapper(saveNFI,saveNFN,saveNAM,class_code+1,seeitgeom);

	  WriteGFID(1,SaveAreaC,SaveAreaI,SaveAreaD,area_found,LONG_ATTR_AREA);
	  WriteGFID(1,SaveHgtC, SaveHgtI, SaveHgtD, hgt_found, LONG_ATTR_HGT);
	  WriteGFID(1,SaveLenC, SaveLenI, SaveLenD, len_found, LONG_ATTR_LEN);
	  WriteGFID(1,SaveNamC, SaveNamI, SaveNamD, nam_found, LONG_ATTR_NAM);
	  WriteGFID(1,SaveZv2C, SaveZv2I, SaveZv2D, zv2_found, LONG_ATTR_ZV2);

	  WriteGFID(gifd_found,savegfid,-999,-999,C_TYPE,LONG_ATTR_ID);

	  gifd_ids[record_num] = global_gifd_id;
  
	  
	}	
    
	


    

    if(ATTRTYPE_ANY_GGDM())
	{

	  if(
		  (strcmp(sav996,"ABCPRT")) &&
	      (strcmp(sav999,"AAAABBBBRRRRFFFFTTTT"))
	    )
	  {
	    if(ATTRTYPE_GGDM21())
		{ 
		  totalnum2 = ggdm21_extra_num*2;
		  thearr = ggdm21_extra;
		} 
		else if(ATTRTYPE_GGDM22())
		{ 
		  totalnum2 = ggdm22_extra_num*2;
		  thearr = ggdm22_extra;
		} 
		else if(ATTRTYPE_GGDM3())
		{ 
		  totalnum2 = ggdm3_extra_num*2;
		  thearr = ggdm3_extra;
		} 

	    starter = 0;

	    if(lastindex<totalnum2)
		{
		  if(!strcmp(sav999,thearr[lastindex]))
		  {
		     starter = lastindex;
		  }
		}


	    for(thisindex=starter;thisindex<totalnum2;thisindex=thisindex+2)
		{ 
		  if(!strcmp(sav999,thearr[thisindex]))
		  { 
		    if(strcmp(sav996,thearr[thisindex+1]))
			{
			  

			  sprintf(expmessage,  "F_CODE/FCSubType: %s/%s",thearr[thisindex],thearr[thisindex+1]);
			  sprintf(foundmessage,"F_CODE/FCSubType: %s/%s",thearr[thisindex],sav996);

			  AddBadClass(foundmessage,expmessage,record_num);
			}
				   
		   lastindex = thisindex;
		   break;
		  }  
		}  
	  }  
	}  
	


      
      
      
      if(class_code==-100)
	{
	  
	  temp_long[record_num]  = -100;
	  temp_short[record_num] = -100;
	  
	  
	  
	}
	else
	{
	  
	  
	  sprintf(Cvalue,"%d %d %s",class_code,seeitgeom,SH_SAC_LONG[0].lod_stuff);
	  sprintf(SH_SAC_LONG[0].lod_stuff,"%s",Cvalue);
	  
	  sprintf(Cvalue,"%d %d %s",class_code,seeitgeom,SH_SAC_SHORT[0].lod_stuff);
	  sprintf(SH_SAC_SHORT[0].lod_stuff,"%s",Cvalue);
	  
	  temp_long [record_num] = SH_FindSCC_LONG (seeitgeom,  class_code,sh_sac_long_index, SH_SAC_LONG, record_num );
	  temp_short[record_num] = SH_FindSCC_SHORT(seeitgeom,  class_code,sh_sac_short_index,SH_SAC_SHORT, record_num);

	  if(startICESAT>=0)
	  { 
	    if(global_trex_shape_layer==0)
		{
		  gcpindex2_0 = temp_long [record_num];
		}
	    else if(global_trex_shape_layer==1)
		{
		  gcpindex2_1 = temp_long [record_num];
		}
	    else if(global_trex_shape_layer==2)
		{
		  gcpindex2_2 = temp_long [record_num];
		}
	    else if(global_trex_shape_layer==3)
		{
		  gcpindex2_3 = temp_long [record_num];
		}
		else
		{
		  printf("SI: got unexpected GTSL: %d\n",global_trex_shape_layer);
		}

	  }


	}
      
      
      
      for(i=0;i<sh_sac_long_index;i++)   
	{
	  if(SH_SAC_LONG[i].lod_stuff!= NULL)
	    {
	      free(SH_SAC_LONG[i].lod_stuff);
	      SH_SAC_LONG[i].lod_stuff = NULL;
	    }
	  
	  if(SH_SAC_SHORT[i].lod_stuff!=NULL)
	    {
	      free(SH_SAC_SHORT[i].lod_stuff);
	      SH_SAC_SHORT[i].lod_stuff = NULL;
	    }
	  
	  if(SH_SAC_LONG[i].nam_stuff!= NULL)
	    {
	      free(SH_SAC_LONG[i].nam_stuff);
	      SH_SAC_LONG[i].nam_stuff = NULL;
	    }
	  
	  if(SH_SAC_SHORT[i].nam_stuff!=NULL)
	    {
	      free(SH_SAC_SHORT[i].nam_stuff);
	      SH_SAC_SHORT[i].nam_stuff = NULL;
	    }
	  
	  
	  
	  if(SH_SAC_LONG[i].geomtype==2)
	    {
	      if(SH_SAC_LONG[i].Cvalue!=NULL)
		{
		  free(SH_SAC_LONG[i].Cvalue);
		  SH_SAC_LONG[i].Cvalue = NULL;
		}
	    }
	}
      
      
      sh_sac_short_index = 0;
      sh_sac_long_index = 0;
    } 
  
  
  
  
  if((ATTRTYPE_MGCP3())||(ATTRTYPE_MGCP4()))
    {
      for(i=0; i<nfields; i++)
	{
	  if(optional_attribute[i]==-11)
	    {
	      if(eType[i]==FTInteger)
		{
		  fprintf(mixnull,"%s:\n  Column %s has mix of Null (-32768) and Non-Null Integer values\n",
			  filename,title[i]);
		}
	      else if(eType[i]==FTDouble)
		{
		  fprintf(mixnull,"%s:\n  Column %s has mix of Null (-32768.0) and Non-Null Real values\n",
			  filename,title[i]);
		}
	   else if(eType[i]==FTString)
	     {
	       fprintf(mixnull,"%s:\n  Column %s has mix of Null (N/A) and Non-Null Character values\n",
		       filename,title[i]);
	     }
	    }
	}
    }
}





void init_shape()
{
  int i,j;
  extern char ErrStr[1000];
  
  
  SH_root         = SH_NILL; 
  SH_Null_Shapes  = 0;
  SH_Points_Done  = 0;
  SH_Linears_Done = 0;
  SH_Areals_Done  = 0;
  global_gifd_id  = -1;
  SH_Linears_Prev = 0;
  SH_Areals_Prev  = 0;
  SH_Grids_Prev   = 0;
  SH_bad_objects  = 0;
  SH_Zero_Shapes  = 0;
  SH_Bad_DBF      = 0;
  SH_BadCoords    = 0;
  num2point       = 0;
  num3point       = 0;
  num2line        = 0;
  num3line        = 0;
  num2area        = 0;
  num3area        = 0;
  ZONE_IN_USE     = -999;
  ErrStr[0]       = '\0';

  for(i=0;i<10;i++)
  {
	scale_found[i] = 0;
  }
  
  if(numtestpolyverts>0)
    {
      free(testpoly.x);
      free(testpoly.y);
      numtestpolyverts = 0;
    }
  
  
  
  
  
  scc_short_items   = 0;
  scc_long_items    = 0;  
  MINXREAD     =  100000000.0;
  MINYREAD     =  100000000.0;
  MINZREAD     =  100000000.0;
  MINZREAD2    =  100000000.0;
  MAXXREAD     = -100000000.0;  
  MAXYREAD     = -100000000.0;
  MAXZREAD     = -100000000.0;  
  MAXZREAD2    = -100000000.0;  
  MINY_P_READ  =  100000000.0;
  MINX_P_READ  =  100000000.0;
  MAXY_P_READ  = -100000000.0;
  MAXX_P_READ  = -100000000.0;
  TestNumLinearNodes = 0;
  NumLinearNodes = 0;
  NumPointNodes  = 0;
  NumArealNodes  = 0;
  TestNumArealNodes  = 0;
  TestNumGridNodes = 0;
  gridpointsread = 0;
  num_grids      = 0;
  maxgridspace   = -1;
  
  for(i=0;i<365;i++)
    {
      for(j=0;j<185;j++)
	{
	  OverLappingGrids[i][j] = 0;
	   OneDegreeContent[i][j] = 0;
	}
    }
  
  Record_LL_Mapping(-1,-1,-1);
  
}



void FreeShapeMemory()
{
  if(rings_allocced>0)
    {
      free(INNERRINGS);
      rings_allocced = 0;
      INNERRINGS = NULL;
    }
  
  if(numtestpolyverts>0)
    {
      free(testpoly.x);
      free(testpoly.y);
      numtestpolyverts = 0;
    }
}







int GetUTF(char *shape_to_import)
{
  FILE *testfile;
  char filename[2000],utftype[1000];
  int i;

  sprintf(filename,"%s.cpg",shape_to_import);
  utftype[0] = '\0';

  testfile = fopen(filename,"r");
  if(testfile==NULL)
  {
	  return 0;
  }

  fscanf(testfile,"%s",utftype);
  fclose(testfile);

   for(i=0;i<(int)strlen(utftype);i++)
    {
      utftype[i] = toupper(utftype[i]);      
    }
 

  if(strstr(utftype,"UTF"))
  {
	  return 1;
  }

  return 0;
}


char *DateSetup(int makeerror, int version, int index)
{
  int i,j;
  static char errmsg[100];
  extern char *GetSourceType(int index);
  extern int ValidSubregionSource(int thisindex);


  #define NUM_TRD4_SRC 77
  #define NUM_TRD3_SRC 77
  #define NUM_TRD2_SRC 102


int Codes_TRD2[NUM_TRD2_SRC]={
0,
1,
2,
3,
4,
5,
6,
7,
8,
9,
10,
11,
16,
17,
18,
19,
20,
21,
22,
24,
25,
26,
27,
28,
29,
30,
31,
32,
33,
34,
35,
36,
37,
38,
39,
40,
41,
42,
43,
44,
45,
46,
47,
48,
49,
50,
51,
52,
53,
54,
55,
56,
57,
58,
59,
60,
61,
62,
63,
64,
65,
66,
67,
68,
69,
70,
71,
72,
73,
74,
75,
76,
77,
78,
79,
80,
81,
82,
83,
84,
85,
86,
87,
88,
89,
90,
91,
92,
93,
94,
95,
996,
997,
998,
999,
1001,
1002,
1003,
1004,
1005,
1006,
1007
};


char *Col_A_TRD2[NUM_TRD2_SRC] = {
"unk",
"adrg",
"aafif",
"chum",
"cit",
"combat",
"cadrg",
"cib1",
"cib5",
"qbrd",
"dnc",
"dpf",
"dtop1",
"dtop2",
"dtop",
"dtop4",
"dtop",
"dvof",
"ffd",
"cover",
"names",
"field",
"icm",
"ikonos",
"ntm",
"imag",
"itd",
"ivd",
"ibd",
"jog",
"landsat",
"lwd",
"mcg",
"msd1",
"msd2",
"msd3",
"msd4",
"msd5",
"midb",
"natdat",
"natmap",
"med",
"nate",
"plan",
"refmap",
"srtm",
"sitmap",
"tod0",
"tod1",
"tod2",
"tod3",
"tod4",
"tod5",
"tlm",
"und",
"uvmap",
"vitd",
"vmap",
"vmap1",
"vmap2",
"wvspls",
"qbrdmm",
"qbrdms",
"qbrdpm",
"qbrdps",
"ikonmm",
"ikonms",
"ikonpm",
"ikonps",
"spt10",
"spt5",
"spt5mm",
"spt5ms",
"spt5pm",
"spt5ps",
"spt2pm",
"spt2mm",
"spt5m",
"spt5s",
"spt10mm",
"spthrg",
"btm2",
"btm50",
"btm100",
"bto25",
"bto50",
"bto100",
"bvd",
"bvd25",
"bvd50",
"bvd100",
"mult",
"np",
"na",
"other",
"frimag",
"frsnsr",
"asrp",
"gaz",
"www",
"orbvu3",
"vmap2i",
};


char *Col_C_TRD2[NUM_TRD2_SRC] = {
"unk",
"adrg",
"aafif",
"chum",
"city",
"combat",
"cadrg",
"cib1",
"cib5",
"qbrd",
"dnc",
"dpf",
"dtop1",
"dtop2",
"dtop3",
"dtop4",
"dtop5",
"dvof",
"ffd",
"cover",
"names",
"field",
"icm",
"ikonos",
"ntm",
"imag",
"itd",
"ivd",
"ibd",
"jog",
"landsat",
"lwd",
"mcg",
"msd1",
"msd2",
"msd3",
"msd4",
"msd5",
"midb",
"natdat",
"natmap",
"med",
"nate",
"plan",
"refmap",
"srtm",
"sitmap",
"tod0",
"tod1",
"tod2",
"tod3",
"tod4",
"tod5",
"tlm",
"und",
"uvmap",
"vitd",
"vmap0",
"vmap1",
"vmap2",
"wvspls",
"qbrdmm",
"qbrdms",
"qbrdpm",
"qbrdps",
"ikonmm",
"ikonms",
"ikonpm",
"ikonps",
"spt10",
"spt5",
"spt5mm",
"spt5ms",
"spt5pm",
"spt5ps",
"spt2pm",
"spt2mm",
"spt5m",
"spt5s",
"spt10mm",
"spthrg",
"btm25",
"btm50",
"btm100",
"bto25",
"bto50",
"bto100",
"bvd",
"bvd25",
"bvd50",
"bvd100",
"mult",
"N_P",
"N_A",
"other",
"frimag",
"frsnsr",
"asrp",
"gaz",
"www",
"orbvu3",
"vmap2i"
};


char *Col_F_TRD2[NUM_TRD2_SRC] = {
"Unknown",
"ADRG",
"AAFIF",
"CHUM",
"City Graphic",
"Combat Chart",
"CADRG",
"CIB1",
"CIB5",
"QuickBird Imagery",
"DNC",
"DPF",
"DTOP 1",
"DTOP 2",
"DTOP 3",
"DTOP 4",
"DTOP 5",
"DVOF",
"FFD",
"Land Cover",
"GeoNames",
"GPS",
"ICM",
"IKONOS Imagery",
"NTM Imagery",
"Imagery",
"ITD",
"IVD",
"International Boundaries",
"JOG",
"Landsat Imagery",
"LWD",
"MC&G",
"MSD 1",
"MSD 2",
"MSD 3",
"MSD 4",
"MSD 5",
"MIDB",
"Native Data",
"Native Map",
"Medical Facilities",
"NATE",
"Planning Graphic",
"Reference Map",
"SRTM",
"Site Map",
"TOD 0",
"TOD 1",
"TOD 2",
"TOD 3",
"TOD 4",
"TOD 5",
"TLM",
"UN Data",
"UVMap",
"VITD",
"VMap 0",
"VMap 1",
"VMap 2",
"WVS Plus",
"QuickBird Multispectral Monoscopic Imagery",
"QuickBird Multispectral Stereoscopic Imagery",
"QuickBird Panchromatic Monoscopic Imagery",
"QuickBird Panchromatic Stereoscopic Imagery",
"Ikonos Multispectral Monoscopic Imagery",
"Ikonos Multispectral Stereoscopic Imagery",
"Ikonos Panchromatic Monoscopic Imagery",
"Ikonos Panchromatic Stereoscopic Imagery",
"SPOT 10m Imagery",
"SPOT 5m Imagery",
"SPOT 5m Multispectral Monoscopic Imagery",
"SPOT 5m Multispectral Stereoscopic Imagery",
"SPOT 5m Panchromatic Monoscopic Imagery",
"SPOT 5m Panchromatic Stereoscopic Imagery",
"SPOT 2.5m Panchromatic Monoscopic Imagery",
"SPOT 2.5m Multispectral Monoscopic Imagery",
"SPOT 5m Monoscopic Imagery",
"SPOT 5m Stereoscopic Imagery",
"SPOT 10m Multispectral Monoscopic Imagery",
"SPOT HRG Digital Terrain Model",
"BGIO 1:25k Thematic Map",
"BGIO 1:50k Thematic Map",
"BGIO 1:100k Thematic Map",
"BGIO 1:25k Topographic Map",
"BGIO 1:50k Topographic Map",
"BGIO 1:100k Topographic Map",
"BGIO Vector Data",
"BGIO 1:25k Vector Data",
"BGIO 1:50k Vector Data",
"BGIO 1:100k Vector Data",
"Multiple",
"Unpopulated",
"Not Applicable",
"Other",
"FR Image Product",
"FR Defense Sensor",
"Arc Standard Raster",
"Gazetteer",
"World-Wide Web",
"OrbView3",
"FR HR Vector Data (VMAP2i)"
};



int Codes_TRD3[NUM_TRD3_SRC]={
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  10,
  11,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  24,
  25,
  26,
  27,
  29,
  30,
  31,
  32,
  33,
  34,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  59,
  60,
  61,
  62,
  63,
  64,
  65,
  85,
  92,
  93,
  94,
  95,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119,
  120,
  121,
  996,
  997,
  998,
  999
};


char *Col_A_TRD3[NUM_TRD3_SRC]={
  "unk",
  "adrg",
  "aafif",
  "chum",
  "city",
  "combat",
  "cadrg",
  "cib1",
  "cib5",
  "dnc",
  "dpf",
  "dtop1",
  "dtop2",
  "dtop3",
  "dtop4",
  "dtop5",
  "dvof",
  "ffd",
  "cover",
  "names",
  "field",
  "icm",
  "ntm",
  "imag",
  "itd",
  "ivd",
  "ibd",
  "jog",
  "lwd",
  "mcg",
  "msd1",
  "msd2",
  "msd3",
  "msd4",
  "msd5",
  "midb",
  "natdat",
  "natmap",
  "med",
  "nate",
  "plan",
  "srtm",
  "sitmap",
  "tod0",
  "tod1",
  "tod2",
  "tod3",
  "tod4",
  "tod5",
  "und",
  "uvmap",
  "vitd",
  "vmap0",
  "vmap1",
  "vmap2",
  "wvspls",
  "spthrg",
  "VectorData",
  "25kVectorData",
  "50kVectorData",
  "100kVectorData",
  "VeryHighResCommMonoImage",
  "VeryHighResCommStereoImage",
  "HighResCommMonoImage",
  "HighResCommStereoImage",
  "MediumResCommMonoImage",
  "MediumResCommStereoImage",
  "LowResCommMonoImage",
  "LowResCommStereoImage",
  "MapOneToTwentyFiveK",
  "MapOneToFiftyK",
  "MapOneToHundredK",
  "RoutingData",
  "mult",
  "N_P",
  "N_A",
  "other"
};


char *Col_C_TRD3[NUM_TRD3_SRC]={
  "unk",
  "adrg",
  "aafif",
  "chum",
  "city",
  "combat",
  "cadrg",
  "cib1",
  "cib5",
  "dnc",
  "dpf",
  "dtop1",
  "dtop2",
  "dtop3",
  "dtop4",
  "dtop5",
  "dvof",
  "ffd",
  "cover",
  "names",
  "field",
  "icm",
  "ntm",
  "imag",
  "itd",
  "ivd",
  "ibd",
  "jog",
  "lwd",
  "mcg",
  "msd1",
  "msd2",
  "msd3",
  "msd4",
  "msd5",
  "midb",
  "natdat",
  "natmap",
  "med",
  "nate",
  "plan",
  "srtm",
  "sitmap",
  "tod0",
  "tod1",
  "tod2",
  "tod3",
  "tod4",
  "tod5",
  "und",
  "uvmap",
  "vitd",
  "vmap0",
  "vmap1",
  "vmap2",
  "wvspls",
  "spthrg",
  "VectorData",
  "25kVectorData",
  "50kVectorData",
  "100kVectorData",
  "VeryHighResCommMonoImage ",
  "VeryHighResCommStereoImage",
  "HighResCommMonoImage",
  "HighResCommStereoImage",
  "MediumResCommMonoImage",
  "MediumResCommStereoImage",
  "LowResCommMonoImage",
  "LowResCommStereoImage",
  "MapOneToTwentyFiveK",
  "MapOneToFiftyK",
  "MapOneToHundredK",
  "RoutingData",
  "mult",
  "N_P",
  "N_A",
  "other"
};


char *Col_F_TRD3[NUM_TRD3_SRC]={
  "Unknown",
  "ADRG",
  "AAFIF",
  "CHUM",
  "City Graphic",
  "Combat Chart",
  "CADRG",
  "CIB1",
  "CIB5",
  "DNC",
  "DPF",
  "DTOP 1",
  "DTOP 2",
  "DTOP 3",
  "DTOP 4",
  "DTOP 5",
  "DVOF",
  "FFD",
  "Land Cover",
  "GeoNames",
  "GPS",
  "ICM",
  "NTM Imagery",
  "Imagery",
  "ITD",
  "IVD",
  "International Boundaries",
  "JOG",
  "LWD",
  "MC&G",
  "MSD 1",
  "MSD 2",
  "MSD 3",
  "MSD 4",
  "MSD 5",
  "MIDB",
  "Native Data",
  "Native Map",
  "Medical Facilities",
  "NATE",
  "Planning Graphic",
  "SRTM",
  "Site Map",
  "TOD 0",
  "TOD 1",
  "TOD 2",
  "TOD 3",
  "TOD 4",
  "TOD 5",
  "UN Data",
  "UVMap",
  "VITD",
  "VMap 0",
  "VMap 1",
  "VMap 2",
  "WVS Plus",
  "SPOT HRG Digital Terrain Model",
  "Vector Data",
  "1:25k Vector Data",
  "1:50k Vector Data",
  "1:100k Vector Data",
  "Very High Resolution Commercial Monoscopic Imagery",
  "Very High Resolution Commercial Stereoscopic Imagery",
  "High Resolution Commercial Monoscopic Imagery",
  "High Resolution Commercial Stereoscopic Imagery",
  "Medium Resolution Commercial Monoscopic Imagery",
  "Medium Resolution Commercial Stereoscopic Imagery",
  "Low Resolution Commercial Monoscopic Imagery",
  "Low Resolution Commercial Stereoscopic Imagery",
  "Map 1:25k",
  "Map 1:50k",
  "Map 1:100k",
  "Routing Data",
  "Multiple",
  "Unpopulated",
  "Not Applicable",
  "Other"
};



char *Col_A_TRD4[NUM_TRD4_SRC]={
  "UNK" , 
  "ngaArcDigRasterGraphic" , 
  "ngaAutoAirFacInfoFile" , 
  "ngaChartUpdateManual" , 
  "ngaCityGraphic" , 
  "ngaCombatChart" , 
  "ngaCompressedAdrg" , 
  "ngaControlledImageBase1" , 
  "ngaControlledImageBase5" , 
  "ngaDigitalNauticalChart" , 
  "ngaDigitalPrintFile" , 
  "ngaDigitalTopoData1" , 
  "ngaDigitalTopoData2" , 
  "ngaDigitalTopoData3" , 
  "ngaDigitalTopoData4" , 
  "ngaDigitalTopoData5" , 
  "ngaDigitalVertObstruction" , 
  "ngaFoundationFeatureData" , 
  "ngaGeoLandCover" , 
  "ngaGeoNames" , 
  "gpsBasedFieldCollect" , 
  "ngaImageCityMap" , 
  "usNtmImagery" , 
  "imageryUnspecified" , 
  "ngaInterimTerrainData" , 
  "ngaInterimVectorData" , 
  "ngaInternationalBoundary" , 
  "ngaJointOperatGraphic" , 
  "ngaLittoralWarfareData" , 
  "mapChartOrGeodeticData" , 
  "ngaMissionSpecificData1" , 
  "ngaMissionSpecificData2" , 
  "ngaMissionSpecificData3" , 
  "ngaMissionSpecificData4" , 
  "ngaMissionSpecificData5" , 
  "usModernizedIntegratedDB" , 
  "nativeData" , 
  "nativeMap" , 
  "ngaMedicalFacilities" , 
  "ngaNominalAttTopoEvalMap" , 
  "ngaPlanningGraphic" , 
  "usShuttleRadarTopoMission" , 
  "siteMap" , 
  "ngaTacticalOceanData0" , 
  "ngaTacticalOceanData1" , 
  "ngaTacticalOceanData2" , 
  "ngaTacticalOceanData3" , 
  "ngaTacticalOceanData4" , 
  "ngaTacticalOceanData5" , 
  "unitedNationsData" , 
  "ngaUrbanVectorMap" , 
  "ngaVectorInterimTerrain" , 
  "ngaVectorMap0" , 
  "ngaVectorMap1" , 
  "ngaVectorMap2" , 
  "ngaWorldVectorShorePlus" , 
  "spotHrgDtm" , 
  "vectorData" , 
  "vectorData25k" , 
  "vectorData50k" , 
  "vectorData100k" , 
  "veryHighResCommMonoImage" , 
  "veryHighResCommStereoImage" , 
  "highResCommMonoImage" , 
  "highResCommStereoImage" , 
  "mediumResCommMonoImage" , 
  "mediumResCommStereoImage" , 
  "lowResCommMonoImage" , 
  "lowResCommStereoImage" , 
  "mapOneToTwentyFiveK" , 
  "mapOneToFiftyK" , 
  "mapOneToHundredK" , 
  "routingData" , 
  "MULT" , 
  "N_P" , 
  "N_A" , 
  "OTH" 
};

int Codes_TRD4[NUM_TRD4_SRC]={
0,
1,
2,
3,
4,
5,
6,
7,
8,
10,
11,
16,
17,
18,
19,
20,
21,
22,
24,
25,
26,
27,
29,
30,
31,
32,
33,
34,
36,
37,
38,
39,
40,
41,
42,
43,
44,
45,
46,
47,
48,
50,
51,
52,
53,
54,
55,
56,
57,
59,
60,
61,
62,
63,
64,
65,
85,
92,
93,
94,
95,
110,
111,
112,
113,
114,
115,
116,
117,
118,
119,
120,
121,
996,
997,
998,
999
};











  if(makeerror==1)
  { 
    if(version==2)
	{  
      for(i=0;i<NUM_TRD2_SRC;i++)
	  { 
        if(Codes_TRD2[i]==index)
		{ 
          return Col_F_TRD2[i];
		} 
	  } 
	}
    else if(version==3)
	{  
      for(i=0;i<NUM_TRD3_SRC;i++)
	  { 
        if(Codes_TRD3[i]==index)
		{ 
          return Col_F_TRD3[i];
		} 
	  } 
	} 
    else if((version==4)||(version==41)||(version==42)||(version==43)||(version==44))
	{  
      for(i=0;i<NUM_TRD4_SRC;i++)
	  { 
        if(Codes_TRD4[i]==index)
		{ 
          return Col_A_TRD4[i];
		}
	  } 
	} 
	else
	{
      printf("Error in DS: %d\n",version);
	}
    sprintf(errmsg,"Could not find code %d",index);
    return errmsg;
  } 


  for(i=0;i<NumSubregionSources;i++)
  {

    SubregionSources[i].attr_enum_code = -1;

    if(ValidSubregionSource(i))
	{
      SubregionSources[i].attr_enum_code = -987654;

      if(version==2)
	  { 
        for(j=0;j<NUM_TRD2_SRC;j++)
		{ 
          if(
			  (!strcmp(GetSourceType(SubregionSources[i].index),Col_A_TRD2[j])) ||
			  (!strcmp(GetSourceType(SubregionSources[i].index),Col_C_TRD2[j])) ||
			  (!strcmp(GetSourceType(SubregionSources[i].index),Col_F_TRD2[j]))
		    )
		  { 
            SubregionSources[i].attr_enum_code = Codes_TRD2[j];
            break;
		  } 
		} 
	  } 

      else if(version==3)
	  { 
        for(j=0;j<NUM_TRD3_SRC;j++)
		{ 
          if(
			  (!strcmp(GetSourceType(SubregionSources[i].index),Col_A_TRD3[j])) ||
			  (!strcmp(GetSourceType(SubregionSources[i].index),Col_C_TRD3[j])) ||
			  (!strcmp(GetSourceType(SubregionSources[i].index),Col_F_TRD3[j]))
		    )
		  { 
            SubregionSources[i].attr_enum_code = Codes_TRD3[j];
            break;
		  } 
		} 
	  } 

      else if((version==4)||(version==41)||(version==42)||(version==43)||(version==44))
	  {
        for(j=0;j<NUM_TRD4_SRC;j++)
		{
          if(!strcmp(GetSourceType(SubregionSources[i].index),Col_A_TRD4[j]))
		  { 
            SubregionSources[i].attr_enum_code = Codes_TRD4[j];
            break;
		  } 
		} 
	  } 

	  if(SubregionSources[i].attr_enum_code==-987654)
	  { 
        printf("Error:  Could not find Source type %s\n",GetSourceType(SubregionSources[i].index));
	  } 
	} 
  }
  return "";
}


int IsPrimarySource(int sourcetype, int version)
{

  if(version==2)
  {
    if((sourcetype>=7   ) && (sourcetype<=9   )){return 1;}
    if((sourcetype>=26  ) && (sourcetype<=26  )){return 1;}
    if((sourcetype>=28  ) && (sourcetype<=30  )){return 1;}
    if((sourcetype>=33  ) && (sourcetype<=33  )){return 1;}
    if((sourcetype>=35  ) && (sourcetype<=35  )){return 1;}
    if((sourcetype>=66  ) && (sourcetype<=85  )){return 1;}
    if((sourcetype>=1002) && (sourcetype<=1002)){return 1;}
  }
  else if(version==3)
  {
    if((sourcetype>=7   ) && (sourcetype<=8   )){return 1;}
    if((sourcetype>=26  ) && (sourcetype<=26  )){return 1;}
    if((sourcetype>=29  ) && (sourcetype<=30  )){return 1;}
    if((sourcetype>=33  ) && (sourcetype<=33  )){return 1;}
    if((sourcetype>=110 ) && (sourcetype<=117 )){return 1;}
  }
  else if((version==4)||(version==41)||(version==42)||(version==43)||(version==44))
  {
    if((sourcetype>=7   ) && (sourcetype<=8   )){return 1;}
    if((sourcetype>=26  ) && (sourcetype<=26  )){return 1;}
    if((sourcetype>=29  ) && (sourcetype<=30  )){return 1;}
    if((sourcetype>=33  ) && (sourcetype<=33  )){return 1;}
    if((sourcetype>=110 ) && (sourcetype<=117 )){return 1;}
  }

  return 0;

}



int BadOldNew(int shapeindex,int version)
{
  int i,yearint,monthint,dayint;
  char yearchar[10],monthchar[5],daychar[5];


  

  if(IsPrimarySource(XML_SRC_TYPE[shapeindex],version)==0)
  {
    return 0;
  }


  if(strlen(XML_SRC_DATE[shapeindex])>9)
  {
    for(i=0;i<10;i++)
	{
	  if((i==4)||(i==7))
	  { 
	    if(XML_SRC_DATE[shapeindex][i]!='-')
		{ 
		  
          return 1;
		} 
	  }  
	  else
	  { 
        if((XML_SRC_DATE[shapeindex][i]<48) || (XML_SRC_DATE[shapeindex][i]>57) )
		{ 
		  
          return 1;
		} 
	  } 
	} 

    yearchar[0] = XML_SRC_DATE[shapeindex][0];
    yearchar[1] = XML_SRC_DATE[shapeindex][1];
    yearchar[2] = XML_SRC_DATE[shapeindex][2];
    yearchar[3] = XML_SRC_DATE[shapeindex][3];
    yearchar[4] = '\0';

    monthchar[0] = XML_SRC_DATE[shapeindex][5];
    monthchar[1] = XML_SRC_DATE[shapeindex][6];
    monthchar[2] = '\0';

    daychar[0] = XML_SRC_DATE[shapeindex][8];
    daychar[1] = XML_SRC_DATE[shapeindex][9];
    daychar[2] = '\0';

    sscanf(yearchar, "%d",&yearint);
    sscanf(monthchar,"%d",&monthint);
    sscanf(daychar,  "%d",&dayint);


    


    if(yearint<OldestYear)
	{
      return 1;
	}
    else if(yearint==OldestYear)
	{
      if(monthint<OldestMonth)
	  {
        return 1;
	  }
      else if(monthint==OldestMonth)
	  { 
        if(dayint<OldestDay)
		{  
         return 1;
		}       
	  }   
	}	 

    if(NewestYear<yearint)
	{
      return 1;
	} 
    else if(yearint==NewestYear)
	{ 
      if(NewestMonth<monthint)
	  {  
        return 1;
	  } 
	  else if(monthint==NewestMonth)
	  { 
        if(NewestDay<dayint)
		{   
          return 1;
		}	    
	  } 
	}
  } 

  return 0;
}



int DifferentDates(int shapeindex,int subregionid)
{

  
  int i,j,foundit = 0,yearint,monthint,dayint;
  char tempstr[1000],yearchar[10],monthchar[5],daychar[5];
  extern void WriteExpected(int type,char *expectstring,char *required, char *valuefound);
  extern int ValidSubregionSource(int thisindex);


  for(i=0;i<NumSubregionSources;i++)
  {
	if(ValidSubregionSource(i))
	{
       if(SubregionSources[i].subregionid==subregionid)
	   {
         
         if(XML_SRC_TYPE[shapeindex]==SubregionSources[i].attr_enum_code)
		 {
           foundit = 1;
           break;
		 }
	   }
	}
  }  


  if(foundit==0)
  {
    return 2;
  }


  


  for(j=0;j<NumSubregionSources;j++)
  {
 	if(ValidSubregionSource(j))
	{
       if(SubregionSources[j].subregionid==subregionid)
	   {
         if(XML_SRC_TYPE[shapeindex]==SubregionSources[j].attr_enum_code)
		 {

			 if(strlen(XML_SRC_DATE[shapeindex])>9)
			 {
				for(i=0;i<10;i++)
				{
	               if((i==4)||(i==7))
				   { 
	                 if(XML_SRC_DATE[shapeindex][i]!='-')
					 { 
	                    sprintf(tempstr,"%s value \"%s\" found (\"%c\" found in position %d.  expected '-')",
			              "Date",XML_SRC_DATE[shapeindex],XML_SRC_DATE[shapeindex][i],i+1);

                        WriteExpected(0,"Expected","format YYYY-MM-DD",tempstr);
	                    return 1;
					 } 
				   } 
	               else
				   { 
                     if((XML_SRC_DATE[shapeindex][i]<48) || (XML_SRC_DATE[shapeindex][i]>57) )
					 { 
	                   sprintf(tempstr,"%s value \"%s\" found (\"%c\" found in position %d.  expected a number)",
			             "Date",XML_SRC_DATE[shapeindex],XML_SRC_DATE[shapeindex][i],i+1);

                      WriteExpected(0,"Expected","format YYYY-MM-DD",tempstr);

	                  return 1;
					 } 
				   } 
				} 

			    yearchar[0] = XML_SRC_DATE[shapeindex][0];
                yearchar[1] = XML_SRC_DATE[shapeindex][1];
                yearchar[2] = XML_SRC_DATE[shapeindex][2];
                yearchar[3] = XML_SRC_DATE[shapeindex][3];
                yearchar[4] = '\0';

                monthchar[0] = XML_SRC_DATE[shapeindex][5];
                monthchar[1] = XML_SRC_DATE[shapeindex][6];
                monthchar[2] = '\0';

                daychar[0] = XML_SRC_DATE[shapeindex][8];
                daychar[1] = XML_SRC_DATE[shapeindex][9];
                daychar[2] = '\0';

                sscanf(yearchar, "%d",&yearint);
                sscanf(monthchar,"%d",&monthint);
                sscanf(daychar,  "%d",&dayint);



				if(SubregionSources[j].type==1) 
				{
                  

                  if(yearint<SubregionSources[j].year)
				  {
                    return 3;
				  }
                  else if(yearint==SubregionSources[j].year)
				  {
                    if(monthint<SubregionSources[j].month)
					{
                      return 3;
					}
	                else if(monthint==SubregionSources[j].month)
					{
                      if(dayint<SubregionSources[j].day)
					  {
                        return 3;
					  }
					  else if(dayint==SubregionSources[j].day)
					  {
                         
						 SubregionSources[j].MatchedOldest = 1;
					  }
					}
				  }
				}
				else if(SubregionSources[j].type==2) 
				{
                  
                  if(SubregionSources[j].year<yearint)
				  {
                    return 3;
				  } 
                  else if(yearint==SubregionSources[j].year)
				  { 
                    if(SubregionSources[j].month<monthint)
					{  
                      return 3;
					} 
	                else if(monthint==SubregionSources[j].month)
					{ 
                      if(SubregionSources[j].day<dayint)
					  {  
                        return 3;
					  }	  
					  else if(dayint==SubregionSources[j].day)
					  {
                         
						 SubregionSources[j].MatchedNewest = 1;
					  }
					}
				  }
				}
				else
				{
                  
				}

			 } 
		 } 
	   } 
	} 
  } 

  return 0;
}


char *GetDate(int passcode, int passsubregionid, int oldnew)
{
  int i;
  extern int ValidSubregionSource(int thisindex);

  for(i=0;i<NumSubregionSources;i++)
  {
	if(ValidSubregionSource(i))
	{
      if(
		  (SubregionSources[i].attr_enum_code==passcode)     &&
          (SubregionSources[i].subregionid==passsubregionid)
		 )
	  {
        if((oldnew==1)&&(SubregionSources[i].type==1))
		{
          return SubregionSources[i].savedate;
		}
		else if((oldnew==2)&&(SubregionSources[i].type==2))
		{
          return SubregionSources[i].savedate;
		}
	  }
	}
  }
  return "Internal Error";
}


void CheckAttrs(int subregionpolyindex, int shapeindex, double x, double y, char *feattype, FILE *pfile, FILE *errfile, char *CCPYRTSAVE, int version)
{
  

  

  int errtype;
  extern char *GetACEALECharCode(int thisindex);


  if(DoAce==0)
  {
    return;
  }

  if((FoundNewest==1)&&(FoundOldest==1))
  {
    if(shapeindex!=LAST_COLDNEW_INDEX)
	{ 
      if(BadOldNew(shapeindex,version)==1)
	  {

        POIINDEX = POIINDEX + 1;
        if(POIINDEX==15)
		{
          POIINDEX = 1;
		}

		if((version==4)||(version==41)||(version==42)||(version==43)||(version==44))
		{
          fprintf(errfile,"Error:  Feature %s (FID %d) has SDV %s which is not within the cell oldest and newest dates (COLDSD,CNEWSD) dates {%d-%d-%d to %d-%d-%d}\n\n",
		    feattype,shapeindex,
		    XML_SRC_DATE[shapeindex],
            OldestYear, OldestMonth, OldestDay,
            NewestYear, NewestMonth, NewestDay);

          fprintf(pfile,"%d %.10lf %.10lf SDV %s which is not within (COLDSD,CNEWSD) dates {%d-%d-%d to %d-%d-%d}\n",
		    POIINDEX,x,y,
		    XML_SRC_DATE[shapeindex],
            OldestYear, OldestMonth, OldestDay,
            NewestYear, NewestMonth, NewestDay);
		}
		else
		{
          fprintf(errfile,"Error:  Feature %s (FID %d) has SRC_DATE %s which is not within the cell oldest and newest dates (COLDSD,CNEWSD) dates {%d-%d-%d to %d-%d-%d}\n\n",
		    feattype,shapeindex,
		    XML_SRC_DATE[shapeindex],
            OldestYear, OldestMonth, OldestDay,
            NewestYear, NewestMonth, NewestDay);

          fprintf(pfile,"%d %.10lf %.10lf SRC_DATE %s which is not within (COLDSD,CNEWSD) dates {%d-%d-%d to %d-%d-%d}\n",
		    POIINDEX,x,y,
		    XML_SRC_DATE[shapeindex],
            OldestYear, OldestMonth, OldestDay,
            NewestYear, NewestMonth, NewestDay);
		}

  	    LAST_COLDNEW_INDEX = shapeindex;
	  } 
	} 
  }

  if(shapeindex!=LAST_SRC_INDEX)
  {
 
	
    errtype = DifferentDates(shapeindex,SubregionPolys[subregionpolyindex].subregionid);



	if(errtype==2) 
	{

      

	  if((version==4)||(version==41)||(version==42)||(version==43)||(version==44))
	  {
        POIINDEX = POIINDEX + 1;
        if(POIINDEX==15)
		{
          POIINDEX = 1;
		}

        fprintf(errfile,"Error:  Feature %s (FID %d) has SRT %d (%s) which is not\n  on the XML's subregion source type list for subregion %d\n\n",
		  feattype,shapeindex,XML_SRC_TYPE[shapeindex],
		  DateSetup(1,version,XML_SRC_TYPE[shapeindex]),
		  SubregionPolys[subregionpolyindex].subregionid);

        fprintf(pfile,"%d %.10lf %.10lf %s with source %s in subregion %d but not on that subregion's source type list\n",
		  POIINDEX,x,y,feattype,DateSetup(1,version,XML_SRC_TYPE[shapeindex]),SubregionPolys[subregionpolyindex].subregionid);

	    LAST_SRC_INDEX = shapeindex;
	  }
	}

    if(errtype==1) 
	{
	  LAST_SRC_INDEX = shapeindex;
	}

    if(errtype==3) 
	{

      POIINDEX = POIINDEX + 1;
      if(POIINDEX==15)
	  { 
        POIINDEX = 1;
	  }  

	  if((version==4)||(version==41)||(version==42)||(version==43)||(version==44))
	  {
        fprintf(errfile,"Error:  Feature %s (FID %d) has SRT %d (%s) with SDV %s which is not within the dates {%s to %s}\nfrom the XML's subregion date specificiations for this source type for subregion %d\n\n",
		  feattype,shapeindex,XML_SRC_TYPE[shapeindex],
		  DateSetup(1,version,XML_SRC_TYPE[shapeindex]),
		  XML_SRC_DATE[shapeindex],
		  GetDate(XML_SRC_TYPE[shapeindex],SubregionPolys[subregionpolyindex].subregionid,1),
		  GetDate(XML_SRC_TYPE[shapeindex],SubregionPolys[subregionpolyindex].subregionid,2),
		  SubregionPolys[subregionpolyindex].subregionid);

        fprintf(pfile,"%d %.10lf %.10lf %s in subregion %d with SDV %s (for SRT %s) not in range %s to %s \n",
		  POIINDEX,x,y,feattype,SubregionPolys[subregionpolyindex].subregionid,XML_SRC_DATE[shapeindex],
		  DateSetup(1,version,XML_SRC_TYPE[shapeindex]),
		  GetDate(XML_SRC_TYPE[shapeindex],SubregionPolys[subregionpolyindex].subregionid,1),
		  GetDate(XML_SRC_TYPE[shapeindex],SubregionPolys[subregionpolyindex].subregionid,2));
	  }
	  else
	  {
        fprintf(errfile,"Error:  Feature %s (FID %d) has SRC_NAME %d (%s) with SRC_DATE %s which is not within the dates {%s to %s}\nfrom the XML's subregion date specificiations for this source type for subregion %d\n\n",
		  feattype,shapeindex,XML_SRC_TYPE[shapeindex],
		  DateSetup(1,version,XML_SRC_TYPE[shapeindex]),
		  XML_SRC_DATE[shapeindex],
		  GetDate(XML_SRC_TYPE[shapeindex],SubregionPolys[subregionpolyindex].subregionid,1),
		  GetDate(XML_SRC_TYPE[shapeindex],SubregionPolys[subregionpolyindex].subregionid,2),
		  SubregionPolys[subregionpolyindex].subregionid);

        fprintf(pfile,"%d %.10lf %.10lf %s in subregion %d with SRC_DATE %s (for SRC_NAME %s) not in range %s to %s \n",
		  POIINDEX,x,y,feattype,SubregionPolys[subregionpolyindex].subregionid,XML_SRC_DATE[shapeindex],
		  DateSetup(1,version,XML_SRC_TYPE[shapeindex]),
		  GetDate(XML_SRC_TYPE[shapeindex],SubregionPolys[subregionpolyindex].subregionid,1),
		  GetDate(XML_SRC_TYPE[shapeindex],SubregionPolys[subregionpolyindex].subregionid,2));
	  }

	  LAST_SRC_INDEX = shapeindex;
	}
  }


  if(version<4) 
  {
    if(
	  (XML_ACE[shapeindex]!=SubregionPolys[subregionpolyindex].ACE) &&
	  (shapeindex!=LAST_ACE_INDEX)
	)
	{ 
      POIINDEX = POIINDEX + 1;
      if(POIINDEX==15)
	  { 
        POIINDEX = 1;
	  }  

      fprintf(errfile,"Error:  Feature %s (FID %d) has ACE %.2lf not matching XML SACEVL (%.2lf)\n\n",
		feattype,shapeindex,XML_ACE[shapeindex],SubregionPolys[subregionpolyindex].ACE);

      fprintf(pfile,"%d %.10lf %.10lf %s with ACE %.2lf not matching XML SACEVL (%.2lf)\n",
		POIINDEX,x,y,feattype,XML_ACE[shapeindex],SubregionPolys[subregionpolyindex].ACE);

	  LAST_ACE_INDEX = shapeindex;
	} 

    if(
	    (XML_ACE_EVAL[shapeindex]!=SubregionPolys[subregionpolyindex].ACE_pick) &&
	    (shapeindex!=LAST_ACE_EVAL_INDEX)
	  )
	{ 
      POIINDEX = POIINDEX + 1;
      if(POIINDEX==15)
	  { 
        POIINDEX = 1;
	  }  

      fprintf(errfile,"Error: Feature %s (FID %d) has ACE_EVAL %d (%s) not matching XML SACEMT %d (%s)\n\n",
		feattype,shapeindex,
		XML_ACE_EVAL[shapeindex],GetACEALECharCode(XML_ACE_EVAL[shapeindex]),
		SubregionPolys[subregionpolyindex].ACE_pick,GetACEALECharCode(SubregionPolys[subregionpolyindex].ACE_pick));

      fprintf(pfile,"%d %.10lf %.10lf %s with ACE_EVAL %d (%s) not matching XML SACEMT %d (%s)\n",
		POIINDEX,x,y,feattype,
		XML_ACE_EVAL[shapeindex],GetACEALECharCode(XML_ACE_EVAL[shapeindex]),
		SubregionPolys[subregionpolyindex].ACE_pick,GetACEALECharCode(SubregionPolys[subregionpolyindex].ACE_pick));

	  LAST_ACE_EVAL_INDEX = shapeindex;
	} 



    if((SubregionPolys[subregionpolyindex].ALE_pick<0)&&(XML_ALE_EVAL[shapeindex]!=998)) 
	{ 
      if(shapeindex!=LAST_ALE_INDEX)
	  { 
        POIINDEX = POIINDEX + 1;
        if(POIINDEX==15)
		{
          POIINDEX = 1;
		} 

        fprintf(errfile,"Error:  Feature %s (FID %d) has ALE_EVAL %d but XML SALEMT not present for subregion %d\n\n",
          feattype,shapeindex,XML_ALE_EVAL[shapeindex],SubregionPolys[subregionpolyindex].subregionid);

        fprintf(pfile,"%d %.10lf %.10lf %s with ALE_EVAL %d but no SALEMT in XML for this subregion (%d)\n",
          POIINDEX,x,y,feattype,XML_ALE_EVAL[shapeindex],SubregionPolys[subregionpolyindex].subregionid);

        LAST_ALE_INDEX = shapeindex;
	  } 
	} 


    if((SubregionPolys[subregionpolyindex].ALE==FAKE_ACE_VALUE)&&(XML_ALE[shapeindex]!=-32765)) 
	{ 
      if(shapeindex!=LAST_ALE2_INDEX)
	  { 
        POIINDEX = POIINDEX + 1;
        if(POIINDEX==15)
		{ 
          POIINDEX = 1;
		} 

        fprintf(errfile,"Error:  Feature %s (FID %d) has ALE %lf but XML SALEVL not present for subregion %d\n\n",
          feattype,shapeindex,XML_ALE[shapeindex],SubregionPolys[subregionpolyindex].subregionid);

        fprintf(pfile,"%d %.10lf %.10lf %s with ALE %lf but no SALEVL in XML for this subregion (%d)\n",
          POIINDEX,x,y,feattype,XML_ALE[shapeindex],SubregionPolys[subregionpolyindex].subregionid);

        LAST_ALE2_INDEX = shapeindex;
	  } 
	} 


    if(SubregionPolys[subregionpolyindex].ALE_pick>=0) 
	{ 
      if(
	      (XML_ALE[shapeindex]!=SubregionPolys[subregionpolyindex].ALE) &&
	      (shapeindex!=LAST_ALE3_INDEX)
	    )
	  {
        POIINDEX = POIINDEX + 1;
        if(POIINDEX==15)
		{
          POIINDEX = 1;
		}   

        fprintf(errfile,"Error:  Feature %s (FID %d) has ALE %.2lf not matching XML SALEVAL (%.2lf)\n\n",
          feattype,shapeindex,XML_ALE[shapeindex],SubregionPolys[subregionpolyindex].ALE);

        fprintf(pfile,"%d %.10lf %.10lf %s with ALE %.2lf not matching XML SALEVAL (%.2lf)\n",
          POIINDEX,x,y,feattype,XML_ALE[shapeindex],SubregionPolys[subregionpolyindex].ALE);

        LAST_ALE3_INDEX = shapeindex;
	  }

      if(
         (XML_ALE_EVAL[shapeindex]!=SubregionPolys[subregionpolyindex].ALE_pick) &&
         (shapeindex!=LAST_ALE_EVAL_INDEX)
        )
	  { 
        POIINDEX = POIINDEX + 1;
        if(POIINDEX==15)
		{  
          POIINDEX = 1;
		}   

        fprintf(errfile,"Error: Feature %s (FID %d) has ALE_EVAL %d (%s) not matching XML SALEMT %d (%s)\n\n",
          feattype,shapeindex,
		  XML_ALE_EVAL[shapeindex],GetACEALECharCode(XML_ALE_EVAL[shapeindex]),
		  SubregionPolys[subregionpolyindex].ALE_pick,GetACEALECharCode(SubregionPolys[subregionpolyindex].ALE_pick));

        fprintf(pfile,"%d %.10lf %.10lf %s with ALE_EVAL %d (%s) not matching XML SALEMT %d (%s)\n",
          POIINDEX,x,y,feattype,
		  XML_ALE_EVAL[shapeindex],GetACEALECharCode(XML_ALE_EVAL[shapeindex]),
		  SubregionPolys[subregionpolyindex].ALE_pick,GetACEALECharCode(SubregionPolys[subregionpolyindex].ALE_pick));

        LAST_ALE_EVAL_INDEX = shapeindex;
	  } 
	} 
  }  



  if(SubregionPolys[subregionpolyindex].SCPYRT!=NULL)
  {





    if(
	    (strcmp(XML_SCPYRT[shapeindex],SubregionPolys[subregionpolyindex].SCPYRT)) &&
	    (shapeindex!=LAST_SCPYRT_INDEX)
	  )
	{
      POIINDEX = POIINDEX + 1;
      if(POIINDEX==15)
	  { 
        POIINDEX = 1;
	  }  

      fprintf(errfile,"Error: Feature %s (FID %d) has CPYRT_NOTE \"%s\" not matching XML SCPYRT \"%s\"\n\n",
		feattype,shapeindex,XML_SCPYRT[shapeindex],SubregionPolys[subregionpolyindex].SCPYRT);

      fprintf(pfile,"%d %.10lf %.10lf %s with CPYRT_NOTE \"%s\" not matching XML SCPYRT \"%s\"\n",
		POIINDEX,x,y,feattype,XML_SCPYRT[shapeindex],SubregionPolys[subregionpolyindex].SCPYRT);

	  LAST_SCPYRT_INDEX = shapeindex;
	} 
  }



  if(CCPYRTSAVE!=NULL)
  {
    if(
	    (strcmp(XML_SCPYRT[shapeindex],CCPYRTSAVE)) &&
	    (shapeindex!=LAST_CCPYRT_INDEX)
	  )
	{
      POIINDEX = POIINDEX + 1;
      if(POIINDEX==15)
	  { 
        POIINDEX = 1;
	  }  

      fprintf(errfile,"Error: Feature %s (FID %d) has CPYRT_NOTE \"%s\" not matching XML CCPYRT \"%s\"\n\n",
		feattype,shapeindex,XML_SCPYRT[shapeindex],CCPYRTSAVE);

      fprintf(pfile,"%d %.10lf %.10lf %s with CPYRT_NOTE \"%s\" not matching XML CCPYRT \"%s\"\n",
		POIINDEX,x,y,feattype,XML_SCPYRT[shapeindex],CCPYRTSAVE);

	  LAST_CCPYRT_INDEX = shapeindex;
	} 
  }
}


void TestXMLVertex(double x, double y, int shapeindex,char *feattype, FILE *pfile, FILE *errfile, char *CCPYRTSAVE, int version)
{
  int i,j,inhole;
  extern int NumSubregionPolys;
  extern struct SubregionPolyStruct *SubregionPolys;

  

  for(i=0;i<NumSubregionPolys;i++)
  {

    
	

      if(SH_PointInAreal(x,y,SubregionPolys[i].x,SubregionPolys[i].y,0,SubregionPolys[i].numverts-1,0))
	  {
		

		inhole = 0;
        for(j=0;j<SubregionPolys[i].numholes;j++)
		{
		  if(SubregionPolys[i].holes[j].usethis==1)
		  {
            if(SH_PointInAreal(x,y,SubregionPolys[i].holes[j].x,SubregionPolys[i].holes[j].y,0,SubregionPolys[i].holes[j].numverts-1,0))
			{ 
              inhole = 1;
              break;
			} 
		  } 
		}

		if(inhole==0)
		{
          if(SubregionPolys[i].FoundFeatureType!=1)
		  {
            SubregionPolys[i].FoundFeatureType = 1;
            SubregionPolys[i].foundx = x; 
            SubregionPolys[i].foundy = y;
		  }
		  CheckAttrs(i,shapeindex,x,y,feattype,pfile,errfile,CCPYRTSAVE,version); 
		}
	  }
	
  }
}



char *GetDBFType(TimDBFFieldType	eType)
{

  if(eType==FTString)
  {
    return "String";
  }
  if(eType==FTDouble)
  {
    return "Double";
  }
  if(eType==FTInteger)
  {
    return "Integer";
  }
  if(eType==FTLogical)
  {
    return "Logical";
  }
  if(eType==FTInvalid)
  {
    return "Invalid";
  }
  return "Unknown!";
}


void BadMetaFields(FILE *errfile,char *shape_to_import, char *fieldname)
{
  fprintf(errfile,"Error:  Shapefile %s does not have field %s\n  Terminating feature/cell level metadata comparisons for this shapefile\n\n",
		shape_to_import,fieldname);;
  DoAce  = 0;
}


void GetFieldIndices(FILE *errfile,char *shape_to_import, int version)
{
  TimDBFHandle hDBF;
  TimDBFFieldType	eType1,eType2,eType3,eType4,eType5,eType6,eType7; 
  int i,nWidth,nDecimals;
  char title[2000];

  

  ACEindex      = -1;
  ALEindex      = -1;
  ACE_EVALindex = -1;
  ALE_EVALindex = -1;
  SCPYRTindex   = -1;
  SRCDATEindex  = -1;
  SRCTYPEindex  = -1;

  if(XML_ACE!=NULL)
  {
    free(XML_ACE);
    XML_ACE = NULL;
  }
  if(XML_ALE!=NULL)
  {
    free(XML_ALE);
    XML_ALE = NULL;
  }

  if(XML_ACE_EVAL!=NULL)
  {
    free(XML_ACE_EVAL);
    XML_ACE_EVAL = NULL;
  }
  if(XML_ALE_EVAL!=NULL)
  {
    free(XML_ALE_EVAL);
    XML_ALE_EVAL = NULL;
  }

  if(XML_SCPYRT!=NULL)
  {
    free(XML_SCPYRT);
    XML_SCPYRT = NULL;
  }

  if(XML_SRC_DATE!=NULL)
  {
    free(XML_SRC_DATE);
    XML_SRC_DATE = NULL;
  }
  if(XML_SRC_TYPE!=NULL)
  {
    free(XML_SRC_TYPE);
    XML_SRC_TYPE = NULL;
  }



  XML_ACE      = (double *)malloc(sizeof(double)*XMLnum_records);
  XML_ALE      = (double *)malloc(sizeof(double)*XMLnum_records);
  XML_ACE_EVAL = (int *)   malloc(sizeof(int)   *XMLnum_records);
  XML_ALE_EVAL = (int *)   malloc(sizeof(int)   *XMLnum_records);
  XML_SCPYRT   = (char **) malloc(sizeof(char *)*XMLnum_records);
  XML_SRC_DATE = (char **) malloc(sizeof(char *)*XMLnum_records);
  XML_SRC_TYPE = (int *)   malloc(sizeof(int)   *XMLnum_records);


  for(i=0;i<XMLnum_records;i++)
  {
    XML_ACE[i]      = FAKE_ACE_VALUE;
    XML_ALE[i]      = FAKE_ACE_VALUE;
	XML_ACE_EVAL[i] = -1;
	XML_ALE_EVAL[i] = -1;
    XML_SCPYRT[i]   = NULL;
	XML_SRC_DATE[i] = NULL;
	XML_SRC_TYPE[i] = -1;
  }


  hDBF = TimDBFOpen(shape_to_import, "rb" );
  if( hDBF == NULL )
    {
      printf( "Unable to open dbf file for:%s\n", shape_to_import );
      return;
    }
  
  if(TimDBFGetFieldCount(hDBF)==0)
    {
      printf( "There is NO attribution fields for shapefile %s\n",shape_to_import);	  
      return;
    }


  if((version==4)||(version==41)||(version==42)||(version==43)||(version==44))
  {
    SCPYRTindex   = TimDBFGetFieldIndex(hDBF,"ccN");  if(SCPYRTindex<0)   {BadMetaFields(errfile,shape_to_import,"CCN"); return;}
    SRCDATEindex  = TimDBFGetFieldIndex(hDBF,"SDv");  if(SRCDATEindex<0)  {BadMetaFields(errfile,shape_to_import,"SDV"); return;}
    SRCTYPEindex  = TimDBFGetFieldIndex(hDBF,"Srt");  if(SRCTYPEindex<0)  {BadMetaFields(errfile,shape_to_import,"SRT"); return;}
  }
  else
  {
    ACEindex      = TimDBFGetFieldIndex(hDBF,"aCe");         if(ACEindex<0)      {BadMetaFields(errfile,shape_to_import,"ACE");        return;}
    ALEindex      = TimDBFGetFieldIndex(hDBF,"aLe");         if(ALEindex<0)      {BadMetaFields(errfile,shape_to_import,"ALE");        return;}
    ACE_EVALindex = TimDBFGetFieldIndex(hDBF,"aCe_evAL");    if(ACE_EVALindex<0) {BadMetaFields(errfile,shape_to_import,"ACE_EVAL");   return;}
    ALE_EVALindex = TimDBFGetFieldIndex(hDBF,"aLe_evAL");    if(ALE_EVALindex<0) {BadMetaFields(errfile,shape_to_import,"ALE_EVAL");   return;}
    SCPYRTindex   = TimDBFGetFieldIndex(hDBF,"cpyRT_noTE");  if(SCPYRTindex<0)   {BadMetaFields(errfile,shape_to_import,"CPYRT_NOTE"); return;}
    SRCDATEindex  = TimDBFGetFieldIndex(hDBF,"Src_DatE");    if(SRCDATEindex<0)  {BadMetaFields(errfile,shape_to_import,"SRC_DATE");   return;}
    SRCTYPEindex  = TimDBFGetFieldIndex(hDBF,"SrC_nAme");    if(SRCTYPEindex<0)  {BadMetaFields(errfile,shape_to_import,"SRC_NAME");   return;}
  }


 

  


  eType3 = TimDBFGetFieldInfo(hDBF,SCPYRTindex,title,&nWidth,&nDecimals);
  if(eType3!=FTString)
  { 
    if((version==4)||(version==41)||(version==42)||(version==43)||(version==44))
	{ 
      printf("Error: wrong field type %s for CCN (expected string).  Not checking feature level metadata vs cell level\n",GetDBFType(eType3));
	}
	else
	{
      printf("Error: wrong field type %s for CPYRT_NOTE (expected string).  Not checking feature level metadata vs cell level\n",GetDBFType(eType3));
	}
    return;
  } 
  eType6 = TimDBFGetFieldInfo(hDBF,SRCDATEindex,title,&nWidth,&nDecimals);
  if(eType6!=FTString)
  {
    if((version==4)||(version==41)||(version==42)||(version==43)||(version==44))
	{ 
	  printf("Error: wrong field type %s for SDV (expected string).  Not checking feature level metadata vs cell level\n",GetDBFType(eType6));
	}
	else
	{
	  printf("Error: wrong field type %s for SRC_DATE (expected string).  Not checking feature level metadata vs cell level\n",GetDBFType(eType6));
	}
    return;
  }
  eType7 = TimDBFGetFieldInfo(hDBF,SRCTYPEindex,title,&nWidth,&nDecimals);
  if(eType7!=FTInteger)
  {
    if((version==4)||(version==41)||(version==42)||(version==43)||(version==44))
	{ 
	  printf("Error: wrong field type %s for SRT (expected integer).  Not checking feature level metadata vs cell level\n",GetDBFType(eType7));
	}
	else
	{
	  printf("Error: wrong field type %s for SRC_NAME (expected integer).  Not checking feature level metadata vs cell level\n",GetDBFType(eType7));
	}
    return;
  }


  if(version<4)
  {
    eType1 = TimDBFGetFieldInfo(hDBF,ACEindex,     title,&nWidth,&nDecimals);
    if(eType1!=FTDouble)
	{ 
	  printf("Error: wrong field type %s for ACE (expected real).  Not checking feature level metadata vs cell level\n",GetDBFType(eType1));
      return;
	} 
    eType2 = TimDBFGetFieldInfo(hDBF,ACE_EVALindex,title,&nWidth,&nDecimals);
    if(eType2!=FTInteger)
	{
	  printf("Error: wrong field type %s for ACE_EVAL (expected integer).  Not checking feature level metadata vs cell level\n",GetDBFType(eType2));
      return;
	} 
    eType4 = TimDBFGetFieldInfo(hDBF,ALEindex,     title,&nWidth,&nDecimals);
    if(eType4!=FTDouble)
	{
      printf("Error: wrong field type %s for ALE (expected real).  Not checking feature level metadata vs cell level\n",GetDBFType(eType4));
      return;
	} 
    eType5 = TimDBFGetFieldInfo(hDBF,ALE_EVALindex,title,&nWidth,&nDecimals);
    if(eType5!=FTInteger)
	{
	  printf("Error: wrong field type %s for ALE_EVAL (expected integer).  Not checking feature level metadata vs cell level\n",GetDBFType(eType5));
      return;
	} 
  }


  for(i=0;i<XMLnum_records;i++)
  {

	if((version==4)||(version==41)||(version==42)||(version==43)||(version==44))
	{
	  XML_ACE[i]      = -1;
	  XML_ALE[i]      = -1;
 	  XML_ACE_EVAL[i] = -1;
 	  XML_ALE_EVAL[i] = -1;
	}
	else
	{
	  XML_ACE[i]      = TimDBFReadDoubleAttribute (hDBF,i,ACEindex);
	  XML_ALE[i]      = TimDBFReadDoubleAttribute (hDBF,i,ALEindex);
 	  XML_ACE_EVAL[i] = TimDBFReadIntegerAttribute(hDBF,i,ACE_EVALindex);
 	  XML_ALE_EVAL[i] = TimDBFReadIntegerAttribute(hDBF,i,ALE_EVALindex);
	}

	XML_SRC_TYPE[i] = TimDBFReadIntegerAttribute(hDBF,i,SRCTYPEindex);

    title[0] = '\0';
    sprintf(title,"%s",MakeUTF((unsigned char *)TimDBFReadStringAttribute(hDBF,i,SCPYRTindex),-1," "," "));
	XML_SCPYRT[i]   = (char *)malloc(strlen(title) + 5);
	sprintf(XML_SCPYRT[i],"%s",title);



    title[0] = '\0';
    sprintf(title,"%s",MakeUTF((unsigned char *)TimDBFReadStringAttribute(hDBF,i,SRCDATEindex),-1," "," "));
	XML_SRC_DATE[i]   = (char *)malloc(strlen(title) + 5);
	sprintf(XML_SRC_DATE[i],"%s",title);





  }

  TimDBFClose( hDBF );
}


int ProcessXMLShapes(FILE *outerrfile, char *shape_to_import, int *pointcount, int *linecount, int *areacount, int shpnum, char *feattype, FILE *pfile, FILE *errfile, char *CCPYRTSAVE, int version)
{
  TimSHPHandle	hSHP;
  int		nShapeType,i,j,thispart,startindex,endindex,thisvert,thisSubPoly,subvert;
  double 	adfMinBound[4], adfMaxBound[4],xint,yint;
  TimSHPObject	*psShape;
  extern Widget drawing_a;
  extern int LineSegmentsIntersect(double xl,double yl,double xk,double yk,double xm,double ym,double xn,double yn,double * xi,double * yi);
  extern void ReportXMLProgress(Widget w, int progresslevel, char *current_shape, char *savefilename, int curr, int total, int shpnum);
  extern char *GetSourceType(int index);
  extern int ValidSubregionSource(int thisindex);




  if(pfile==NULL)
  {
    printf("NULL OPF2!\n");
	exit(-1);
  }


  DateSetup(0,version,-1);


  


  LAST_ACE_INDEX      = -999;
  LAST_ALE_INDEX      = -999;
  LAST_ALE2_INDEX     = -999;
  LAST_ALE3_INDEX     = -999;
  LAST_ACE_EVAL_INDEX = -999;
  LAST_ALE_EVAL_INDEX = -999;
  LAST_SCPYRT_INDEX   = -999;
  LAST_CCPYRT_INDEX   = -999;
  LAST_SRC_INDEX      = -999;
  LAST_COLDNEW_INDEX  = -999;

  

  hSHP = TimSHPOpen(shape_to_import, "rb" );      
  if( hSHP == NULL )
    {
      printf( "Unable to open shp and/or shx file for: %s\n", shape_to_import );
      return 0;
    }

  
  TimSHPGetInfo( hSHP, &XMLnum_records, &nShapeType, adfMinBound, adfMaxBound );
 

  GetFieldIndices(errfile,shape_to_import,version);


  for( i = 0; i < XMLnum_records; i++ )
  {
    

    if(i%1000==0)
	{
      ReportXMLProgress(drawing_a,i+1,shape_to_import,"",i,XMLnum_records,shpnum);
	}

    psShape = TimSHPReadObject( hSHP, i );

    switch(psShape->nTimSHPType)
	{
	  
	  case TimSHPT_NULL:  
	    break;
	  
	  case TimSHPT_POINTZ:
	  case TimSHPT_POINT:      
	  case TimSHPT_POINTM:

	  *pointcount = *pointcount + 1;

      TestXMLVertex(psShape->padfX[0],psShape->padfY[0],i,feattype,pfile,errfile,CCPYRTSAVE,version);

	  break;
	  
	  
      case TimSHPT_MULTIPOINTZ: 
      case TimSHPT_MULTIPOINT:   
      case TimSHPT_MULTIPOINTM: 
       fprintf(outerrfile,"Error:  found illegal shapefile type %s for shapefile %s\n\n",ParseShapeType(psShape->nTimSHPType),shape_to_import);
       printf("Multipoint shapefile....error\n");
	  break;
	  
	  
      case TimSHPT_ARCZ:        
      case TimSHPT_ARC:        
      case TimSHPT_ARCM:  
	  
	  *linecount = *linecount + psShape->nParts;

	  if(psShape->nParts>1)
	    {
	      printf("detected multi part line shapefile...error\n");
          fprintf(outerrfile,"Error:  found %d-part line feature in shapefile %s\n\n",psShape->nParts,shape_to_import);
	    }


      for(thispart=0;thispart<psShape->nParts;thispart++)
	  {
        startindex = psShape->panPartStart[thispart];
  
		if(thispart==(psShape->nParts-1))
		{ 
          endindex = psShape->nVertices-1;
		} 
        else
		{ 
          endindex = psShape->panPartStart[thispart+1] - 1;
		}

        for(thisvert=startindex;thisvert<=endindex;thisvert++)
		{ 
          TestXMLVertex(psShape->padfX[thisvert],psShape->padfY[thisvert],i,feattype,pfile,errfile,CCPYRTSAVE,version);
		}
	  }


	  


      for(thisSubPoly=0;thisSubPoly<NumSubregionPolys;thisSubPoly++)
	  { 
        if(SubregionPolys[thisSubPoly].FoundFeatureType==0)
		{
          for(subvert=1;subvert<SubregionPolys[thisSubPoly].numverts;subvert++)
		  {
             

            if(SubregionPolys[thisSubPoly].FoundFeatureType==1)
			{ 
	          break;
			} 

            for(thispart=0;thispart<psShape->nParts;thispart++)
			{ 
              if(SubregionPolys[thisSubPoly].FoundFeatureType==1)
			  { 
	            break;
			  } 

              startindex = psShape->panPartStart[thispart];
  
              if(thispart==(psShape->nParts-1))
			  {  
                endindex = psShape->nVertices-1;
			  }  
              else
			  { 
                endindex = psShape->panPartStart[thispart+1] - 1;
			  } 

              for(thisvert=startindex+1;thisvert<=endindex;thisvert++)
			  {  
			    if (LineSegmentsIntersect(
					   SubregionPolys[thisSubPoly].x[subvert-1],SubregionPolys[thisSubPoly].y[subvert-1],
					   SubregionPolys[thisSubPoly].x[subvert]  ,SubregionPolys[thisSubPoly].y[subvert],
					   psShape->padfX[thisvert-1]              ,psShape->padfY[thisvert-1],
					   psShape->padfX[thisvert]                ,psShape->padfY[thisvert],
					   &xint,&yint) > 0)
				{
                  SubregionPolys[thisSubPoly].FoundFeatureType = 1;
                  SubregionPolys[thisSubPoly].foundx = xint;
                  SubregionPolys[thisSubPoly].foundy = yint;

                  printf("second chance A found for subregion %d around location %lf %lf in %s\n",
                       SubregionPolys[thisSubPoly].subregionid,xint,yint,shape_to_import);

                  if(SH_PointInAreal(xint,yint,psShape->padfX,psShape->padfY,startindex,endindex,0))
				  {
                    CheckAttrs(thisSubPoly,i,xint,yint,feattype,pfile,errfile,CCPYRTSAVE,version);
				  }

                  break;
				}
			  }
			}
		  }
		}
	  }



	  break;


      case TimSHPT_MULTIPATCH: 
        printf("found multipatch data in %s\n",shape_to_import);
        fprintf(outerrfile,"Error:  found illegal shapefile type %s for shapefile %s\n\n",ParseShapeType(psShape->nTimSHPType),shape_to_import);
      case TimSHPT_POLYGONZ: 
      case TimSHPT_POLYGON:       
      case TimSHPT_POLYGONM: 

      MakeInnerPtrs(psShape,i,shape_to_import,0);
	        
      for(j=0;j<psShape->nParts;j++)
	  {
	    if(INNERRINGS[j]>0) 
		{
		  *areacount = *areacount + 1;
		} 
	  }


	  

      for(thispart=0;thispart<psShape->nParts;thispart++)
	  {
        startindex = psShape->panPartStart[thispart];
  
		if(thispart==(psShape->nParts-1))
		{ 
          endindex = psShape->nVertices-1;
		} 
        else
		{ 
          endindex = psShape->panPartStart[thispart+1] - 1;
		}

        for(thisvert=startindex;thisvert<=endindex;thisvert++)
		{ 
          TestXMLVertex(psShape->padfX[thisvert],psShape->padfY[thisvert],i,feattype,pfile,errfile,CCPYRTSAVE,version);
		}
	  }


      for(thispart=0;thispart<psShape->nParts;thispart++)
	  {
        startindex = psShape->panPartStart[thispart];
  
		if(thispart==(psShape->nParts-1))
		{ 
          endindex = psShape->nVertices-1;
		} 
        else
		{ 
          endindex = psShape->panPartStart[thispart+1] - 1;
		}

        

        for(thisSubPoly=0;thisSubPoly<NumSubregionPolys;thisSubPoly++)
		{ 
          if(SubregionPolys[thisSubPoly].FoundFeatureType==0)
		  {
            for(subvert=0;subvert<SubregionPolys[thisSubPoly].numverts;subvert++)
			{
               if(SH_PointInAreal(SubregionPolys[thisSubPoly].x[subvert],SubregionPolys[thisSubPoly].y[subvert],
				   psShape->padfX,psShape->padfY,startindex,endindex,1))
			   {  
                 SubregionPolys[thisSubPoly].FoundFeatureType = 1;
                 SubregionPolys[thisSubPoly].foundx = SubregionPolys[thisSubPoly].x[subvert];
                 SubregionPolys[thisSubPoly].foundy = SubregionPolys[thisSubPoly].y[subvert];

                 printf("second chance B found for subregion %d around vertex %lf %lf (%d total) in %s\n",
                   SubregionPolys[thisSubPoly].subregionid,psShape->padfX[startindex],psShape->padfY[startindex],endindex-startindex+1,shape_to_import);

                 if(SH_PointInAreal(SubregionPolys[thisSubPoly].x[subvert],SubregionPolys[thisSubPoly].y[subvert],
				     psShape->padfX,psShape->padfY,startindex,endindex,0))  
				 {
                   CheckAttrs(thisSubPoly,i,SubregionPolys[thisSubPoly].x[subvert],SubregionPolys[thisSubPoly].y[subvert],feattype,pfile,errfile,CCPYRTSAVE,version);
				 }

				 break;
			   }
			}
		  }
		}
	  }

	  
	  


      for(thisSubPoly=0;thisSubPoly<NumSubregionPolys;thisSubPoly++)
	  { 
        if(SubregionPolys[thisSubPoly].FoundFeatureType==0)
		{
          for(subvert=1;subvert<SubregionPolys[thisSubPoly].numverts;subvert++)
		  {
             

             if(SubregionPolys[thisSubPoly].FoundFeatureType==1)
			 { 
	           break;
			 } 

             for(thispart=0;thispart<psShape->nParts;thispart++)
			 { 
                if(SubregionPolys[thisSubPoly].FoundFeatureType==1)
				{ 
	              break;
				} 

                startindex = psShape->panPartStart[thispart];
  
                if(thispart==(psShape->nParts-1))
				{  
                  endindex = psShape->nVertices-1;
				}  
                else
				{ 
                  endindex = psShape->panPartStart[thispart+1] - 1;
				} 

                for(thisvert=startindex+1;thisvert<=endindex;thisvert++)
				{  
			       if (LineSegmentsIntersect(
					   SubregionPolys[thisSubPoly].x[subvert-1],SubregionPolys[thisSubPoly].y[subvert-1],
					   SubregionPolys[thisSubPoly].x[subvert]  ,SubregionPolys[thisSubPoly].y[subvert],
					   psShape->padfX[thisvert-1]              ,psShape->padfY[thisvert-1],
					   psShape->padfX[thisvert]                ,psShape->padfY[thisvert],
					   &xint,&yint) > 0)
				   {
                     SubregionPolys[thisSubPoly].FoundFeatureType = 1;
					 SubregionPolys[thisSubPoly].foundx = xint;
					 SubregionPolys[thisSubPoly].foundy = yint;

                     printf("second chance C found for subregion %d around location %lf %lf in %s\n",
                       SubregionPolys[thisSubPoly].subregionid,xint,yint,shape_to_import);

                     if(SH_PointInAreal(xint,yint,psShape->padfX,psShape->padfY,startindex,endindex,0))
					 { 
					   
                       CheckAttrs(thisSubPoly,i,xint,yint,feattype,pfile,errfile,CCPYRTSAVE,version);
					 } 

				     break;
				   }
				} 
			 } 
		  } 
		}  
	  } 

	  break;
	  
	default:

	  printf("   Error:  bad shape type %d in shapefile %s\n",psShape->nTimSHPType,shape_to_import);
      fprintf(outerrfile,"Error:  found illegal shapefile type %d for shapefile %s\n\n",psShape->nTimSHPType,shape_to_import);
	  TimSHPClose( hSHP );
	  return 0;
	}
      
      TimSHPDestroyObject( psShape );
    }

  TimSHPClose( hSHP );


  if(XML_ACE!=NULL)
  {
    free(XML_ACE);
    XML_ACE = NULL;
  }
  if(XML_ALE!=NULL)
  {
    free(XML_ALE);
    XML_ALE = NULL;
  }

  if(XML_ACE_EVAL!=NULL)
  {
    free(XML_ACE_EVAL);
    XML_ACE_EVAL = NULL;
  }
  if(XML_ALE_EVAL!=NULL)
  {
    free(XML_ALE_EVAL);
    XML_ALE_EVAL = NULL;
  }

  if(XML_SCPYRT!=NULL)
  {
    for(i=0;i<XMLnum_records;i++)
	{
      free(XML_SCPYRT[i]);
	}
    free(XML_SCPYRT);
    XML_SCPYRT = NULL;
  }

  if(XML_SRC_DATE!=NULL)
  {
    for(i=0;i<XMLnum_records;i++)
	{
      free(XML_SRC_DATE[i]);
	}
    free(XML_SRC_DATE);
    XML_SRC_DATE = NULL;
  }

  if(XML_SRC_TYPE!=NULL)
  {
    free(XML_SRC_TYPE);
    XML_SRC_TYPE = NULL;
  }





  return 1;
}




void ProcessSF(char *shape_to_import)
{
  TimSHPHandle	hSHP;
  int		nShapeType, nEntities,i;
  double 	adfMinBound[4], adfMaxBound[4];
  TimSHPObject	*psShape;
  TimDBFHandle hDBF;
  extern void ProcessShape(int num, TimSHPObject *psSHP, int startindex,int endindex, int type);
  
  
  
  hSHP = TimSHPOpen(shape_to_import, "rb" );      
  if( hSHP == NULL )
    {
      printf( "Unable to open shp and/or shx file for: %s\n", shape_to_import );
      return;
    }
  
 
  
  TimSHPGetInfo( hSHP, &nEntities, &nShapeType, adfMinBound, adfMaxBound );
  
  
  
  hDBF = TimDBFOpen(shape_to_import, "rb" );
  if( hDBF == NULL )
    {
      printf( "Unable to open dbf file for:%s\n", shape_to_import );
      TimSHPClose( hSHP );
      return;
    }
  
  
  if( TimDBFGetFieldCount(hDBF) == 0 )
    {
      printf( "There is NO attribution fields for shapefile %s\n",
	      shape_to_import);	  
      return;
    }
  
  
  if((TimDBFGetRecordCount(hDBF))!=nEntities)
    {
      printf("   Error:  shapefile %s has %d shapes but %d DB entries\n",
	     shape_to_import,nEntities,TimDBFGetRecordCount(hDBF));
      
      if(nEntities>0)
	{
	  printf("      Ignoring this shapefile\n");
	  
	  TimSHPClose( hSHP );
	  TimDBFClose( hDBF );
	  
	  return;
	}
    }
  
  
  if(nEntities==0)
    {
      printf("   Error:  This shapefile has zero shapes.  Ignoring this shapefile.\n");
      
      TimSHPClose( hSHP );
      TimDBFClose( hDBF );
      
      return;
    }
  


  
  if(temp_short!=NULL)
    {
      free(temp_short);
      temp_short = NULL;
    }
  
  
  temp_short = (int *) malloc(sizeof(int) * (nEntities+1));
  if(temp_short==NULL){printf("temp_short: out of mem\n"); exit(-1);}
  
  
  GL_magnitudes = (double *)malloc(SzD*(nEntities+5));
  GL_instances  = (int *)   malloc(SzI*(nEntities+5));
  GL_condnums   = (int *)   malloc(SzI*(nEntities+5));
  GL_IDs        = (char **) malloc(sizeof(char *)*(nEntities+5));
  GL_errnums    = (char **) malloc(sizeof(char *)*(nEntities+5));
  GL_geoms      = (char **) malloc(sizeof(char *)*(nEntities+5));
  
  for(i=0;i<nEntities+5;i++)
    {
      GL_IDs    [i]   = NULL;
      GL_errnums[i]   = NULL;
      GL_geoms  [i]   = NULL;
    }
  
  
  GetFields(hDBF,nEntities);
  
  

  
  for( i = 0; i < nEntities; i++ )
    {
      
      psShape = TimSHPReadObject( hSHP, i );
      
      switch(psShape->nTimSHPType)
	{
	  
	case TimSHPT_NULL:  
	  break;
	  
	  
	case TimSHPT_POINTZ:
	case TimSHPT_POINT:      
	case TimSHPT_POINTM:
	  
	  if(temp_short[i]==1)
	    {
	      ProcessShape(i,psShape,0,0,2);
	    }
	  
	  break;
	  
	  
	  
	case TimSHPT_MULTIPOINTZ: 
	case TimSHPT_MULTIPOINT:   
	case TimSHPT_MULTIPOINTM: 
	  break;
	  
	  
	case TimSHPT_ARCZ:        
	case TimSHPT_ARC:        
	case TimSHPT_ARCM:  
	  
	  if(psShape->nParts>1)
	    {
	      printf("detected multi part shape\n");
	    }
	  else
	    {	      
	      if(temp_short[i]==1)
		{
		  ProcessShape(i,psShape,0,psShape->nVertices-1,1);
		}
	      
	      break;
	    }
	  
	  
	case TimSHPT_MULTIPATCH: 
	  printf("found multipatch data in %s\n",shape_to_import);
	case TimSHPT_POLYGONZ: 
	case TimSHPT_POLYGON:       
	case TimSHPT_POLYGONM: 
	  break;
	  
	default:
	  printf("   Error:  bad shape type %d in shapefile %s\n",
		 psShape->nTimSHPType,shape_to_import);
	  TimSHPClose( hSHP );
	  TimDBFClose( hDBF );
	  return;
	}
      
      TimSHPDestroyObject( psShape );
    }
  
  
  TimSHPClose( hSHP );
  TimDBFClose( hDBF );
  
  
  free(GL_magnitudes);
  free(GL_instances);
  free(GL_condnums);
  
  for(i=0;i<nEntities+5;i++)
    {
      if(GL_IDs[i]!=NULL)
	{
	  free(GL_IDs[i]);
	}
      if(GL_errnums[i]!=NULL)
	{
	  free(GL_errnums[i]);
	}
      if(GL_geoms[i]!=NULL)
	{
	  free(GL_geoms[i]);
	}
    }
  
  free(GL_IDs);
  free(GL_errnums);
  free(GL_geoms);
  
  free(temp_short);
  temp_short = NULL;

}



void AddEmptyShapefile(char *shape_to_import, int type, int num)
{
  if(type==1)
  {
    fprintf(emptyshapes,"Empty Shapefile: %s\n",shape_to_import);
  }
  else if(type==2)
  {
    fprintf(emptyshapes,"Shapefile With Invalid DBF: %s\n",shape_to_import);
  }
  else if(type==3)
  {
    fprintf(emptyshapes,"Shapefile with invalid \"feature\" #%d (will fail ShapeChk.exe): %s\n",num,shape_to_import);
  }
}


int import_shape(char *shape_to_import,int files_done, char *allshapes, 
		 char *fcode,char *shortname,
		 int *longitemsfound, int *shortitemsfound, int addtolong, int addtoshort, char *override_curr_file)
{
  TimSHPHandle	hSHP;
  int		nShapeType, nEntities, i, bValidate = 0,nInvalidCount=0;
  double 	adfMinBound[4], adfMaxBound[4];
  TimSHPObject	*psShape;
  int threeD,j;
  TimDBFHandle hDBF;
  int SEEITGEOM;
  int doattr=1;
  int total=0;
  int k;
  extern int goodGCP2; 
  extern int global_trex_shape_layer,gcpindex2_0,gcpindex2_1,gcpindex2_2,gcpindex2_3;
  extern FILE *badtrex;

  if(ABORT_EXTRACT==1)
    {
      return 0;
    }


  sh_nodes_freed = 0;
  startICESAT = -1;
  
  if(override_curr_file[0]=='\0')
  {
    printf("Import shapefile %s\n",shape_to_import);
  }
  else
  {
    printf("import shapefile %s\n",override_curr_file);
  }

  

  ShapeWriteArealLinear(NULL,0,0, 0,0,0,0,-999);
  ShapeWritePoint(NULL,0,0,0,0,0,-999);

  
  
  hSHP = TimSHPOpen(shape_to_import, "rb" );      
  if( hSHP == NULL )
    {
      printf( "Unable to open shp and/or shx file for: %s\n", shape_to_import );
      return 0;
    }
  
  
  
  TimSHPGetInfo( hSHP, &nEntities, &nShapeType, adfMinBound, adfMaxBound );


  if(
     (nShapeType==TimSHPT_POINT)        ||
     (nShapeType==TimSHPT_POINTZ)       
     )
    {
      SEEITGEOM = 5;  	  
    }
  else if(
     (nShapeType==TimSHPT_POINTM)       ||
     (nShapeType==TimSHPT_MULTIPOINT)   ||
     (nShapeType==TimSHPT_MULTIPOINTZ)  ||
     (nShapeType==TimSHPT_MULTIPOINTM)
     )
    {
	  AddBadShapeType(nShapeType,shape_to_import);
      SEEITGEOM = 5;  	  
    }

  else if(
	  (nShapeType==TimSHPT_ARC)||
	  (nShapeType==TimSHPT_ARCZ)
	  )
    {
      SEEITGEOM = 4;  
    }
  else if(nShapeType==TimSHPT_ARCM)
    {
 	  AddBadShapeType(nShapeType,shape_to_import);
      SEEITGEOM = 4;  
    }

  else if(
	  (nShapeType==TimSHPT_POLYGON)    ||
	  (nShapeType==TimSHPT_POLYGONZ) 
	  )
    {
      SEEITGEOM = 1;  
    }
  else if(
	  	  (nShapeType==TimSHPT_MULTIPATCH) ||
          (nShapeType==TimSHPT_POLYGONM)
		 )
    {
 	  AddBadShapeType(nShapeType,shape_to_import);
      SEEITGEOM = 1;  
    }
  else if(nShapeType==TimSHPT_NULL)
  {
	  
  }
  else
    {
      printf("   Error:  bad shape type %d in %s\n",nShapeType,shape_to_import);
      
      TimSHPClose( hSHP );
      *longitemsfound  = 0;
      *shortitemsfound = 0;
      
      exit(-1);
    }
  
  

  


  
  
  
  
  hDBF = TimDBFOpen(shape_to_import, "rb" );
  if( hDBF == NULL )
    {
      printf( "Unable to open dbf file for:%s\n", shape_to_import );
      TimSHPClose( hSHP );
      *longitemsfound  = 0;
      *shortitemsfound = 0;
      
      exit(-1);
    }
  
  
  if( TimDBFGetFieldCount(hDBF) == 0 )
    {
      printf( "There is NO attribution fields for shapefile %s\n",
	      shape_to_import);	  
    }


  if( (TESTVV==0) && ((TimDBFGetRecordCount(hDBF))!=nEntities) )
    {
      printf("   Error:  shapefile %s has %d shapes but %d DB entries\n",
	     shape_to_import,nEntities,TimDBFGetRecordCount(hDBF));

      if(nEntities>0)
	{
	  printf("      Ignoring this shapefile\n");
	  
	  TimSHPClose( hSHP );
	  TimDBFClose( hDBF );
	  
	  *longitemsfound  = scc_long_items;
	  *shortitemsfound = scc_short_items;
	  
	  return 1;
	}
    }
  




  
  if(nEntities==0)
    {
      printf("   This shapefile has zero shapes.  Ignoring this shapefile.\n");
      
      TimSHPClose( hSHP );
      TimDBFClose( hDBF );
      
      *longitemsfound  = scc_long_items;
      *shortitemsfound = scc_short_items;
      
      AddEmptyShapefile(shape_to_import,1,-999);

      return 1;
    }
  

  if(CREATING_TREX==1)
  {
    if( (!strcmp(fcode,"GB005")) && (strstr(shortname,"LAB_")) )
	{ 
      if(SEEITGEOM!=1)
	  {
		printf("Not importing %s because not area type\n",shape_to_import);

        fprintf(badtrex,"IMPORT_SENTINEL Error:\n");
        fprintf(badtrex,"IMPORT_SENTINEL   Not importing %s because not area type\n",shape_to_import);

	    TimSHPClose( hSHP );
	    TimDBFClose( hDBF );
	  
	    *longitemsfound  = scc_long_items;
	    *shortitemsfound = scc_short_items;
	  
	    return 1;
	  }
	} 
  }








  

  

#if(TESTVV==1)
  {
	
    

	
    

	
    BuildSpecialIndices(3,&nEntities);  
  }
#else
  {
    BuildIndices(hDBF,nEntities,SEEITGEOM,allshapes,shape_to_import,files_done,
	       fcode,shortname,doattr,hSHP);
  }
#endif

  if(NULLFILE>0)
  {
	 printf("  IGNORING shapefile %s\n  because of failure to read feature %d in it's DBF file (is it a valid shapefile?)\n  Is the DBF file truncated to 2.0GB from it's true (valid) size?\n",shape_to_import,NULLFILE-1000);

     AddEmptyShapefile(shape_to_import,2,-999);
	 NULLFILE = 0;
	 SH_Bad_DBF = SH_Bad_DBF + 1;
	  
	 TimSHPClose( hSHP );
	 TimDBFClose( hDBF );
	  
	 *longitemsfound  = scc_long_items;
	 *shortitemsfound = scc_short_items;
	 return 1;
  }


  if(ABORT_EXTRACT==1)
    {
      return 0;
    }
  
  
  
  for(i=0;i<nEntities;i++)
  {
    if(temp_long[i]>=0)
	{
	  temp_long [i] = temp_long [i] + addtolong;
	  temp_short[i] = temp_short[i] + addtoshort;
	}
  }
  
  if(global_trex_shape_layer==0)
  {
	gcpindex2_0 = gcpindex2_0 + addtolong;
  }
  if(global_trex_shape_layer==1)
  {
	gcpindex2_1 = gcpindex2_1 + addtolong;
  }
  if(global_trex_shape_layer==2)
  {
	gcpindex2_2 = gcpindex2_2 + addtolong;
  }
  if(global_trex_shape_layer==3)
  {
	gcpindex2_3 = gcpindex2_3 + addtolong;
  }
  
  


  
  
  
  
  for( i = 0; i < nEntities; i++ )
    {
      
      if(temp_long[i]<0)
	{
	   
       if((SH_Points_Done+SH_Linears_Done+SH_Areals_Done+SH_bad_objects)%250==0)
	   {
	      update_shape_import(allshapes,shape_to_import, files_done,nEntities,nEntities,
			      SH_Points_Done,SH_Linears_Done,SH_Areals_Done,gridpointsread,
			      0,0,0,0,SH_bad_objects, SH_BadCoords,SH_Null_Shapes,SH_Zero_Shapes,SH_Bad_DBF);
	   } 


	  if(temp_long[i]==-1000)
	    {
	      
	      
	      continue;
	    }
	  else if(temp_long[i]==-100)
	    {
	      
	      SH_bad_objects = SH_bad_objects + 1;
	      AddBadClass("NO FCODE FOUNDzzzSentinel",fcode,i);
	    }


	  

	  Record_LL_Mapping(gifd_ids[i],-1,i);
	  continue;
	}
      
      psShape = TimSHPReadObject( hSHP, i );
      threeD = 0;

if(i==(nEntities-1))
{
  if(Tim_EOF==0)
  {
    printf("***Error:  That SHP file has a corrupt last entry (%d)\n",nEntities+1);
    AddEmptyShapefile(shape_to_import,3,nEntities+1);
  }
}

      if(ABORT_EXTRACT==1)
	{
	  return 0;
	}
      
      
      if((SH_Points_Done+SH_Linears_Done+SH_Areals_Done)%250==0)
	{
	  update_shape_import(allshapes,shape_to_import, files_done,nEntities,nEntities,
			      SH_Points_Done,SH_Linears_Done,SH_Areals_Done,gridpointsread,
			      0,0,0,0,SH_bad_objects, SH_BadCoords,SH_Null_Shapes,SH_Zero_Shapes,SH_Bad_DBF);
	}


      
      switch(psShape->nTimSHPType)
	{
	  
	case TimSHPT_NULL:  
	  break;
	  
	  
	  
	case TimSHPT_POINTZ:
	  threeD = 1;
	case TimSHPT_POINT:      
	case TimSHPT_POINTM:
	  
	  ShapeWritePoint(psShape,0,threeD,temp_short[i],temp_long[i],i,0);
	  SH_Points_Done++;
	  break;
	  
	  
	case TimSHPT_MULTIPOINTZ: 
	  threeD = 1;
	case TimSHPT_MULTIPOINT:   
	case TimSHPT_MULTIPOINTM: 
	  
	  
	  for(j=0;j<psShape->nVertices;j++)
	    {
	      if(psShape->nVertices>1)
		{
		  ShapeWritePoint(psShape,j,threeD,temp_short[i],temp_long[i],i,1);  
		}
	      else
		{
		  ShapeWritePoint(psShape,j,threeD,temp_short[i],temp_long[i],i,0);  
		}
	      
	      if(j==0)
		{
		  SH_Points_Done = SH_Points_Done + 1;
		  if(psShape->nVertices>1)
		    {
		      NumMultiPartPointFeatures = NumMultiPartPointFeatures + 1;
		      NumPointParts = NumPointParts + 1;
		    }
		}
	      else
		{
		  NumPointParts = NumPointParts + 1;
		}
	    }
	  break;
	  
	  
	case TimSHPT_ARCZ:        
	  threeD = 1;
	case TimSHPT_ARC:        
	case TimSHPT_ARCM:  


	  if(psShape->nParts==0)
	    {
	    }
	  else
	    {
	      for(j=0;j<psShape->nParts;j++)
		{
		  
		  if(psShape->nParts>1)
		    {
		      ShapeWriteArealLinear(psShape,j,threeD,0,temp_short[i],temp_long[i],i,1); 
		    }
		  else
		    {
		      ShapeWriteArealLinear(psShape,j,threeD,0,temp_short[i],temp_long[i],i,0); 
		    }
		  
		  if(j==0)
		    {
		      SH_Linears_Done = SH_Linears_Done + 1;
		      if(psShape->nParts>1)
			  {
			    NumMultiPartLineFeatures = NumMultiPartLineFeatures + 1;
			    NumLineParts = NumLineParts + 1;
			  }
		    }
		  else
		    {
		      NumLineParts = NumLineParts + 1;
		    }
		}
	    }
	  break;
	  
	  
	  
	case TimSHPT_MULTIPATCH: 
	  printf("found multipatch data in %s\n",shape_to_import);
	case TimSHPT_POLYGONZ: 
	  threeD = 1;
	case TimSHPT_POLYGON:       
	case TimSHPT_POLYGONM: 
	  
	  if(psShape->nParts==0)
	    {
printf("0 parts\n");
	    }
	  else
	    {
	      MakeInnerPtrs(psShape,i,shape_to_import,1);
	      
	      total = 0;
	      SH_Areals_Done = SH_Areals_Done + 1;
	      
	      for(k=0;k<psShape->nParts;k++)
		{
		  if(INNERRINGS[k]>0) 
		    {
		      total++;		      
		    }
		  else
		    {
		      NumHoles = NumHoles + 1;
		    }
		}
	      
	      if(total>1)
		{
		  NumMultiPartAreaFeatures = NumMultiPartAreaFeatures + 1;
		  NumAreaParts = NumAreaParts + total;
		}
	      
	        
	      for(j=0;j<psShape->nParts;j++)
		{
		  
		  
		  if(INNERRINGS[j]>0)
		    {
		      
		      
		      if(total>1)
			{
			  ShapeWriteArealLinear(psShape,j,threeD,1,temp_short[i],temp_long[i],i, 1);
			}
		      else
			{
			  ShapeWriteArealLinear(psShape,j,threeD,1,temp_short[i],temp_long[i],i, 0); 
			}
		      
		      
		      for(k=0;k<psShape->nParts;k++)
			{
			  if(INNERRINGS[k] == (  (-1)*(j+1) )  )
			    {
			      
			      ShapeWriteArealLinear(psShape,k,threeD,1,temp_short[i],temp_long[i],i, 0); 
			    }
			}
		    }
		}
	    }
	  break;
	  
	default:
	  printf("   Error:  bad shape type %d in shapefile %s\n",
		 psShape->nTimSHPType,shape_to_import);
	  TimSHPClose( hSHP );
	  TimDBFClose( hDBF );
	  if(temp_short!=NULL)
	    {
	      free(temp_short);
	      temp_short = NULL;
	    }
	  if(temp_long!=NULL)
	    {
	      free(temp_long);
	      temp_long = NULL;
	    }
	  return 1;
	}
      
      
      if( bValidate )
	{
	  
	  int nAltered = TimSHPRewindObject( hSHP, psShape );
	  
	  if( nAltered > 0 )
	    {
	      printf( "  %d rings wound in the wrong direction.\n",
		      nAltered );
	      nInvalidCount++;
	    }
	}
      
      TimSHPDestroyObject( psShape );
    }
  
  
  TimSHPClose( hSHP );
  TimDBFClose( hDBF );
  
  
  if(temp_short!=NULL)
    {
      free(temp_short);
      temp_short = NULL;
    }
  if(temp_long!=NULL)
    {
      free(temp_long);
      temp_long = NULL;
    }
  if(gifd_ids!=NULL)
    {
      free(gifd_ids);
      gifd_ids = NULL;
    }
  
  if(
     (bValidate) &&
     (nInvalidCount>0)
     )
    {
      printf( "%d object has invalid ring orderings.\n", nInvalidCount );
    }
  
  
  
  *longitemsfound  = scc_long_items;
  *shortitemsfound = scc_short_items;


  if(startICESAT>=0)
  {
    goodGCP2 = goodGCP2 + SH_Points_Done - startICESAT;
  }


  update_shape_import(allshapes,shape_to_import, files_done,nEntities,nEntities,
		      SH_Points_Done,SH_Linears_Done,SH_Areals_Done,gridpointsread,
		      0,0,0,0,SH_bad_objects, SH_BadCoords,SH_Null_Shapes,SH_Zero_Shapes,SH_Bad_DBF);
  
  return (!ABORT_EXTRACT);
}
